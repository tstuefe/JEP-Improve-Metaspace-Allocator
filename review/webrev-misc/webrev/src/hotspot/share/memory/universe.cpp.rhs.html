<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-misc.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "aot/aotLoader.hpp"
  27 #include "classfile/classLoader.hpp"
  28 #include "classfile/classLoaderDataGraph.hpp"
  29 #include "classfile/javaClasses.hpp"
  30 #include "classfile/stringTable.hpp"
  31 #include "classfile/symbolTable.hpp"
  32 #include "classfile/systemDictionary.hpp"
  33 #include "classfile/vmSymbols.hpp"
  34 #include "code/codeBehaviours.hpp"
  35 #include "code/codeCache.hpp"
  36 #include "code/dependencies.hpp"
  37 #include "gc/shared/collectedHeap.inline.hpp"
  38 #include "gc/shared/gcArguments.hpp"
  39 #include "gc/shared/gcConfig.hpp"
  40 #include "gc/shared/gcLogPrecious.hpp"
  41 #include "gc/shared/gcTraceTime.inline.hpp"
  42 #include "gc/shared/oopStorageSet.hpp"
  43 #include "interpreter/interpreter.hpp"
  44 #include "logging/log.hpp"
  45 #include "logging/logStream.hpp"
  46 #include "memory/heapShared.hpp"
  47 #include "memory/filemap.hpp"
  48 #include "memory/metadataFactory.hpp"
  49 #include "memory/metaspaceClosure.hpp"
  50 #include "memory/metaspaceCounters.hpp"
  51 #include "memory/metaspaceShared.hpp"
  52 #include "memory/oopFactory.hpp"
  53 #include "memory/resourceArea.hpp"
  54 #include "memory/universe.hpp"
  55 #include "oops/compressedOops.hpp"
  56 #include "oops/constantPool.hpp"
  57 #include "oops/instanceClassLoaderKlass.hpp"
  58 #include "oops/instanceKlass.hpp"
  59 #include "oops/instanceMirrorKlass.hpp"
  60 #include "oops/instanceRefKlass.hpp"
  61 #include "oops/objArrayOop.inline.hpp"
  62 #include "oops/oop.inline.hpp"
  63 #include "oops/oopHandle.inline.hpp"
  64 #include "oops/typeArrayKlass.hpp"
  65 #include "prims/resolvedMethodTable.hpp"
  66 #include "runtime/arguments.hpp"
  67 #include "runtime/atomic.hpp"
  68 #include "runtime/deoptimization.hpp"
  69 #include "runtime/flags/jvmFlagConstraintList.hpp"
  70 #include "runtime/handles.inline.hpp"
  71 #include "runtime/init.hpp"
  72 #include "runtime/java.hpp"
  73 #include "runtime/javaCalls.hpp"
  74 #include "runtime/sharedRuntime.hpp"
  75 #include "runtime/synchronizer.hpp"
  76 #include "runtime/thread.inline.hpp"
  77 #include "runtime/timerTrace.hpp"
  78 #include "runtime/vmOperations.hpp"
  79 #include "services/memoryService.hpp"
  80 #include "utilities/align.hpp"
  81 #include "utilities/autoRestore.hpp"
  82 #include "utilities/copy.hpp"
  83 #include "utilities/debug.hpp"
  84 #include "utilities/events.hpp"
  85 #include "utilities/formatBuffer.hpp"
  86 #include "utilities/hashtable.inline.hpp"
  87 #include "utilities/macros.hpp"
  88 #include "utilities/ostream.hpp"
  89 #include "utilities/preserveException.hpp"
  90 
  91 // Known objects
  92 Klass* Universe::_typeArrayKlassObjs[T_LONG+1]        = { NULL /*, NULL...*/ };
  93 Klass* Universe::_objectArrayKlassObj                 = NULL;
  94 OopHandle Universe::_mirrors[T_VOID+1];
  95 
  96 OopHandle Universe::_main_thread_group;
  97 OopHandle Universe::_system_thread_group;
  98 OopHandle Universe::_the_empty_class_array;
  99 OopHandle Universe::_the_null_string;
 100 OopHandle Universe::_the_min_jint_string;
 101 
 102 OopHandle Universe::_the_null_sentinel;
 103 
 104 // _out_of_memory_errors is an objArray
 105 enum OutOfMemoryInstance { _oom_java_heap,
 106                            _oom_c_heap,
 107                            _oom_metaspace,
 108                            _oom_class_metaspace,
 109                            _oom_array_size,
 110                            _oom_gc_overhead_limit,
 111                            _oom_realloc_objects,
 112                            _oom_retry,
 113                            _oom_count };
 114 
 115 OopHandle Universe::_out_of_memory_errors;
 116 OopHandle Universe::_delayed_stack_overflow_error_message;
 117 OopHandle Universe::_preallocated_out_of_memory_error_array;
 118 volatile jint Universe::_preallocated_out_of_memory_error_avail_count = 0;
 119 
 120 OopHandle Universe::_null_ptr_exception_instance;
 121 OopHandle Universe::_arithmetic_exception_instance;
 122 OopHandle Universe::_virtual_machine_error_instance;
 123 
 124 OopHandle Universe::_reference_pending_list;
 125 
 126 Array&lt;Klass*&gt;* Universe::_the_array_interfaces_array = NULL;
 127 LatestMethodCache* Universe::_finalizer_register_cache = NULL;
 128 LatestMethodCache* Universe::_loader_addClass_cache    = NULL;
 129 LatestMethodCache* Universe::_throw_illegal_access_error_cache = NULL;
 130 LatestMethodCache* Universe::_throw_no_such_method_error_cache = NULL;
 131 LatestMethodCache* Universe::_do_stack_walk_cache     = NULL;
 132 
 133 bool Universe::_verify_in_progress                    = false;
 134 long Universe::verify_flags                           = Universe::Verify_All;
 135 
 136 Array&lt;int&gt;* Universe::_the_empty_int_array            = NULL;
 137 Array&lt;u2&gt;* Universe::_the_empty_short_array           = NULL;
 138 Array&lt;Klass*&gt;* Universe::_the_empty_klass_array     = NULL;
 139 Array&lt;InstanceKlass*&gt;* Universe::_the_empty_instance_klass_array  = NULL;
 140 Array&lt;Method*&gt;* Universe::_the_empty_method_array   = NULL;
 141 
 142 // These variables are guarded by FullGCALot_lock.
 143 debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)
 144 debug_only(int Universe::_fullgc_alot_dummy_next = 0;)
 145 
 146 // Heap
 147 int             Universe::_verify_count = 0;
 148 
 149 // Oop verification (see MacroAssembler::verify_oop)
 150 uintptr_t       Universe::_verify_oop_mask = 0;
 151 uintptr_t       Universe::_verify_oop_bits = (uintptr_t) -1;
 152 
 153 int             Universe::_base_vtable_size = 0;
 154 bool            Universe::_bootstrapping = false;
 155 bool            Universe::_module_initialized = false;
 156 bool            Universe::_fully_initialized = false;
 157 
 158 size_t          Universe::_heap_capacity_at_last_gc;
 159 size_t          Universe::_heap_used_at_last_gc = 0;
 160 
 161 OopStorage*     Universe::_vm_weak = NULL;
 162 OopStorage*     Universe::_vm_global = NULL;
 163 
 164 CollectedHeap*  Universe::_collectedHeap = NULL;
 165 
 166 objArrayOop Universe::the_empty_class_array ()  {
 167   return (objArrayOop)_the_empty_class_array.resolve();
 168 }
 169 
 170 oop Universe::main_thread_group()                 { return _main_thread_group.resolve(); }
 171 void Universe::set_main_thread_group(oop group)   { _main_thread_group = OopHandle(vm_global(), group); }
 172 
 173 oop Universe::system_thread_group()               { return _system_thread_group.resolve(); }
 174 void Universe::set_system_thread_group(oop group) { _system_thread_group = OopHandle(vm_global(), group); }
 175 
 176 oop Universe::the_null_string()                   { return _the_null_string.resolve(); }
 177 oop Universe::the_min_jint_string()               { return _the_min_jint_string.resolve(); }
 178 
 179 oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }
 180 oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }
 181 oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }
 182 
 183 oop Universe::the_null_sentinel()                 { return _the_null_sentinel.resolve(); }
 184 
 185 oop Universe::int_mirror()                        { return check_mirror(_mirrors[T_INT].resolve()); }
 186 oop Universe::float_mirror()                      { return check_mirror(_mirrors[T_FLOAT].resolve()); }
 187 oop Universe::double_mirror()                     { return check_mirror(_mirrors[T_DOUBLE].resolve()); }
 188 oop Universe::byte_mirror()                       { return check_mirror(_mirrors[T_BYTE].resolve()); }
 189 oop Universe::bool_mirror()                       { return check_mirror(_mirrors[T_BOOLEAN].resolve()); }
 190 oop Universe::char_mirror()                       { return check_mirror(_mirrors[T_CHAR].resolve()); }
 191 oop Universe::long_mirror()                       { return check_mirror(_mirrors[T_LONG].resolve()); }
 192 oop Universe::short_mirror()                      { return check_mirror(_mirrors[T_SHORT].resolve()); }
 193 oop Universe::void_mirror()                       { return check_mirror(_mirrors[T_VOID].resolve()); }
 194 
 195 oop Universe::java_mirror(BasicType t) {
 196   assert((uint)t &lt; T_VOID+1, "range check");
 197   return check_mirror(_mirrors[t].resolve());
 198 }
 199 
 200 // Used by CDS dumping
 201 void Universe::replace_mirror(BasicType t, oop new_mirror) {
 202   Universe::_mirrors[t].replace(new_mirror);
 203 }
 204 
 205 // Not sure why CDS has to do this
 206 void Universe::clear_basic_type_mirrors() {
 207   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 208     if (!is_reference_type((BasicType)i)) {
 209       Universe::_mirrors[i].replace(NULL);
 210     }
 211   }
 212 }
 213 
 214 void Universe::basic_type_classes_do(void f(Klass*)) {
 215   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 216     f(_typeArrayKlassObjs[i]);
 217   }
 218 }
 219 
 220 void Universe::basic_type_classes_do(KlassClosure *closure) {
 221   for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 222     closure-&gt;do_klass(_typeArrayKlassObjs[i]);
 223   }
 224 }
 225 
 226 void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {
 227   it-&gt;push(&amp;_klass);
 228 }
 229 
 230 void Universe::metaspace_pointers_do(MetaspaceClosure* it) {
 231   for (int i = 0; i &lt; T_LONG+1; i++) {
 232     it-&gt;push(&amp;_typeArrayKlassObjs[i]);
 233   }
 234   it-&gt;push(&amp;_objectArrayKlassObj);
 235 
 236   it-&gt;push(&amp;_the_empty_int_array);
 237   it-&gt;push(&amp;_the_empty_short_array);
 238   it-&gt;push(&amp;_the_empty_klass_array);
 239   it-&gt;push(&amp;_the_empty_instance_klass_array);
 240   it-&gt;push(&amp;_the_empty_method_array);
 241   it-&gt;push(&amp;_the_array_interfaces_array);
 242 
 243   _finalizer_register_cache-&gt;metaspace_pointers_do(it);
 244   _loader_addClass_cache-&gt;metaspace_pointers_do(it);
 245   _throw_illegal_access_error_cache-&gt;metaspace_pointers_do(it);
 246   _throw_no_such_method_error_cache-&gt;metaspace_pointers_do(it);
 247   _do_stack_walk_cache-&gt;metaspace_pointers_do(it);
 248 }
 249 
 250 // Serialize metadata and pointers to primitive type mirrors in and out of CDS archive
 251 void Universe::serialize(SerializeClosure* f) {
 252 
 253 #if INCLUDE_CDS_JAVA_HEAP
 254   {
 255     oop mirror_oop;
 256     for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 257       if (f-&gt;reading()) {
 258         f-&gt;do_oop(&amp;mirror_oop); // read from archive
 259         assert(oopDesc::is_oop_or_null(mirror_oop), "is oop");
 260         // Only create an OopHandle for non-null mirrors
 261         if (mirror_oop != NULL) {
 262           _mirrors[i] = OopHandle(vm_global(), mirror_oop);
 263         }
 264       } else {
 265         mirror_oop = _mirrors[i].resolve();
 266         f-&gt;do_oop(&amp;mirror_oop); // write to archive
 267       }
 268       if (mirror_oop != NULL) { // may be null if archived heap is disabled
 269         java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);
 270       }
 271     }
 272   }
 273 #endif
 274 
 275   for (int i = 0; i &lt; T_LONG+1; i++) {
 276     f-&gt;do_ptr((void**)&amp;_typeArrayKlassObjs[i]);
 277   }
 278 
 279   f-&gt;do_ptr((void**)&amp;_objectArrayKlassObj);
 280   f-&gt;do_ptr((void**)&amp;_the_array_interfaces_array);
 281   f-&gt;do_ptr((void**)&amp;_the_empty_int_array);
 282   f-&gt;do_ptr((void**)&amp;_the_empty_short_array);
 283   f-&gt;do_ptr((void**)&amp;_the_empty_method_array);
 284   f-&gt;do_ptr((void**)&amp;_the_empty_klass_array);
 285   f-&gt;do_ptr((void**)&amp;_the_empty_instance_klass_array);
 286   _finalizer_register_cache-&gt;serialize(f);
 287   _loader_addClass_cache-&gt;serialize(f);
 288   _throw_illegal_access_error_cache-&gt;serialize(f);
 289   _throw_no_such_method_error_cache-&gt;serialize(f);
 290   _do_stack_walk_cache-&gt;serialize(f);
 291 }
 292 
 293 
 294 void Universe::check_alignment(uintx size, uintx alignment, const char* name) {
 295   if (size &lt; alignment || size % alignment != 0) {
 296     vm_exit_during_initialization(
 297       err_msg("Size of %s (" UINTX_FORMAT " bytes) must be aligned to " UINTX_FORMAT " bytes", name, size, alignment));
 298   }
 299 }
 300 
 301 void initialize_basic_type_klass(Klass* k, TRAPS) {
 302   Klass* ok = SystemDictionary::Object_klass();
 303 #if INCLUDE_CDS
 304   if (UseSharedSpaces) {
 305     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
 306     assert(k-&gt;super() == ok, "u3");
 307     if (k-&gt;is_instance_klass()) {
 308       InstanceKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), NULL, CHECK);
 309     } else {
 310       ArrayKlass::cast(k)-&gt;restore_unshareable_info(loader_data, Handle(), CHECK);
 311     }
 312   } else
 313 #endif
 314   {
 315     k-&gt;initialize_supers(ok, NULL, CHECK);
 316   }
 317   k-&gt;append_to_sibling_list();
 318 }
 319 
 320 void Universe::genesis(TRAPS) {
 321   ResourceMark rm(THREAD);
 322   HandleMark   hm(THREAD);
 323 
 324   { AutoModifyRestore&lt;bool&gt; temporarily(_bootstrapping, true);
 325 
 326     { MutexLocker mc(THREAD, Compile_lock);
 327 
 328       java_lang_Class::allocate_fixup_lists();
 329 
 330       // determine base vtable size; without that we cannot create the array klasses
 331       compute_base_vtable_size();
 332 
 333       if (!UseSharedSpaces) {
 334         for (int i = T_BOOLEAN; i &lt; T_LONG+1; i++) {
 335           _typeArrayKlassObjs[i] = TypeArrayKlass::create_klass((BasicType)i, CHECK);
 336         }
 337 
 338         ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
 339 
 340         _the_array_interfaces_array     = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 2, NULL, CHECK);
 341         _the_empty_int_array            = MetadataFactory::new_array&lt;int&gt;(null_cld, 0, CHECK);
 342         _the_empty_short_array          = MetadataFactory::new_array&lt;u2&gt;(null_cld, 0, CHECK);
 343         _the_empty_method_array         = MetadataFactory::new_array&lt;Method*&gt;(null_cld, 0, CHECK);
 344         _the_empty_klass_array          = MetadataFactory::new_array&lt;Klass*&gt;(null_cld, 0, CHECK);
 345         _the_empty_instance_klass_array = MetadataFactory::new_array&lt;InstanceKlass*&gt;(null_cld, 0, CHECK);
 346       }
 347     }
 348 
 349     vmSymbols::initialize(CHECK);
 350 
 351     SystemDictionary::initialize(CHECK);
 352 
 353     // Create string constants
 354     oop s = StringTable::intern("null", CHECK);
 355     _the_null_string = OopHandle(vm_global(), s);
 356     s = StringTable::intern("-2147483648", CHECK);
 357     _the_min_jint_string = OopHandle(vm_global(), s);
 358 
 359 
 360 #if INCLUDE_CDS
 361     if (UseSharedSpaces) {
 362       // Verify shared interfaces array.
 363       assert(_the_array_interfaces_array-&gt;at(0) ==
 364              SystemDictionary::Cloneable_klass(), "u3");
 365       assert(_the_array_interfaces_array-&gt;at(1) ==
 366              SystemDictionary::Serializable_klass(), "u3");
 367     } else
 368 #endif
 369     {
 370       // Set up shared interfaces array.  (Do this before supers are set up.)
 371       _the_array_interfaces_array-&gt;at_put(0, SystemDictionary::Cloneable_klass());
 372       _the_array_interfaces_array-&gt;at_put(1, SystemDictionary::Serializable_klass());
 373     }
 374 
 375     initialize_basic_type_klass(boolArrayKlassObj(), CHECK);
 376     initialize_basic_type_klass(charArrayKlassObj(), CHECK);
 377     initialize_basic_type_klass(floatArrayKlassObj(), CHECK);
 378     initialize_basic_type_klass(doubleArrayKlassObj(), CHECK);
 379     initialize_basic_type_klass(byteArrayKlassObj(), CHECK);
 380     initialize_basic_type_klass(shortArrayKlassObj(), CHECK);
 381     initialize_basic_type_klass(intArrayKlassObj(), CHECK);
 382     initialize_basic_type_klass(longArrayKlassObj(), CHECK);
 383   } // end of core bootstrapping
 384 
 385   {
 386     Handle tns = java_lang_String::create_from_str("&lt;null_sentinel&gt;", CHECK);
 387     _the_null_sentinel = OopHandle(vm_global(), tns());
 388   }
 389 
 390   // Create a handle for reference_pending_list
 391   _reference_pending_list = OopHandle(vm_global(), NULL);
 392 
 393   // Maybe this could be lifted up now that object array can be initialized
 394   // during the bootstrapping.
 395 
 396   // OLD
 397   // Initialize _objectArrayKlass after core bootstraping to make
 398   // sure the super class is set up properly for _objectArrayKlass.
 399   // ---
 400   // NEW
 401   // Since some of the old system object arrays have been converted to
 402   // ordinary object arrays, _objectArrayKlass will be loaded when
 403   // SystemDictionary::initialize(CHECK); is run. See the extra check
 404   // for Object_klass_loaded in objArrayKlassKlass::allocate_objArray_klass_impl.
 405   _objectArrayKlassObj = InstanceKlass::
 406     cast(SystemDictionary::Object_klass())-&gt;array_klass(1, CHECK);
 407   // OLD
 408   // Add the class to the class hierarchy manually to make sure that
 409   // its vtable is initialized after core bootstrapping is completed.
 410   // ---
 411   // New
 412   // Have already been initialized.
 413   _objectArrayKlassObj-&gt;append_to_sibling_list();
 414 
 415   #ifdef ASSERT
 416   if (FullGCALot) {
 417     // Allocate an array of dummy objects.
 418     // We'd like these to be at the bottom of the old generation,
 419     // so that when we free one and then collect,
 420     // (almost) the whole heap moves
 421     // and we find out if we actually update all the oops correctly.
 422     // But we can't allocate directly in the old generation,
 423     // so we allocate wherever, and hope that the first collection
 424     // moves these objects to the bottom of the old generation.
 425     int size = FullGCALotDummies * 2;
 426 
 427     objArrayOop    naked_array = oopFactory::new_objArray(SystemDictionary::Object_klass(), size, CHECK);
 428     objArrayHandle dummy_array(THREAD, naked_array);
 429     int i = 0;
 430     while (i &lt; size) {
 431         // Allocate dummy in old generation
 432       oop dummy = SystemDictionary::Object_klass()-&gt;allocate_instance(CHECK);
 433       dummy_array-&gt;obj_at_put(i++, dummy);
 434     }
 435     {
 436       // Only modify the global variable inside the mutex.
 437       // If we had a race to here, the other dummy_array instances
 438       // and their elements just get dropped on the floor, which is fine.
 439       MutexLocker ml(THREAD, FullGCALot_lock);
 440       if (_fullgc_alot_dummy_array.is_empty()) {
 441         _fullgc_alot_dummy_array = OopHandle(vm_global(), dummy_array());
 442       }
 443     }
 444     assert(i == ((objArrayOop)_fullgc_alot_dummy_array.resolve())-&gt;length(), "just checking");
 445   }
 446   #endif
 447 }
 448 
 449 void Universe::initialize_basic_type_mirrors(TRAPS) {
 450 #if INCLUDE_CDS_JAVA_HEAP
 451     if (UseSharedSpaces &amp;&amp;
 452         HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 453         _mirrors[T_INT].resolve() != NULL) {
 454       assert(HeapShared::is_heap_object_archiving_allowed(), "Sanity");
 455 
 456       // check that all mirrors are mapped also
 457       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 458         if (!is_reference_type((BasicType)i)) {
 459           oop m = _mirrors[i].resolve();
 460           assert(m != NULL, "archived mirrors should not be NULL");
 461         }
 462       }
 463     } else
 464       // _mirror[T_INT} could be NULL if archived heap is not mapped.
 465 #endif
 466     {
 467       for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
 468         BasicType bt = (BasicType)i;
 469         if (!is_reference_type(bt)) {
 470           oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);
 471           _mirrors[i] = OopHandle(vm_global(), m);
 472         }
 473       }
 474     }
 475 }
 476 
 477 void Universe::fixup_mirrors(TRAPS) {
 478   // Bootstrap problem: all classes gets a mirror (java.lang.Class instance) assigned eagerly,
 479   // but we cannot do that for classes created before java.lang.Class is loaded. Here we simply
 480   // walk over permanent objects created so far (mostly classes) and fixup their mirrors. Note
 481   // that the number of objects allocated at this point is very small.
 482   assert(SystemDictionary::Class_klass_loaded(), "java.lang.Class should be loaded");
 483   HandleMark hm(THREAD);
 484 
 485   if (!UseSharedSpaces) {
 486     // Cache the start of the static fields
 487     InstanceMirrorKlass::init_offset_of_static_fields();
 488   }
 489 
 490   GrowableArray &lt;Klass*&gt;* list = java_lang_Class::fixup_mirror_list();
 491   int list_length = list-&gt;length();
 492   for (int i = 0; i &lt; list_length; i++) {
 493     Klass* k = list-&gt;at(i);
 494     assert(k-&gt;is_klass(), "List should only hold classes");
 495     EXCEPTION_MARK;
 496     java_lang_Class::fixup_mirror(k, CATCH);
 497   }
 498   delete java_lang_Class::fixup_mirror_list();
 499   java_lang_Class::set_fixup_mirror_list(NULL);
 500 }
 501 
 502 #define assert_pll_locked(test) \
 503   assert(Heap_lock-&gt;test(), "Reference pending list access requires lock")
 504 
 505 #define assert_pll_ownership() assert_pll_locked(owned_by_self)
 506 
 507 oop Universe::reference_pending_list() {
 508   if (Thread::current()-&gt;is_VM_thread()) {
 509     assert_pll_locked(is_locked);
 510   } else {
 511     assert_pll_ownership();
 512   }
 513   return _reference_pending_list.resolve();
 514 }
 515 
 516 void Universe::clear_reference_pending_list() {
 517   assert_pll_ownership();
 518   _reference_pending_list.replace(NULL);
 519 }
 520 
 521 bool Universe::has_reference_pending_list() {
 522   assert_pll_ownership();
 523   return _reference_pending_list.peek() != NULL;
 524 }
 525 
 526 oop Universe::swap_reference_pending_list(oop list) {
 527   assert_pll_locked(is_locked);
 528   return _reference_pending_list.xchg(list);
 529 }
 530 
 531 #undef assert_pll_locked
 532 #undef assert_pll_ownership
 533 
 534 void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {
 535   // init vtable of k and all subclasses
 536   ko-&gt;vtable().initialize_vtable(false, CHECK);
 537   if (ko-&gt;is_instance_klass()) {
 538     for (Klass* sk = ko-&gt;subklass();
 539          sk != NULL;
 540          sk = sk-&gt;next_sibling()) {
 541       reinitialize_vtable_of(sk, CHECK);
 542     }
 543   }
 544 }
 545 
 546 void Universe::reinitialize_vtables(TRAPS) {
 547   // The vtables are initialized by starting at java.lang.Object and
 548   // initializing through the subclass links, so that the super
 549   // classes are always initialized first.
 550   Klass* ok = SystemDictionary::Object_klass();
 551   Universe::reinitialize_vtable_of(ok, THREAD);
 552 }
 553 
 554 
 555 void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {
 556   k-&gt;itable().initialize_itable(false, CHECK);
 557 }
 558 
 559 
 560 void Universe::reinitialize_itables(TRAPS) {
 561   MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);
 562   ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);
 563 }
 564 
 565 
 566 bool Universe::on_page_boundary(void* addr) {
 567   return is_aligned(addr, os::vm_page_size());
 568 }
 569 
 570 // the array of preallocated errors with backtraces
 571 objArrayOop Universe::preallocated_out_of_memory_errors() {
 572   return (objArrayOop)_preallocated_out_of_memory_error_array.resolve();
 573 }
 574 
 575 objArrayOop Universe::out_of_memory_errors() { return (objArrayOop)_out_of_memory_errors.resolve(); }
 576 
 577 oop Universe::out_of_memory_error_java_heap() {
 578   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_java_heap));
 579 }
 580 
 581 oop Universe::out_of_memory_error_c_heap() {
 582   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_c_heap));
 583 }
 584 
 585 oop Universe::out_of_memory_error_metaspace() {
 586   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_metaspace));
 587 }
 588 
 589 oop Universe::out_of_memory_error_class_metaspace() {
 590   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_class_metaspace));
 591 }
 592 
 593 oop Universe::out_of_memory_error_array_size() {
 594   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_array_size));
 595 }
 596 
 597 oop Universe::out_of_memory_error_gc_overhead_limit() {
 598   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_gc_overhead_limit));
 599 }
 600 
 601 oop Universe::out_of_memory_error_realloc_objects() {
 602   return gen_out_of_memory_error(out_of_memory_errors()-&gt;obj_at(_oom_realloc_objects));
 603 }
 604 
 605 // Throw default _out_of_memory_error_retry object as it will never propagate out of the VM
 606 oop Universe::out_of_memory_error_retry()              { return out_of_memory_errors()-&gt;obj_at(_oom_retry);  }
 607 oop Universe::delayed_stack_overflow_error_message()   { return _delayed_stack_overflow_error_message.resolve(); }
 608 
 609 
 610 bool Universe::should_fill_in_stack_trace(Handle throwable) {
 611   // never attempt to fill in the stack trace of preallocated errors that do not have
 612   // backtrace. These errors are kept alive forever and may be "re-used" when all
 613   // preallocated errors with backtrace have been consumed. Also need to avoid
 614   // a potential loop which could happen if an out of memory occurs when attempting
 615   // to allocate the backtrace.
 616   objArrayOop preallocated_oom = out_of_memory_errors();
 617   for (int i = 0; i &lt; _oom_count; i++) {
 618     if (throwable() == preallocated_oom-&gt;obj_at(i)) {
 619       return false;
 620     }
 621   }
 622   return true;
 623 }
 624 
 625 
 626 oop Universe::gen_out_of_memory_error(oop default_err) {
 627   // generate an out of memory error:
 628   // - if there is a preallocated error and stack traces are available
 629   //   (j.l.Throwable is initialized), then return the preallocated
 630   //   error with a filled in stack trace, and with the message
 631   //   provided by the default error.
 632   // - otherwise, return the default error, without a stack trace.
 633   int next;
 634   if ((_preallocated_out_of_memory_error_avail_count &gt; 0) &amp;&amp;
 635       SystemDictionary::Throwable_klass()-&gt;is_initialized()) {
 636     next = (int)Atomic::add(&amp;_preallocated_out_of_memory_error_avail_count, -1);
 637     assert(next &lt; (int)PreallocatedOutOfMemoryErrorCount, "avail count is corrupt");
 638   } else {
 639     next = -1;
 640   }
 641   if (next &lt; 0) {
 642     // all preallocated errors have been used.
 643     // return default
 644     return default_err;
 645   } else {
 646     Thread* THREAD = Thread::current();
 647     Handle default_err_h(THREAD, default_err);
 648     // get the error object at the slot and set set it to NULL so that the
 649     // array isn't keeping it alive anymore.
 650     Handle exc(THREAD, preallocated_out_of_memory_errors()-&gt;obj_at(next));
 651     assert(exc() != NULL, "slot has been used already");
 652     preallocated_out_of_memory_errors()-&gt;obj_at_put(next, NULL);
 653 
 654     // use the message from the default error
 655     oop msg = java_lang_Throwable::message(default_err_h());
 656     assert(msg != NULL, "no message");
 657     java_lang_Throwable::set_message(exc(), msg);
 658 
 659     // populate the stack trace and return it.
 660     java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(exc);
 661     return exc();
 662   }
 663 }
 664 
 665 // Setup preallocated OutOfMemoryError errors
 666 void Universe::create_preallocated_out_of_memory_errors(TRAPS) {
 667   InstanceKlass* ik = SystemDictionary::OutOfMemoryError_klass();
 668   objArrayOop oa = oopFactory::new_objArray(ik, _oom_count, CHECK);
 669   objArrayHandle oom_array(THREAD, oa);
 670 
 671   for (int i = 0; i &lt; _oom_count; i++) {
 672     oop oom_obj = ik-&gt;allocate_instance(CHECK);
 673     oom_array-&gt;obj_at_put(i, oom_obj);
 674   }
 675   _out_of_memory_errors = OopHandle(vm_global(), oom_array());
 676 
 677   Handle msg = java_lang_String::create_from_str("Java heap space", CHECK);
 678   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_java_heap), msg());
 679 
 680   msg = java_lang_String::create_from_str("C heap space", CHECK);
 681   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_c_heap), msg());
 682 
 683   msg = java_lang_String::create_from_str("Metaspace", CHECK);
 684   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_metaspace), msg());
 685 
 686   msg = java_lang_String::create_from_str("Compressed class space", CHECK);
 687   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_class_metaspace), msg());
 688 
 689   msg = java_lang_String::create_from_str("Requested array size exceeds VM limit", CHECK);
 690   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_array_size), msg());
 691 
 692   msg = java_lang_String::create_from_str("GC overhead limit exceeded", CHECK);
 693   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_gc_overhead_limit), msg());
 694 
 695   msg = java_lang_String::create_from_str("Java heap space: failed reallocation of scalar replaced objects", CHECK);
 696   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_realloc_objects), msg());
 697 
 698   msg = java_lang_String::create_from_str("Java heap space: failed retryable allocation", CHECK);
 699   java_lang_Throwable::set_message(oom_array-&gt;obj_at(_oom_retry), msg());
 700 
 701   // Setup the array of errors that have preallocated backtrace
 702   int len = (StackTraceInThrowable) ? (int)PreallocatedOutOfMemoryErrorCount : 0;
 703   objArrayOop instance = oopFactory::new_objArray(ik, len, CHECK);
 704   _preallocated_out_of_memory_error_array = OopHandle(vm_global(), instance);
 705   objArrayHandle preallocated_oom_array(THREAD, instance);
 706 
 707   for (int i=0; i&lt;len; i++) {
 708     oop err = ik-&gt;allocate_instance(CHECK);
 709     Handle err_h(THREAD, err);
 710     java_lang_Throwable::allocate_backtrace(err_h, CHECK);
 711     preallocated_oom_array-&gt;obj_at_put(i, err_h());
 712   }
 713   _preallocated_out_of_memory_error_avail_count = (jint)len;
 714 }
 715 
 716 intptr_t Universe::_non_oop_bits = 0;
 717 
 718 void* Universe::non_oop_word() {
 719   // Neither the high bits nor the low bits of this value is allowed
 720   // to look like (respectively) the high or low bits of a real oop.
 721   //
 722   // High and low are CPU-specific notions, but low always includes
 723   // the low-order bit.  Since oops are always aligned at least mod 4,
 724   // setting the low-order bit will ensure that the low half of the
 725   // word will never look like that of a real oop.
 726   //
 727   // Using the OS-supplied non-memory-address word (usually 0 or -1)
 728   // will take care of the high bits, however many there are.
 729 
 730   if (_non_oop_bits == 0) {
 731     _non_oop_bits = (intptr_t)os::non_memory_address_word() | 1;
 732   }
 733 
 734   return (void*)_non_oop_bits;
 735 }
 736 
 737 static void initialize_global_behaviours() {
 738   CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());
 739 }
 740 
 741 jint universe_init() {
 742   assert(!Universe::_fully_initialized, "called after initialize_vtables");
 743   guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord),
 744          "LogHeapWordSize is incorrect.");
 745   guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?");
 746   guarantee(sizeof(oop) % sizeof(HeapWord) == 0,
 747             "oop size is not not a multiple of HeapWord size");
 748 
 749   TraceTime timer("Genesis", TRACETIME_LOG(Info, startuptime));
 750 
 751   initialize_global_behaviours();
 752 
 753   GCLogPrecious::initialize();
 754 
 755   GCConfig::arguments()-&gt;initialize_heap_sizes();
 756 
 757   jint status = Universe::initialize_heap();
 758   if (status != JNI_OK) {
 759     return status;
 760   }
 761 
 762   Universe::initialize_tlab();
 763 
 764   Metaspace::global_initialize();
 765 
 766   // Initialize performance counters for metaspaces
 767   MetaspaceCounters::initialize_performance_counters();
 768   CompressedClassSpaceCounters::initialize_performance_counters();
 769 
 770   AOTLoader::universe_init();
 771 
 772   // Checks 'AfterMemoryInit' constraints.
 773   if (!JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterMemoryInit)) {
 774     return JNI_EINVAL;
 775   }
 776 
 777   // Create memory for metadata.  Must be after initializing heap for
 778   // DumpSharedSpaces.
 779   ClassLoaderData::init_null_class_loader_data();
 780 
 781   // We have a heap so create the Method* caches before
 782   // Metaspace::initialize_shared_spaces() tries to populate them.
 783   Universe::_finalizer_register_cache = new LatestMethodCache();
 784   Universe::_loader_addClass_cache    = new LatestMethodCache();
 785   Universe::_throw_illegal_access_error_cache = new LatestMethodCache();
 786   Universe::_throw_no_such_method_error_cache = new LatestMethodCache();
 787   Universe::_do_stack_walk_cache = new LatestMethodCache();
 788 
 789 #if INCLUDE_CDS
 790   if (UseSharedSpaces) {
 791     // Read the data structures supporting the shared spaces (shared
 792     // system dictionary, symbol table, etc.).  After that, access to
 793     // the file (other than the mapped regions) is no longer needed, and
 794     // the file is closed. Closing the file does not affect the
 795     // currently mapped regions.
 796     MetaspaceShared::initialize_shared_spaces();
 797     StringTable::create_table();
 798   } else
 799 #endif
 800   {
 801     SymbolTable::create_table();
 802     StringTable::create_table();
 803   }
 804 
 805 #if INCLUDE_CDS
 806   if (Arguments::is_dumping_archive()) {
 807     MetaspaceShared::prepare_for_dumping();
 808   }
 809 #endif
 810 
 811   if (strlen(VerifySubSet) &gt; 0) {
 812     Universe::initialize_verify_flags();
 813   }
 814 
 815   ResolvedMethodTable::create_table();
 816 
 817   return JNI_OK;
 818 }
 819 
 820 jint Universe::initialize_heap() {
 821   assert(_collectedHeap == NULL, "Heap already created");
 822   _collectedHeap = GCConfig::arguments()-&gt;create_heap();
 823 
 824   log_info(gc)("Using %s", _collectedHeap-&gt;name());
 825   return _collectedHeap-&gt;initialize();
 826 }
 827 
 828 void Universe::initialize_tlab() {
 829   ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());
 830   if (UseTLAB) {
 831     assert(Universe::heap()-&gt;supports_tlab_allocation(),
 832            "Should support thread-local allocation buffers");
 833     ThreadLocalAllocBuffer::startup_initialization();
 834   }
 835 }
 836 
 837 ReservedHeapSpace Universe::reserve_heap(size_t heap_size, size_t alignment) {
 838 
 839   assert(alignment &lt;= Arguments::conservative_max_heap_alignment(),
 840          "actual alignment " SIZE_FORMAT " must be within maximum heap alignment " SIZE_FORMAT,
 841          alignment, Arguments::conservative_max_heap_alignment());
 842 
 843   size_t total_reserved = align_up(heap_size, alignment);
 844   assert(!UseCompressedOops || (total_reserved &lt;= (OopEncodingHeapMax - os::vm_page_size())),
 845       "heap size is too big for compressed oops");
 846 
 847   bool use_large_pages = UseLargePages &amp;&amp; is_aligned(alignment, os::large_page_size());
 848   assert(!UseLargePages
 849       || UseParallelGC
 850       || use_large_pages, "Wrong alignment to use large pages");
 851 
 852   // Now create the space.
 853   ReservedHeapSpace total_rs(total_reserved, alignment, use_large_pages, AllocateHeapAt);
 854 
 855   if (total_rs.is_reserved()) {
 856     assert((total_reserved == total_rs.size()) &amp;&amp; ((uintptr_t)total_rs.base() % alignment == 0),
 857            "must be exactly of required size and alignment");
 858     // We are good.
 859 
 860     if (AllocateHeapAt != NULL) {
 861       log_info(gc,heap)("Successfully allocated Java heap at location %s", AllocateHeapAt);
 862     }
 863 
 864     if (UseCompressedOops) {
 865       CompressedOops::initialize(total_rs);
 866     }
 867 
 868     Universe::calculate_verify_data((HeapWord*)total_rs.base(), (HeapWord*)total_rs.end());
 869 
 870     return total_rs;
 871   }
 872 
 873   vm_exit_during_initialization(
 874     err_msg("Could not reserve enough space for " SIZE_FORMAT "KB object heap",
 875             total_reserved/K));
 876 
 877   // satisfy compiler
 878   ShouldNotReachHere();
 879   return ReservedHeapSpace(0, 0, false);
 880 }
 881 
 882 
 883 // It's the caller's responsibility to ensure glitch-freedom
 884 // (if required).
 885 void Universe::update_heap_info_at_gc() {
 886   _heap_capacity_at_last_gc = heap()-&gt;capacity();
 887   _heap_used_at_last_gc     = heap()-&gt;used();
 888 }
 889 
 890 OopStorage* Universe::vm_weak() {
 891   return Universe::_vm_weak;
 892 }
 893 
 894 OopStorage* Universe::vm_global() {
 895   return Universe::_vm_global;
 896 }
 897 
 898 void Universe::oopstorage_init() {
 899   Universe::_vm_global = OopStorageSet::create_strong("VM Global");
 900   Universe::_vm_weak = OopStorageSet::create_weak("VM Weak");
 901 }
 902 
 903 void universe_oopstorage_init() {
 904   Universe::oopstorage_init();
 905 }
 906 
 907 void initialize_known_method(LatestMethodCache* method_cache,
 908                              InstanceKlass* ik,
 909                              const char* method,
 910                              Symbol* signature,
 911                              bool is_static, TRAPS)
 912 {
 913   TempNewSymbol name = SymbolTable::new_symbol(method);
 914   Method* m = NULL;
 915   // The klass must be linked before looking up the method.
 916   if (!ik-&gt;link_class_or_fail(THREAD) ||
 917       ((m = ik-&gt;find_method(name, signature)) == NULL) ||
 918       is_static != m-&gt;is_static()) {
 919     ResourceMark rm(THREAD);
 920     // NoSuchMethodException doesn't actually work because it tries to run the
 921     // &lt;init&gt; function before java_lang_Class is linked. Print error and exit.
 922     vm_exit_during_initialization(err_msg("Unable to link/verify %s.%s method",
 923                                  ik-&gt;name()-&gt;as_C_string(), method));
 924   }
 925   method_cache-&gt;init(ik, m);
 926 }
 927 
 928 void Universe::initialize_known_methods(TRAPS) {
 929   // Set up static method for registering finalizers
 930   initialize_known_method(_finalizer_register_cache,
 931                           SystemDictionary::Finalizer_klass(),
 932                           "register",
 933                           vmSymbols::object_void_signature(), true, CHECK);
 934 
 935   initialize_known_method(_throw_illegal_access_error_cache,
 936                           SystemDictionary::internal_Unsafe_klass(),
 937                           "throwIllegalAccessError",
 938                           vmSymbols::void_method_signature(), true, CHECK);
 939 
 940   initialize_known_method(_throw_no_such_method_error_cache,
 941                           SystemDictionary::internal_Unsafe_klass(),
 942                           "throwNoSuchMethodError",
 943                           vmSymbols::void_method_signature(), true, CHECK);
 944 
 945   // Set up method for registering loaded classes in class loader vector
 946   initialize_known_method(_loader_addClass_cache,
 947                           SystemDictionary::ClassLoader_klass(),
 948                           "addClass",
 949                           vmSymbols::class_void_signature(), false, CHECK);
 950 
 951   // Set up method for stack walking
 952   initialize_known_method(_do_stack_walk_cache,
 953                           SystemDictionary::AbstractStackWalker_klass(),
 954                           "doStackWalk",
 955                           vmSymbols::doStackWalk_signature(), false, CHECK);
 956 }
 957 
 958 void universe2_init() {
 959   EXCEPTION_MARK;
 960   Universe::genesis(CATCH);
 961 }
 962 
 963 // Set after initialization of the module runtime, call_initModuleRuntime
 964 void universe_post_module_init() {
 965   Universe::_module_initialized = true;
 966 }
 967 
 968 bool universe_post_init() {
 969   assert(!is_init_completed(), "Error: initialization not yet completed!");
 970   Universe::_fully_initialized = true;
 971   EXCEPTION_MARK;
 972   if (!UseSharedSpaces) {
 973     ResourceMark rm;
 974     Universe::reinitialize_vtables(CHECK_false);
 975     Universe::reinitialize_itables(CHECK_false);
 976   }
 977 
 978   HandleMark hm(THREAD);
 979   // Setup preallocated empty java.lang.Class array for Method reflection.
 980 
 981   objArrayOop the_empty_class_array = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_false);
 982   Universe::_the_empty_class_array = OopHandle(Universe::vm_global(), the_empty_class_array);
 983 
 984   // Setup preallocated OutOfMemoryError errors
 985   Universe::create_preallocated_out_of_memory_errors(CHECK_false);
 986 
 987   oop instance;
 988   // Setup preallocated cause message for delayed StackOverflowError
 989   if (StackReservedPages &gt; 0) {
 990     instance = java_lang_String::create_oop_from_str("Delayed StackOverflowError due to ReservedStackAccess annotated method", CHECK_false);
 991     Universe::_delayed_stack_overflow_error_message = OopHandle(Universe::vm_global(), instance);
 992   }
 993 
 994   // Setup preallocated NullPointerException
 995   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
 996   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);
 997   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
 998   Universe::_null_ptr_exception_instance = OopHandle(Universe::vm_global(), instance);
 999 
1000   // Setup preallocated ArithmeticException
1001   // (this is currently used for a cheap &amp; dirty solution in compiler exception handling)
1002   k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);
1003   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1004   Universe::_arithmetic_exception_instance = OopHandle(Universe::vm_global(), instance);
1005 
1006   // Virtual Machine Error for when we get into a situation we can't resolve
1007   k = SystemDictionary::VirtualMachineError_klass();
1008   bool linked = InstanceKlass::cast(k)-&gt;link_class_or_fail(CHECK_false);
1009   if (!linked) {
1010      tty-&gt;print_cr("Unable to link/verify VirtualMachineError class");
1011      return false; // initialization failed
1012   }
1013   instance = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_false);
1014   Universe::_virtual_machine_error_instance = OopHandle(Universe::vm_global(), instance);
1015 
1016   Handle msg = java_lang_String::create_from_str("/ by zero", CHECK_false);
1017   java_lang_Throwable::set_message(Universe::arithmetic_exception_instance(), msg());
1018 
1019   Universe::initialize_known_methods(CHECK_false);
1020 
1021   // This needs to be done before the first scavenge/gc, since
1022   // it's an input to soft ref clearing policy.
1023   {
1024     MutexLocker x(THREAD, Heap_lock);
1025     Universe::update_heap_info_at_gc();
1026   }
1027 
1028   // ("weak") refs processing infrastructure initialization
1029   Universe::heap()-&gt;post_initialize();
1030 
1031   MemoryService::add_metaspace_memory_pools();
1032 
1033   MemoryService::set_universe_heap(Universe::heap());
1034 #if INCLUDE_CDS
1035   MetaspaceShared::post_initialize(CHECK_false);
1036 #endif
1037   return true;
1038 }
1039 
1040 
1041 void Universe::compute_base_vtable_size() {
1042   _base_vtable_size = ClassLoader::compute_Object_vtable();
1043 }
1044 
1045 void Universe::print_on(outputStream* st) {
1046   GCMutexLocker hl(Heap_lock); // Heap_lock might be locked by caller thread.
1047   st-&gt;print_cr("Heap");
1048   heap()-&gt;print_on(st);
1049 }
1050 
1051 void Universe::print_heap_at_SIGBREAK() {
1052   if (PrintHeapAtSIGBREAK) {
1053     print_on(tty);
1054     tty-&gt;cr();
1055     tty-&gt;flush();
1056   }
1057 }
1058 
1059 void Universe::print_heap_before_gc() {
1060   LogTarget(Debug, gc, heap) lt;
1061   if (lt.is_enabled()) {
1062     LogStream ls(lt);
1063     ls.print("Heap before GC invocations=%u (full %u):", heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1064     ResourceMark rm;
1065     heap()-&gt;print_on(&amp;ls);
1066   }
1067 }
1068 
1069 void Universe::print_heap_after_gc() {
1070   LogTarget(Debug, gc, heap) lt;
1071   if (lt.is_enabled()) {
1072     LogStream ls(lt);
1073     ls.print("Heap after GC invocations=%u (full %u):", heap()-&gt;total_collections(), heap()-&gt;total_full_collections());
1074     ResourceMark rm;
1075     heap()-&gt;print_on(&amp;ls);
1076   }
1077 }
1078 
1079 void Universe::initialize_verify_flags() {
1080   verify_flags = 0;
1081   const char delimiter[] = " ,";
1082 
1083   size_t length = strlen(VerifySubSet);
1084   char* subset_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
1085   strncpy(subset_list, VerifySubSet, length + 1);
1086   char* save_ptr;
1087 
1088   char* token = strtok_r(subset_list, delimiter, &amp;save_ptr);
1089   while (token != NULL) {
1090     if (strcmp(token, "threads") == 0) {
1091       verify_flags |= Verify_Threads;
1092     } else if (strcmp(token, "heap") == 0) {
1093       verify_flags |= Verify_Heap;
1094     } else if (strcmp(token, "symbol_table") == 0) {
1095       verify_flags |= Verify_SymbolTable;
1096     } else if (strcmp(token, "string_table") == 0) {
1097       verify_flags |= Verify_StringTable;
1098     } else if (strcmp(token, "codecache") == 0) {
1099       verify_flags |= Verify_CodeCache;
1100     } else if (strcmp(token, "dictionary") == 0) {
1101       verify_flags |= Verify_SystemDictionary;
1102     } else if (strcmp(token, "classloader_data_graph") == 0) {
1103       verify_flags |= Verify_ClassLoaderDataGraph;
1104     } else if (strcmp(token, "metaspace") == 0) {
1105       verify_flags |= Verify_MetaspaceUtils;
1106     } else if (strcmp(token, "jni_handles") == 0) {
1107       verify_flags |= Verify_JNIHandles;
1108     } else if (strcmp(token, "codecache_oops") == 0) {
1109       verify_flags |= Verify_CodeCacheOops;
1110     } else if (strcmp(token, "resolved_method_table") == 0) {
1111       verify_flags |= Verify_ResolvedMethodTable;
1112     } else {
1113       vm_exit_during_initialization(err_msg("VerifySubSet: \'%s\' memory sub-system is unknown, please correct it", token));
1114     }
1115     token = strtok_r(NULL, delimiter, &amp;save_ptr);
1116   }
1117   FREE_C_HEAP_ARRAY(char, subset_list);
1118 }
1119 
1120 bool Universe::should_verify_subset(uint subset) {
1121   if (verify_flags &amp; subset) {
1122     return true;
1123   }
1124   return false;
1125 }
1126 
1127 void Universe::verify(VerifyOption option, const char* prefix) {
1128   // The use of _verify_in_progress is a temporary work around for
1129   // 6320749.  Don't bother with a creating a class to set and clear
1130   // it since it is only used in this method and the control flow is
1131   // straight forward.
1132   _verify_in_progress = true;
1133 
1134   COMPILER2_PRESENT(
1135     assert(!DerivedPointerTable::is_active(),
1136          "DPT should not be active during verification "
1137          "(of thread stacks below)");
1138   )
1139 
1140   Thread* thread = Thread::current();
1141   ResourceMark rm(thread);
1142   HandleMark hm(thread);  // Handles created during verification can be zapped
1143   _verify_count++;
1144 
1145   FormatBuffer&lt;&gt; title("Verifying %s", prefix);
1146   GCTraceTime(Info, gc, verify) tm(title.buffer());
1147   if (should_verify_subset(Verify_Threads)) {
1148     log_debug(gc, verify)("Threads");
1149     Threads::verify();
1150   }
1151   if (should_verify_subset(Verify_Heap)) {
1152     log_debug(gc, verify)("Heap");
1153     heap()-&gt;verify(option);
1154   }
1155   if (should_verify_subset(Verify_SymbolTable)) {
1156     log_debug(gc, verify)("SymbolTable");
1157     SymbolTable::verify();
1158   }
1159   if (should_verify_subset(Verify_StringTable)) {
1160     log_debug(gc, verify)("StringTable");
1161     StringTable::verify();
1162   }
1163   if (should_verify_subset(Verify_CodeCache)) {
1164   {
1165     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1166     log_debug(gc, verify)("CodeCache");
1167     CodeCache::verify();
1168   }
1169   }
1170   if (should_verify_subset(Verify_SystemDictionary)) {
1171     log_debug(gc, verify)("SystemDictionary");
1172     SystemDictionary::verify();
1173   }
1174   if (should_verify_subset(Verify_ClassLoaderDataGraph)) {
1175     log_debug(gc, verify)("ClassLoaderDataGraph");
1176     ClassLoaderDataGraph::verify();
1177   }
1178   if (should_verify_subset(Verify_MetaspaceUtils)) {
1179     log_debug(gc, verify)("MetaspaceUtils");
<a name="1" id="anc1"></a><span class="changed">1180     DEBUG_ONLY(MetaspaceUtils::verify(true);)</span>
1181   }
1182   if (should_verify_subset(Verify_JNIHandles)) {
1183     log_debug(gc, verify)("JNIHandles");
1184     JNIHandles::verify();
1185   }
1186   if (should_verify_subset(Verify_CodeCacheOops)) {
1187     log_debug(gc, verify)("CodeCache Oops");
1188     CodeCache::verify_oops();
1189   }
1190   if (should_verify_subset(Verify_ResolvedMethodTable)) {
1191     log_debug(gc, verify)("ResolvedMethodTable Oops");
1192     ResolvedMethodTable::verify();
1193   }
1194 
1195   _verify_in_progress = false;
1196 }
1197 
1198 
1199 #ifndef PRODUCT
1200 void Universe::calculate_verify_data(HeapWord* low_boundary, HeapWord* high_boundary) {
1201   assert(low_boundary &lt; high_boundary, "bad interval");
1202 
1203   // decide which low-order bits we require to be clear:
1204   size_t alignSize = MinObjAlignmentInBytes;
1205   size_t min_object_size = CollectedHeap::min_fill_size();
1206 
1207   // make an inclusive limit:
1208   uintptr_t max = (uintptr_t)high_boundary - min_object_size*wordSize;
1209   uintptr_t min = (uintptr_t)low_boundary;
1210   assert(min &lt; max, "bad interval");
1211   uintptr_t diff = max ^ min;
1212 
1213   // throw away enough low-order bits to make the diff vanish
1214   uintptr_t mask = (uintptr_t)(-1);
1215   while ((mask &amp; diff) != 0)
1216     mask &lt;&lt;= 1;
1217   uintptr_t bits = (min &amp; mask);
1218   assert(bits == (max &amp; mask), "correct mask");
1219   // check an intermediate value between min and max, just to make sure:
1220   assert(bits == ((min + (max-min)/2) &amp; mask), "correct mask");
1221 
1222   // require address alignment, too:
1223   mask |= (alignSize - 1);
1224 
1225   if (!(_verify_oop_mask == 0 &amp;&amp; _verify_oop_bits == (uintptr_t)-1)) {
1226     assert(_verify_oop_mask == mask &amp;&amp; _verify_oop_bits == bits, "mask stability");
1227   }
1228   _verify_oop_mask = mask;
1229   _verify_oop_bits = bits;
1230 }
1231 
1232 // Oop verification (see MacroAssembler::verify_oop)
1233 
1234 uintptr_t Universe::verify_oop_mask() {
1235   return _verify_oop_mask;
1236 }
1237 
1238 uintptr_t Universe::verify_oop_bits() {
1239   return _verify_oop_bits;
1240 }
1241 
1242 uintptr_t Universe::verify_mark_mask() {
1243   return markWord::lock_mask_in_place;
1244 }
1245 
1246 uintptr_t Universe::verify_mark_bits() {
1247   intptr_t mask = verify_mark_mask();
1248   intptr_t bits = (intptr_t)markWord::prototype().value();
1249   assert((bits &amp; ~mask) == 0, "no stray header bits");
1250   return bits;
1251 }
1252 #endif // PRODUCT
1253 
1254 
1255 void LatestMethodCache::init(Klass* k, Method* m) {
1256   if (!UseSharedSpaces) {
1257     _klass = k;
1258   }
1259 #ifndef PRODUCT
1260   else {
1261     // sharing initilization should have already set up _klass
1262     assert(_klass != NULL, "just checking");
1263   }
1264 #endif
1265 
1266   _method_idnum = m-&gt;method_idnum();
1267   assert(_method_idnum &gt;= 0, "sanity check");
1268 }
1269 
1270 
1271 Method* LatestMethodCache::get_method() {
1272   if (klass() == NULL) return NULL;
1273   InstanceKlass* ik = InstanceKlass::cast(klass());
1274   Method* m = ik-&gt;method_with_idnum(method_idnum());
1275   assert(m != NULL, "sanity check");
1276   return m;
1277 }
1278 
1279 
1280 #ifdef ASSERT
1281 // Release dummy object(s) at bottom of heap
1282 bool Universe::release_fullgc_alot_dummy() {
1283   MutexLocker ml(FullGCALot_lock);
1284   objArrayOop fullgc_alot_dummy_array = (objArrayOop)_fullgc_alot_dummy_array.resolve();
1285   if (fullgc_alot_dummy_array != NULL) {
1286     if (_fullgc_alot_dummy_next &gt;= fullgc_alot_dummy_array-&gt;length()) {
1287       // No more dummies to release, release entire array instead
1288       _fullgc_alot_dummy_array.release(Universe::vm_global());
1289       return false;
1290     }
1291 
1292     // Release dummy at bottom of old generation
1293     fullgc_alot_dummy_array-&gt;obj_at_put(_fullgc_alot_dummy_next++, NULL);
1294   }
1295   return true;
1296 }
1297 
1298 #endif // ASSERT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
