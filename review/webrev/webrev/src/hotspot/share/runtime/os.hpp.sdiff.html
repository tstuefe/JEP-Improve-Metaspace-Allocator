<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/runtime </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/runtime/globals.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/vmOperations.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/runtime/os.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 388 
 389   // Page manipulation
 390   struct page_info {
 391     size_t size;
 392     int lgrp_id;
 393   };
 394   static bool   get_page_info(char *start, page_info* info);
 395   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 396 
 397   static char*  non_memory_address_word();
 398   // reserve, commit and pin the entire memory region
 399   static char*  reserve_memory_special(size_t size, size_t alignment,
 400                                        char* addr, bool executable);
 401   static bool   release_memory_special(char* addr, size_t bytes);
 402   static void   large_page_init();
 403   static size_t large_page_size();
 404   static bool   can_commit_large_page_memory();
 405   static bool   can_execute_large_page_memory();
 406 
 407   // Check if pointer points to readable memory (by 4-byte read access)


 408   static bool    is_readable_pointer(const void* p);
 409   static bool    is_readable_range(const void* from, const void* to);
 410 
 411   // threads
 412 
 413   enum ThreadType {
 414     vm_thread,
 415     cgc_thread,        // Concurrent GC thread
 416     pgc_thread,        // Parallel GC thread
 417     java_thread,       // Java, CodeCacheSweeper, JVMTIAgent and Service threads.
 418     compiler_thread,
 419     watcher_thread,
 420     os_thread
 421   };
 422 
 423   static bool create_thread(Thread* thread,
 424                             ThreadType thr_type,
 425                             size_t req_stack_size = 0);
 426 
 427   // The "main thread", also known as "starting thread", is the thread

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 388 
 389   // Page manipulation
 390   struct page_info {
 391     size_t size;
 392     int lgrp_id;
 393   };
 394   static bool   get_page_info(char *start, page_info* info);
 395   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 396 
 397   static char*  non_memory_address_word();
 398   // reserve, commit and pin the entire memory region
 399   static char*  reserve_memory_special(size_t size, size_t alignment,
 400                                        char* addr, bool executable);
 401   static bool   release_memory_special(char* addr, size_t bytes);
 402   static void   large_page_init();
 403   static size_t large_page_size();
 404   static bool   can_commit_large_page_memory();
 405   static bool   can_execute_large_page_memory();
 406 
 407   // Check if pointer points to readable memory (by 4-byte read access)
<span class="new"> 408   // !! Unreliable before VM initialization! Use CanUseSafeFetch32() to test</span>
<span class="new"> 409   //    if this function is reliable !!</span>
 410   static bool    is_readable_pointer(const void* p);
 411   static bool    is_readable_range(const void* from, const void* to);
 412 
 413   // threads
 414 
 415   enum ThreadType {
 416     vm_thread,
 417     cgc_thread,        // Concurrent GC thread
 418     pgc_thread,        // Parallel GC thread
 419     java_thread,       // Java, CodeCacheSweeper, JVMTIAgent and Service threads.
 420     compiler_thread,
 421     watcher_thread,
 422     os_thread
 423   };
 424 
 425   static bool create_thread(Thread* thread,
 426                             ThreadType thr_type,
 427                             size_t req_stack_size = 0);
 428 
 429   // The "main thread", also known as "starting thread", is the thread

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/runtime/globals.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/vmOperations.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
