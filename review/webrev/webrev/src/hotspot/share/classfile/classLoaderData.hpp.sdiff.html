<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/classfile </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/classfile/classLoaderData.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderDataGraph.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/classfile/classLoaderData.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  46 // A class loader represents a linkset. Conceptually, a linkset identifies
  47 // the complete transitive closure of resolved links that a dynamic linker can
  48 // produce.
  49 //
  50 // A ClassLoaderData also encapsulates the allocation space, called a metaspace,
  51 // used by the dynamic linker to allocate the runtime representation of all
  52 // the types it defines.
  53 //
  54 // ClassLoaderData are stored in the runtime representation of classes,
  55 // and provides iterators for root tracing and other GC operations.
  56 
  57 class ClassLoaderDataGraph;
  58 class JNIMethodBlock;
  59 class ModuleEntry;
  60 class PackageEntry;
  61 class ModuleEntryTable;
  62 class PackageEntryTable;
  63 class DictionaryEntry;
  64 class Dictionary;
  65 




  66 // ClassLoaderData class
  67 
  68 class ClassLoaderData : public CHeapObj&lt;mtClass&gt; {
  69   friend class VMStructs;
  70 
  71  private:
  72   class ChunkedHandleList {
  73     struct Chunk : public CHeapObj&lt;mtClass&gt; {
  74       static const size_t CAPACITY = 32;
  75 
  76       oop _data[CAPACITY];
  77       volatile juint _size;
  78       Chunk* _next;
  79 
  80       Chunk(Chunk* c) : _size(0), _next(c) { }
  81     };
  82 
  83     Chunk* volatile _head;
  84 
  85     void oops_do_chunk(OopClosure* f, Chunk* c, const juint size);

</pre><hr></hr><pre>
  96     void oops_do(OopClosure* f);
  97 
  98     int count() const;
  99   };
 100 
 101   friend class ClassLoaderDataGraph;
 102   friend class ClassLoaderDataGraphIterator;
 103   friend class ClassLoaderDataGraphKlassIteratorAtomic;
 104   friend class ClassLoaderDataGraphKlassIteratorStatic;
 105   friend class ClassLoaderDataGraphMetaspaceIterator;
 106   friend class Klass;
 107   friend class MetaDataFactory;
 108   friend class Method;
 109 
 110   static ClassLoaderData * _the_null_class_loader_data;
 111 
 112   WeakHandle _holder;       // The oop that determines lifetime of this class loader
 113   OopHandle  _class_loader; // The instance of java/lang/ClassLoader associated with
 114                             // this ClassLoaderData
 115 
<span class="changed"> 116   ClassLoaderMetaspace * volatile _metaspace;  // Meta-space where meta-data defined by the</span>
 117                                     // classes in the class loader are allocated.
 118   Mutex* _metaspace_lock;  // Locks the metaspace for allocations and setup.
 119   bool _unloading;         // true if this class loader goes away
 120   bool _has_class_mirror_holder; // If true, CLD is dedicated to one class and that class determines
 121                                  // the CLDs lifecycle.  For example, a non-strong hidden class or an
 122                                  // unsafe anonymous class.  Arrays of these classes are also assigned
 123                                  // to these class loader datas.
 124 
 125   // Remembered sets support for the oops in the class loader data.
 126   bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
 127   bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
 128 
 129   int _keep_alive;         // if this CLD is kept alive.
 130                            // Used for non-strong hidden classes, unsafe anonymous classes and the
 131                            // boot class loader. _keep_alive does not need to be volatile or
 132                            // atomic since there is one unique CLD per non-strong hidden class
 133                            // or unsafe anonymous class.
 134 
 135   volatile int _claim; // non-zero if claimed, for example during GC traces.
 136                        // To avoid applying oop closure more than once.

</pre><hr></hr><pre>
 209 
 210   // The "claim" is typically used to check if oops_do needs to be applied on
 211   // the CLD or not. Most GCs only perform strong marking during the marking phase.
 212   enum Claim {
 213     _claim_none         = 0,
 214     _claim_finalizable  = 2,
 215     _claim_strong       = 3,
 216     _claim_other        = 4
 217   };
 218   void clear_claim() { _claim = 0; }
 219   void clear_claim(int claim);
 220   bool claimed() const { return _claim != 0; }
 221   bool claimed(int claim) const { return (_claim &amp; claim) == claim; }
 222   bool try_claim(int claim);
 223 
 224   // Computes if the CLD is alive or not. This is safe to call in concurrent
 225   // contexts.
 226   bool is_alive() const;
 227 
 228   // Accessors
<span class="changed"> 229   ClassLoaderMetaspace* metaspace_or_null() const { return _metaspace; }</span>
 230 
 231   static ClassLoaderData* the_null_class_loader_data() {
 232     return _the_null_class_loader_data;
 233   }
 234 
 235   Mutex* metaspace_lock() const { return _metaspace_lock; }
 236 
 237   bool has_class_mirror_holder() const { return _has_class_mirror_holder; }
 238 
 239   static void init_null_class_loader_data();
 240 
 241   bool is_the_null_class_loader_data() const {
 242     return this == _the_null_class_loader_data;
 243   }
 244 
 245   // Returns true if this class loader data is for the system class loader.
 246   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 247   bool is_system_class_loader_data() const;
 248 
 249   // Returns true if this class loader data is for the platform class loader.
 250   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 251   bool is_platform_class_loader_data() const;
 252 
 253   // Returns true if this class loader data is for the boot class loader.
 254   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 255   inline bool is_boot_class_loader_data() const;
 256 
 257   bool is_builtin_class_loader_data() const;
 258   bool is_permanent_class_loader_data() const;
 259 
 260   // The Metaspace is created lazily so may be NULL.  This
 261   // method will allocate a Metaspace if needed.
<span class="changed"> 262   ClassLoaderMetaspace* metaspace_non_null();</span>
 263 
 264   inline oop class_loader() const;
 265 
 266   // Returns true if this class loader data is for a loader going away.
 267   // Note that this is only safe after the GC has computed if the CLD is
 268   // unloading or not. In concurrent contexts where there are no such
 269   // guarantees, is_alive() should be used instead.
 270   bool is_unloading() const     {
 271     assert(!(is_the_null_class_loader_data() &amp;&amp; _unloading), "The null class loader can never be unloaded");
 272     return _unloading;
 273   }
 274 
 275   // Used to refcount a non-strong hidden class's or unsafe anonymous class's CLD in order to
 276   // indicate their aliveness.
 277   void inc_keep_alive();
 278   void dec_keep_alive();
 279 
 280   void initialize_holder(Handle holder);
 281 
 282   void oops_do(OopClosure* f, int claim_value, bool clear_modified_oops = false);

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
  46 // A class loader represents a linkset. Conceptually, a linkset identifies
  47 // the complete transitive closure of resolved links that a dynamic linker can
  48 // produce.
  49 //
  50 // A ClassLoaderData also encapsulates the allocation space, called a metaspace,
  51 // used by the dynamic linker to allocate the runtime representation of all
  52 // the types it defines.
  53 //
  54 // ClassLoaderData are stored in the runtime representation of classes,
  55 // and provides iterators for root tracing and other GC operations.
  56 
  57 class ClassLoaderDataGraph;
  58 class JNIMethodBlock;
  59 class ModuleEntry;
  60 class PackageEntry;
  61 class ModuleEntryTable;
  62 class PackageEntryTable;
  63 class DictionaryEntry;
  64 class Dictionary;
  65 
<span class="new">  66 namespace metaspace {</span>
<span class="new">  67   class ClassLoaderMetaspace;</span>
<span class="new">  68 }</span>
<span class="new">  69 </span>
  70 // ClassLoaderData class
  71 
  72 class ClassLoaderData : public CHeapObj&lt;mtClass&gt; {
  73   friend class VMStructs;
  74 
  75  private:
  76   class ChunkedHandleList {
  77     struct Chunk : public CHeapObj&lt;mtClass&gt; {
  78       static const size_t CAPACITY = 32;
  79 
  80       oop _data[CAPACITY];
  81       volatile juint _size;
  82       Chunk* _next;
  83 
  84       Chunk(Chunk* c) : _size(0), _next(c) { }
  85     };
  86 
  87     Chunk* volatile _head;
  88 
  89     void oops_do_chunk(OopClosure* f, Chunk* c, const juint size);

</pre><hr></hr><pre>
 100     void oops_do(OopClosure* f);
 101 
 102     int count() const;
 103   };
 104 
 105   friend class ClassLoaderDataGraph;
 106   friend class ClassLoaderDataGraphIterator;
 107   friend class ClassLoaderDataGraphKlassIteratorAtomic;
 108   friend class ClassLoaderDataGraphKlassIteratorStatic;
 109   friend class ClassLoaderDataGraphMetaspaceIterator;
 110   friend class Klass;
 111   friend class MetaDataFactory;
 112   friend class Method;
 113 
 114   static ClassLoaderData * _the_null_class_loader_data;
 115 
 116   WeakHandle _holder;       // The oop that determines lifetime of this class loader
 117   OopHandle  _class_loader; // The instance of java/lang/ClassLoader associated with
 118                             // this ClassLoaderData
 119 
<span class="changed"> 120   metaspace::ClassLoaderMetaspace* volatile _metaspace;  // Meta-space where meta-data defined by the</span>
 121                                     // classes in the class loader are allocated.
 122   Mutex* _metaspace_lock;  // Locks the metaspace for allocations and setup.
 123   bool _unloading;         // true if this class loader goes away
 124   bool _has_class_mirror_holder; // If true, CLD is dedicated to one class and that class determines
 125                                  // the CLDs lifecycle.  For example, a non-strong hidden class or an
 126                                  // unsafe anonymous class.  Arrays of these classes are also assigned
 127                                  // to these class loader datas.
 128 
 129   // Remembered sets support for the oops in the class loader data.
 130   bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
 131   bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
 132 
 133   int _keep_alive;         // if this CLD is kept alive.
 134                            // Used for non-strong hidden classes, unsafe anonymous classes and the
 135                            // boot class loader. _keep_alive does not need to be volatile or
 136                            // atomic since there is one unique CLD per non-strong hidden class
 137                            // or unsafe anonymous class.
 138 
 139   volatile int _claim; // non-zero if claimed, for example during GC traces.
 140                        // To avoid applying oop closure more than once.

</pre><hr></hr><pre>
 213 
 214   // The "claim" is typically used to check if oops_do needs to be applied on
 215   // the CLD or not. Most GCs only perform strong marking during the marking phase.
 216   enum Claim {
 217     _claim_none         = 0,
 218     _claim_finalizable  = 2,
 219     _claim_strong       = 3,
 220     _claim_other        = 4
 221   };
 222   void clear_claim() { _claim = 0; }
 223   void clear_claim(int claim);
 224   bool claimed() const { return _claim != 0; }
 225   bool claimed(int claim) const { return (_claim &amp; claim) == claim; }
 226   bool try_claim(int claim);
 227 
 228   // Computes if the CLD is alive or not. This is safe to call in concurrent
 229   // contexts.
 230   bool is_alive() const;
 231 
 232   // Accessors
<span class="changed"> 233   metaspace::ClassLoaderMetaspace* metaspace_or_null() const { return _metaspace; }</span>
 234 
 235   static ClassLoaderData* the_null_class_loader_data() {
 236     return _the_null_class_loader_data;
 237   }
 238 
 239   Mutex* metaspace_lock() const { return _metaspace_lock; }
 240 
 241   bool has_class_mirror_holder() const { return _has_class_mirror_holder; }
 242 
 243   static void init_null_class_loader_data();
 244 
 245   bool is_the_null_class_loader_data() const {
 246     return this == _the_null_class_loader_data;
 247   }
 248 
 249   // Returns true if this class loader data is for the system class loader.
 250   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 251   bool is_system_class_loader_data() const;
 252 
 253   // Returns true if this class loader data is for the platform class loader.
 254   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 255   bool is_platform_class_loader_data() const;
 256 
 257   // Returns true if this class loader data is for the boot class loader.
 258   // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
 259   inline bool is_boot_class_loader_data() const;
 260 
 261   bool is_builtin_class_loader_data() const;
 262   bool is_permanent_class_loader_data() const;
 263 
 264   // The Metaspace is created lazily so may be NULL.  This
 265   // method will allocate a Metaspace if needed.
<span class="changed"> 266   metaspace::ClassLoaderMetaspace* metaspace_non_null();</span>
 267 
 268   inline oop class_loader() const;
 269 
 270   // Returns true if this class loader data is for a loader going away.
 271   // Note that this is only safe after the GC has computed if the CLD is
 272   // unloading or not. In concurrent contexts where there are no such
 273   // guarantees, is_alive() should be used instead.
 274   bool is_unloading() const     {
 275     assert(!(is_the_null_class_loader_data() &amp;&amp; _unloading), "The null class loader can never be unloaded");
 276     return _unloading;
 277   }
 278 
 279   // Used to refcount a non-strong hidden class's or unsafe anonymous class's CLD in order to
 280   // indicate their aliveness.
 281   void inc_keep_alive();
 282   void dec_keep_alive();
 283 
 284   void initialize_holder(Handle holder);
 285 
 286   void oops_do(OopClosure* f, int claim_value, bool clear_modified_oops = false);

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/classfile/classLoaderData.cpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderDataGraph.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
