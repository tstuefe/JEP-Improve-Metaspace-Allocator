<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_GC_SHARED_GCVMOPERATIONS_HPP
  26 #define SHARE_GC_SHARED_GCVMOPERATIONS_HPP
  27 
  28 #include "gc/shared/collectedHeap.hpp"
  29 #include "gc/shared/genCollectedHeap.hpp"
  30 #include "memory/heapInspection.hpp"
<a name="1" id="anc1"></a>
  31 #include "prims/jvmtiExport.hpp"
  32 #include "runtime/handles.hpp"
  33 #include "runtime/jniHandles.hpp"
  34 #include "runtime/synchronizer.hpp"
  35 #include "runtime/vmOperations.hpp"
  36 
  37 // The following class hierarchy represents
  38 // a set of operations (VM_Operation) related to GC.
  39 //
  40 //  VM_Operation
  41 //      VM_GC_Operation
  42 //          VM_GC_HeapInspection
  43 //          VM_GenCollectFull
  44 //          VM_GenCollectFullConcurrent
  45 //          VM_ParallelGCSystemGC
  46 //          VM_CollectForAllocation
  47 //              VM_GenCollectForAllocation
  48 //              VM_ParallelGCFailedAllocation
  49 //  VM_GC_Operation
  50 //   - implements methods common to all classes in the hierarchy:
  51 //     prevents multiple gc requests and manages lock on heap;
  52 //
  53 //  VM_GC_HeapInspection
  54 //   - prints class histogram on SIGBREAK if PrintClassHistogram
  55 //     is specified; and also the attach "inspectheap" operation
  56 //
  57 //  VM_CollectForAllocation
  58 //  VM_GenCollectForAllocation
  59 //  VM_ParallelGCFailedAllocation
  60 //   - this operation is invoked when allocation is failed;
  61 //     operation performs garbage collection and tries to
  62 //     allocate afterwards;
  63 //
  64 //  VM_GenCollectFull
  65 //  VM_GenCollectFullConcurrent
  66 //  VM_ParallelGCSystemGC
  67 //   - these operations preform full collection of heaps of
  68 //     different kind
  69 //
  70 
  71 class VM_GC_Operation: public VM_Operation {
  72  protected:
  73   uint           _gc_count_before;         // gc count before acquiring PLL
  74   uint           _full_gc_count_before;    // full gc count before acquiring PLL
  75   bool           _full;                    // whether a "full" collection
  76   bool           _prologue_succeeded;      // whether doit_prologue succeeded
  77   GCCause::Cause _gc_cause;                // the putative cause for this gc op
  78   bool           _gc_locked;               // will be set if gc was locked
  79 
  80   virtual bool skip_operation() const;
  81 
  82  public:
  83   VM_GC_Operation(uint gc_count_before,
  84                   GCCause::Cause _cause,
  85                   uint full_gc_count_before = 0,
  86                   bool full = false) {
  87     _full = full;
  88     _prologue_succeeded = false;
  89     _gc_count_before    = gc_count_before;
  90 
  91     // A subclass constructor will likely overwrite the following
  92     _gc_cause           = _cause;
  93 
  94     _gc_locked = false;
  95 
  96     _full_gc_count_before = full_gc_count_before;
  97     // In ParallelScavengeHeap::mem_allocate() collections can be
  98     // executed within a loop and _all_soft_refs_clear can be set
  99     // true after they have been cleared by a collection and another
 100     // collection started so that _all_soft_refs_clear can be true
 101     // when this collection is started.  Don't assert that
 102     // _all_soft_refs_clear have to be false here even though
 103     // mutators have run.  Soft refs will be cleared again in this
 104     // collection.
 105   }
 106   ~VM_GC_Operation();
 107 
 108   // Acquire the reference synchronization lock
 109   virtual bool doit_prologue();
 110   // Do notifyAll (if needed) and release held lock
 111   virtual void doit_epilogue();
 112 
 113   virtual bool allow_nested_vm_operations() const  { return true; }
 114   bool prologue_succeeded() const { return _prologue_succeeded; }
 115 
 116   void set_gc_locked() { _gc_locked = true; }
 117   bool gc_locked() const  { return _gc_locked; }
 118 
 119   static void notify_gc_begin(bool full = false);
 120   static void notify_gc_end();
 121 };
 122 
 123 
 124 class VM_GC_HeapInspection: public VM_GC_Operation {
 125  private:
 126   outputStream* _out;
 127   bool _full_gc;
 128  public:
 129   VM_GC_HeapInspection(outputStream* out, bool request_full_gc) :
 130     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
 131                     GCCause::_heap_inspection /* GC Cause */,
 132                     0 /* total full collections, dummy, ignored */,
 133                     request_full_gc), _out(out), _full_gc(request_full_gc) {}
 134 
 135   ~VM_GC_HeapInspection() {}
 136   virtual VMOp_Type type() const { return VMOp_GC_HeapInspection; }
 137   virtual bool skip_operation() const;
 138   virtual void doit();
 139  protected:
 140   bool collect();
 141 };
 142 
 143 class VM_CollectForAllocation : public VM_GC_Operation {
 144  protected:
 145   size_t    _word_size; // Size of object to be allocated (in number of words)
 146   HeapWord* _result;    // Allocation result (NULL if allocation failed)
 147 
 148  public:
 149   VM_CollectForAllocation(size_t word_size, uint gc_count_before, GCCause::Cause cause);
 150 
 151   HeapWord* result() const {
 152     return _result;
 153   }
 154 };
 155 
 156 class VM_GenCollectForAllocation : public VM_CollectForAllocation {
 157  private:
 158   bool        _tlab;                       // alloc is of a tlab.
 159  public:
 160   VM_GenCollectForAllocation(size_t word_size,
 161                              bool tlab,
 162                              uint gc_count_before)
 163     : VM_CollectForAllocation(word_size, gc_count_before, GCCause::_allocation_failure),
 164       _tlab(tlab) {
 165     assert(word_size != 0, "An allocation should always be requested with this operation.");
 166   }
 167   ~VM_GenCollectForAllocation()  {}
 168   virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }
 169   virtual void doit();
 170 };
 171 
 172 // VM operation to invoke a collection of the heap as a
 173 // GenCollectedHeap heap.
 174 class VM_GenCollectFull: public VM_GC_Operation {
 175  private:
 176   GenCollectedHeap::GenerationType _max_generation;
 177  public:
 178   VM_GenCollectFull(uint gc_count_before,
 179                     uint full_gc_count_before,
 180                     GCCause::Cause gc_cause,
 181                     GenCollectedHeap::GenerationType max_generation)
 182     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,
 183                       max_generation != GenCollectedHeap::YoungGen /* full */),
 184       _max_generation(max_generation) { }
 185   ~VM_GenCollectFull() {}
 186   virtual VMOp_Type type() const { return VMOp_GenCollectFull; }
 187   virtual void doit();
 188 };
 189 
 190 class VM_CollectForMetadataAllocation: public VM_GC_Operation {
 191  private:
 192   MetaWord*                _result;
 193   size_t                   _size;     // size of object to be allocated
 194   Metaspace::MetadataType  _mdtype;
 195   ClassLoaderData*         _loader_data;
 196 
 197  public:
 198   VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
 199                                   size_t size,
 200                                   Metaspace::MetadataType mdtype,
 201                                   uint gc_count_before,
 202                                   uint full_gc_count_before,
 203                                   GCCause::Cause gc_cause);
 204 
 205   virtual VMOp_Type type() const { return VMOp_CollectForMetadataAllocation; }
 206   virtual void doit();
 207   MetaWord* result() const       { return _result; }
 208 
 209   bool initiate_concurrent_GC();
 210 };
 211 
 212 class SvcGCMarker : public StackObj {
 213  private:
 214   JvmtiGCMarker _jgcm;
 215  public:
 216   typedef enum { MINOR, FULL, CONCURRENT } reason_type;
 217 
 218   SvcGCMarker(reason_type reason ) {
 219     VM_GC_Operation::notify_gc_begin(reason == FULL);
 220   }
 221 
 222   ~SvcGCMarker() {
 223     VM_GC_Operation::notify_gc_end();
 224   }
 225 };
 226 
 227 #endif // SHARE_GC_SHARED_GCVMOPERATIONS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
