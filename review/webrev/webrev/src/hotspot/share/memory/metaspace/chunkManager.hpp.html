<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  27 #define SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "memory/metaspace/freeChunkList.hpp"
  33 #include "memory/metaspace/metachunk.hpp"
  34 
  35 namespace metaspace {
  36 
  37 class VirtualSpaceList;
  38 struct cm_stats_t;
  39 
  40 // ChunkManager has a central role.
  41 
  42 // SpaceManagers request chunks from it. It keeps the freelists for chunks.
  43 // If the freelist is exhausted it allocates new chunks from a connected
  44 // VirtualSpaceList.
  45 //
  46 class ChunkManager : public CHeapObj&lt;mtMetaspace&gt; {
  47 
  48   // A chunk manager is connected to a virtual space list which is used
  49   // to allocate new root chunks when no free chunks are found.
  50   VirtualSpaceList* const _vslist;
  51 
  52   // Name
  53   const char* const _name;
  54 
  55   // Freelists
  56   FreeChunkListVector _chunks;
  57 
  58   // Returns true if this manager contains the given chunk. Slow (walks free lists) and
  59   // only needed for verifications.
  60   DEBUG_ONLY(bool contains_chunk(Metachunk* c) const;)
  61 
  62   // Given a chunk we are about to handout to the caller, make sure it is committed
  63   // according to constants::committed_words_on_fresh_chunks.
  64   // May fail if we hit the commit limit.
  65   static bool commit_chunk_before_handout(Metachunk* c);
  66 
  67   // Given a chunk, split it into a target chunk of a smaller size (target level)
  68   //  at least one, possible more splinter chunks. Splinter chunks are added to the
  69   //  freelist.
  70   // The original chunk must be outside of the freelist and its state must be free.
  71   // The resulting target chunk will be located at the same address as the original
  72   //  chunk, but it will of course be smaller (of a higher level).
  73   // The committed areas within the original chunk carry over to the resulting
  74   //  chunks.
  75   void split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level);
  76 
  77   // See get_chunk(s,s,s)
  78   Metachunk* get_chunk_locked(size_t preferred_word_size, size_t min_word_size, size_t min_committed_words);
  79 
  80   // Uncommit all chunks equal or below the given level.
  81   void uncommit_free_chunks(chunklevel_t max_level);
  82 
  83 public:
  84 
  85   // Creates a chunk manager with a given name (which is for debug purposes only)
  86   // and an associated space list which will be used to request new chunks from
  87   // (see get_chunk())
  88   ChunkManager(const char* name, VirtualSpaceList* space_list);
  89 
  90   // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
  91   //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
  92   // On error, will return NULL.
  93   //
  94   // This function may fail for two reasons:
  95   // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
  96   //   is non-expandable but needs expanding - aka out of compressed class space).
  97   // - Or, if the necessary space cannot be committed because we hit a commit limit.
  98   //   This may be either the GC threshold or MaxMetaspaceSize.
  99   Metachunk* get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words);
 100 
 101   // Convenience function - get a chunk of a given level, uncommitted.
 102   Metachunk* get_chunk(chunklevel_t lvl) { return get_chunk(lvl, lvl, 0); }
 103 
 104   // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 105   //  with neighbors.
 106   // Happens after a Classloader was unloaded and releases its metaspace chunks.
 107   // !! Notes:
 108   //    1) After this method returns, c may not be valid anymore. ** Do not access c after this function returns **.
 109   //    2) This function will not remove c from its current chunk list. This has to be done by the caller prior to
 110   //       calling this method.
 111   void return_chunk(Metachunk* c);
 112 
 113   // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
 114   void return_chunk_simple(Metachunk* c);
 115 
 116   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
 117   // enlarge it in place by claiming its trailing buddy.
 118   //
 119   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 120   //
 121   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 122   // double in size (level decreased by one).
 123   //
 124   // On success, true is returned, false otherwise.
 125   bool attempt_enlarge_chunk(Metachunk* c);
 126 
 127   // Attempt to reclaim free areas in metaspace wholesale:
 128   // - first, attempt to purge nodes of the backing virtual space. This can only be successful
 129   //   if whole nodes are only containing free chunks, so it highly depends on fragmentation.
 130   // - then, it will uncommit areas of free chunks according to the rules laid down in
 131   //   settings (see settings.hpp).
 132   void wholesale_reclaim();
 133 
 134   // Run verifications. slow=true: verify chunk-internal integrity too.
 135   DEBUG_ONLY(void verify(bool slow) const;)
 136   DEBUG_ONLY(void verify_locked(bool slow) const;)
 137 
 138   // Returns the name of this chunk manager.
 139   const char* name() const                  { return _name; }
 140 
 141   // Returns total number of chunks
 142   int total_num_chunks() const              { return _chunks.num_chunks(); }
 143 
 144   // Returns number of words in all free chunks (regardless of commit state).
 145   size_t total_word_size() const            { return _chunks.word_size(); }
 146 
 147   // Returns number of committed words in all free chunks.
 148   size_t total_committed_word_size() const  { return _chunks.committed_word_size(); }
 149 
 150   // Update statistics.
 151   void add_to_statistics(cm_stats_t* out) const;
 152 
 153   void print_on(outputStream* st) const;
 154   void print_on_locked(outputStream* st) const;
 155 
 156 private:
 157 
 158   static ChunkManager* _chunkmanager_class;
 159   static ChunkManager* _chunkmanager_nonclass;
 160 
 161 public:
 162 
 163   static ChunkManager* chunkmanager_class() { return _chunkmanager_class; }
 164   static ChunkManager* chunkmanager_nonclass() { return _chunkmanager_nonclass; }
 165 
 166   static void set_chunkmanager_class(ChunkManager* cm);
 167   static void set_chunkmanager_nonclass(ChunkManager* cm);
 168 
 169 
 170 };
 171 
 172 } // namespace metaspace
 173 
 174 #endif // SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
</pre></body></html>
