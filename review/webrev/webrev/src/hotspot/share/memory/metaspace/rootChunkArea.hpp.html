<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/rootChunkArea.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019 SAP SE. All rights reserved.
   3  * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_ROOTCHUNKAREA_HPP
  27 #define SHARE_MEMORY_METASPACE_ROOTCHUNKAREA_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "utilities/debug.hpp"
  32 #include "utilities/globalDefinitions.hpp"
  33 
  34 class outputStream;
  35 
  36 namespace metaspace {
  37 
  38 class Metachunk;
  39 class MetachunkClosure;
  40 class FreeChunkListVector;
  41 class VirtualSpaceNode;
  42 
  43 
  44 // RootChunkArea describes the chunk composition of a root-chunk-sized area.
  45 //
  46 
  47 class RootChunkArea {
  48 
  49   // The base address of this area.
  50   const MetaWord* const _base;
  51 
  52   // The first chunk in this area; if this area is maximally
  53   // folded, this is the root chunk covering the whole area size.
  54   Metachunk* _first_chunk;
  55 
  56 public:
  57 
  58   RootChunkArea(const MetaWord* base);
  59   ~RootChunkArea();
  60 
  61   // Initialize: allocate a root node and a root chunk header; return the
  62   // root chunk header. It will be partly initialized.
  63   // Note: this just allocates a memory-less header; memory itself is allocated inside VirtualSpaceNode.
  64   Metachunk* alloc_root_chunk_header(VirtualSpaceNode* node);
  65 
  66 
  67   // Given a chunk c, split it recursively until you get a chunk of the given target_level.
  68   //
  69   // The resulting target chunk resides at the same address as the original chunk.
  70   // The resulting splinters are added to freelists.
  71   //
  72   // Returns pointer to the result chunk; the splitted-off chunks are added as
  73   //  free chunks to the freelists.
  74   void split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists);
  75 
  76   // Given a chunk, attempt to merge it recursively with its neighboring chunks.
  77   //
  78   // If successful (merged at least once), returns address of
  79   // the merged chunk; NULL otherwise.
  80   //
  81   // The merged chunks are removed from the freelists.
  82   //
  83   // !!! Please note that if this method returns a non-NULL value, the
  84   // original chunk will be invalid and should not be accessed anymore! !!!
  85   Metachunk* merge(Metachunk* c, FreeChunkListVector* freelists);
  86 
  87   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
  88   // enlarge it in place by claiming its trailing buddy.
  89   //
  90   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
  91   //
  92   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
  93   // double in size (level decreased by one).
  94   //
  95   // On success, true is returned, false otherwise.
  96   bool attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists);
  97 
  98   // Returns true if all chunks in this area are free; false if not.
  99   bool all_chunks_are_free() const;
 100 
 101   /// range ///
 102 
 103   const MetaWord* base() const  { return _base; }
 104   size_t word_size() const      { return chunklevel::MAX_CHUNK_WORD_SIZE; }
 105   const MetaWord* end() const   { return _base + word_size(); }
 106 
 107   // Direct access to the first chunk (use with care)
 108   Metachunk* first_chunk()              { return _first_chunk; }
 109   const Metachunk* first_chunk() const  { return _first_chunk; }
 110 
 111   //// Debug stuff ////
 112 
 113 #ifdef ASSERT
 114   void check_pointer(const MetaWord* p) const {
 115     assert(p &gt;= _base &amp;&amp; p &lt; _base + word_size(),
 116            "pointer " PTR_FORMAT " oob for this root area [" PTR_FORMAT ".." PTR_FORMAT ")",
 117            p2i(p), p2i(_base), p2i(_base + word_size()));
 118   }
 119   void verify(bool slow) const;
 120 
 121   // This is a separate operation from verify(). We should be able to call verify()
 122   // from almost anywhere, regardless of state, but verify_area_is_ideally_merged()
 123   // can only be called outside split and merge ops.
 124   void verify_area_is_ideally_merged() const;
 125 #endif // ASSERT
 126 
 127   void print_on(outputStream* st) const;
 128 
 129 };
 130 
 131 
 132 ///////////////////////
 133 // A lookup table for RootChunkAreas: given an address into a VirtualSpaceNode,
 134 // it gives the RootChunkArea containing this address.
 135 // To reduce pointer chasing, the LUT entries (of type RootChunkArea) are
 136 // following this object.
 137 class RootChunkAreaLUT {
 138 
 139   // Base address of the whole area.
 140   const MetaWord* const _base;
 141 
 142   // Number of root chunk areas.
 143   const int _num;
 144 
 145   // Array of RootChunkArea objects.
 146   RootChunkArea* _arr;
 147 
 148 #ifdef ASSERT
 149   void check_pointer(const MetaWord* p) const {
 150     assert(p &gt;= base() &amp;&amp; p &lt; base() + word_size(), "Invalid pointer");
 151   }
 152 #endif
 153 
 154   // Given an address into this range, return the index into the area array for the
 155   // area this address falls into.
 156   int index_by_address(const MetaWord* p) const {
 157     DEBUG_ONLY(check_pointer(p);)
 158     int idx = (int)((p - base()) / chunklevel::MAX_CHUNK_WORD_SIZE);
 159     assert(idx &gt;= 0 &amp;&amp; idx &lt; _num, "Sanity");
 160     return idx;
 161   }
 162 
 163 public:
 164 
 165   RootChunkAreaLUT(const MetaWord* base, size_t word_size);
 166   ~RootChunkAreaLUT();
 167 
 168   // Given a memory address into the range this array covers, return the
 169   // corresponding area object. If none existed at this position, create it
 170   // on demand.
 171   RootChunkArea* get_area_by_address(const MetaWord* p) const {
 172     const int idx = index_by_address(p);
 173     RootChunkArea* ra = _arr + idx;
 174     DEBUG_ONLY(ra-&gt;check_pointer(p);)
 175     return _arr + idx;
 176   }
 177 
 178   // Access area by its index
 179   int number_of_areas() const                               { return _num; }
 180   RootChunkArea* get_area_by_index(int index)               { assert(index &gt;= 0 &amp;&amp; index &lt; _num, "oob"); return _arr + index; }
 181   const RootChunkArea* get_area_by_index(int index) const   { assert(index &gt;= 0 &amp;&amp; index &lt; _num, "oob"); return _arr + index; }
 182 
 183   /// range ///
 184 
 185   const MetaWord* base() const  { return _base; }
 186   size_t word_size() const      { return _num * chunklevel::MAX_CHUNK_WORD_SIZE; }
 187   const MetaWord* end() const   { return _base + word_size(); }
 188 
 189   DEBUG_ONLY(void verify(bool slow) const;)
 190 
 191   void print_on(outputStream* st) const;
 192 
 193 };
 194 
 195 
 196 } // namespace metaspace
 197 
 198 #endif // SHARE_MEMORY_METASPACE_ROOTCHUNKAREA_HPP
</pre></body></html>
