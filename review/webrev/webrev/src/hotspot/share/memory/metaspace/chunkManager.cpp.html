<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 
  28 
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  32 #include "memory/metaspace/chunkLevel.hpp"
  33 #include "memory/metaspace/chunkManager.hpp"
  34 #include "memory/metaspace/internStat.hpp"
  35 #include "memory/metaspace/metachunk.hpp"
  36 #include "memory/metaspace/metaspaceCommon.hpp"
  37 #include "memory/metaspace/metaspaceStatistics.hpp"
  38 #include "memory/metaspace/settings.hpp"
  39 #include "memory/metaspace/virtualSpaceNode.hpp"
  40 #include "memory/metaspace/virtualSpaceList.hpp"
  41 #include "runtime/mutexLocker.hpp"
  42 #include "utilities/debug.hpp"
  43 #include "utilities/globalDefinitions.hpp"
  44 
  45 namespace metaspace {
  46 
  47 #define LOGFMT         "ChkMgr @" PTR_FORMAT " (%s)"
  48 #define LOGFMT_ARGS    p2i(this), this-&gt;_name
  49 
  50 // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
  51 void ChunkManager::return_chunk_simple(Metachunk* c) {
  52 
  53   assert_lock_strong(MetaspaceExpand_lock);
  54 
  55   DEBUG_ONLY(c-&gt;verify(false));
  56 
  57   const chunklevel_t lvl = c-&gt;level();
  58   _chunks.add(c);
  59   c-&gt;reset_used_words();
  60 
  61   // Tracing
  62   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",
  63                        _name, METACHUNK_FORMAT_ARGS(c));
  64 
  65 }
  66 
  67 // Creates a chunk manager with a given name (which is for debug purposes only)
  68 // and an associated space list which will be used to request new chunks from
  69 // (see get_chunk())
  70 ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)
  71   : _vslist(space_list),
  72     _name(name),
  73     _chunks()
  74 {
  75 }
  76 
  77 // Given a chunk we are about to handout to the caller, make sure it is committed
  78 // according to constants::committed_words_on_fresh_chunks
  79 bool ChunkManager::commit_chunk_before_handout(Metachunk* c) {
  80   assert_lock_strong(MetaspaceExpand_lock);
  81   const size_t must_be_committed = MIN2(c-&gt;word_size(), Settings::committed_words_on_fresh_chunks());
  82   return c-&gt;ensure_committed_locked(must_be_committed);
  83 }
  84 
  85 // Given a chunk, split it into a target chunk of a smaller size (higher target level)
  86 //  and at least one, possible several splinter chunks.
  87 // The original chunk must be outside of the freelist and its state must be free.
  88 // The splinter chunks are added to the freelist.
  89 // The resulting target chunk will be located at the same address as the original
  90 //  chunk, but it will of course be smaller (of a higher level).
  91 // The committed areas within the original chunk carry over to the resulting
  92 //  chunks.
  93 void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {
  94 
  95   assert_lock_strong(MetaspaceExpand_lock);
  96 
  97   assert(c-&gt;is_free(), "chunk to be split must be free.");
  98   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");
  99   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");
 100 
 101   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)
 102   DEBUG_ONLY(c-&gt;verify(true);)
 103 
 104   UL2(debug, "splitting chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",
 105       METACHUNK_FORMAT_ARGS(c), target_level);
 106 
 107   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)
 108 
 109   const chunklevel_t orig_level = c-&gt;level();
 110   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);
 111 
 112   // Splitting should never fail.
 113   assert(c-&gt;level() == target_level, "Sanity");
 114 
 115   // The size of the committed portion should not change (subject to the reduced chunk size of course)
 116 #ifdef ASSERT
 117   if (committed_words_before &gt; c-&gt;word_size()) {
 118     assert(c-&gt;is_fully_committed(), "Sanity");
 119   } else {
 120     assert(c-&gt;committed_words() == committed_words_before, "Sanity");
 121   }
 122 #endif
 123 
 124   DEBUG_ONLY(c-&gt;verify(false));
 125 
 126   DEBUG_ONLY(verify_locked(true);)
 127 
 128   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 129 
 130 }
 131 
 132 // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
 133 //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
 134 // On error, will return NULL.
 135 //
 136 // This function may fail for two reasons:
 137 // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
 138 //   is non-expandable but needs expanding - aka out of compressed class space).
 139 // - Or, if the necessary space cannot be committed because we hit a commit limit.
 140 //   This may be either the GC threshold or MaxMetaspaceSize.
 141 Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {
 142 
 143   assert(preferred_level &lt;= max_level, "Sanity");
 144   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");
 145 
 146   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 147 
 148   DEBUG_ONLY(verify_locked(false);)
 149 
 150   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)
 151   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)
 152   assert(max_level &gt;= preferred_level, "invalid level.");
 153 
 154   UL2(debug, "requested chunk: pref_level: " CHKLVL_FORMAT
 155      ", max_level: " CHKLVL_FORMAT ", min committed size: " SIZE_FORMAT ".",
 156      preferred_level, max_level, min_committed_words);
 157 
 158   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.
 159 
 160   // 1) Search best or smaller committed chunks (first attempt):
 161   //    Start at the preferred chunk size and work your way down (level up).
 162   //    But for now, only consider chunks larger than a certain threshold -
 163   //    this is to prevent large loaders (eg boot) from unnecessarily gobbling up
 164   //    all the tiny splinter chunks lambdas leave around.
 165   Metachunk* c = NULL;
 166   c = _chunks.search_chunk_ascending(preferred_level, MIN2((chunklevel_t)(preferred_level + 2), max_level), min_committed_words);
 167 
 168   // 2) Search larger committed chunks:
 169   //    If that did not yield anything, look at larger chunks, which may be committed. We would have to split
 170   //    them first, of course.
 171   if (c == NULL) {
 172     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);
 173   }
 174 
 175   // 3) Search best or smaller committed chunks (second attempt):
 176   //    Repeat (1) but now consider even the tiniest chunks as long as they are large enough to hold the
 177   //    committed min size.
 178   if (c == NULL) {
 179     c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);
 180   }
 181 
 182   // if we did not get anything yet, there are no free chunks commmitted enough. Repeat search but look for uncommitted chunks too:
 183 
 184   // 4) Search best or smaller chunks, can be uncommitted:
 185   if (c == NULL) {
 186     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);
 187   }
 188 
 189   // 5) Search a larger uncommitted chunk:
 190   if (c == NULL) {
 191     c = _chunks.search_chunk_descending(preferred_level, 0);
 192   }
 193 
 194   if (c != NULL) {
 195     UL(trace, "taken from freelist.");
 196   }
 197 
 198   // Failing all that, allocate a new root chunk from the connected virtual space.
 199   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)
 200   if (c == NULL) {
 201     c = _vslist-&gt;allocate_root_chunk();
 202     if (c == NULL) {
 203       UL(info, "failed to get new root chunk.");
 204     } else {
 205       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");
 206       UL(debug, "allocated new root chunk.");
 207     }
 208   }
 209 
 210   if (c == NULL) {
 211     UL2(info, "failed to get chunk (preferred level: " CHKLVL_FORMAT
 212        ", max level " CHKLVL_FORMAT ".", preferred_level, max_level);
 213     return NULL;
 214   }
 215 
 216   // Now we have a chunk. It may be too large for the callers needs. It also may not be committed enough.
 217   // So we may have to split it, and commit its starting granules.
 218   //
 219   // Note that we, as step 1, commit the chunk. Committing may fail and by doing the committing before
 220   // the split we can easily add the still unsplit chunk back to the freelist without having to re-merge.
 221   //
 222   // As step 2 we split the chunk. Splitting preserves the committed regions underlying the chunk, and
 223   // since the target chunk is the first in the original chunk area, the target chunk will be committed
 224   // enough.
 225 
 226   const size_t need_to_commit = MAX2(Settings::committed_words_on_fresh_chunks(), min_committed_words);
 227   if (c-&gt;committed_words() &lt; need_to_commit) {
 228     if (c-&gt;ensure_committed_locked(need_to_commit) == false) {
 229       UL2(info, "failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",
 230           need_to_commit,  METACHUNK_FORMAT_ARGS(c));
 231       _chunks.add(c);
 232       return NULL;
 233     }
 234   }
 235 
 236   // If too large, split chunk and add the splinter chunks back to the freelist.
 237   if (c-&gt;level() &lt; preferred_level) {
 238     split_chunk_and_add_splinters(c, preferred_level);
 239     assert(c-&gt;level() == preferred_level, "split failed?");
 240   }
 241 
 242   // Any chunk returned from ChunkManager shall be marked as in use.
 243   c-&gt;set_in_use();
 244 
 245   DEBUG_ONLY(verify_locked(false);)
 246   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 247 
 248   UL2(debug, "handing out chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 249 
 250   DEBUG_ONLY(InternalStats::inc_num_chunks_taken_from_freelist();)
 251 
 252   return c;
 253 
 254 }
 255 
 256 // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 257 //  with neighbors.
 258 // As a side effect this removes the chunk from whatever list it has been in previously.
 259 // Happens after a Classloader was unloaded and releases its metaspace chunks.
 260 // !! Note: this may invalidate the chunk. Do not access the chunk after
 261 //    this function returns !!
 262 void ChunkManager::return_chunk(Metachunk* c) {
 263 
 264   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 265 
 266   UL2(debug, ": returning chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 267 
 268   DEBUG_ONLY(c-&gt;verify(true);)
 269 
 270   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");
 271 
 272   assert(c-&gt;is_in_use(), "Unexpected chunk state");
 273   assert(!c-&gt;in_list(), "Remove from list first");
 274   c-&gt;set_free();
 275   c-&gt;reset_used_words();
 276 
 277   const chunklevel_t orig_lvl = c-&gt;level();
 278 
 279   Metachunk* merged = NULL;
 280   if (!c-&gt;is_root_chunk()) {
 281     // Only attempt merging if we are not of the lowest level already.
 282     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);
 283   }
 284 
 285   if (merged != NULL) {
 286 
 287     DEBUG_ONLY(merged-&gt;verify(false));
 288 
 289     // We did merge our chunk into a different chunk.
 290 
 291     // We did merge chunks and now have a bigger chunk.
 292     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");
 293 
 294     UL2(debug, "merged into chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(merged));
 295 
 296     c = merged;
 297 
 298   }
 299 
 300   if (Settings::uncommit_on_return() &amp;&amp;
 301       Settings::uncommit_on_return_min_word_size() &lt;= c-&gt;word_size())
 302   {
 303 
 304     UL2(debug, "uncommitting free chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 305     c-&gt;uncommit_locked();
 306   }
 307 
 308   return_chunk_simple(c);
 309 
 310   DEBUG_ONLY(verify_locked(false);)
 311   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 312 
 313   DEBUG_ONLY(InternalStats::inc_num_chunks_returned_to_freelist();)
 314 
 315 }
 316 
 317 // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to
 318 // enlarge it in place by claiming its trailing buddy.
 319 //
 320 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 321 //
 322 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 323 // double in size (level decreased by one).
 324 //
 325 // On success, true is returned, false otherwise.
 326 bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {
 327   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 328   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);
 329 }
 330 
 331 static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {
 332   if (word_size_1 == word_size_2) {
 333     print_scaled_words(st, word_size_1);
 334     st-&gt;print (" (no change)");
 335   } else {
 336     print_scaled_words(st, word_size_1);
 337     st-&gt;print("-&gt;");
 338     print_scaled_words(st, word_size_2);
 339     st-&gt;print(" (");
 340     if (word_size_2 &lt;= word_size_1) {
 341       st-&gt;print("-");
 342       print_scaled_words(st, word_size_1 - word_size_2);
 343     } else {
 344       st-&gt;print("+");
 345       print_scaled_words(st, word_size_2 - word_size_1);
 346     }
 347     st-&gt;print(")");
 348   }
 349 }
 350 
 351 // Attempt to reclaim free areas in metaspace wholesale:
 352 // - first, attempt to purge nodes of the backing virtual space. This can only be successful
 353 //   if whole nodes are only containing free chunks, so it highly depends on fragmentation.
 354 // - then, it will uncommit areas of free chunks according to the rules laid down in
 355 //   settings (see settings.hpp).
 356 void ChunkManager::wholesale_reclaim() {
 357 
 358   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 359 
 360   UL(info, ": reclaiming memory...");
 361 
 362   const size_t reserved_before = _vslist-&gt;reserved_words();
 363   const size_t committed_before = _vslist-&gt;committed_words();
 364   int num_nodes_purged = 0;
 365 
 366   if (Settings::delete_nodes_on_purge()) {
 367     num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);
 368     DEBUG_ONLY(InternalStats::inc_num_purges();)
 369   }
 370 
 371   if (Settings::uncommit_on_purge()) {
 372     const chunklevel_t max_level =
 373         chunklevel::level_fitting_word_size(Settings::uncommit_on_purge_min_word_size());
 374     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;
 375          l &lt;= max_level;
 376          l ++)
 377     {
 378       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {
 379         c-&gt;uncommit_locked();
 380       }
 381     }
 382     DEBUG_ONLY(InternalStats::inc_num_wholesale_uncommits();)
 383   }
 384 
 385   const size_t reserved_after = _vslist-&gt;reserved_words();
 386   const size_t committed_after = _vslist-&gt;committed_words();
 387 
 388   // Print a nice report.
 389   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {
 390     UL(info, "nothing reclaimed.");
 391   } else {
 392     LogTarget(Info, metaspace) lt;
 393     if (lt.is_enabled()) {
 394       LogStream ls(lt);
 395       ls.print_cr(LOGFMT ": finished reclaiming memory: ", LOGFMT_ARGS);
 396 
 397       ls.print("reserved: ");
 398       print_word_size_delta(&amp;ls, reserved_before, reserved_after);
 399       ls.cr();
 400 
 401       ls.print("committed: ");
 402       print_word_size_delta(&amp;ls, committed_before, committed_after);
 403       ls.cr();
 404 
 405       ls.print_cr("full nodes purged: %d", num_nodes_purged);
 406     }
 407   }
 408 
 409   DEBUG_ONLY(_vslist-&gt;verify_locked(true));
 410   DEBUG_ONLY(verify_locked(true));
 411 
 412 }
 413 
 414 
 415 ChunkManager* ChunkManager::_chunkmanager_class = NULL;
 416 ChunkManager* ChunkManager::_chunkmanager_nonclass = NULL;
 417 
 418 void ChunkManager::set_chunkmanager_class(ChunkManager* cm) {
 419   assert(_chunkmanager_class == NULL, "Sanity");
 420   _chunkmanager_class = cm;
 421 }
 422 
 423 void ChunkManager::set_chunkmanager_nonclass(ChunkManager* cm) {
 424   assert(_chunkmanager_nonclass == NULL, "Sanity");
 425   _chunkmanager_nonclass = cm;
 426 }
 427 
 428 
 429 
 430 // Update statistics.
 431 void ChunkManager::add_to_statistics(cm_stats_t* out) const {
 432 
 433   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 434 
 435   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 436     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);
 437     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);
 438   }
 439 
 440   DEBUG_ONLY(out-&gt;verify();)
 441 
 442 }
 443 
 444 #ifdef ASSERT
 445 
 446 void ChunkManager::verify(bool slow) const {
 447   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 448   verify_locked(slow);
 449 }
 450 
 451 void ChunkManager::verify_locked(bool slow) const {
 452   assert_lock_strong(MetaspaceExpand_lock);
 453   assert(_vslist != NULL, "No vslist");
 454   _chunks.verify();
 455 }
 456 
 457 bool ChunkManager::contains_chunk(Metachunk* c) const {
 458   return _chunks.contains(c);
 459 }
 460 
 461 #endif // ASSERT
 462 
 463 void ChunkManager::print_on(outputStream* st) const {
 464   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 465   print_on_locked(st);
 466 }
 467 
 468 void ChunkManager::print_on_locked(outputStream* st) const {
 469   assert_lock_strong(MetaspaceExpand_lock);
 470   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
 471                total_num_chunks(), total_word_size(), _chunks.committed_word_size());
 472   _chunks.print_on(st);
 473 }
 474 
 475 } // namespace metaspace
 476 
 477 
 478 
</pre></body></html>
