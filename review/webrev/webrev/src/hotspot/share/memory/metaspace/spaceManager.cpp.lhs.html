<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include "precompiled.hpp"
  25 
  26 #include "logging/log.hpp"
  27 #include "logging/logStream.hpp"
<a name="2" id="anc2"></a>


  28 #include "memory/metaspace/chunkManager.hpp"
<a name="3" id="anc3"></a>
  29 #include "memory/metaspace/metachunk.hpp"
<a name="4" id="anc4"></a><span class="removed">  30 #include "memory/metaspace/metaDebug.hpp"</span>
  31 #include "memory/metaspace/metaspaceCommon.hpp"
<a name="5" id="anc5"></a>
  32 #include "memory/metaspace/spaceManager.hpp"
  33 #include "memory/metaspace/virtualSpaceList.hpp"
  34 #include "runtime/atomic.hpp"
  35 #include "runtime/init.hpp"
  36 #include "services/memoryService.hpp"
<a name="6" id="anc6"></a>
  37 #include "utilities/debug.hpp"
  38 #include "utilities/globalDefinitions.hpp"
  39 
  40 namespace metaspace {
  41 
<a name="7" id="anc7"></a><span class="changed">  42 #define assert_counter(expected_value, real_value, msg) \</span>
<span class="changed">  43   assert( (expected_value) == (real_value),             \</span>
<span class="changed">  44          "Counter mismatch (%s): expected " SIZE_FORMAT \</span>
<span class="changed">  45          ", but got: " SIZE_FORMAT ".", msg, expected_value, \</span>
<span class="changed">  46          real_value);</span>
  47 
<a name="8" id="anc8"></a><span class="changed">  48 // SpaceManager methods</span>



  49 
<a name="9" id="anc9"></a><span class="changed">  50 size_t SpaceManager::adjust_initial_chunk_size(size_t requested, bool is_class_space) {</span>
<span class="changed">  51   size_t chunk_sizes[] = {</span>
<span class="changed">  52       specialized_chunk_size(is_class_space),</span>
<span class="changed">  53       small_chunk_size(is_class_space),</span>
<span class="changed">  54       medium_chunk_size(is_class_space)</span>
<span class="changed">  55   };</span>
  56 
<a name="10" id="anc10"></a><span class="changed">  57   // Adjust up to one of the fixed chunk sizes ...</span>
<span class="changed">  58   for (size_t i = 0; i &lt; ARRAY_SIZE(chunk_sizes); i++) {</span>
<span class="changed">  59     if (requested &lt;= chunk_sizes[i]) {</span>
<span class="changed">  60       return chunk_sizes[i];</span>
<span class="changed">  61     }</span>






  62   }
<a name="11" id="anc11"></a>






  63 
<a name="12" id="anc12"></a><span class="removed">  64   // ... or return the size as a humongous chunk.</span>
<span class="removed">  65   return requested;</span>
  66 }
  67 
<a name="13" id="anc13"></a><span class="changed">  68 size_t SpaceManager::adjust_initial_chunk_size(size_t requested) const {</span>
<span class="changed">  69   return adjust_initial_chunk_size(requested, is_class());</span>


  70 }
  71 
<a name="14" id="anc14"></a><span class="changed">  72 size_t SpaceManager::get_initial_chunk_size(Metaspace::MetaspaceType type) const {</span>
<span class="changed">  73   size_t requested;</span>
  74 
<a name="15" id="anc15"></a><span class="changed">  75   if (is_class()) {</span>
<span class="changed">  76     switch (type) {</span>
<span class="changed">  77     case Metaspace::BootMetaspaceType:              requested = Metaspace::first_class_chunk_word_size(); break;</span>
<span class="changed">  78     case Metaspace::ClassMirrorHolderMetaspaceType: requested = ClassSpecializedChunk; break;</span>
<span class="changed">  79     case Metaspace::ReflectionMetaspaceType:        requested = ClassSpecializedChunk; break;</span>
<span class="changed">  80     default:                                        requested = ClassSmallChunk; break;</span>
<span class="changed">  81     }</span>
<span class="changed">  82   } else {</span>
<span class="changed">  83     switch (type) {</span>
<span class="changed">  84     case Metaspace::BootMetaspaceType:              requested = Metaspace::first_chunk_word_size(); break;</span>
<span class="changed">  85     case Metaspace::ClassMirrorHolderMetaspaceType: requested = SpecializedChunk; break;</span>
<span class="changed">  86     case Metaspace::ReflectionMetaspaceType:        requested = SpecializedChunk; break;</span>
<span class="changed">  87     default:                                        requested = SmallChunk; break;</span>
  88     }
<a name="16" id="anc16"></a>







  89   }
  90 
<a name="17" id="anc17"></a><span class="changed">  91   // Adjust to one of the fixed chunk sizes (unless humongous)</span>
<span class="changed">  92   const size_t adjusted = adjust_initial_chunk_size(requested);</span>
  93 
<a name="18" id="anc18"></a><span class="changed">  94   assert(adjusted != 0, "Incorrect initial chunk size. Requested: "</span>
<span class="changed">  95          SIZE_FORMAT " adjusted: " SIZE_FORMAT, requested, adjusted);</span>
  96 
<a name="19" id="anc19"></a><span class="changed">  97   return adjusted;</span>
<span class="changed">  98 }</span>



  99 
<a name="20" id="anc20"></a><span class="changed"> 100 void SpaceManager::locked_print_chunks_in_use_on(outputStream* st) const {</span>





 101 
<a name="21" id="anc21"></a><span class="removed"> 102   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {</span>
<span class="removed"> 103     st-&gt;print("SpaceManager: " UINTX_FORMAT " %s chunks.",</span>
<span class="removed"> 104         num_chunks_by_type(i), chunk_size_name(i));</span>
 105   }
 106 
<a name="22" id="anc22"></a><span class="removed"> 107   chunk_manager()-&gt;locked_print_free_chunks(st);</span>
 108 }
 109 
<a name="23" id="anc23"></a><span class="changed"> 110 size_t SpaceManager::calc_chunk_size(size_t word_size) {</span>




 111 
<a name="24" id="anc24"></a><span class="changed"> 112   // Decide between a small chunk and a medium chunk.  Up to</span>
<span class="changed"> 113   // _small_chunk_limit small chunks can be allocated.</span>
<span class="changed"> 114   // After that a medium chunk is preferred.</span>
<span class="changed"> 115   size_t chunk_word_size;</span>




 116 
<a name="25" id="anc25"></a><span class="changed"> 117   // Special case for hidden metadata space.</span>
<span class="changed"> 118   // ClassMirrorHolder metadata space is usually small since it is used for</span>
<span class="changed"> 119   // class loader data's whose life cycle is governed by one class such as a</span>
<span class="changed"> 120   // non-strong hidden class or unsafe anonymous class.  The majority within 1K - 2K range and</span>
<span class="changed"> 121   // rarely about 4K (64-bits JVM).</span>
<span class="changed"> 122   // Instead of jumping to SmallChunk after initial chunk exhausted, keeping allocation</span>
<span class="changed"> 123   // from SpecializeChunk up to _anon_or_delegating_metadata_specialize_chunk_limit (4)</span>
<span class="changed"> 124   // reduces space waste from 60+% to around 30%.</span>
<span class="changed"> 125   if ((_space_type == Metaspace::ClassMirrorHolderMetaspaceType || _space_type == Metaspace::ReflectionMetaspaceType) &amp;&amp;</span>
<span class="changed"> 126       _mdtype == Metaspace::NonClassType &amp;&amp;</span>
<span class="changed"> 127       num_chunks_by_type(SpecializedIndex) &lt; anon_and_delegating_metadata_specialize_chunk_limit &amp;&amp;</span>
<span class="changed"> 128       word_size + Metachunk::overhead() &lt;= SpecializedChunk) {</span>
<span class="changed"> 129     return SpecializedChunk;</span>
 130   }
 131 
<a name="26" id="anc26"></a><span class="changed"> 132   if (num_chunks_by_type(MediumIndex) == 0 &amp;&amp;</span>
<span class="changed"> 133       num_chunks_by_type(SmallIndex) &lt; small_chunk_limit) {</span>
<span class="changed"> 134     chunk_word_size = (size_t) small_chunk_size();</span>
<span class="changed"> 135     if (word_size + Metachunk::overhead() &gt; small_chunk_size()) {</span>
<span class="changed"> 136       chunk_word_size = medium_chunk_size();</span>
<span class="changed"> 137     }</span>
<span class="changed"> 138   } else {</span>
<span class="changed"> 139     chunk_word_size = medium_chunk_size();</span>
<span class="changed"> 140   }</span>
 141 
<a name="27" id="anc27"></a><span class="changed"> 142   // Might still need a humongous chunk.  Enforce</span>
<span class="changed"> 143   // humongous allocations sizes to be aligned up to</span>
<span class="changed"> 144   // the smallest chunk size.</span>
<span class="changed"> 145   size_t if_humongous_sized_chunk =</span>
<span class="changed"> 146     align_up(word_size + Metachunk::overhead(),</span>
<span class="changed"> 147                   smallest_chunk_size());</span>
<span class="changed"> 148   chunk_word_size =</span>
<span class="changed"> 149     MAX2((size_t) chunk_word_size, if_humongous_sized_chunk);</span>
 150 
<a name="28" id="anc28"></a><span class="removed"> 151   assert(!SpaceManager::is_humongous(word_size) ||</span>
<span class="removed"> 152          chunk_word_size == if_humongous_sized_chunk,</span>
<span class="removed"> 153          "Size calculation is wrong, word_size " SIZE_FORMAT</span>
<span class="removed"> 154          " chunk_word_size " SIZE_FORMAT,</span>
<span class="removed"> 155          word_size, chunk_word_size);</span>
<span class="removed"> 156   Log(gc, metaspace, alloc) log;</span>
<span class="removed"> 157   if (log.is_trace() &amp;&amp; SpaceManager::is_humongous(word_size)) {</span>
<span class="removed"> 158     log.trace("Metadata humongous allocation:");</span>
<span class="removed"> 159     log.trace("  word_size " PTR_FORMAT, word_size);</span>
<span class="removed"> 160     log.trace("  chunk_word_size " PTR_FORMAT, chunk_word_size);</span>
<span class="removed"> 161     log.trace("    chunk overhead " PTR_FORMAT, Metachunk::overhead());</span>
<span class="removed"> 162   }</span>
<span class="removed"> 163   return chunk_word_size;</span>
 164 }
 165 
<a name="29" id="anc29"></a><span class="changed"> 166 void SpaceManager::track_metaspace_memory_usage() {</span>
<span class="changed"> 167   if (is_init_completed()) {</span>
<span class="changed"> 168     if (is_class()) {</span>
<span class="changed"> 169       MemoryService::track_compressed_class_memory_usage();</span>
<span class="changed"> 170     }</span>
<span class="changed"> 171     MemoryService::track_metaspace_memory_usage();</span>
<span class="changed"> 172   }</span>

















 173 }
 174 
<a name="30" id="anc30"></a><span class="changed"> 175 MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {</span>
<span class="changed"> 176   assert_lock_strong(_lock);</span>
<span class="changed"> 177   assert(vs_list()-&gt;current_virtual_space() != NULL,</span>
<span class="changed"> 178          "Should have been set");</span>
<span class="changed"> 179   assert(current_chunk() == NULL ||</span>
<span class="changed"> 180          current_chunk()-&gt;allocate(word_size) == NULL,</span>
<span class="changed"> 181          "Don't need to expand");</span>
<span class="changed"> 182   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 183 </span>
<span class="changed"> 184   if (log_is_enabled(Trace, gc, metaspace, freelist)) {</span>
<span class="changed"> 185     size_t words_left = 0;</span>
<span class="changed"> 186     size_t words_used = 0;</span>
<span class="changed"> 187     if (current_chunk() != NULL) {</span>
<span class="changed"> 188       words_left = current_chunk()-&gt;free_word_size();</span>
<span class="changed"> 189       words_used = current_chunk()-&gt;used_word_size();</span>
<span class="changed"> 190     }</span>
<span class="changed"> 191     log_trace(gc, metaspace, freelist)("SpaceManager::grow_and_allocate for " SIZE_FORMAT " words " SIZE_FORMAT " words used " SIZE_FORMAT " words left",</span>
<span class="changed"> 192                                        word_size, words_used, words_left);</span>
<span class="changed"> 193   }</span>
 194 
<a name="31" id="anc31"></a><span class="changed"> 195   // Get another chunk</span>
<span class="changed"> 196   size_t chunk_word_size = calc_chunk_size(word_size);</span>
<span class="changed"> 197   Metachunk* next = get_new_chunk(chunk_word_size);</span>
 198 
<a name="32" id="anc32"></a><span class="changed"> 199   MetaWord* mem = NULL;</span>
 200 
<a name="33" id="anc33"></a><span class="changed"> 201   // If a chunk was available, add it to the in-use chunk list</span>
<span class="changed"> 202   // and do an allocation from it.</span>
<span class="changed"> 203   if (next != NULL) {</span>
<span class="changed"> 204     // Add to this manager's list of chunks in use.</span>
<span class="changed"> 205     // If the new chunk is humongous, it was created to serve a single large allocation. In that</span>
<span class="changed"> 206     // case it usually makes no sense to make it the current chunk, since the next allocation would</span>
<span class="changed"> 207     // need to allocate a new chunk anyway, while we would now prematurely retire a perfectly</span>
<span class="changed"> 208     // good chunk which could be used for more normal allocations.</span>
<span class="changed"> 209     bool make_current = true;</span>
<span class="changed"> 210     if (next-&gt;get_chunk_type() == HumongousIndex &amp;&amp;</span>
<span class="changed"> 211         current_chunk() != NULL) {</span>
<span class="changed"> 212       make_current = false;</span>
<span class="changed"> 213     }</span>
<span class="changed"> 214     add_chunk(next, make_current);</span>
<span class="changed"> 215     mem = next-&gt;allocate(word_size);</span>
<span class="changed"> 216   }</span>
 217 
<a name="34" id="anc34"></a><span class="changed"> 218   // Track metaspace memory usage statistic.</span>
<span class="changed"> 219   track_metaspace_memory_usage();</span>
 220 
<a name="35" id="anc35"></a><span class="changed"> 221   return mem;</span>
<span class="changed"> 222 }</span>








 223 
<a name="36" id="anc36"></a><span class="changed"> 224 void SpaceManager::print_on(outputStream* st) const {</span>
<span class="changed"> 225   SpaceManagerStatistics stat;</span>
<span class="changed"> 226   add_to_statistics(&amp;stat); // will lock _lock.</span>
<span class="changed"> 227   stat.print_on(st, 1*K, false);</span>
<span class="changed"> 228 }</span>
<span class="changed"> 229 </span>
<span class="changed"> 230 SpaceManager::SpaceManager(Metaspace::MetadataType mdtype,</span>
<span class="changed"> 231                            Metaspace::MetaspaceType space_type,//</span>
<span class="changed"> 232                            Mutex* lock) :</span>
<span class="changed"> 233   _lock(lock),</span>
<span class="changed"> 234   _mdtype(mdtype),</span>
<span class="changed"> 235   _space_type(space_type),</span>
<span class="changed"> 236   _chunk_list(NULL),</span>
<span class="changed"> 237   _current_chunk(NULL),</span>
<span class="changed"> 238   _overhead_words(0),</span>
<span class="changed"> 239   _capacity_words(0),</span>
<span class="changed"> 240   _used_words(0),</span>
<span class="changed"> 241   _block_freelists(NULL) {</span>
<span class="changed"> 242   Metadebug::init_allocation_fail_alot_count();</span>
<span class="changed"> 243   memset(_num_chunks_by_type, 0, sizeof(_num_chunks_by_type));</span>
<span class="changed"> 244   log_trace(gc, metaspace, freelist)("SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="changed"> 245 }</span>
<span class="changed"> 246 </span>
<span class="changed"> 247 void SpaceManager::account_for_new_chunk(const Metachunk* new_chunk) {</span>
<span class="changed"> 248 </span>
<span class="changed"> 249   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 250 </span>
<span class="changed"> 251   _capacity_words += new_chunk-&gt;word_size();</span>
<span class="changed"> 252   _overhead_words += Metachunk::overhead();</span>
<span class="changed"> 253   DEBUG_ONLY(new_chunk-&gt;verify());</span>
<span class="changed"> 254   _num_chunks_by_type[new_chunk-&gt;get_chunk_type()] ++;</span>
<span class="changed"> 255 </span>
<span class="changed"> 256   // Adjust global counters:</span>
<span class="changed"> 257   MetaspaceUtils::inc_capacity(mdtype(), new_chunk-&gt;word_size());</span>
<span class="changed"> 258   MetaspaceUtils::inc_overhead(mdtype(), Metachunk::overhead());</span>
<span class="changed"> 259 }</span>
<span class="changed"> 260 </span>
<span class="changed"> 261 void SpaceManager::account_for_allocation(size_t words) {</span>
<span class="changed"> 262   // Note: we should be locked with the ClassloaderData-specific metaspace lock.</span>
<span class="changed"> 263   // We may or may not be locked with the global metaspace expansion lock.</span>
<span class="changed"> 264   assert_lock_strong(lock());</span>
 265 
<a name="37" id="anc37"></a><span class="changed"> 266   // Add to the per SpaceManager totals. This can be done non-atomically.</span>
<span class="changed"> 267   _used_words += words;</span>
 268 
<a name="38" id="anc38"></a><span class="changed"> 269   // Adjust global counters. This will be done atomically.</span>
<span class="changed"> 270   MetaspaceUtils::inc_used(mdtype(), words);</span>
<span class="changed"> 271 }</span>
 272 
<a name="39" id="anc39"></a><span class="changed"> 273 void SpaceManager::account_for_spacemanager_death() {</span>
 274 
<a name="40" id="anc40"></a><span class="changed"> 275   assert_lock_strong(MetaspaceExpand_lock);</span>
 276 
<a name="41" id="anc41"></a><span class="removed"> 277   MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);</span>
<span class="removed"> 278   MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);</span>
<span class="removed"> 279   MetaspaceUtils::dec_used(mdtype(), _used_words);</span>
 280 }
 281 
<a name="42" id="anc42"></a><span class="changed"> 282 SpaceManager::~SpaceManager() {</span>




 283 
<a name="43" id="anc43"></a><span class="changed"> 284   // This call this-&gt;_lock which can't be done while holding MetaspaceExpand_lock</span>
<span class="changed"> 285   DEBUG_ONLY(verify_metrics());</span>
 286 
<a name="44" id="anc44"></a><span class="changed"> 287   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 288 </span>
<span class="changed"> 289   account_for_spacemanager_death();</span>

 290 
<a name="45" id="anc45"></a><span class="changed"> 291   Log(gc, metaspace, freelist) log;</span>
<span class="changed"> 292   if (log.is_trace()) {</span>
<span class="changed"> 293     log.trace("~SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="changed"> 294     ResourceMark rm;</span>
<span class="changed"> 295     LogStream ls(log.trace());</span>
<span class="changed"> 296     locked_print_chunks_in_use_on(&amp;ls);</span>
<span class="changed"> 297     if (block_freelists() != NULL) {</span>
<span class="changed"> 298       block_freelists()-&gt;print_on(&amp;ls);</span>
 299     }
<a name="46" id="anc46"></a>



 300   }
 301 
<a name="47" id="anc47"></a><span class="changed"> 302   // Add all the chunks in use by this space manager</span>
<span class="changed"> 303   // to the global list of free chunks.</span>


 304 
<a name="48" id="anc48"></a><span class="changed"> 305   // Follow each list of chunks-in-use and add them to the</span>
<span class="changed"> 306   // free lists.  Each list is NULL terminated.</span>
<span class="changed"> 307   chunk_manager()-&gt;return_chunk_list(chunk_list());</span>
<span class="changed"> 308 #ifdef ASSERT</span>
<span class="changed"> 309   _chunk_list = NULL;</span>
<span class="changed"> 310   _current_chunk = NULL;</span>
<span class="changed"> 311 #endif</span>
 312 
<a name="49" id="anc49"></a><span class="changed"> 313 #ifdef ASSERT</span>
<span class="changed"> 314   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed"> 315     chunk_manager()-&gt;locked_verify(true);</span>
<span class="changed"> 316   END_EVERY_NTH</span>
<span class="changed"> 317 #endif</span>

 318 
<a name="50" id="anc50"></a><span class="changed"> 319   if (_block_freelists != NULL) {</span>
<span class="changed"> 320     delete _block_freelists;</span>


 321   }
<a name="51" id="anc51"></a><span class="removed"> 322 }</span>
 323 
<a name="52" id="anc52"></a><span class="changed"> 324 void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 325   assert_lock_strong(lock());</span>
<span class="changed"> 326   // Allocations and deallocations are in raw_word_size</span>
<span class="changed"> 327   size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="changed"> 328   // Lazily create a block_freelist</span>
<span class="changed"> 329   if (block_freelists() == NULL) {</span>
<span class="changed"> 330     _block_freelists = new BlockFreelist();</span>
 331   }
<a name="53" id="anc53"></a><span class="removed"> 332   block_freelists()-&gt;return_block(p, raw_word_size);</span>
<span class="removed"> 333   DEBUG_ONLY(Atomic::inc(&amp;(g_internal_statistics.num_deallocs)));</span>
<span class="removed"> 334 }</span>
 335 
<a name="54" id="anc54"></a><span class="changed"> 336 // Adds a chunk to the list of chunks in use.</span>
<span class="changed"> 337 void SpaceManager::add_chunk(Metachunk* new_chunk, bool make_current) {</span>
 338 
<a name="55" id="anc55"></a><span class="changed"> 339   assert_lock_strong(_lock);</span>
<span class="changed"> 340   assert(new_chunk != NULL, "Should not be NULL");</span>
<span class="changed"> 341   assert(new_chunk-&gt;next() == NULL, "Should not be on a list");</span>
 342 
<a name="56" id="anc56"></a><span class="changed"> 343   new_chunk-&gt;reset_empty();</span>
 344 
<a name="57" id="anc57"></a><span class="changed"> 345   // Find the correct list and and set the current</span>
<span class="changed"> 346   // chunk for that list.</span>
<span class="changed"> 347   ChunkIndex index = chunk_manager()-&gt;list_index(new_chunk-&gt;word_size());</span>
 348 
<a name="58" id="anc58"></a><span class="changed"> 349   if (make_current) {</span>
<span class="changed"> 350     // If we are to make the chunk current, retire the old current chunk and replace</span>
<span class="changed"> 351     // it with the new chunk.</span>
<span class="changed"> 352     retire_current_chunk();</span>
<span class="changed"> 353     set_current_chunk(new_chunk);</span>
<span class="changed"> 354   }</span>

 355 
<a name="59" id="anc59"></a><span class="changed"> 356   // Add the new chunk at the head of its respective chunk list.</span>
<span class="changed"> 357   new_chunk-&gt;set_next(_chunk_list);</span>
<span class="changed"> 358   _chunk_list = new_chunk;</span>
 359 
<a name="60" id="anc60"></a><span class="changed"> 360   // Adjust counters.</span>
<span class="changed"> 361   account_for_new_chunk(new_chunk);</span>
 362 
<a name="61" id="anc61"></a><span class="changed"> 363   assert(new_chunk-&gt;is_empty(), "Not ready for reuse");</span>
<span class="changed"> 364   Log(gc, metaspace, freelist) log;</span>
<span class="changed"> 365   if (log.is_trace()) {</span>
<span class="changed"> 366     log.trace("SpaceManager::added chunk: ");</span>
<span class="changed"> 367     ResourceMark rm;</span>
<span class="changed"> 368     LogStream ls(log.trace());</span>
<span class="changed"> 369     new_chunk-&gt;print_on(&amp;ls);</span>
<span class="changed"> 370     chunk_manager()-&gt;locked_print_free_chunks(&amp;ls);</span>





 371   }
<a name="62" id="anc62"></a><span class="removed"> 372 }</span>
 373 
<a name="63" id="anc63"></a><span class="changed"> 374 void SpaceManager::retire_current_chunk() {</span>


 375   if (current_chunk() != NULL) {
<a name="64" id="anc64"></a><span class="changed"> 376     size_t remaining_words = current_chunk()-&gt;free_word_size();</span>
<span class="changed"> 377     if (remaining_words &gt;= SmallBlocks::small_block_min_size()) {</span>
<span class="changed"> 378       MetaWord* ptr = current_chunk()-&gt;allocate(remaining_words);</span>
<span class="changed"> 379       deallocate(ptr, remaining_words);</span>
<span class="changed"> 380       account_for_allocation(remaining_words);</span>






 381     }
 382   }
<a name="65" id="anc65"></a><span class="removed"> 383 }</span>
 384 
<a name="66" id="anc66"></a><span class="changed"> 385 Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {</span>
<span class="changed"> 386   // Get a chunk from the chunk freelist</span>
<span class="changed"> 387   Metachunk* next = chunk_manager()-&gt;chunk_freelist_allocate(chunk_word_size);</span>






 388 
<a name="67" id="anc67"></a><span class="changed"> 389   if (next == NULL) {</span>
<span class="changed"> 390     next = vs_list()-&gt;get_new_chunk(chunk_word_size,</span>
<span class="changed"> 391                                     medium_chunk_bunch());</span>

 392   }
 393 
<a name="68" id="anc68"></a><span class="removed"> 394   Log(gc, metaspace, alloc) log;</span>
<span class="removed"> 395   if (log.is_trace() &amp;&amp; next != NULL &amp;&amp;</span>
<span class="removed"> 396       SpaceManager::is_humongous(next-&gt;word_size())) {</span>
<span class="removed"> 397     log.trace("  new humongous chunk word size " PTR_FORMAT, next-&gt;word_size());</span>
 398   }
 399 
<a name="69" id="anc69"></a><span class="changed"> 400   return next;</span>
<span class="changed"> 401 }</span>
 402 
<a name="70" id="anc70"></a><span class="changed"> 403 MetaWord* SpaceManager::allocate(size_t word_size) {</span>
<span class="changed"> 404   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 405   size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="changed"> 406   BlockFreelist* fl =  block_freelists();</span>
<span class="changed"> 407   MetaWord* p = NULL;</span>
 408 
<a name="71" id="anc71"></a><span class="changed"> 409   // Allocation from the dictionary is expensive in the sense that</span>
<span class="changed"> 410   // the dictionary has to be searched for a size.  Don't allocate</span>
<span class="changed"> 411   // from the dictionary until it starts to get fat.  Is this</span>
<span class="changed"> 412   // a reasonable policy?  Maybe an skinny dictionary is fast enough</span>
<span class="changed"> 413   // for allocations.  Do some profiling.  JJJ</span>
<span class="changed"> 414   if (fl != NULL &amp;&amp; fl-&gt;total_size() &gt; allocation_from_dictionary_limit) {</span>
<span class="changed"> 415     p = fl-&gt;get_block(raw_word_size);</span>
<span class="changed"> 416     if (p != NULL) {</span>
<span class="changed"> 417       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs_from_deallocated_blocks));</span>
<span class="changed"> 418     }</span>
<span class="changed"> 419   }</span>
<span class="changed"> 420   if (p == NULL) {</span>
<span class="changed"> 421     p = allocate_work(raw_word_size);</span>
 422   }
 423 
<a name="72" id="anc72"></a><span class="changed"> 424 #ifdef ASSERT</span>
<span class="changed"> 425   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed"> 426     verify_metrics_locked();</span>
<span class="changed"> 427   END_EVERY_NTH</span>
<span class="changed"> 428 #endif</span>
 429 
<a name="73" id="anc73"></a><span class="changed"> 430   return p;</span>
<span class="changed"> 431 }</span>







 432 
<a name="74" id="anc74"></a><span class="removed"> 433 // Returns the address of spaced allocated for "word_size".</span>
<span class="removed"> 434 // This methods does not know about blocks (Metablocks)</span>
<span class="removed"> 435 MetaWord* SpaceManager::allocate_work(size_t word_size) {</span>
<span class="removed"> 436   assert_lock_strong(lock());</span>
 437 #ifdef ASSERT
<a name="75" id="anc75"></a><span class="changed"> 438   if (Metadebug::test_metadata_failure()) {</span>
<span class="changed"> 439     return NULL;</span>

 440   }
 441 #endif
<a name="76" id="anc76"></a><span class="removed"> 442   // Is there space in the current chunk?</span>
<span class="removed"> 443   MetaWord* result = NULL;</span>
 444 
<a name="77" id="anc77"></a><span class="changed"> 445   if (current_chunk() != NULL) {</span>
<span class="changed"> 446     result = current_chunk()-&gt;allocate(word_size);</span>



 447   }
 448 
<a name="78" id="anc78"></a><span class="changed"> 449   if (result == NULL) {</span>
<span class="changed"> 450     result = grow_and_allocate(word_size);</span>
<span class="changed"> 451   }</span>
 452 
<a name="79" id="anc79"></a><span class="changed"> 453   if (result != NULL) {</span>
<span class="changed"> 454     account_for_allocation(word_size);</span>


 455   }
 456 
<a name="80" id="anc80"></a><span class="changed"> 457   return result;</span>

 458 }
 459 
<a name="81" id="anc81"></a><span class="changed"> 460 void SpaceManager::verify() {</span>
<span class="changed"> 461   Metachunk* curr = chunk_list();</span>
<span class="changed"> 462   while (curr != NULL) {</span>
<span class="changed"> 463     DEBUG_ONLY(do_verify_chunk(curr);)</span>
<span class="changed"> 464     assert(curr-&gt;is_tagged_free() == false, "Chunk should be tagged as in use.");</span>
<span class="changed"> 465     curr = curr-&gt;next();</span>
 466   }
<a name="82" id="anc82"></a>

















 467 }
 468 
<a name="83" id="anc83"></a><span class="changed"> 469 void SpaceManager::verify_chunk_size(Metachunk* chunk) {</span>
<span class="changed"> 470   assert(is_humongous(chunk-&gt;word_size()) ||</span>
<span class="changed"> 471          chunk-&gt;word_size() == medium_chunk_size() ||</span>
<span class="changed"> 472          chunk-&gt;word_size() == small_chunk_size() ||</span>
<span class="changed"> 473          chunk-&gt;word_size() == specialized_chunk_size(),</span>
<span class="changed"> 474          "Chunk size is wrong");</span>
<span class="changed"> 475   return;</span>
 476 }
 477 
<a name="84" id="anc84"></a><span class="changed"> 478 void SpaceManager::add_to_statistics_locked(SpaceManagerStatistics* out) const {</span>
<span class="changed"> 479   assert_lock_strong(lock());</span>
<span class="changed"> 480   Metachunk* chunk = chunk_list();</span>
<span class="changed"> 481   while (chunk != NULL) {</span>
<span class="changed"> 482     UsedChunksStatistics&amp; chunk_stat = out-&gt;chunk_stats(chunk-&gt;get_chunk_type());</span>
<span class="changed"> 483     chunk_stat.add_num(1);</span>
<span class="changed"> 484     chunk_stat.add_cap(chunk-&gt;word_size());</span>
<span class="changed"> 485     chunk_stat.add_overhead(Metachunk::overhead());</span>
<span class="changed"> 486     chunk_stat.add_used(chunk-&gt;used_word_size() - Metachunk::overhead());</span>
<span class="changed"> 487     if (chunk != current_chunk()) {</span>
<span class="changed"> 488       chunk_stat.add_waste(chunk-&gt;free_word_size());</span>



 489     } else {
<a name="85" id="anc85"></a><span class="changed"> 490       chunk_stat.add_free(chunk-&gt;free_word_size());</span>
 491     }
<a name="86" id="anc86"></a><span class="removed"> 492     chunk = chunk-&gt;next();</span>
 493   }
<a name="87" id="anc87"></a><span class="changed"> 494   if (block_freelists() != NULL) {</span>
<span class="changed"> 495     out-&gt;add_free_blocks_info(block_freelists()-&gt;num_blocks(), block_freelists()-&gt;total_size());</span>


 496   }
<a name="88" id="anc88"></a>


 497 }
 498 
<a name="89" id="anc89"></a><span class="changed"> 499 void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {</span>


 500   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<a name="90" id="anc90"></a><span class="changed"> 501   add_to_statistics_locked(out);</span>














 502 }
 503 
<a name="91" id="anc91"></a>
 504 #ifdef ASSERT
<a name="92" id="anc92"></a><span class="changed"> 505 void SpaceManager::verify_metrics_locked() const {</span>


 506   assert_lock_strong(lock());
 507 
<a name="93" id="anc93"></a><span class="changed"> 508   SpaceManagerStatistics stat;</span>
<span class="changed"> 509   add_to_statistics_locked(&amp;stat);</span>
 510 
<a name="94" id="anc94"></a><span class="changed"> 511   UsedChunksStatistics chunk_stats = stat.totals();</span>
 512 
<a name="95" id="anc95"></a><span class="changed"> 513   DEBUG_ONLY(chunk_stats.check_sanity());</span>














 514 
<a name="96" id="anc96"></a><span class="removed"> 515   assert_counter(_capacity_words, chunk_stats.cap(), "SpaceManager::_capacity_words");</span>
<span class="removed"> 516   assert_counter(_used_words, chunk_stats.used(), "SpaceManager::_used_words");</span>
<span class="removed"> 517   assert_counter(_overhead_words, chunk_stats.overhead(), "SpaceManager::_overhead_words");</span>
 518 }
 519 
<a name="97" id="anc97"></a><span class="changed"> 520 void SpaceManager::verify_metrics() const {</span>

 521   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<a name="98" id="anc98"></a><span class="changed"> 522   verify_metrics_locked();</span>
















 523 }
<a name="99" id="anc99"></a>
 524 #endif // ASSERT
<a name="100" id="anc100"></a>















 525 
 526 
 527 } // namespace metaspace
 528 
<a name="101" id="anc101"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="101" type="hidden" /></form></body></html>
