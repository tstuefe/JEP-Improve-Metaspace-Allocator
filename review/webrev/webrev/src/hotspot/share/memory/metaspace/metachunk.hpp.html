<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metachunk.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  26 #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  27 
  28 
  29 #include "memory/metaspace/counter.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "utilities/debug.hpp"
  32 #include "utilities/globalDefinitions.hpp"
  33 
  34 
  35 class outputStream;
  36 
  37 namespace metaspace {
  38 
  39 class VirtualSpaceNode;
  40 
  41 // Todo: comment is outdated.
  42 
  43 //  Metachunk - Quantum of allocation from a Virtualspace
  44 //    Metachunks are reused (when freed are put on a global freelist) and
  45 //    have no permanent association to a SpaceManager.
  46 
  47 //            +--------------+ &lt;- end    ----+         --+
  48 //            |              |               |           |
  49 //            |              |               | free      |
  50 //            |              |               |
  51 //            |              |               |           | size (aka capacity)
  52 //            |              |               |           |
  53 //            | -----------  | &lt;- top     -- +           |
  54 //            |              |               |           |
  55 //            |              |               | used      |
  56 //            +--------------+ &lt;- start   -- +        -- +
  57 
  58 // Note: this is a chunk **descriptor**. The real Payload area lives in metaspace,
  59 // this class lives somewhere else.
  60 class Metachunk {
  61 
  62   // start of chunk memory; NULL if dead.
  63   MetaWord* _base;
  64 
  65   // Used words.
  66   size_t _used_words;
  67 
  68   // Size of the region, starting from base, which is guaranteed to be committed. In words.
  69   //  The actual size of committed regions may actually be larger.
  70   //
  71   //  (This is a performance optimization. The underlying VirtualSpaceNode knows
  72   //   which granules are committed; but we want to avoid having to ask.)
  73   size_t _committed_words;
  74 
  75   chunklevel_t _level; // aka size.
  76 
  77   // state_free:    free, owned by ChunkManager
  78   // state_in_use:  in-use, owned by SpaceManager
  79   // dead:          just a hollow chunk header without associated memory, owned
  80   //                 by chunk header pool.
  81   enum state_t {
  82     state_free = 0,
  83     state_in_use = 1,
  84     state_dead = 2
  85   };
  86   state_t _state;
  87 
  88   // We need unfortunately a back link to the virtual space node
  89   // for splitting and merging nodes.
  90   VirtualSpaceNode* _vsnode;
  91 
  92 
  93   // A chunk header is kept in a list:
  94   // 1 in the list of used chunks inside a SpaceManager, if it is in use
  95   // 2 in the list of free chunks inside a ChunkManager, if it is free
  96   // 3 in the freelist of unused headers inside the ChunkHeaderPool,
  97   //   if it is unused (e.g. result of chunk merging) and has no associated
  98   //   memory area.
  99   Metachunk* _prev;
 100   Metachunk* _next;
 101 
 102   // Furthermore, we keep, per chunk, information about the neighboring chunks.
 103   // This is needed to split and merge chunks.
 104   //
 105   // Note: These members can be modified concurrently while a chunk is alive and in use.
 106   // This can happen if a neighboring chunk is added or removed.
 107   // This means only read or modify these members under expand lock protection.
 108   Metachunk* _prev_in_vs;
 109   Metachunk* _next_in_vs;
 110 
 111   // Commit uncommitted section of the chunk.
 112   // Fails if we hit a commit limit.
 113   bool commit_up_to(size_t new_committed_words);
 114 
 115   DEBUG_ONLY(static void assert_have_expand_lock();)
 116 
 117 public:
 118 
 119   Metachunk()
 120     : _base(NULL),
 121       _used_words(0),
 122       _committed_words(0),
 123       _level(chunklevel::ROOT_CHUNK_LEVEL),
 124       _state(state_free),
 125       _vsnode(NULL),
 126       _prev(NULL), _next(NULL),
 127       _prev_in_vs(NULL), _next_in_vs(NULL)
 128   {}
 129 
 130  void clear() {
 131    _base = NULL;
 132    _used_words = 0;
 133    _committed_words = 0;
 134    _level = chunklevel::ROOT_CHUNK_LEVEL;
 135    _state = state_free;
 136    _vsnode = NULL;
 137    _prev = NULL;
 138    _next = NULL;
 139    _prev_in_vs = NULL;
 140    _next_in_vs = NULL;
 141   }
 142 
 143 
 144   size_t word_size() const        { return chunklevel::word_size_for_level(_level); }
 145 
 146   MetaWord* base() const          { return _base; }
 147   MetaWord* top() const           { return base() + _used_words; }
 148   MetaWord* committed_top() const { return base() + _committed_words; }
 149   MetaWord* end() const           { return base() + word_size(); }
 150 
 151   // Chunk list wiring
 152   void set_prev(Metachunk* c)     { _prev = c; }
 153   Metachunk* prev() const         { return _prev; }
 154   void set_next(Metachunk* c)     { _next = c; }
 155   Metachunk* next() const         { return _next; }
 156 
 157   DEBUG_ONLY(bool in_list() const { return _prev != NULL || _next != NULL; })
 158 
 159   // Physical neighbors wiring
 160   void set_prev_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _prev_in_vs = c; }
 161   Metachunk* prev_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _prev_in_vs; }
 162   void set_next_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _next_in_vs = c; }
 163   Metachunk* next_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _next_in_vs; }
 164 
 165   bool is_free() const            { return _state == state_free; }
 166   bool is_in_use() const          { return _state == state_in_use; }
 167   bool is_dead() const            { return _state == state_dead; }
 168   void set_free()                 { _state = state_free; }
 169   void set_in_use()               { _state = state_in_use; }
 170   void set_dead()                 { _state = state_dead; }
 171 
 172   // Return a single char presentation of the state ('f', 'u', 'd')
 173   char get_state_char() const;
 174 
 175   void inc_level()                { _level ++; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }
 176   void dec_level()                { _level --; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }
 177   chunklevel_t level() const          { return _level; }
 178 
 179   // Convenience functions for extreme levels.
 180   bool is_root_chunk() const      { return chunklevel::ROOT_CHUNK_LEVEL == _level; }
 181   bool is_leaf_chunk() const      { return chunklevel::HIGHEST_CHUNK_LEVEL == _level; }
 182 
 183   VirtualSpaceNode* vsnode() const        { return _vsnode; }
 184 
 185   size_t used_words() const                   { return _used_words; }
 186   size_t free_words() const                   { return word_size() - used_words(); }
 187   size_t free_below_committed_words() const   { return committed_words() - used_words(); }
 188   void reset_used_words()                     { _used_words = 0; }
 189 
 190   size_t committed_words() const      { return _committed_words; }
 191   void set_committed_words(size_t v);
 192   bool is_fully_committed() const     { return committed_words() == word_size(); }
 193   bool is_fully_uncommitted() const   { return committed_words() == 0; }
 194 
 195   // Ensure that chunk is committed up to at least new_committed_words words.
 196   // Fails if we hit a commit limit.
 197   bool ensure_committed(size_t new_committed_words);
 198   bool ensure_committed_locked(size_t new_committed_words);
 199 
 200   bool ensure_fully_committed()           { return ensure_committed(word_size()); }
 201   bool ensure_fully_committed_locked()    { return ensure_committed_locked(word_size()); }
 202 
 203   // Ensure that the chunk is committed far enough to serve an additional allocation of word_size.
 204   bool ensure_committed_additional(size_t additional_word_size)   {
 205     return ensure_committed(used_words() + additional_word_size);
 206   }
 207 
 208   // Uncommit chunk area. The area must be a common multiple of the
 209   // commit granule size (in other words, we cannot uncommit chunks smaller than
 210   // a commit granule size).
 211   void uncommit();
 212   void uncommit_locked();
 213 
 214   // Allocation from a chunk
 215 
 216   // Allocate word_size words from this chunk (word_size must be aligned to
 217   //  allocation_alignment_words).
 218   //
 219   // Caller must make sure the chunk is both large enough and committed far enough
 220   // to hold the allocation. Will always work.
 221   //
 222   MetaWord* allocate(size_t request_word_size);
 223 
 224   // Initialize structure for reuse.
 225   void initialize(VirtualSpaceNode* node, MetaWord* base, chunklevel_t lvl) {
 226     _vsnode = node; _base = base; _level = lvl;
 227     _used_words = _committed_words = 0; _state = state_free;
 228     _next = _prev = _next_in_vs = _prev_in_vs = NULL;
 229   }
 230 
 231   // Returns true if this chunk is the leader in its buddy pair, false if not.
 232   // Do not call for root chunks.
 233   bool is_leader() const {
 234     assert(!is_root_chunk(), "Root chunks have no buddy."); // Bit harsh?
 235     return is_aligned(base(), chunklevel::word_size_for_level(level() - 1) * BytesPerWord);
 236   }
 237 
 238   //// Debug stuff ////
 239 #ifdef ASSERT
 240   void verify(bool slow) const;
 241   // Verifies linking with neighbors in virtual space. Needs expand lock protection.
 242   void verify_neighborhood() const;
 243   void zap_header(uint8_t c = 0x17);
 244   void fill_with_pattern(MetaWord pattern, size_t word_size);
 245   void check_pattern(MetaWord pattern, size_t word_size);
 246 
 247   // Returns true if given pointer points into the payload area of this chunk.
 248   bool is_valid_pointer(const MetaWord* p) const {
 249     return base() &lt;= p &amp;&amp; p &lt; top();
 250   }
 251 
 252   // Returns true if given pointer points into the commmitted payload area of this chunk.
 253   bool is_valid_committed_pointer(const MetaWord* p) const {
 254     return base() &lt;= p &amp;&amp; p &lt; committed_top();
 255   }
 256 
 257 #endif // ASSERT
 258 
 259   void print_on(outputStream* st) const;
 260 
 261 };
 262 
 263 // Little print helpers: since we often print out chunks, here some convenience macros
 264 #define METACHUNK_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT
 265 #define METACHUNK_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level()
 266 
 267 #define METACHUNK_FULL_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT " (" SIZE_FORMAT "), used: " SIZE_FORMAT ", committed: " SIZE_FORMAT ", committed-free: " SIZE_FORMAT
 268 #define METACHUNK_FULL_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level(), chunk-&gt;word_size(), chunk-&gt;used_words(), chunk-&gt;committed_words(), chunk-&gt;free_below_committed_words()
 269 
 270 } // namespace metaspace
 271 
 272 #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
</pre></body></html>
