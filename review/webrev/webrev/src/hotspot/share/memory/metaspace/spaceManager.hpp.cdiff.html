<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace/spaceManager.hpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.cpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/spaceManager.hpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
<span class="newmarker">--- 1,8 ----</span>
  /*
   * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="new">+  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<hr /><span class="oldmarker">*** 25,233 ****</span>
  #ifndef SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  #define SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  
  #include "memory/allocation.hpp"
  #include "memory/metaspace.hpp"
<span class="changed">! #include "memory/metaspace/blockFreelist.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceCommon.hpp"</span>
  #include "memory/metaspace/metachunk.hpp"
<span class="changed">! #include "memory/metaspace/metaspaceStatistics.hpp"</span>
<span class="changed">! #include "utilities/debug.hpp"</span>
<span class="changed">! #include "utilities/globalDefinitions.hpp"</span>
  
  class outputStream;
  class Mutex;
  
  namespace metaspace {
  
<span class="removed">- //  SpaceManager - used by Metaspace to handle allocations</span>
<span class="removed">- class SpaceManager : public CHeapObj&lt;mtClass&gt; {</span>
<span class="removed">-   friend class ::ClassLoaderMetaspace;</span>
<span class="removed">-   friend class Metadebug;</span>
<span class="removed">- </span>
<span class="removed">-  private:</span>
<span class="removed">- </span>
<span class="removed">-   // protects allocations</span>
<span class="removed">-   Mutex* const _lock;</span>
<span class="removed">- </span>
<span class="removed">-   // Type of metadata allocated.</span>
<span class="removed">-   const Metaspace::MetadataType   _mdtype;</span>
<span class="removed">- </span>
<span class="removed">-   // Type of metaspace</span>
<span class="removed">-   const Metaspace::MetaspaceType  _space_type;</span>
<span class="removed">- </span>
<span class="removed">-   // List of chunks in use by this SpaceManager.  Allocations</span>
<span class="removed">-   // are done from the current chunk.  The list is used for deallocating</span>
<span class="removed">-   // chunks when the SpaceManager is freed.</span>
<span class="removed">-   Metachunk* _chunk_list;</span>
<span class="removed">-   Metachunk* _current_chunk;</span>
  
<span class="changed">!   enum {</span>
  
<span class="changed">!     // Maximum number of small chunks to allocate to a SpaceManager</span>
<span class="changed">!     small_chunk_limit = 4,</span>
  
<span class="changed">!     // Maximum number of specialize chunks to allocate for anonymous and delegating</span>
<span class="changed">!     // metadata space to a SpaceManager</span>
<span class="changed">!     anon_and_delegating_metadata_specialize_chunk_limit = 4,</span>
  
<span class="changed">!     allocation_from_dictionary_limit = 4 * K</span>
<span class="changed">! </span>
<span class="changed">!   };</span>
  
<span class="changed">!   // Some running counters, but lets keep their number small to not add to much to</span>
<span class="changed">!   // the per-classloader footprint.</span>
<span class="changed">!   // Note: capacity = used + free + waste + overhead. We do not keep running counters for</span>
<span class="changed">!   // free and waste. Their sum can be deduced from the three other values.</span>
<span class="changed">!   size_t _overhead_words;</span>
<span class="changed">!   size_t _capacity_words;</span>
<span class="changed">!   size_t _used_words;</span>
<span class="changed">!   uintx _num_chunks_by_type[NumberOfInUseLists];</span>
  
<span class="changed">!   // Free lists of blocks are per SpaceManager since they</span>
<span class="changed">!   // are assumed to be in chunks in use by the SpaceManager</span>
<span class="changed">!   // and all chunks in use by a SpaceManager are freed when</span>
<span class="changed">!   // the class loader using the SpaceManager is collected.</span>
<span class="changed">!   BlockFreelist* _block_freelists;</span>
  
<span class="changed">!  private:</span>
<span class="changed">!   // Accessors</span>
<span class="changed">!   Metachunk* chunk_list() const { return _chunk_list; }</span>
  
<span class="changed">!   BlockFreelist* block_freelists() const { return _block_freelists; }</span>
  
<span class="changed">!   Metaspace::MetadataType mdtype() { return _mdtype; }</span>
  
<span class="changed">!   VirtualSpaceList* vs_list()   const { return Metaspace::get_space_list(_mdtype); }</span>
<span class="changed">!   ChunkManager* chunk_manager() const { return Metaspace::get_chunk_manager(_mdtype); }</span>
  
<span class="changed">!   Metachunk* current_chunk() const { return _current_chunk; }</span>
<span class="changed">!   void set_current_chunk(Metachunk* v) {</span>
<span class="changed">!     _current_chunk = v;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   Metachunk* find_current_chunk(size_t word_size);</span>
  
<span class="changed">!   // Add chunk to the list of chunks in use</span>
<span class="changed">!   void add_chunk(Metachunk* v, bool make_current);</span>
<span class="changed">!   void retire_current_chunk();</span>
  
    Mutex* lock() const { return _lock; }
  
<span class="changed">!   // Adds to the given statistic object. Expects to be locked with lock().</span>
<span class="changed">!   void add_to_statistics_locked(SpaceManagerStatistics* out) const;</span>
  
<span class="removed">-   // Verify internal counters against the current state. Expects to be locked with lock().</span>
<span class="removed">-   DEBUG_ONLY(void verify_metrics_locked() const;)</span>
<span class="removed">- </span>
<span class="removed">-  public:</span>
<span class="removed">-   SpaceManager(Metaspace::MetadataType mdtype,</span>
<span class="removed">-                Metaspace::MetaspaceType space_type,</span>
<span class="removed">-                Mutex* lock);</span>
    ~SpaceManager();
  
<span class="changed">!   enum ChunkMultiples {</span>
<span class="changed">!     MediumChunkMultiple = 4</span>
<span class="changed">!   };</span>
<span class="changed">! </span>
<span class="changed">!   static size_t specialized_chunk_size(bool is_class) { return is_class ? ClassSpecializedChunk : SpecializedChunk; }</span>
<span class="changed">!   static size_t small_chunk_size(bool is_class)       { return is_class ? ClassSmallChunk : SmallChunk; }</span>
<span class="changed">!   static size_t medium_chunk_size(bool is_class)      { return is_class ? ClassMediumChunk : MediumChunk; }</span>
<span class="changed">! </span>
<span class="changed">!   static size_t smallest_chunk_size(bool is_class)    { return specialized_chunk_size(is_class); }</span>
<span class="changed">! </span>
<span class="changed">!   // Accessors</span>
<span class="changed">!   bool is_class() const { return _mdtype == Metaspace::ClassType; }</span>
<span class="changed">! </span>
<span class="changed">!   size_t specialized_chunk_size() const { return specialized_chunk_size(is_class()); }</span>
<span class="changed">!   size_t small_chunk_size()       const { return small_chunk_size(is_class()); }</span>
<span class="changed">!   size_t medium_chunk_size()      const { return medium_chunk_size(is_class()); }</span>
<span class="changed">! </span>
<span class="changed">!   size_t smallest_chunk_size()    const { return smallest_chunk_size(is_class()); }</span>
<span class="changed">! </span>
<span class="changed">!   size_t medium_chunk_bunch()     const { return medium_chunk_size() * MediumChunkMultiple; }</span>
<span class="changed">! </span>
<span class="changed">!   bool is_humongous(size_t word_size) { return word_size &gt; medium_chunk_size(); }</span>
<span class="changed">! </span>
<span class="changed">!   size_t capacity_words() const     { return _capacity_words; }</span>
<span class="changed">!   size_t used_words() const         { return _used_words; }</span>
<span class="changed">!   size_t overhead_words() const     { return _overhead_words; }</span>
<span class="changed">! </span>
<span class="changed">!   // Adjust local, global counters after a new chunk has been added.</span>
<span class="changed">!   void account_for_new_chunk(const Metachunk* new_chunk);</span>
<span class="changed">! </span>
<span class="changed">!   // Adjust local, global counters after space has been allocated from the current chunk.</span>
<span class="changed">!   void account_for_allocation(size_t words);</span>
<span class="changed">! </span>
<span class="changed">!   // Adjust global counters just before the SpaceManager dies, after all its chunks</span>
<span class="changed">!   // have been returned to the freelist.</span>
<span class="changed">!   void account_for_spacemanager_death();</span>
<span class="changed">! </span>
<span class="changed">!   // Adjust the initial chunk size to match one of the fixed chunk list sizes,</span>
<span class="changed">!   // or return the unadjusted size if the requested size is humongous.</span>
<span class="changed">!   static size_t adjust_initial_chunk_size(size_t requested, bool is_class_space);</span>
<span class="changed">!   size_t adjust_initial_chunk_size(size_t requested) const;</span>
<span class="changed">! </span>
<span class="changed">!   // Get the initial chunks size for this metaspace type.</span>
<span class="changed">!   size_t get_initial_chunk_size(Metaspace::MetaspaceType type) const;</span>
<span class="changed">! </span>
<span class="changed">!   // Todo: remove this once we have counters by chunk type.</span>
<span class="changed">!   uintx num_chunks_by_type(ChunkIndex chunk_type) const       { return _num_chunks_by_type[chunk_type]; }</span>
<span class="changed">! </span>
<span class="changed">!   Metachunk* get_new_chunk(size_t chunk_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Block allocation and deallocation.</span>
<span class="changed">!   // Allocates a block from the current chunk</span>
    MetaWord* allocate(size_t word_size);
  
<span class="changed">!   // Helper for allocations</span>
<span class="changed">!   MetaWord* allocate_work(size_t word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Returns a block to the per manager freelist</span>
    void deallocate(MetaWord* p, size_t word_size);
  
<span class="changed">!   // Based on the allocation size and a minimum chunk size,</span>
<span class="changed">!   // returned chunk size (for expanding space for chunk allocation).</span>
<span class="changed">!   size_t calc_chunk_size(size_t allocation_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Called when an allocation from the current chunk fails.</span>
<span class="changed">!   // Gets a new chunk (may require getting a new virtual space),</span>
<span class="changed">!   // and allocates from that chunk.</span>
<span class="changed">!   MetaWord* grow_and_allocate(size_t word_size);</span>
  
<span class="changed">!   // Notify memory usage to MemoryService.</span>
<span class="changed">!   void track_metaspace_memory_usage();</span>
  
<span class="changed">!   // debugging support.</span>
  
    void print_on(outputStream* st) const;
<span class="changed">!   void locked_print_chunks_in_use_on(outputStream* st) const;</span>
<span class="changed">! </span>
<span class="changed">!   void verify();</span>
<span class="changed">!   void verify_chunk_size(Metachunk* chunk);</span>
<span class="changed">! </span>
<span class="changed">!   // This adjusts the size given to be greater than the minimum allocation size in</span>
<span class="changed">!   // words for data in metaspace.  Esentially the minimum size is currently 3 words.</span>
<span class="changed">!   size_t get_allocation_word_size(size_t word_size) {</span>
<span class="changed">!     size_t byte_size = word_size * BytesPerWord;</span>
<span class="changed">! </span>
<span class="changed">!     size_t raw_bytes_size = MAX2(byte_size, sizeof(Metablock));</span>
<span class="changed">!     raw_bytes_size = align_up(raw_bytes_size, Metachunk::object_alignment());</span>
<span class="changed">! </span>
<span class="changed">!     size_t raw_word_size = raw_bytes_size / BytesPerWord;</span>
<span class="changed">!     assert(raw_word_size * BytesPerWord == raw_bytes_size, "Size problem");</span>
<span class="changed">! </span>
<span class="changed">!     return raw_word_size;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Adds to the given statistic object.</span>
<span class="changed">!   void add_to_statistics(SpaceManagerStatistics* out) const;</span>
<span class="changed">! </span>
<span class="changed">!   // Verify internal counters against the current state.</span>
<span class="changed">!   DEBUG_ONLY(void verify_metrics() const;)</span>
  
  };
  
<span class="removed">- </span>
  } // namespace metaspace
  
  #endif // SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
<span class="newmarker">--- 26,156 ----</span>
  #ifndef SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  #define SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  
  #include "memory/allocation.hpp"
  #include "memory/metaspace.hpp"
<span class="changed">! #include "memory/metaspace/chunkManager.hpp"</span>
  #include "memory/metaspace/metachunk.hpp"
<span class="changed">! #include "memory/metaspace/metachunkList.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="changed">! </span>
  
  class outputStream;
  class Mutex;
  
  namespace metaspace {
  
  
<span class="changed">! class ArenaGrowthPolicy;</span>
<span class="changed">! class FreeBlocks;</span>
  
<span class="changed">! struct sm_stats_t;</span>
  
<span class="changed">! // The SpaceManager:</span>
<span class="changed">! // - keeps a list of chunks-in-use by the class loader, as well as a current chunk used</span>
<span class="changed">! //   to allocate from</span>
<span class="changed">! // - keeps a dictionary of free MetaBlocks. Those can be remnants of a retired chunk or</span>
<span class="changed">! //   allocations which were not needed anymore for some reason (e.g. releasing half-allocated</span>
<span class="changed">! //   structures when class loading fails)</span>
  
<span class="changed">! class SpaceManager : public CHeapObj&lt;mtClass&gt; {</span>
  
<span class="changed">!   // Lock handed down from the associated ClassLoaderData.</span>
<span class="changed">!   //  Protects allocations from this space.</span>
<span class="changed">!   Mutex* const _lock;</span>
  
<span class="changed">!   // The chunk manager to allocate chunks from.</span>
<span class="changed">!   ChunkManager* const _chunk_manager;</span>
  
<span class="changed">!   // The chunk allocation strategy to use.</span>
<span class="changed">!   const ArenaGrowthPolicy* const _growth_policy;</span>
  
<span class="changed">!   // List of chunks. Head of the list is the current chunk.</span>
<span class="changed">!   MetachunkList _chunks;</span>
  
<span class="changed">!   // Structure to take care of leftover/deallocated space in used chunks</span>
<span class="changed">!   FreeBlocks* _fbl;</span>
  
<span class="changed">!   Metachunk* current_chunk()              { return _chunks.first(); }</span>
<span class="changed">!   const Metachunk* current_chunk() const  { return _chunks.first(); }</span>
  
<span class="changed">!   // Points to outside size counter which we are to increase/decrease when we allocate memory</span>
<span class="changed">!   // on behalf of a user or when we are destroyed.</span>
<span class="changed">!   SizeAtomicCounter* const _total_used_words_counter;</span>
  
<span class="changed">!   const char* const _name;</span>
  
<span class="changed">!   // Whether or not this is a "micro loader" which is not expected to load more than one class.</span>
<span class="changed">!   const bool _is_micro_loader;</span>
  
    Mutex* lock() const                           { return _lock; }
<span class="new">+   ChunkManager* chunk_manager() const           { return _chunk_manager; }</span>
  
<span class="changed">!   // free block list</span>
<span class="changed">!   FreeBlocks* fbl() const                       { return _fbl; }</span>
<span class="changed">!   void add_allocation_to_fbl(MetaWord* p, size_t word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Given a chunk, add its remaining free committed space to the free block list.</span>
<span class="changed">!   void salvage_chunk(Metachunk* c);</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate a new chunk from the underlying chunk manager able to hold at least</span>
<span class="changed">!   // requested word size.</span>
<span class="changed">!   Metachunk* allocate_new_chunk(size_t requested_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Returns the level of the next chunk to be added, acc to growth policy.</span>
<span class="changed">!   chunklevel_t next_chunk_level() const;</span>
<span class="changed">! </span>
<span class="changed">!   // Attempt to enlarge the current chunk to make it large enough to hold at least</span>
<span class="changed">!   //  requested_word_size additional words.</span>
<span class="changed">!   //</span>
<span class="changed">!   // On success, true is returned, false otherwise.</span>
<span class="changed">!   bool attempt_enlarge_current_chunk(size_t requested_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="changed">!   // because it is not needed anymore (requires CLD lock to be active).</span>
<span class="changed">!   void deallocate_locked(MetaWord* p, size_t word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Returns true if the area indicated by pointer and size have actually been allocated</span>
<span class="changed">!   // from this space manager.</span>
<span class="changed">!   DEBUG_ONLY(bool is_valid_area(MetaWord* p, size_t word_size) const;)</span>
<span class="changed">! </span>
<span class="changed">! public:</span>
<span class="changed">! </span>
<span class="changed">!   SpaceManager(ChunkManager* chunk_manager,</span>
<span class="changed">!                const ArenaGrowthPolicy* growth_policy,</span>
<span class="changed">!                Mutex* lock,</span>
<span class="changed">!                SizeAtomicCounter* total_used_words_counter,</span>
<span class="changed">!                const char* name,</span>
<span class="changed">!                bool is_micro_loader);</span>
  
    ~SpaceManager();
  
<span class="changed">!   // Allocate memory from Metaspace.</span>
<span class="changed">!   // 1) Attempt to allocate from the dictionary of deallocated blocks.</span>
<span class="changed">!   // 2) Attempt to allocate from the current chunk.</span>
<span class="changed">!   // 3) Attempt to enlarge the current chunk in place if it is too small.</span>
<span class="changed">!   // 4) Attempt to get a new chunk and allocate from that chunk.</span>
<span class="changed">!   // At any point, if we hit a commit limit, we return NULL.</span>
    MetaWord* allocate(size_t word_size);
  
<span class="changed">!   // Prematurely returns a metaspace allocation to the _block_freelists because it is not</span>
<span class="changed">!   // needed anymore.</span>
    void deallocate(MetaWord* p, size_t word_size);
  
<span class="changed">!   // Update statistics. This walks all in-use chunks.</span>
<span class="changed">!   void add_to_statistics(sm_stats_t* out) const;</span>
  
<span class="changed">!   // Convenience method to get the most important usage statistics.</span>
<span class="changed">!   // For deeper analysis use add_to_statistics().</span>
<span class="changed">!   void usage_numbers(size_t* p_used_words, size_t* p_committed_words, size_t* p_capacity_words) const;</span>
  
<span class="changed">!   DEBUG_ONLY(void verify(bool slow) const;)</span>
<span class="changed">!   DEBUG_ONLY(void verify_locked(bool slow) const;)</span>
  
    void print_on(outputStream* st) const;
<span class="changed">!   void print_on_locked(outputStream* st) const;</span>
  
  };
  
  } // namespace metaspace
  
  #endif // SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.cpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

