<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Udiff src/hotspot/share/memory/metaspace/metachunk.cpp</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.hpp.udiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/metachunk.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -1,7 +1,8 @@</span>
 /*
<span class="removed">- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="new">+ * Copyright (c) 2019, SAP SE. All rights reserved.</span>
<span class="new">+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
</pre><hr /><pre>
<span class="newmarker">@@ -20,153 +21,488 @@</span>
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  *
  */
 
<span class="new">+</span>
 #include "precompiled.hpp"
<span class="removed">-#include "memory/allocation.hpp"</span>
<span class="new">+</span>
<span class="new">+#include "logging/log.hpp"</span>
<span class="new">+#include "memory/metaspace/chunkLevel.hpp"</span>
 #include "memory/metaspace/metachunk.hpp"
<span class="removed">-#include "memory/metaspace/occupancyMap.hpp"</span>
<span class="new">+#include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="new">+#include "memory/metaspace/settings.hpp"</span>
 #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="new">+#include "runtime/mutexLocker.hpp"</span>
<span class="new">+</span>
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #include "utilities/debug.hpp"
 
 namespace metaspace {
 
<span class="removed">-size_t Metachunk::object_alignment() {</span>
<span class="removed">-  // Must align pointers and sizes to 8,</span>
<span class="removed">-  // so that 64 bit types get correctly aligned.</span>
<span class="removed">-  const size_t alignment = 8;</span>
<span class="removed">-</span>
<span class="removed">-  // Make sure that the Klass alignment also agree.</span>
<span class="removed">-  STATIC_ASSERT(alignment == (size_t)KlassAlignmentInBytes);</span>
<span class="removed">-</span>
<span class="removed">-  return alignment;</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-size_t Metachunk::overhead() {</span>
<span class="removed">-  return align_up(sizeof(Metachunk), object_alignment()) / BytesPerWord;</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-// Metachunk methods</span>
<span class="removed">-</span>
<span class="removed">-Metachunk::Metachunk(ChunkIndex chunktype, bool is_class, size_t word_size,</span>
<span class="removed">-                     VirtualSpaceNode* container)</span>
<span class="removed">-    : Metabase&lt;Metachunk&gt;(word_size),</span>
<span class="removed">-    _container(container),</span>
<span class="removed">-    _top(NULL),</span>
<span class="removed">-    _sentinel(CHUNK_SENTINEL),</span>
<span class="removed">-    _chunk_type(chunktype),</span>
<span class="removed">-    _is_class(is_class),</span>
<span class="removed">-    _origin(origin_normal),</span>
<span class="removed">-    _use_count(0)</span>
<span class="removed">-{</span>
<span class="removed">-  _top = initial_top();</span>
<span class="removed">-  set_is_tagged_free(false);</span>
<span class="new">+// Return a single char presentation of the state ('f', 'u', 'd')</span>
<span class="new">+char Metachunk::get_state_char() const {</span>
<span class="new">+  switch (_state) {</span>
<span class="new">+  case state_free:    return 'f';</span>
<span class="new">+  case state_in_use:  return 'u';</span>
<span class="new">+  case state_dead:    return 'd';</span>
<span class="new">+  }</span>
<span class="new">+  return '?';</span>
<span class="new">+}</span>
<span class="new">+</span>
 #ifdef ASSERT
<span class="removed">-  mangle(uninitMetaWordVal);</span>
<span class="removed">-  verify();</span>
<span class="removed">-#endif</span>
<span class="new">+void Metachunk::assert_have_expand_lock() {</span>
<span class="new">+  assert_lock_strong(MetaspaceExpand_lock);</span>
 }
<span class="new">+#endif</span>
<span class="new">+</span>
<span class="new">+// Commit uncommitted section of the chunk.</span>
<span class="new">+// Fails if we hit a commit limit.</span>
<span class="new">+bool Metachunk::commit_up_to(size_t new_committed_words) {</span>
<span class="new">+</span>
<span class="new">+  // Please note:</span>
<span class="new">+  //</span>
<span class="new">+  // VirtualSpaceNode::ensure_range_is_committed(), when called over a range containing both committed and uncommitted parts,</span>
<span class="new">+  // will replace the whole range with a new mapping, thus erasing the existing content in the committed parts. Therefore</span>
<span class="new">+  // we must make sure never to call VirtualSpaceNode::ensure_range_is_committed() over a range containing live data.</span>
<span class="new">+  //</span>
<span class="new">+  // Luckily, this cannot happen by design. We have two cases:</span>
<span class="new">+  //</span>
<span class="new">+  // 1) chunks equal or larger than a commit granule.</span>
<span class="new">+  //    In this case, due to chunk geometry, the chunk should cover whole commit granules (in other words, a chunk equal or larger than</span>
<span class="new">+  //    a commit granule will never share a granule with a neighbor). That means whatever we commit or uncommit here does not affect</span>
<span class="new">+  //    neighboring chunks. We only have to take care not to re-commit used parts of ourself. We do this by moving the committed_words</span>
<span class="new">+  //    limit in multiple of commit granules.</span>
<span class="new">+  //</span>
<span class="new">+  // 2) chunks smaller than a commit granule.</span>
<span class="new">+  //    In this case, a chunk shares a single commit granule with its neighbors. But this never can be a problem:</span>
<span class="new">+  //    - Either the commit granule is already committed (and maybe the neighbors contain live data). In that case calling</span>
<span class="new">+  //      ensure_range_is_committed() will do nothing.</span>
<span class="new">+  //    - Or the commit granule is not committed, but in this case, the neighbors are uncommitted too and cannot contain live data.</span>
<span class="new">+</span>
<span class="new">+#ifdef ASSERT</span>
<span class="new">+  if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="new">+    // case (1)</span>
<span class="new">+    assert(is_aligned(base(), Settings::commit_granule_bytes()) &amp;&amp;</span>
<span class="new">+           is_aligned(end(), Settings::commit_granule_bytes()),</span>
<span class="new">+           "Chunks larger than a commit granule must cover whole granules.");</span>
<span class="new">+    assert(is_aligned(_committed_words, Settings::commit_granule_words()),</span>
<span class="new">+           "The commit boundary must be aligned to commit granule size");</span>
<span class="new">+    assert(_used_words &lt;= _committed_words, "Sanity");</span>
<span class="new">+  } else {</span>
<span class="new">+    // case (2)</span>
<span class="new">+    assert(_committed_words == 0 || _committed_words == word_size(), "Sanity");</span>
<span class="new">+  }</span>
<span class="new">+#endif</span>
<span class="new">+</span>
<span class="new">+  // We should hold the expand lock at this point.</span>
<span class="new">+  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+</span>
<span class="new">+  const size_t commit_from = _committed_words;</span>
<span class="new">+  const size_t commit_to =   MIN2(align_up(new_committed_words, Settings::commit_granule_words()), word_size());</span>
 
<span class="removed">-MetaWord* Metachunk::allocate(size_t word_size) {</span>
<span class="removed">-  MetaWord* result = NULL;</span>
<span class="removed">-  // If available, bump the pointer to allocate.</span>
<span class="removed">-  if (free_word_size() &gt;= word_size) {</span>
<span class="removed">-    result = _top;</span>
<span class="removed">-    _top = _top + word_size;</span>
<span class="new">+  assert(commit_from &gt;= used_words(), "Sanity");</span>
<span class="new">+  assert(commit_to &lt;= word_size(), "Sanity");</span>
<span class="new">+</span>
<span class="new">+  if (commit_to &gt; commit_from) {</span>
<span class="new">+    log_debug(metaspace)("Chunk " METACHUNK_FORMAT ": attempting to move commit line to "</span>
<span class="new">+                         SIZE_FORMAT " words.", METACHUNK_FORMAT_ARGS(this), commit_to);</span>
<span class="new">+</span>
<span class="new">+    if (!_vsnode-&gt;ensure_range_is_committed(base() + commit_from, commit_to - commit_from)) {</span>
<span class="new">+      DEBUG_ONLY(verify(true);)</span>
<span class="new">+      return false;</span>
<span class="new">+    }</span>
   }
<span class="removed">-  return result;</span>
<span class="new">+</span>
<span class="new">+  // Remember how far we have committed.</span>
<span class="new">+  _committed_words = commit_to;</span>
<span class="new">+</span>
<span class="new">+  DEBUG_ONLY(verify(true);)</span>
<span class="new">+</span>
<span class="new">+  return true;</span>
<span class="new">+</span>
 }
 
<span class="removed">-// _bottom points to the start of the chunk including the overhead.</span>
<span class="removed">-size_t Metachunk::used_word_size() const {</span>
<span class="removed">-  return pointer_delta(_top, bottom(), sizeof(MetaWord));</span>
<span class="new">+</span>
<span class="new">+// Ensure that chunk is committed up to at least new_committed_words words.</span>
<span class="new">+// Fails if we hit a commit limit.</span>
<span class="new">+bool Metachunk::ensure_committed(size_t new_committed_words) {</span>
<span class="new">+</span>
<span class="new">+  bool rc = true;</span>
<span class="new">+</span>
<span class="new">+  if (new_committed_words &gt; committed_words()) {</span>
<span class="new">+    MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+    rc = commit_up_to(new_committed_words);</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+  return rc;</span>
<span class="new">+</span>
 }
 
<span class="removed">-size_t Metachunk::free_word_size() const {</span>
<span class="removed">-  return pointer_delta(end(), _top, sizeof(MetaWord));</span>
<span class="new">+bool Metachunk::ensure_committed_locked(size_t new_committed_words) {</span>
<span class="new">+</span>
<span class="new">+  // the .._locked() variant should be called if we own the lock already.</span>
<span class="new">+  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+</span>
<span class="new">+  bool rc = true;</span>
<span class="new">+</span>
<span class="new">+  if (new_committed_words &gt; committed_words()) {</span>
<span class="new">+    rc = commit_up_to(new_committed_words);</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+  return rc;</span>
<span class="new">+</span>
 }
 
<span class="removed">-void Metachunk::print_on(outputStream* st) const {</span>
<span class="removed">-  st-&gt;print_cr("Metachunk:"</span>
<span class="removed">-               " bottom " PTR_FORMAT " top " PTR_FORMAT</span>
<span class="removed">-               " end " PTR_FORMAT " size " SIZE_FORMAT " (%s)",</span>
<span class="removed">-               p2i(bottom()), p2i(_top), p2i(end()), word_size(),</span>
<span class="removed">-               chunk_size_name(get_chunk_type()));</span>
<span class="removed">-  if (Verbose) {</span>
<span class="removed">-    st-&gt;print_cr("    used " SIZE_FORMAT " free " SIZE_FORMAT,</span>
<span class="removed">-                 used_word_size(), free_word_size());</span>
<span class="new">+// Uncommit chunk area. The area must be a common multiple of the</span>
<span class="new">+// commit granule size (in other words, we cannot uncommit chunks smaller than</span>
<span class="new">+// a commit granule size).</span>
<span class="new">+void Metachunk::uncommit() {</span>
<span class="new">+  MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+  uncommit_locked();</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+void Metachunk::uncommit_locked() {</span>
<span class="new">+  // Only uncommit chunks which are free, have no used words set (extra precaution) and are equal or larger in size than a single commit granule.</span>
<span class="new">+  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+  assert(_state == state_free &amp;&amp; _used_words == 0 &amp;&amp; word_size() &gt;= Settings::commit_granule_words(),</span>
<span class="new">+         "Only free chunks equal or larger than commit granule size can be uncommitted "</span>
<span class="new">+         "(chunk " METACHUNK_FULL_FORMAT ").", METACHUNK_FULL_FORMAT_ARGS(this));</span>
<span class="new">+  if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="new">+    _vsnode-&gt;uncommit_range(base(), word_size());</span>
<span class="new">+    _committed_words = 0;</span>
   }
 }
<span class="new">+void Metachunk::set_committed_words(size_t v) {</span>
<span class="new">+  // Set committed words. Since we know that we only commit whole commit granules, we can round up v here.</span>
<span class="new">+  v = MIN2(align_up(v, Settings::commit_granule_words()), word_size());</span>
<span class="new">+ _committed_words = v;</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+// Allocate word_size words from this chunk (word_size must be aligned to</span>
<span class="new">+//  allocation_alignment_words).</span>
<span class="new">+//</span>
<span class="new">+// Caller must make sure the chunk is both large enough and committed far enough</span>
<span class="new">+// to hold the allocation. Will always work.</span>
<span class="new">+//</span>
<span class="new">+MetaWord* Metachunk::allocate(size_t request_word_size) {</span>
<span class="new">+</span>
<span class="new">+  log_trace(metaspace)("Chunk " METACHUNK_FULL_FORMAT ": allocating " SIZE_FORMAT " words.",</span>
<span class="new">+                       METACHUNK_FULL_FORMAT_ARGS(this), request_word_size);</span>
<span class="new">+</span>
<span class="new">+  // Caller must have made sure this works</span>
<span class="new">+  assert(free_words() &gt;= request_word_size, "Chunk too small.");</span>
<span class="new">+  assert(free_below_committed_words() &gt;= request_word_size, "Chunk not committed.");</span>
<span class="new">+</span>
<span class="new">+  MetaWord* const p = top();</span>
<span class="new">+</span>
<span class="new">+  _used_words += request_word_size;</span>
<span class="new">+</span>
<span class="new">+  SOMETIMES(verify(false);)</span>
<span class="new">+</span>
<span class="new">+  return p;</span>
<span class="new">+</span>
<span class="new">+}</span>
 
 #ifdef ASSERT
<span class="removed">-void Metachunk::mangle(juint word_value) {</span>
<span class="removed">-  // Overwrite the payload of the chunk and not the links that</span>
<span class="removed">-  // maintain list of chunks.</span>
<span class="removed">-  HeapWord* start = (HeapWord*)initial_top();</span>
<span class="removed">-  size_t size = word_size() - overhead();</span>
<span class="removed">-  Copy::fill_to_words(start, size, word_value);</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-void Metachunk::verify() const {</span>
<span class="removed">-  assert(is_valid_sentinel(), "Chunk " PTR_FORMAT ": sentinel invalid", p2i(this));</span>
<span class="removed">-  const ChunkIndex chunk_type = get_chunk_type();</span>
<span class="removed">-  assert(is_valid_chunktype(chunk_type), "Chunk " PTR_FORMAT ": Invalid chunk type.", p2i(this));</span>
<span class="removed">-  if (chunk_type != HumongousIndex) {</span>
<span class="removed">-    assert(word_size() == get_size_for_nonhumongous_chunktype(chunk_type, is_class()),</span>
<span class="removed">-           "Chunk " PTR_FORMAT ": wordsize " SIZE_FORMAT " does not fit chunk type %s.",</span>
<span class="removed">-           p2i(this), word_size(), chunk_size_name(chunk_type));</span>
<span class="removed">-  }</span>
<span class="removed">-  assert(is_valid_chunkorigin(get_origin()), "Chunk " PTR_FORMAT ": Invalid chunk origin.", p2i(this));</span>
<span class="removed">-  assert(bottom() &lt;= _top &amp;&amp; _top &lt;= (MetaWord*)end(),</span>
<span class="removed">-         "Chunk " PTR_FORMAT ": Chunk top out of chunk bounds.", p2i(this));</span>
<span class="removed">-</span>
<span class="removed">-  // For non-humongous chunks, starting address shall be aligned</span>
<span class="removed">-  // to its chunk size. Humongous chunks start address is</span>
<span class="removed">-  // aligned to specialized chunk size.</span>
<span class="removed">-  const size_t required_alignment =</span>
<span class="removed">-    (chunk_type != HumongousIndex ? word_size() : get_size_for_nonhumongous_chunktype(SpecializedIndex, is_class())) * sizeof(MetaWord);</span>
<span class="removed">-  assert(is_aligned((address)this, required_alignment),</span>
<span class="removed">-         "Chunk " PTR_FORMAT ": (size " SIZE_FORMAT ") not aligned to " SIZE_FORMAT ".",</span>
<span class="removed">-         p2i(this), word_size() * sizeof(MetaWord), required_alignment);</span>
<span class="new">+</span>
<span class="new">+// Zap this structure.</span>
<span class="new">+void Metachunk::zap_header(uint8_t c) {</span>
<span class="new">+  memset(this, c, sizeof(Metachunk));</span>
 }
 
<span class="removed">-#endif // ASSERT</span>
<span class="new">+void Metachunk::fill_with_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="new">+  assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="new">+  for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="new">+    _base[l] = pattern;</span>
<span class="new">+  }</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+void Metachunk::check_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="new">+  assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="new">+  for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="new">+    assert(_base[l] == pattern,</span>
<span class="new">+           "chunk " METACHUNK_FULL_FORMAT ": pattern change at " PTR_FORMAT ": expected " UINTX_FORMAT " but got " UINTX_FORMAT ".",</span>
<span class="new">+           METACHUNK_FULL_FORMAT_ARGS(this), p2i(_base + l), (uintx)pattern, (uintx)_base[l]);</span>
<span class="new">+</span>
<span class="new">+    ////////////////////////////////////////////</span>
<span class="new">+    // A double-headed list of Metachunks.</span>
<span class="new">+</span>
<span class="new">+    class AbstractMetachunkList {</span>
<span class="new">+</span>
<span class="new">+      Metachunk* _first;</span>
<span class="new">+      Metachunk* _last;</span>
<span class="new">+</span>
<span class="new">+      // Number of chunks</span>
<span class="new">+      IntCounter _num;</span>
<span class="new">+</span>
<span class="new">+    protected:</span>
<span class="new">+</span>
<span class="new">+      AbstractMetachunkList() : _first(NULL), _last(NULL), _num() {}</span>
<span class="new">+</span>
<span class="new">+      Metachunk* first() const { return _first; }</span>
<span class="new">+      int count() const { return _num.get(); }</span>
<span class="new">+</span>
<span class="new">+      // Add chunk to the front of the list.</span>
<span class="new">+      void add_front(Metachunk* c) {</span>
<span class="new">+        if (_first == NULL) {</span>
<span class="new">+          assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="new">+          _first = _last = c;</span>
<span class="new">+          c-&gt;set_prev(NULL);</span>
<span class="new">+          c-&gt;set_next(NULL);</span>
<span class="new">+        } else {</span>
<span class="new">+          assert(_last != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="new">+          c-&gt;set_next(_first);</span>
<span class="new">+          c-&gt;set_prev(NULL);</span>
<span class="new">+          _first-&gt;set_prev(c);</span>
<span class="new">+          _first = c;</span>
<span class="new">+        }</span>
<span class="new">+        _num.increment();</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+      // Add chunk to the back of the list.</span>
<span class="new">+      void add_back(Metachunk* c) {</span>
<span class="new">+        if (_last == NULL) {</span>
<span class="new">+          assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="new">+          _last = _first = c;</span>
<span class="new">+          c-&gt;set_prev(NULL);</span>
<span class="new">+          c-&gt;set_next(NULL);</span>
<span class="new">+        } else {</span>
<span class="new">+          assert(_first != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="new">+          c-&gt;set_next(NULL);</span>
<span class="new">+          c-&gt;set_prev(_last);</span>
<span class="new">+          _last-&gt;set_next(c);</span>
<span class="new">+          _last = c;</span>
<span class="new">+        }</span>
<span class="new">+        _num.increment();</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+      // Remove chunk from the front of the list. Returns NULL if list is empty.</span>
<span class="new">+      Metachunk* remove_front() {</span>
<span class="new">+        Metachunk* c = NULL;</span>
<span class="new">+        if (_first == NULL) {</span>
<span class="new">+          assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="new">+        } else {</span>
<span class="new">+          c = _first;</span>
<span class="new">+          assert(c-&gt;prev() == NULL, "Sanity");</span>
<span class="new">+          if (_first == _last) {</span>
<span class="new">+            assert(_num.get() == 1, "Sanity");</span>
<span class="new">+            _first = _last = NULL;</span>
<span class="new">+          } else {</span>
<span class="new">+            assert(_num.get() &gt; 1, "Sanity");</span>
<span class="new">+            _first = _first-&gt;next();</span>
<span class="new">+            _first-&gt;set_prev(NULL);</span>
<span class="new">+          }</span>
<span class="new">+          _num.decrement();</span>
<span class="new">+          c-&gt;set_next(NULL);</span>
<span class="new">+        }</span>
<span class="new">+        return c;</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+      // Remove chunk from the back of the list. Returns NULL if list is empty.</span>
<span class="new">+      Metachunk* remove_back() {</span>
<span class="new">+        Metachunk* c = NULL;</span>
<span class="new">+        if (_last == NULL) {</span>
<span class="new">+          assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="new">+        } else {</span>
<span class="new">+          c = _last;</span>
<span class="new">+          assert(c-&gt;next() == NULL, "Sanity");</span>
<span class="new">+          if (_first == _last) {</span>
<span class="new">+            assert(_num.get() == 1, "Sanity");</span>
<span class="new">+            _first = _last = NULL;</span>
<span class="new">+          } else {</span>
<span class="new">+            assert(_num.get() &gt; 1, "Sanity");</span>
<span class="new">+            _last = _last-&gt;prev();</span>
<span class="new">+            _last-&gt;set_next(NULL);</span>
<span class="new">+          }</span>
<span class="new">+          _num.decrement();</span>
<span class="new">+          c-&gt;set_prev(NULL);</span>
<span class="new">+        }</span>
<span class="new">+        return c;</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+    public:</span>
<span class="new">+</span>
<span class="new">+    #ifdef ASSERT</span>
<span class="new">+      bool contains(const Metachunk* c) const;</span>
<span class="new">+      void verify() const;</span>
<span class="new">+    #endif</span>
<span class="new">+</span>
<span class="new">+      // Returns size, in words, of committed space of all chunks in this list.</span>
<span class="new">+      // Note: walks list.</span>
<span class="new">+      size_t committed_word_size() const {</span>
<span class="new">+        size_t l = 0;</span>
<span class="new">+        for (const Metachunk* c = _first; c != NULL; c = c-&gt;next()) {</span>
<span class="new">+          l += c-&gt;committed_words();</span>
<span class="new">+        }</span>
<span class="new">+        return l;</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+      void print_on(outputStream* st) const;</span>
<span class="new">+</span>
<span class="new">+    };</span>
<span class="new">+</span>
<span class="new">+    class UnsortedMetachunkList : public AbstractMetachunkList {</span>
<span class="new">+    public:</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+    };</span>
<span class="new">+</span>
 
<span class="removed">-// Helper, returns a descriptive name for the given index.</span>
<span class="removed">-const char* chunk_size_name(ChunkIndex index) {</span>
<span class="removed">-  switch (index) {</span>
<span class="removed">-    case SpecializedIndex:</span>
<span class="removed">-      return "specialized";</span>
<span class="removed">-    case SmallIndex:</span>
<span class="removed">-      return "small";</span>
<span class="removed">-    case MediumIndex:</span>
<span class="removed">-      return "medium";</span>
<span class="removed">-    case HumongousIndex:</span>
<span class="removed">-      return "humongous";</span>
<span class="removed">-    default:</span>
<span class="removed">-      return "Invalid index";</span>
   }
 }
 
<span class="removed">-#ifdef ASSERT</span>
<span class="removed">-void do_verify_chunk(Metachunk* chunk) {</span>
<span class="removed">-  guarantee(chunk != NULL, "Sanity");</span>
<span class="removed">-  // Verify chunk itself; then verify that it is consistent with the</span>
<span class="removed">-  // occupany map of its containing node.</span>
<span class="removed">-  chunk-&gt;verify();</span>
<span class="removed">-  VirtualSpaceNode* const vsn = chunk-&gt;container();</span>
<span class="removed">-  OccupancyMap* const ocmap = vsn-&gt;occupancy_map();</span>
<span class="removed">-  ocmap-&gt;verify_for_chunk(chunk);</span>
<span class="new">+</span>
<span class="new">+// Verifies linking with neighbors in virtual space.</span>
<span class="new">+// Can only be done under expand lock protection.</span>
<span class="new">+void Metachunk::verify_neighborhood() const {</span>
<span class="new">+</span>
<span class="new">+  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+  assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="new">+</span>
<span class="new">+  if (is_root_chunk()) {</span>
<span class="new">+</span>
<span class="new">+    // Root chunks are all alone in the world.</span>
<span class="new">+    assert(next_in_vs() == NULL || prev_in_vs() == NULL, "Root chunks should have no neighbors");</span>
<span class="new">+</span>
<span class="new">+  } else {</span>
<span class="new">+</span>
<span class="new">+    // Non-root chunks have neighbors, at least one, possibly two.</span>
<span class="new">+</span>
<span class="new">+    assert(next_in_vs() != NULL || prev_in_vs() != NULL,</span>
<span class="new">+           "A non-root chunk should have neighbors (chunk @" PTR_FORMAT</span>
<span class="new">+           ", base " PTR_FORMAT ", level " CHKLVL_FORMAT ".",</span>
<span class="new">+           p2i(this), p2i(base()), level());</span>
<span class="new">+</span>
<span class="new">+    if (prev_in_vs() != NULL) {</span>
<span class="new">+      assert(prev_in_vs()-&gt;end() == base(),</span>
<span class="new">+             "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to predecessor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="new">+             METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()));</span>
<span class="new">+      assert(prev_in_vs()-&gt;next_in_vs() == this,</span>
<span class="new">+             "Chunk " METACHUNK_FULL_FORMAT ": broken link to left neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="new">+             METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()), p2i(prev_in_vs()-&gt;next_in_vs()));</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    if (next_in_vs() != NULL) {</span>
<span class="new">+      assert(end() == next_in_vs()-&gt;base(),</span>
<span class="new">+             "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to successor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="new">+             METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()));</span>
<span class="new">+      assert(next_in_vs()-&gt;prev_in_vs() == this,</span>
<span class="new">+             "Chunk " METACHUNK_FULL_FORMAT ": broken link to right neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="new">+             METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()), p2i(next_in_vs()-&gt;prev_in_vs()));</span>
<span class="new">+    }</span>
<span class="new">+</span>
<span class="new">+    // One of the neighbors must be the buddy. It can be whole or splintered.</span>
<span class="new">+</span>
<span class="new">+    // The chunk following us or preceeding us may be our buddy or a splintered part of it.</span>
<span class="new">+    Metachunk* buddy = is_leader() ? next_in_vs() : prev_in_vs();</span>
<span class="new">+</span>
<span class="new">+    assert(buddy != NULL, "Missing neighbor.");</span>
<span class="new">+    assert(!buddy-&gt;is_dead(), "Invalid buddy state.");</span>
<span class="new">+</span>
<span class="new">+    // This neighbor is either or buddy (same level) or a splinter of our buddy - hence</span>
<span class="new">+    // the level can never be smaller (aka the chunk size cannot be larger).</span>
<span class="new">+    assert(buddy-&gt;level() &gt;= level(), "Wrong level.");</span>
<span class="new">+</span>
<span class="new">+    if (buddy-&gt;level() == level()) {</span>
<span class="new">+</span>
<span class="new">+      // If the buddy is of the same size as us, it is unsplintered.</span>
<span class="new">+      assert(buddy-&gt;is_leader() == !is_leader(),</span>
<span class="new">+             "Only one chunk can be leader in a pair");</span>
<span class="new">+</span>
<span class="new">+      // When direct buddies are neighbors, one or both should be in use, otherwise they should</span>
<span class="new">+      // have been merged.</span>
<span class="new">+</span>
<span class="new">+      // But since we call this verification function from internal functions where we are about to merge or just did split,</span>
<span class="new">+      // do not test this. We have RootChunkArea::verify_area_is_ideally_merged() for testing that.</span>
<span class="new">+</span>
<span class="new">+      // assert(buddy-&gt;is_in_use() || is_in_use(), "incomplete merging?");</span>
<span class="new">+</span>
<span class="new">+      if (is_leader()) {</span>
<span class="new">+        assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="new">+        assert(is_aligned(base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="new">+      } else {</span>
<span class="new">+        assert(buddy-&gt;end() == base(), "Sanity");</span>
<span class="new">+        assert(is_aligned(buddy-&gt;base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+    } else {</span>
<span class="new">+</span>
<span class="new">+      // Buddy, but splintered, and this is a part of it.</span>
<span class="new">+      if (is_leader()) {</span>
<span class="new">+        assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="new">+      } else {</span>
<span class="new">+        assert(buddy-&gt;end() &gt; (base() - word_size()), "Sanity");</span>
<span class="new">+      }</span>
<span class="new">+</span>
<span class="new">+    }</span>
<span class="new">+  }</span>
 }
<span class="removed">-#endif</span>
 
<span class="removed">-void do_update_in_use_info_for_chunk(Metachunk* chunk, bool inuse) {</span>
<span class="removed">-  chunk-&gt;set_is_tagged_free(!inuse);</span>
<span class="removed">-  OccupancyMap* const ocmap = chunk-&gt;container()-&gt;occupancy_map();</span>
<span class="removed">-  ocmap-&gt;set_region_in_use((MetaWord*)chunk, chunk-&gt;word_size(), inuse);</span>
<span class="new">+volatile MetaWord dummy = 0;</span>
<span class="new">+</span>
<span class="new">+void Metachunk::verify(bool slow) const {</span>
<span class="new">+</span>
<span class="new">+  // Note. This should be called under CLD lock protection.</span>
<span class="new">+</span>
<span class="new">+  // We can verify everything except the _prev_in_vs/_next_in_vs pair.</span>
<span class="new">+  // This is because neighbor chunks may be added concurrently, so we cannot rely</span>
<span class="new">+  //  on the content of _next_in_vs/_prev_in_vs unless we have the expand lock.</span>
<span class="new">+</span>
<span class="new">+  assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="new">+</span>
<span class="new">+  if (is_free()) {</span>
<span class="new">+    assert(used_words() == 0, "free chunks are not used.");</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+  // Note: only call this on a life Metachunk.</span>
<span class="new">+  chunklevel::check_valid_level(level());</span>
<span class="new">+</span>
<span class="new">+  assert(base() != NULL, "No base ptr");</span>
<span class="new">+</span>
<span class="new">+  assert(committed_words() &gt;= used_words(),</span>
<span class="new">+         "mismatch: committed: " SIZE_FORMAT ", used: " SIZE_FORMAT ".",</span>
<span class="new">+         committed_words(), used_words());</span>
<span class="new">+</span>
<span class="new">+  assert(word_size() &gt;= committed_words(),</span>
<span class="new">+         "mismatch: word_size: " SIZE_FORMAT ", committed: " SIZE_FORMAT ".",</span>
<span class="new">+         word_size(), committed_words());</span>
<span class="new">+</span>
<span class="new">+  // Test base pointer</span>
<span class="new">+  assert(base() != NULL, "Base pointer NULL");</span>
<span class="new">+  assert(vsnode() != NULL, "No space");</span>
<span class="new">+  vsnode()-&gt;check_pointer(base());</span>
<span class="new">+</span>
<span class="new">+  // Starting address shall be aligned to chunk size.</span>
<span class="new">+  const size_t required_alignment = word_size() * sizeof(MetaWord);</span>
<span class="new">+  assert_is_aligned(base(), required_alignment);</span>
<span class="new">+</span>
<span class="new">+  // If slow, test the committed area</span>
<span class="new">+  if (slow &amp;&amp; _committed_words &gt; 0) {</span>
<span class="new">+    for (const MetaWord* p = _base; p &lt; _base + _committed_words; p += os::vm_page_size()) {</span>
<span class="new">+      dummy = *p;</span>
<span class="new">+    }</span>
<span class="new">+    dummy = *(_base + _committed_words - 1);</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+}</span>
<span class="new">+#endif // ASSERT</span>
<span class="new">+</span>
<span class="new">+void Metachunk::print_on(outputStream* st) const {</span>
<span class="new">+</span>
<span class="new">+  // Note: must also work with invalid/random data. (e.g. do not call word_size())</span>
<span class="new">+  st-&gt;print("Chunk @" PTR_FORMAT ", state %c, base " PTR_FORMAT ", "</span>
<span class="new">+            "level " CHKLVL_FORMAT " (" SIZE_FORMAT " words), "</span>
<span class="new">+            "used " SIZE_FORMAT " words, committed " SIZE_FORMAT " words.",</span>
<span class="new">+            p2i(this), get_state_char(), p2i(base()), level(),</span>
<span class="new">+            (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : (size_t)-1),</span>
<span class="new">+            used_words(), committed_words());</span>
<span class="new">+</span>
 }
 
 } // namespace metaspace
 
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.hpp.udiff.html' target='_top'>next &gt</a></center>
</body></html>

