<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/memory/metaspace </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/spaceManager.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>

<table><tr valign="top">
<td><pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include "precompiled.hpp"
  25 
  26 #include "logging/log.hpp"
  27 #include "logging/logStream.hpp"



  28 #include "memory/metaspace/chunkManager.hpp"

  29 #include "memory/metaspace/metachunk.hpp"
<span class="removed">  30 #include "memory/metaspace/metaDebug.hpp"</span>
  31 #include "memory/metaspace/metaspaceCommon.hpp"

  32 #include "memory/metaspace/spaceManager.hpp"
  33 #include "memory/metaspace/virtualSpaceList.hpp"
  34 #include "runtime/atomic.hpp"
  35 #include "runtime/init.hpp"
  36 #include "services/memoryService.hpp"

  37 #include "utilities/debug.hpp"
  38 #include "utilities/globalDefinitions.hpp"
  39 
  40 namespace metaspace {
  41 
<span class="changed">  42 #define assert_counter(expected_value, real_value, msg) \</span>
<span class="changed">  43   assert( (expected_value) == (real_value),             \</span>
<span class="changed">  44          "Counter mismatch (%s): expected " SIZE_FORMAT \</span>
<span class="changed">  45          ", but got: " SIZE_FORMAT ".", msg, expected_value, \</span>
<span class="changed">  46          real_value);</span>
  47 
<span class="changed">  48 // SpaceManager methods</span>



  49 
<span class="changed">  50 size_t SpaceManager::adjust_initial_chunk_size(size_t requested, bool is_class_space) {</span>
<span class="changed">  51   size_t chunk_sizes[] = {</span>
<span class="changed">  52       specialized_chunk_size(is_class_space),</span>
<span class="changed">  53       small_chunk_size(is_class_space),</span>
<span class="changed">  54       medium_chunk_size(is_class_space)</span>
<span class="changed">  55   };</span>
  56 
<span class="changed">  57   // Adjust up to one of the fixed chunk sizes ...</span>
<span class="changed">  58   for (size_t i = 0; i &lt; ARRAY_SIZE(chunk_sizes); i++) {</span>
<span class="changed">  59     if (requested &lt;= chunk_sizes[i]) {</span>
<span class="changed">  60       return chunk_sizes[i];</span>
<span class="changed">  61     }</span>






  62   }







  63 
<span class="removed">  64   // ... or return the size as a humongous chunk.</span>
<span class="removed">  65   return requested;</span>
  66 }
  67 
<span class="changed">  68 size_t SpaceManager::adjust_initial_chunk_size(size_t requested) const {</span>
<span class="changed">  69   return adjust_initial_chunk_size(requested, is_class());</span>


  70 }
  71 
<span class="changed">  72 size_t SpaceManager::get_initial_chunk_size(Metaspace::MetaspaceType type) const {</span>
<span class="changed">  73   size_t requested;</span>
  74 
<span class="changed">  75   if (is_class()) {</span>
<span class="changed">  76     switch (type) {</span>
<span class="changed">  77     case Metaspace::BootMetaspaceType:              requested = Metaspace::first_class_chunk_word_size(); break;</span>
<span class="changed">  78     case Metaspace::ClassMirrorHolderMetaspaceType: requested = ClassSpecializedChunk; break;</span>
<span class="changed">  79     case Metaspace::ReflectionMetaspaceType:        requested = ClassSpecializedChunk; break;</span>
<span class="changed">  80     default:                                        requested = ClassSmallChunk; break;</span>
<span class="changed">  81     }</span>
<span class="changed">  82   } else {</span>
<span class="changed">  83     switch (type) {</span>
<span class="changed">  84     case Metaspace::BootMetaspaceType:              requested = Metaspace::first_chunk_word_size(); break;</span>
<span class="changed">  85     case Metaspace::ClassMirrorHolderMetaspaceType: requested = SpecializedChunk; break;</span>
<span class="changed">  86     case Metaspace::ReflectionMetaspaceType:        requested = SpecializedChunk; break;</span>
<span class="changed">  87     default:                                        requested = SmallChunk; break;</span>
  88     }








  89   }
  90 
<span class="changed">  91   // Adjust to one of the fixed chunk sizes (unless humongous)</span>
<span class="changed">  92   const size_t adjusted = adjust_initial_chunk_size(requested);</span>
  93 
<span class="changed">  94   assert(adjusted != 0, "Incorrect initial chunk size. Requested: "</span>
<span class="changed">  95          SIZE_FORMAT " adjusted: " SIZE_FORMAT, requested, adjusted);</span>
  96 
<span class="changed">  97   return adjusted;</span>
<span class="changed">  98 }</span>



  99 
<span class="changed"> 100 void SpaceManager::locked_print_chunks_in_use_on(outputStream* st) const {</span>





 101 
<span class="removed"> 102   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {</span>
<span class="removed"> 103     st-&gt;print("SpaceManager: " UINTX_FORMAT " %s chunks.",</span>
<span class="removed"> 104         num_chunks_by_type(i), chunk_size_name(i));</span>
 105   }
 106 
<span class="removed"> 107   chunk_manager()-&gt;locked_print_free_chunks(st);</span>
 108 }
 109 
<span class="changed"> 110 size_t SpaceManager::calc_chunk_size(size_t word_size) {</span>




 111 
<span class="changed"> 112   // Decide between a small chunk and a medium chunk.  Up to</span>
<span class="changed"> 113   // _small_chunk_limit small chunks can be allocated.</span>
<span class="changed"> 114   // After that a medium chunk is preferred.</span>
<span class="changed"> 115   size_t chunk_word_size;</span>




 116 
<span class="changed"> 117   // Special case for hidden metadata space.</span>
<span class="changed"> 118   // ClassMirrorHolder metadata space is usually small since it is used for</span>
<span class="changed"> 119   // class loader data's whose life cycle is governed by one class such as a</span>
<span class="changed"> 120   // non-strong hidden class or unsafe anonymous class.  The majority within 1K - 2K range and</span>
<span class="changed"> 121   // rarely about 4K (64-bits JVM).</span>
<span class="changed"> 122   // Instead of jumping to SmallChunk after initial chunk exhausted, keeping allocation</span>
<span class="changed"> 123   // from SpecializeChunk up to _anon_or_delegating_metadata_specialize_chunk_limit (4)</span>
<span class="changed"> 124   // reduces space waste from 60+% to around 30%.</span>
<span class="changed"> 125   if ((_space_type == Metaspace::ClassMirrorHolderMetaspaceType || _space_type == Metaspace::ReflectionMetaspaceType) &amp;&amp;</span>
<span class="changed"> 126       _mdtype == Metaspace::NonClassType &amp;&amp;</span>
<span class="changed"> 127       num_chunks_by_type(SpecializedIndex) &lt; anon_and_delegating_metadata_specialize_chunk_limit &amp;&amp;</span>
<span class="changed"> 128       word_size + Metachunk::overhead() &lt;= SpecializedChunk) {</span>
<span class="changed"> 129     return SpecializedChunk;</span>
 130   }
 131 
<span class="changed"> 132   if (num_chunks_by_type(MediumIndex) == 0 &amp;&amp;</span>
<span class="changed"> 133       num_chunks_by_type(SmallIndex) &lt; small_chunk_limit) {</span>
<span class="changed"> 134     chunk_word_size = (size_t) small_chunk_size();</span>
<span class="changed"> 135     if (word_size + Metachunk::overhead() &gt; small_chunk_size()) {</span>
<span class="changed"> 136       chunk_word_size = medium_chunk_size();</span>
<span class="changed"> 137     }</span>
<span class="changed"> 138   } else {</span>
<span class="changed"> 139     chunk_word_size = medium_chunk_size();</span>
<span class="changed"> 140   }</span>
 141 
<span class="changed"> 142   // Might still need a humongous chunk.  Enforce</span>
<span class="changed"> 143   // humongous allocations sizes to be aligned up to</span>
<span class="changed"> 144   // the smallest chunk size.</span>
<span class="changed"> 145   size_t if_humongous_sized_chunk =</span>
<span class="changed"> 146     align_up(word_size + Metachunk::overhead(),</span>
<span class="changed"> 147                   smallest_chunk_size());</span>
<span class="changed"> 148   chunk_word_size =</span>
<span class="changed"> 149     MAX2((size_t) chunk_word_size, if_humongous_sized_chunk);</span>
 150 
<span class="removed"> 151   assert(!SpaceManager::is_humongous(word_size) ||</span>
<span class="removed"> 152          chunk_word_size == if_humongous_sized_chunk,</span>
<span class="removed"> 153          "Size calculation is wrong, word_size " SIZE_FORMAT</span>
<span class="removed"> 154          " chunk_word_size " SIZE_FORMAT,</span>
<span class="removed"> 155          word_size, chunk_word_size);</span>
<span class="removed"> 156   Log(gc, metaspace, alloc) log;</span>
<span class="removed"> 157   if (log.is_trace() &amp;&amp; SpaceManager::is_humongous(word_size)) {</span>
<span class="removed"> 158     log.trace("Metadata humongous allocation:");</span>
<span class="removed"> 159     log.trace("  word_size " PTR_FORMAT, word_size);</span>
<span class="removed"> 160     log.trace("  chunk_word_size " PTR_FORMAT, chunk_word_size);</span>
<span class="removed"> 161     log.trace("    chunk overhead " PTR_FORMAT, Metachunk::overhead());</span>
<span class="removed"> 162   }</span>
<span class="removed"> 163   return chunk_word_size;</span>
 164 }
 165 
<span class="changed"> 166 void SpaceManager::track_metaspace_memory_usage() {</span>
<span class="changed"> 167   if (is_init_completed()) {</span>
<span class="changed"> 168     if (is_class()) {</span>
<span class="changed"> 169       MemoryService::track_compressed_class_memory_usage();</span>
<span class="changed"> 170     }</span>
<span class="changed"> 171     MemoryService::track_metaspace_memory_usage();</span>
<span class="changed"> 172   }</span>

















 173 }
 174 
<span class="changed"> 175 MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {</span>
<span class="changed"> 176   assert_lock_strong(_lock);</span>
<span class="changed"> 177   assert(vs_list()-&gt;current_virtual_space() != NULL,</span>
<span class="changed"> 178          "Should have been set");</span>
<span class="changed"> 179   assert(current_chunk() == NULL ||</span>
<span class="changed"> 180          current_chunk()-&gt;allocate(word_size) == NULL,</span>
<span class="changed"> 181          "Don't need to expand");</span>
<span class="changed"> 182   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 183 </span>
<span class="changed"> 184   if (log_is_enabled(Trace, gc, metaspace, freelist)) {</span>
<span class="changed"> 185     size_t words_left = 0;</span>
<span class="changed"> 186     size_t words_used = 0;</span>
<span class="changed"> 187     if (current_chunk() != NULL) {</span>
<span class="changed"> 188       words_left = current_chunk()-&gt;free_word_size();</span>
<span class="changed"> 189       words_used = current_chunk()-&gt;used_word_size();</span>
<span class="changed"> 190     }</span>
<span class="changed"> 191     log_trace(gc, metaspace, freelist)("SpaceManager::grow_and_allocate for " SIZE_FORMAT " words " SIZE_FORMAT " words used " SIZE_FORMAT " words left",</span>
<span class="changed"> 192                                        word_size, words_used, words_left);</span>
<span class="changed"> 193   }</span>
 194 
<span class="changed"> 195   // Get another chunk</span>
<span class="changed"> 196   size_t chunk_word_size = calc_chunk_size(word_size);</span>
<span class="changed"> 197   Metachunk* next = get_new_chunk(chunk_word_size);</span>
 198 
<span class="changed"> 199   MetaWord* mem = NULL;</span>
 200 
<span class="changed"> 201   // If a chunk was available, add it to the in-use chunk list</span>
<span class="changed"> 202   // and do an allocation from it.</span>
<span class="changed"> 203   if (next != NULL) {</span>
<span class="changed"> 204     // Add to this manager's list of chunks in use.</span>
<span class="changed"> 205     // If the new chunk is humongous, it was created to serve a single large allocation. In that</span>
<span class="changed"> 206     // case it usually makes no sense to make it the current chunk, since the next allocation would</span>
<span class="changed"> 207     // need to allocate a new chunk anyway, while we would now prematurely retire a perfectly</span>
<span class="changed"> 208     // good chunk which could be used for more normal allocations.</span>
<span class="changed"> 209     bool make_current = true;</span>
<span class="changed"> 210     if (next-&gt;get_chunk_type() == HumongousIndex &amp;&amp;</span>
<span class="changed"> 211         current_chunk() != NULL) {</span>
<span class="changed"> 212       make_current = false;</span>
<span class="changed"> 213     }</span>
<span class="changed"> 214     add_chunk(next, make_current);</span>
<span class="changed"> 215     mem = next-&gt;allocate(word_size);</span>
<span class="changed"> 216   }</span>
 217 
<span class="changed"> 218   // Track metaspace memory usage statistic.</span>
<span class="changed"> 219   track_metaspace_memory_usage();</span>
 220 
<span class="changed"> 221   return mem;</span>
<span class="changed"> 222 }</span>








 223 
<span class="changed"> 224 void SpaceManager::print_on(outputStream* st) const {</span>
<span class="changed"> 225   SpaceManagerStatistics stat;</span>
<span class="changed"> 226   add_to_statistics(&amp;stat); // will lock _lock.</span>
<span class="changed"> 227   stat.print_on(st, 1*K, false);</span>
<span class="changed"> 228 }</span>
<span class="changed"> 229 </span>
<span class="changed"> 230 SpaceManager::SpaceManager(Metaspace::MetadataType mdtype,</span>
<span class="changed"> 231                            Metaspace::MetaspaceType space_type,//</span>
<span class="changed"> 232                            Mutex* lock) :</span>
<span class="changed"> 233   _lock(lock),</span>
<span class="changed"> 234   _mdtype(mdtype),</span>
<span class="changed"> 235   _space_type(space_type),</span>
<span class="changed"> 236   _chunk_list(NULL),</span>
<span class="changed"> 237   _current_chunk(NULL),</span>
<span class="changed"> 238   _overhead_words(0),</span>
<span class="changed"> 239   _capacity_words(0),</span>
<span class="changed"> 240   _used_words(0),</span>
<span class="changed"> 241   _block_freelists(NULL) {</span>
<span class="changed"> 242   Metadebug::init_allocation_fail_alot_count();</span>
<span class="changed"> 243   memset(_num_chunks_by_type, 0, sizeof(_num_chunks_by_type));</span>
<span class="changed"> 244   log_trace(gc, metaspace, freelist)("SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="changed"> 245 }</span>
<span class="changed"> 246 </span>
<span class="changed"> 247 void SpaceManager::account_for_new_chunk(const Metachunk* new_chunk) {</span>
<span class="changed"> 248 </span>
<span class="changed"> 249   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 250 </span>
<span class="changed"> 251   _capacity_words += new_chunk-&gt;word_size();</span>
<span class="changed"> 252   _overhead_words += Metachunk::overhead();</span>
<span class="changed"> 253   DEBUG_ONLY(new_chunk-&gt;verify());</span>
<span class="changed"> 254   _num_chunks_by_type[new_chunk-&gt;get_chunk_type()] ++;</span>
<span class="changed"> 255 </span>
<span class="changed"> 256   // Adjust global counters:</span>
<span class="changed"> 257   MetaspaceUtils::inc_capacity(mdtype(), new_chunk-&gt;word_size());</span>
<span class="changed"> 258   MetaspaceUtils::inc_overhead(mdtype(), Metachunk::overhead());</span>
<span class="changed"> 259 }</span>
<span class="changed"> 260 </span>
<span class="changed"> 261 void SpaceManager::account_for_allocation(size_t words) {</span>
<span class="changed"> 262   // Note: we should be locked with the ClassloaderData-specific metaspace lock.</span>
<span class="changed"> 263   // We may or may not be locked with the global metaspace expansion lock.</span>
<span class="changed"> 264   assert_lock_strong(lock());</span>
 265 
<span class="changed"> 266   // Add to the per SpaceManager totals. This can be done non-atomically.</span>
<span class="changed"> 267   _used_words += words;</span>
 268 
<span class="changed"> 269   // Adjust global counters. This will be done atomically.</span>
<span class="changed"> 270   MetaspaceUtils::inc_used(mdtype(), words);</span>
<span class="changed"> 271 }</span>
 272 
<span class="changed"> 273 void SpaceManager::account_for_spacemanager_death() {</span>
 274 
<span class="changed"> 275   assert_lock_strong(MetaspaceExpand_lock);</span>
 276 
<span class="removed"> 277   MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);</span>
<span class="removed"> 278   MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);</span>
<span class="removed"> 279   MetaspaceUtils::dec_used(mdtype(), _used_words);</span>
 280 }
 281 
<span class="changed"> 282 SpaceManager::~SpaceManager() {</span>




 283 
<span class="changed"> 284   // This call this-&gt;_lock which can't be done while holding MetaspaceExpand_lock</span>
<span class="changed"> 285   DEBUG_ONLY(verify_metrics());</span>
 286 
<span class="changed"> 287   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 288 </span>
<span class="changed"> 289   account_for_spacemanager_death();</span>

 290 
<span class="changed"> 291   Log(gc, metaspace, freelist) log;</span>
<span class="changed"> 292   if (log.is_trace()) {</span>
<span class="changed"> 293     log.trace("~SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="changed"> 294     ResourceMark rm;</span>
<span class="changed"> 295     LogStream ls(log.trace());</span>
<span class="changed"> 296     locked_print_chunks_in_use_on(&amp;ls);</span>
<span class="changed"> 297     if (block_freelists() != NULL) {</span>
<span class="changed"> 298       block_freelists()-&gt;print_on(&amp;ls);</span>
 299     }




 300   }
 301 
<span class="changed"> 302   // Add all the chunks in use by this space manager</span>
<span class="changed"> 303   // to the global list of free chunks.</span>


 304 
<span class="changed"> 305   // Follow each list of chunks-in-use and add them to the</span>
<span class="changed"> 306   // free lists.  Each list is NULL terminated.</span>
<span class="changed"> 307   chunk_manager()-&gt;return_chunk_list(chunk_list());</span>
<span class="changed"> 308 #ifdef ASSERT</span>
<span class="changed"> 309   _chunk_list = NULL;</span>
<span class="changed"> 310   _current_chunk = NULL;</span>
<span class="changed"> 311 #endif</span>
 312 
<span class="changed"> 313 #ifdef ASSERT</span>
<span class="changed"> 314   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed"> 315     chunk_manager()-&gt;locked_verify(true);</span>
<span class="changed"> 316   END_EVERY_NTH</span>
<span class="changed"> 317 #endif</span>

 318 
<span class="changed"> 319   if (_block_freelists != NULL) {</span>
<span class="changed"> 320     delete _block_freelists;</span>


 321   }
<span class="removed"> 322 }</span>
 323 
<span class="changed"> 324 void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 325   assert_lock_strong(lock());</span>
<span class="changed"> 326   // Allocations and deallocations are in raw_word_size</span>
<span class="changed"> 327   size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="changed"> 328   // Lazily create a block_freelist</span>
<span class="changed"> 329   if (block_freelists() == NULL) {</span>
<span class="changed"> 330     _block_freelists = new BlockFreelist();</span>
 331   }
<span class="removed"> 332   block_freelists()-&gt;return_block(p, raw_word_size);</span>
<span class="removed"> 333   DEBUG_ONLY(Atomic::inc(&amp;(g_internal_statistics.num_deallocs)));</span>
<span class="removed"> 334 }</span>
 335 
<span class="changed"> 336 // Adds a chunk to the list of chunks in use.</span>
<span class="changed"> 337 void SpaceManager::add_chunk(Metachunk* new_chunk, bool make_current) {</span>
 338 
<span class="changed"> 339   assert_lock_strong(_lock);</span>
<span class="changed"> 340   assert(new_chunk != NULL, "Should not be NULL");</span>
<span class="changed"> 341   assert(new_chunk-&gt;next() == NULL, "Should not be on a list");</span>
 342 
<span class="changed"> 343   new_chunk-&gt;reset_empty();</span>
 344 
<span class="changed"> 345   // Find the correct list and and set the current</span>
<span class="changed"> 346   // chunk for that list.</span>
<span class="changed"> 347   ChunkIndex index = chunk_manager()-&gt;list_index(new_chunk-&gt;word_size());</span>
 348 
<span class="changed"> 349   if (make_current) {</span>
<span class="changed"> 350     // If we are to make the chunk current, retire the old current chunk and replace</span>
<span class="changed"> 351     // it with the new chunk.</span>
<span class="changed"> 352     retire_current_chunk();</span>
<span class="changed"> 353     set_current_chunk(new_chunk);</span>
<span class="changed"> 354   }</span>

 355 
<span class="changed"> 356   // Add the new chunk at the head of its respective chunk list.</span>
<span class="changed"> 357   new_chunk-&gt;set_next(_chunk_list);</span>
<span class="changed"> 358   _chunk_list = new_chunk;</span>
 359 
<span class="changed"> 360   // Adjust counters.</span>
<span class="changed"> 361   account_for_new_chunk(new_chunk);</span>
 362 
<span class="changed"> 363   assert(new_chunk-&gt;is_empty(), "Not ready for reuse");</span>
<span class="changed"> 364   Log(gc, metaspace, freelist) log;</span>
<span class="changed"> 365   if (log.is_trace()) {</span>
<span class="changed"> 366     log.trace("SpaceManager::added chunk: ");</span>
<span class="changed"> 367     ResourceMark rm;</span>
<span class="changed"> 368     LogStream ls(log.trace());</span>
<span class="changed"> 369     new_chunk-&gt;print_on(&amp;ls);</span>
<span class="changed"> 370     chunk_manager()-&gt;locked_print_free_chunks(&amp;ls);</span>





 371   }
<span class="removed"> 372 }</span>
 373 
<span class="changed"> 374 void SpaceManager::retire_current_chunk() {</span>


 375   if (current_chunk() != NULL) {
<span class="changed"> 376     size_t remaining_words = current_chunk()-&gt;free_word_size();</span>
<span class="changed"> 377     if (remaining_words &gt;= SmallBlocks::small_block_min_size()) {</span>
<span class="changed"> 378       MetaWord* ptr = current_chunk()-&gt;allocate(remaining_words);</span>
<span class="changed"> 379       deallocate(ptr, remaining_words);</span>
<span class="changed"> 380       account_for_allocation(remaining_words);</span>






 381     }
 382   }
<span class="removed"> 383 }</span>
 384 
<span class="changed"> 385 Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {</span>
<span class="changed"> 386   // Get a chunk from the chunk freelist</span>
<span class="changed"> 387   Metachunk* next = chunk_manager()-&gt;chunk_freelist_allocate(chunk_word_size);</span>






 388 
<span class="changed"> 389   if (next == NULL) {</span>
<span class="changed"> 390     next = vs_list()-&gt;get_new_chunk(chunk_word_size,</span>
<span class="changed"> 391                                     medium_chunk_bunch());</span>

 392   }
 393 
<span class="removed"> 394   Log(gc, metaspace, alloc) log;</span>
<span class="removed"> 395   if (log.is_trace() &amp;&amp; next != NULL &amp;&amp;</span>
<span class="removed"> 396       SpaceManager::is_humongous(next-&gt;word_size())) {</span>
<span class="removed"> 397     log.trace("  new humongous chunk word size " PTR_FORMAT, next-&gt;word_size());</span>
 398   }
 399 
<span class="changed"> 400   return next;</span>
<span class="changed"> 401 }</span>
 402 
<span class="changed"> 403 MetaWord* SpaceManager::allocate(size_t word_size) {</span>
<span class="changed"> 404   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 405   size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="changed"> 406   BlockFreelist* fl =  block_freelists();</span>
<span class="changed"> 407   MetaWord* p = NULL;</span>
 408 
<span class="changed"> 409   // Allocation from the dictionary is expensive in the sense that</span>
<span class="changed"> 410   // the dictionary has to be searched for a size.  Don't allocate</span>
<span class="changed"> 411   // from the dictionary until it starts to get fat.  Is this</span>
<span class="changed"> 412   // a reasonable policy?  Maybe an skinny dictionary is fast enough</span>
<span class="changed"> 413   // for allocations.  Do some profiling.  JJJ</span>
<span class="changed"> 414   if (fl != NULL &amp;&amp; fl-&gt;total_size() &gt; allocation_from_dictionary_limit) {</span>
<span class="changed"> 415     p = fl-&gt;get_block(raw_word_size);</span>
<span class="changed"> 416     if (p != NULL) {</span>
<span class="changed"> 417       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs_from_deallocated_blocks));</span>
<span class="changed"> 418     }</span>
<span class="changed"> 419   }</span>
<span class="changed"> 420   if (p == NULL) {</span>
<span class="changed"> 421     p = allocate_work(raw_word_size);</span>
 422   }
 423 
<span class="changed"> 424 #ifdef ASSERT</span>
<span class="changed"> 425   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed"> 426     verify_metrics_locked();</span>
<span class="changed"> 427   END_EVERY_NTH</span>
<span class="changed"> 428 #endif</span>
 429 
<span class="changed"> 430   return p;</span>
<span class="changed"> 431 }</span>







 432 
<span class="removed"> 433 // Returns the address of spaced allocated for "word_size".</span>
<span class="removed"> 434 // This methods does not know about blocks (Metablocks)</span>
<span class="removed"> 435 MetaWord* SpaceManager::allocate_work(size_t word_size) {</span>
<span class="removed"> 436   assert_lock_strong(lock());</span>
 437 #ifdef ASSERT
<span class="changed"> 438   if (Metadebug::test_metadata_failure()) {</span>
<span class="changed"> 439     return NULL;</span>

 440   }
 441 #endif
<span class="removed"> 442   // Is there space in the current chunk?</span>
<span class="removed"> 443   MetaWord* result = NULL;</span>
 444 
<span class="changed"> 445   if (current_chunk() != NULL) {</span>
<span class="changed"> 446     result = current_chunk()-&gt;allocate(word_size);</span>



 447   }
 448 
<span class="changed"> 449   if (result == NULL) {</span>
<span class="changed"> 450     result = grow_and_allocate(word_size);</span>
<span class="changed"> 451   }</span>
 452 
<span class="changed"> 453   if (result != NULL) {</span>
<span class="changed"> 454     account_for_allocation(word_size);</span>


 455   }
 456 
<span class="changed"> 457   return result;</span>

 458 }
 459 
<span class="changed"> 460 void SpaceManager::verify() {</span>
<span class="changed"> 461   Metachunk* curr = chunk_list();</span>
<span class="changed"> 462   while (curr != NULL) {</span>
<span class="changed"> 463     DEBUG_ONLY(do_verify_chunk(curr);)</span>
<span class="changed"> 464     assert(curr-&gt;is_tagged_free() == false, "Chunk should be tagged as in use.");</span>
<span class="changed"> 465     curr = curr-&gt;next();</span>
 466   }


















 467 }
 468 
<span class="changed"> 469 void SpaceManager::verify_chunk_size(Metachunk* chunk) {</span>
<span class="changed"> 470   assert(is_humongous(chunk-&gt;word_size()) ||</span>
<span class="changed"> 471          chunk-&gt;word_size() == medium_chunk_size() ||</span>
<span class="changed"> 472          chunk-&gt;word_size() == small_chunk_size() ||</span>
<span class="changed"> 473          chunk-&gt;word_size() == specialized_chunk_size(),</span>
<span class="changed"> 474          "Chunk size is wrong");</span>
<span class="changed"> 475   return;</span>
 476 }
 477 
<span class="changed"> 478 void SpaceManager::add_to_statistics_locked(SpaceManagerStatistics* out) const {</span>
<span class="changed"> 479   assert_lock_strong(lock());</span>
<span class="changed"> 480   Metachunk* chunk = chunk_list();</span>
<span class="changed"> 481   while (chunk != NULL) {</span>
<span class="changed"> 482     UsedChunksStatistics&amp; chunk_stat = out-&gt;chunk_stats(chunk-&gt;get_chunk_type());</span>
<span class="changed"> 483     chunk_stat.add_num(1);</span>
<span class="changed"> 484     chunk_stat.add_cap(chunk-&gt;word_size());</span>
<span class="changed"> 485     chunk_stat.add_overhead(Metachunk::overhead());</span>
<span class="changed"> 486     chunk_stat.add_used(chunk-&gt;used_word_size() - Metachunk::overhead());</span>
<span class="changed"> 487     if (chunk != current_chunk()) {</span>
<span class="changed"> 488       chunk_stat.add_waste(chunk-&gt;free_word_size());</span>



 489     } else {
<span class="changed"> 490       chunk_stat.add_free(chunk-&gt;free_word_size());</span>
 491     }
<span class="removed"> 492     chunk = chunk-&gt;next();</span>
 493   }
<span class="changed"> 494   if (block_freelists() != NULL) {</span>
<span class="changed"> 495     out-&gt;add_free_blocks_info(block_freelists()-&gt;num_blocks(), block_freelists()-&gt;total_size());</span>


 496   }



 497 }
 498 
<span class="changed"> 499 void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {</span>


 500   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<span class="changed"> 501   add_to_statistics_locked(out);</span>














 502 }
 503 

 504 #ifdef ASSERT
<span class="changed"> 505 void SpaceManager::verify_metrics_locked() const {</span>


 506   assert_lock_strong(lock());
 507 
<span class="changed"> 508   SpaceManagerStatistics stat;</span>
<span class="changed"> 509   add_to_statistics_locked(&amp;stat);</span>
 510 
<span class="changed"> 511   UsedChunksStatistics chunk_stats = stat.totals();</span>
 512 
<span class="changed"> 513   DEBUG_ONLY(chunk_stats.check_sanity());</span>














 514 
<span class="removed"> 515   assert_counter(_capacity_words, chunk_stats.cap(), "SpaceManager::_capacity_words");</span>
<span class="removed"> 516   assert_counter(_used_words, chunk_stats.used(), "SpaceManager::_used_words");</span>
<span class="removed"> 517   assert_counter(_overhead_words, chunk_stats.overhead(), "SpaceManager::_overhead_words");</span>
 518 }
 519 
<span class="changed"> 520 void SpaceManager::verify_metrics() const {</span>

 521   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<span class="changed"> 522   verify_metrics_locked();</span>
















 523 }

 524 #endif // ASSERT
















 525 
 526 
 527 } // namespace metaspace
 528 
</pre></td><td><pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="new">   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "logging/logStream.hpp"
<span class="new">  29 #include "memory/metaspace/allocationGuard.hpp"</span>
<span class="new">  30 #include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="new">  31 #include "memory/metaspace/freeBlocks.hpp"</span>
  32 #include "memory/metaspace/chunkManager.hpp"
<span class="new">  33 #include "memory/metaspace/internStat.hpp"</span>
  34 #include "memory/metaspace/metachunk.hpp"

  35 #include "memory/metaspace/metaspaceCommon.hpp"
<span class="new">  36 #include "memory/metaspace/metaspaceStatistics.hpp"</span>
  37 #include "memory/metaspace/spaceManager.hpp"
  38 #include "memory/metaspace/virtualSpaceList.hpp"
  39 #include "runtime/atomic.hpp"
  40 #include "runtime/init.hpp"
  41 #include "services/memoryService.hpp"
<span class="new">  42 #include "utilities/align.hpp"</span>
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
  45 
  46 namespace metaspace {
  47 
<span class="changed">  48 #define LOGFMT         "SpcMgr @" PTR_FORMAT " (%s)"</span>
<span class="changed">  49 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>



  50 
<span class="changed">  51 // Given a net allocation word size, return the raw word size we actually allocate.</span>
<span class="changed">  52 // Note: externally visible for gtests.</span>
<span class="changed">  53 //static</span>
<span class="changed">  54 size_t get_raw_allocation_word_size(size_t net_word_size) {</span>
  55 
<span class="changed">  56   size_t byte_size = net_word_size * BytesPerWord;</span>





  57 
<span class="changed">  58   // Deallocated metablocks are kept in a binlist which limits their minimal</span>
<span class="changed">  59   //  size to at least the size of a binlist item (2 words).</span>
<span class="changed">  60   byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);</span>
<span class="changed">  61 </span>
<span class="changed">  62   // Metaspace allocations are aligned to word size.</span>
<span class="changed">  63   byte_size = align_up(byte_size, allocation_alignment_bytes);</span>
<span class="changed">  64 </span>
<span class="changed">  65   // If we guard allocations, we need additional space for a prefix.</span>
<span class="changed">  66 #ifdef ASSERT</span>
<span class="changed">  67   if (Settings::use_allocation_guard()) {</span>
<span class="changed">  68     byte_size += align_up(prefix_size(), allocation_alignment_bytes);</span>
  69   }
<span class="new">  70 #endif</span>
<span class="new">  71 </span>
<span class="new">  72   size_t word_size = byte_size / BytesPerWord;</span>
<span class="new">  73 </span>
<span class="new">  74   assert(word_size * BytesPerWord == byte_size, "Sanity");</span>
<span class="new">  75 </span>
<span class="new">  76   return word_size;</span>
  77 


  78 }
  79 
<span class="changed">  80 // Returns the level of the next chunk to be added, acc to growth policy.</span>
<span class="changed">  81 chunklevel_t SpaceManager::next_chunk_level() const {</span>
<span class="changed">  82   const int growth_step = _chunks.count();</span>
<span class="changed">  83   return _growth_policy-&gt;get_level_at_step(growth_step);</span>
  84 }
  85 
<span class="changed">  86 // Given a chunk, add its remaining free committed space to the free block list.</span>
<span class="changed">  87 void SpaceManager::salvage_chunk(Metachunk* c) {</span>
  88 
<span class="changed">  89   if (Settings::handle_deallocations() == false) {</span>
<span class="changed">  90     return;</span>











  91   }
<span class="new">  92 </span>
<span class="new">  93   assert_lock_strong(lock());</span>
<span class="new">  94 </span>
<span class="new">  95   // If the chunk is completely empty, just return it to the chunk manager.</span>
<span class="new">  96   if (c-&gt;used_words() == 0) {</span>
<span class="new">  97     UL2(trace, "salvage: returning empty chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="new">  98     _chunk_manager-&gt;return_chunk(c);</span>
<span class="new">  99     return;</span>
 100   }
 101 
<span class="changed"> 102   size_t remaining_words = c-&gt;free_below_committed_words();</span>

 103 
<span class="changed"> 104   if (remaining_words &gt; FreeBlocks::minimal_word_size) {</span>

 105 
<span class="changed"> 106     UL2(trace, "salvaging chunk " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));</span>
<span class="changed"> 107 </span>
<span class="changed"> 108     MetaWord* ptr = c-&gt;allocate(remaining_words);</span>
<span class="changed"> 109     assert(ptr != NULL, "Should have worked");</span>
<span class="changed"> 110     _total_used_words_counter-&gt;increment_by(remaining_words);</span>
 111 
<span class="changed"> 112     add_allocation_to_fbl(ptr, remaining_words);</span>
<span class="changed"> 113 </span>
<span class="changed"> 114     // After this operation: the chunk should have no free committed space left.</span>
<span class="changed"> 115     assert(c-&gt;free_below_committed_words() == 0,</span>
<span class="changed"> 116            "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",</span>
<span class="changed"> 117            METACHUNK_FULL_FORMAT_ARGS(c));</span>
 118 



 119   }
 120 

 121 }
 122 
<span class="changed"> 123 // Allocate a new chunk from the underlying chunk manager able to hold at least</span>
<span class="changed"> 124 // requested word size.</span>
<span class="changed"> 125 Metachunk* SpaceManager::allocate_new_chunk(size_t requested_word_size) {</span>
<span class="changed"> 126 </span>
<span class="changed"> 127   assert_lock_strong(lock());</span>
 128 
<span class="changed"> 129   // Should this ever happen, we need to increase the maximum possible chunk size.</span>
<span class="changed"> 130   guarantee(requested_word_size &lt;= chunklevel::MAX_CHUNK_WORD_SIZE,</span>
<span class="changed"> 131             "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",</span>
<span class="changed"> 132             requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="changed"> 133 </span>
<span class="changed"> 134   const int growth_step = _chunks.count();</span>
<span class="changed"> 135   const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);</span>
<span class="changed"> 136   const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());</span>
 137 
<span class="changed"> 138   Metachunk* c = _chunk_manager-&gt;get_chunk(preferred_level, max_level, requested_word_size);</span>
<span class="changed"> 139   if (c == NULL) {</span>
<span class="changed"> 140     return NULL;</span>










 141   }
 142 
<span class="changed"> 143   assert(c-&gt;is_in_use(), "Wrong chunk state.");</span>
<span class="changed"> 144   assert(c-&gt;free_below_committed_words() &gt;= requested_word_size, "Chunk not committed");</span>







 145 
<span class="changed"> 146   return c;</span>







 147 













 148 }
 149 
<span class="changed"> 150 void SpaceManager::add_allocation_to_fbl(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 151   assert(Settings::handle_deallocations(), "Sanity");</span>
<span class="changed"> 152   if (_fbl == NULL) {</span>
<span class="changed"> 153     _fbl = new FreeBlocks(); // Create only on demand</span>
<span class="changed"> 154   }</span>
<span class="changed"> 155   _fbl-&gt;add_block(p, word_size);</span>
<span class="changed"> 156 }</span>
<span class="changed"> 157 </span>
<span class="changed"> 158 SpaceManager::SpaceManager(ChunkManager* chunk_manager,</span>
<span class="changed"> 159              const ArenaGrowthPolicy* growth_policy,</span>
<span class="changed"> 160              Mutex* lock,</span>
<span class="changed"> 161              SizeAtomicCounter* total_used_words_counter,</span>
<span class="changed"> 162              const char* name,</span>
<span class="changed"> 163              bool is_micro_loader)</span>
<span class="changed"> 164 : _lock(lock),</span>
<span class="changed"> 165   _chunk_manager(chunk_manager),</span>
<span class="changed"> 166   _growth_policy(growth_policy),</span>
<span class="changed"> 167   _chunks(),</span>
<span class="changed"> 168   _fbl(NULL),</span>
<span class="changed"> 169   _total_used_words_counter(total_used_words_counter),</span>
<span class="changed"> 170   _name(name),</span>
<span class="changed"> 171   _is_micro_loader(is_micro_loader)</span>
<span class="changed"> 172 {</span>
<span class="changed"> 173   UL(debug, ": born.");</span>
 174 }
 175 
<span class="changed"> 176 SpaceManager::~SpaceManager() {</span>


















 177 
<span class="changed"> 178   DEBUG_ONLY(verify(true);)</span>


 179 
<span class="changed"> 180   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);</span>
 181 
<span class="changed"> 182   MemRangeCounter return_counter;</span>















 183 
<span class="changed"> 184   Metachunk* c = _chunks.first();</span>
<span class="changed"> 185   Metachunk* c2 = NULL;</span>
 186 
<span class="changed"> 187   while(c) {</span>
<span class="changed"> 188     c2 = c-&gt;next();</span>
<span class="changed"> 189     return_counter.add(c-&gt;used_words());</span>
<span class="changed"> 190     DEBUG_ONLY(c-&gt;set_prev(NULL);)</span>
<span class="changed"> 191     DEBUG_ONLY(c-&gt;set_next(NULL);)</span>
<span class="changed"> 192     UL2(debug, "return chunk: " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 193     _chunk_manager-&gt;return_chunk(c);</span>
<span class="changed"> 194     // c may be invalid after return_chunk(c) was called. Don't access anymore.</span>
<span class="changed"> 195     c = c2;</span>
<span class="changed"> 196   }</span>
 197 
<span class="changed"> 198   UL2(info, "returned %d chunks, total capacity " SIZE_FORMAT " words.",</span>
<span class="changed"> 199       return_counter.count(), return_counter.total_size());</span>







































 200 
<span class="changed"> 201   _total_used_words_counter-&gt;decrement_by(return_counter.total_size());</span>

 202 
<span class="changed"> 203   DEBUG_ONLY(chunk_manager()-&gt;verify(true);)</span>


 204 
<span class="changed"> 205   delete _fbl;</span>
 206 
<span class="changed"> 207   UL(debug, ": dies.");</span>
 208 



 209 }
 210 
<span class="changed"> 211 // Attempt to enlarge the current chunk to make it large enough to hold at least</span>
<span class="changed"> 212 //  requested_word_size additional words.</span>
<span class="changed"> 213 //</span>
<span class="changed"> 214 // On success, true is returned, false otherwise.</span>
<span class="changed"> 215 bool SpaceManager::attempt_enlarge_current_chunk(size_t requested_word_size) {</span>
 216 
<span class="changed"> 217   Metachunk* c = current_chunk();</span>
<span class="changed"> 218   assert(c-&gt;free_words() &lt; requested_word_size, "Sanity");</span>
 219 
<span class="changed"> 220   // Not if chunk enlargment is switched off...</span>
<span class="changed"> 221   if (Settings::enlarge_chunks_in_place() == false) {</span>
<span class="changed"> 222     return false;</span>
<span class="changed"> 223   }</span>
 224 
<span class="changed"> 225   // ... we also disallow it for very large chunks...</span>
<span class="changed"> 226   if (c-&gt;word_size() &gt; Settings::enlarge_chunks_in_place_max_word_size()) {</span>
<span class="changed"> 227     return false;</span>





 228   }
<span class="new"> 229 </span>
<span class="new"> 230   // ... nor if we are already a root chunk ...</span>
<span class="new"> 231   if (c-&gt;is_root_chunk()) {</span>
<span class="new"> 232     return false;</span>
 233   }
 234 
<span class="changed"> 235   // ... nor if the combined size of chunk content and new content would bring us above the size of a root chunk ...</span>
<span class="changed"> 236   if ((c-&gt;used_words() + requested_word_size) &gt; metaspace::chunklevel::MAX_CHUNK_WORD_SIZE) {</span>
<span class="changed"> 237     return false;</span>
<span class="changed"> 238   }</span>
 239 
<span class="changed"> 240   const chunklevel_t new_level =</span>
<span class="changed"> 241       chunklevel::level_fitting_word_size(c-&gt;used_words() + requested_word_size);</span>
<span class="changed"> 242   assert(new_level &lt; c-&gt;level(), "Sanity");</span>




 243 
<span class="changed"> 244   // Atm we only enlarge by one level (so, doubling the chunk in size). So, if the requested enlargement</span>
<span class="changed"> 245   // would require the chunk to more than double in size, we bail. But this covers about 99% of all cases,</span>
<span class="changed"> 246   // so this is good enough.</span>
<span class="changed"> 247   if (new_level &lt; c-&gt;level() - 1) {</span>
<span class="changed"> 248     return false;</span>
<span class="changed"> 249   }</span>
 250 
<span class="changed"> 251   // This only works if chunk is the leader of its buddy pair (and also if buddy</span>
<span class="changed"> 252   // is free and unsplit, but that we cannot check outside of metaspace lock).</span>
<span class="changed"> 253   if (!c-&gt;is_leader()) {</span>
<span class="changed"> 254     return false;</span>
 255   }

 256 
<span class="changed"> 257   // If the size added to the chunk would be larger than allowed for the next growth step</span>
<span class="changed"> 258   // dont enlarge.</span>
<span class="changed"> 259   if (next_chunk_level() &gt; c-&gt;level()) {</span>
<span class="changed"> 260     return false;</span>



 261   }



 262 
<span class="changed"> 263   bool success = _chunk_manager-&gt;attempt_enlarge_chunk(c);</span>

 264 
<span class="changed"> 265   assert(success == false || c-&gt;free_words() &gt;= requested_word_size, "Sanity");</span>


 266 
<span class="changed"> 267   return success;</span>
 268 
<span class="changed"> 269 }</span>


 270 
<span class="changed"> 271 // Allocate memory from Metaspace.</span>
<span class="changed"> 272 // 1) Attempt to allocate from the free block list.</span>
<span class="changed"> 273 // 2) Attempt to allocate from the current chunk.</span>
<span class="changed"> 274 // 3) Attempt to enlarge the current chunk in place if it is too small.</span>
<span class="changed"> 275 // 4) Attempt to get a new chunk and allocate from that chunk.</span>
<span class="changed"> 276 // At any point, if we hit a commit limit, we return NULL.</span>
<span class="changed"> 277 MetaWord* SpaceManager::allocate(size_t requested_word_size) {</span>
 278 
<span class="changed"> 279   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 280 </span>
<span class="changed"> 281   UL2(trace, "requested " SIZE_FORMAT " words.", requested_word_size);</span>
 282 
<span class="changed"> 283   MetaWord* p = NULL;</span>

 284 
<span class="changed"> 285   const size_t raw_word_size = get_raw_allocation_word_size(requested_word_size);</span>
<span class="changed"> 286 </span>
<span class="changed"> 287   // 1) Attempt to allocate from the free blocks list</span>
<span class="changed"> 288   if (Settings::handle_deallocations() &amp;&amp; _fbl != NULL &amp;&amp; !_fbl-&gt;is_empty()) {</span>
<span class="changed"> 289     p = _fbl-&gt;get_block(raw_word_size);</span>
<span class="changed"> 290     if (p != NULL) {</span>
<span class="changed"> 291       DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)</span>
<span class="changed"> 292       UL2(trace, "taken from fbl (now: %d, " SIZE_FORMAT ").",</span>
<span class="changed"> 293           _fbl-&gt;count(), _fbl-&gt;total_size());</span>
<span class="changed"> 294       // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -</span>
<span class="changed"> 295       // that means that we do not modify any counters and therefore can skip the epilog.</span>
<span class="changed"> 296       return p;</span>
<span class="changed"> 297     }</span>
 298   }

 299 
<span class="changed"> 300   bool current_chunk_too_small = false;</span>
<span class="changed"> 301   bool commit_failure = false;</span>
<span class="changed"> 302 </span>
 303   if (current_chunk() != NULL) {
<span class="changed"> 304 </span>
<span class="changed"> 305     // 2) Attempt to satisfy the allocation from the current chunk.</span>
<span class="changed"> 306 </span>
<span class="changed"> 307     // If the current chunk is too small to hold the requested size, attempt to enlarge it.</span>
<span class="changed"> 308     // If that fails, retire the chunk.</span>
<span class="changed"> 309     if (current_chunk()-&gt;free_words() &lt; raw_word_size) {</span>
<span class="changed"> 310       if (!attempt_enlarge_current_chunk(raw_word_size)) {</span>
<span class="changed"> 311         current_chunk_too_small = true;</span>
<span class="changed"> 312       } else {</span>
<span class="changed"> 313         DEBUG_ONLY(InternalStats::inc_num_chunks_enlarged();)</span>
<span class="changed"> 314         UL(debug, "enlarged chunk.");</span>
 315       }
 316     }

 317 
<span class="changed"> 318     // Commit the chunk far enough to hold the requested word size. If that fails, we</span>
<span class="changed"> 319     // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the</span>
<span class="changed"> 320     // chunk.</span>
<span class="changed"> 321     if (!current_chunk_too_small) {</span>
<span class="changed"> 322       if (!current_chunk()-&gt;ensure_committed_additional(raw_word_size)) {</span>
<span class="changed"> 323         UL2(info, "commit failure (requested size: " SIZE_FORMAT ")", raw_word_size);</span>
<span class="changed"> 324         commit_failure = true;</span>
<span class="changed"> 325       }</span>
<span class="changed"> 326     }</span>
 327 
<span class="changed"> 328     // Allocate from the current chunk. This should work now.</span>
<span class="changed"> 329     if (!current_chunk_too_small &amp;&amp; !commit_failure) {</span>
<span class="changed"> 330       p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="changed"> 331       assert(p != NULL, "Allocation from chunk failed.");</span>
 332     }
 333 




 334   }
 335 
<span class="changed"> 336   if (p == NULL) {</span>

 337 
<span class="changed"> 338     // If we are here, we either had no current chunk to begin with or it was deemed insufficient.</span>
<span class="changed"> 339     assert(current_chunk() == NULL ||</span>
<span class="changed"> 340            current_chunk_too_small || commit_failure, "Sanity");</span>


 341 
<span class="changed"> 342     Metachunk* new_chunk = allocate_new_chunk(raw_word_size);</span>
<span class="changed"> 343 </span>
<span class="changed"> 344     if (new_chunk != NULL) {</span>
<span class="changed"> 345 </span>
<span class="changed"> 346       UL2(debug, "allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",</span>
<span class="changed"> 347           METACHUNK_FORMAT_ARGS(new_chunk), requested_word_size);</span>
<span class="changed"> 348 </span>
<span class="changed"> 349       assert(new_chunk-&gt;free_below_committed_words() &gt;= raw_word_size, "Sanity");</span>
<span class="changed"> 350 </span>
<span class="changed"> 351       // We have a new chunk. Before making it the current chunk, retire the old one.</span>
<span class="changed"> 352       if (current_chunk() != NULL) {</span>
<span class="changed"> 353         salvage_chunk(current_chunk());</span>
<span class="changed"> 354         DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)</span>
 355       }
 356 
<span class="changed"> 357       _chunks.add(new_chunk);</span>




 358 
<span class="changed"> 359       // Now, allocate from that chunk. That should work.</span>
<span class="changed"> 360       p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="changed"> 361       assert(p != NULL, "Allocation from chunk failed.");</span>
<span class="changed"> 362 </span>
<span class="changed"> 363     } else {</span>
<span class="changed"> 364       UL2(info, "failed to allocate new chunk for requested word size " SIZE_FORMAT ".", requested_word_size);</span>
<span class="changed"> 365     }</span>
<span class="changed"> 366 </span>
<span class="changed"> 367   }</span>
 368 




 369 #ifdef ASSERT
<span class="changed"> 370   // When using allocation guards, establish a prefix.</span>
<span class="changed"> 371   if (p != NULL &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="changed"> 372     p = establish_prefix(p, raw_word_size);</span>
 373   }
 374 #endif


 375 
<span class="changed"> 376   if (p == NULL) {</span>
<span class="changed"> 377     DEBUG_ONLY(InternalStats::inc_num_allocs_failed_limit();)</span>
<span class="changed"> 378   } else {</span>
<span class="changed"> 379     DEBUG_ONLY(InternalStats::inc_num_allocs();)</span>
<span class="changed"> 380     _total_used_words_counter-&gt;increment_by(raw_word_size);</span>
 381   }
 382 
<span class="changed"> 383   SOMETIMES(verify_locked(true);)</span>


 384 
<span class="changed"> 385   if (p == NULL) {</span>
<span class="changed"> 386     UL(info, "allocation failed, returned NULL.");</span>
<span class="changed"> 387   } else {</span>
<span class="changed"> 388     UL2(trace, "returned " PTR_FORMAT ".", p2i(p));</span>
 389   }
 390 
<span class="changed"> 391   return p;</span>
<span class="changed"> 392 </span>
 393 }
 394 
<span class="changed"> 395 // Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="changed"> 396 // because it is not needed anymore (requires CLD lock to be active).</span>
<span class="changed"> 397 void SpaceManager::deallocate_locked(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 398 </span>
<span class="changed"> 399   if (Settings::handle_deallocations() == false) {</span>
<span class="changed"> 400     return;</span>
 401   }
<span class="new"> 402 </span>
<span class="new"> 403   assert_lock_strong(lock());</span>
<span class="new"> 404 </span>
<span class="new"> 405   // At this point a current chunk must exist since we only deallocate if we did allocate before.</span>
<span class="new"> 406   assert(current_chunk() != NULL, "stray deallocation?");</span>
<span class="new"> 407 </span>
<span class="new"> 408   assert(is_valid_area(p, word_size),</span>
<span class="new"> 409          "Pointer range not part of this SpaceManager and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",</span>
<span class="new"> 410          p2i(p), p2i(p + word_size));</span>
<span class="new"> 411 </span>
<span class="new"> 412   UL2(trace, "deallocating " PTR_FORMAT ", word size: " SIZE_FORMAT ".",</span>
<span class="new"> 413       p2i(p), word_size);</span>
<span class="new"> 414 </span>
<span class="new"> 415   size_t raw_word_size = get_raw_allocation_word_size(word_size);</span>
<span class="new"> 416   add_allocation_to_fbl(p, raw_word_size);</span>
<span class="new"> 417 </span>
<span class="new"> 418   DEBUG_ONLY(verify_locked(false);)</span>
<span class="new"> 419 </span>
 420 }
 421 
<span class="changed"> 422 // Prematurely returns a metaspace allocation to the _block_freelists because it is not</span>
<span class="changed"> 423 // needed anymore.</span>
<span class="changed"> 424 void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 425   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 426   deallocate_locked(p, word_size);</span>


 427 }
 428 
<span class="changed"> 429 // Update statistics. This walks all in-use chunks.</span>
<span class="changed"> 430 void SpaceManager::add_to_statistics(sm_stats_t* out) const {</span>
<span class="changed"> 431 </span>
<span class="changed"> 432   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 433 </span>
<span class="changed"> 434   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 435     in_use_chunk_stats_t&amp; ucs = out-&gt;stats[c-&gt;level()];</span>
<span class="changed"> 436     ucs.num ++;</span>
<span class="changed"> 437     ucs.word_size += c-&gt;word_size();</span>
<span class="changed"> 438     ucs.committed_words += c-&gt;committed_words();</span>
<span class="changed"> 439     ucs.used_words += c-&gt;used_words();</span>
<span class="changed"> 440     // Note: for free and waste, we only count what's committed.</span>
<span class="changed"> 441     if (c == current_chunk()) {</span>
<span class="changed"> 442       ucs.free_words += c-&gt;free_below_committed_words();</span>
 443     } else {
<span class="changed"> 444       ucs.waste_words += c-&gt;free_below_committed_words();</span>
 445     }

 446   }
<span class="changed"> 447 </span>
<span class="changed"> 448   if (_fbl != NULL) {</span>
<span class="changed"> 449     out-&gt;free_blocks_num += _fbl-&gt;count();</span>
<span class="changed"> 450     out-&gt;free_blocks_word_size += _fbl-&gt;total_size();</span>
 451   }
<span class="new"> 452 </span>
<span class="new"> 453   SOMETIMES(out-&gt;verify();)</span>
<span class="new"> 454 </span>
 455 }
 456 
<span class="changed"> 457 // Convenience method to get the most important usage statistics.</span>
<span class="changed"> 458 // For deeper analysis use add_to_statistics().</span>
<span class="changed"> 459 void SpaceManager::usage_numbers(size_t* p_used_words, size_t* p_committed_words, size_t* p_capacity_words) const {</span>
 460   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<span class="changed"> 461   size_t used = 0, comm = 0, cap = 0;</span>
<span class="changed"> 462   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 463     used += c-&gt;used_words();</span>
<span class="changed"> 464     comm += c-&gt;committed_words();</span>
<span class="changed"> 465     cap += c-&gt;word_size();</span>
<span class="changed"> 466   }</span>
<span class="changed"> 467   if (p_used_words != NULL) {</span>
<span class="changed"> 468     *p_used_words = used;</span>
<span class="changed"> 469   }</span>
<span class="changed"> 470   if (p_committed_words != NULL) {</span>
<span class="changed"> 471     *p_committed_words = comm;</span>
<span class="changed"> 472   }</span>
<span class="changed"> 473   if (p_capacity_words != NULL) {</span>
<span class="changed"> 474     *p_capacity_words = cap;</span>
<span class="changed"> 475   }</span>
 476 }
 477 
<span class="new"> 478 </span>
 479 #ifdef ASSERT
<span class="changed"> 480 </span>
<span class="changed"> 481 void SpaceManager::verify_locked(bool slow) const {</span>
<span class="changed"> 482 </span>
 483   assert_lock_strong(lock());
 484 
<span class="changed"> 485   assert(_growth_policy != NULL &amp;&amp; _chunk_manager != NULL, "Sanity");</span>

 486 
<span class="changed"> 487   _chunks.verify();</span>
 488 
<span class="changed"> 489   if (_fbl != NULL) {</span>
<span class="changed"> 490     _fbl-&gt;verify();</span>
<span class="changed"> 491   }</span>
<span class="changed"> 492 </span>
<span class="changed"> 493   // In slow mode, verify guard zones of all allocations</span>
<span class="changed"> 494   if (slow &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="changed"> 495     for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 496       const MetaWord* p = c-&gt;base();</span>
<span class="changed"> 497       while (p &lt; c-&gt;top()) {</span>
<span class="changed"> 498         const prefix_t* pp = (const prefix_t*)p;</span>
<span class="changed"> 499         check_prefix(pp);</span>
<span class="changed"> 500         p += pp-&gt;word_size;</span>
<span class="changed"> 501       }</span>
<span class="changed"> 502     }</span>
<span class="changed"> 503   }</span>
 504 



 505 }
 506 
<span class="changed"> 507 void SpaceManager::verify(bool slow) const {</span>
<span class="changed"> 508 </span>
 509   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<span class="changed"> 510   verify_locked(slow);</span>
<span class="changed"> 511 </span>
<span class="changed"> 512 }</span>
<span class="changed"> 513 </span>
<span class="changed"> 514 // Returns true if the area indicated by pointer and size have actually been allocated</span>
<span class="changed"> 515 // from this space manager.</span>
<span class="changed"> 516 bool SpaceManager::is_valid_area(MetaWord* p, size_t word_size) const {</span>
<span class="changed"> 517   assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");</span>
<span class="changed"> 518   bool found = false;</span>
<span class="changed"> 519   if (!found) {</span>
<span class="changed"> 520     for (const Metachunk* c = _chunks.first(); c != NULL &amp;&amp; !found; c = c-&gt;next()) {</span>
<span class="changed"> 521       assert(c-&gt;is_valid_committed_pointer(p) ==</span>
<span class="changed"> 522              c-&gt;is_valid_committed_pointer(p + word_size - 1), "range intersects");</span>
<span class="changed"> 523       found = c-&gt;is_valid_committed_pointer(p);</span>
<span class="changed"> 524     }</span>
<span class="changed"> 525   }</span>
<span class="changed"> 526   return found;</span>
 527 }
<span class="new"> 528 </span>
 529 #endif // ASSERT
<span class="new"> 530 </span>
<span class="new"> 531 void SpaceManager::print_on(outputStream* st) const {</span>
<span class="new"> 532   MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new"> 533   print_on_locked(st);</span>
<span class="new"> 534 }</span>
<span class="new"> 535 </span>
<span class="new"> 536 void SpaceManager::print_on_locked(outputStream* st) const {</span>
<span class="new"> 537   assert_lock_strong(_lock);</span>
<span class="new"> 538   st-&gt;print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="new"> 539                _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());</span>
<span class="new"> 540   _chunks.print_on(st);</span>
<span class="new"> 541   st-&gt;cr();</span>
<span class="new"> 542   st-&gt;print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,</span>
<span class="new"> 543                 _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));</span>
<span class="new"> 544 }</span>
<span class="new"> 545 </span>
 546 
 547 
 548 } // namespace metaspace
 549 
</pre></td>
</tr></table>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
