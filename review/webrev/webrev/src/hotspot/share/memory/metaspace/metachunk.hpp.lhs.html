<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  25 #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  26 
<a name="2" id="anc2"></a><span class="changed">  27 #include "memory/metaspace/metabase.hpp"</span>
<span class="changed">  28 #include "memory/metaspace/metaspaceCommon.hpp"</span>

  29 #include "utilities/debug.hpp"
  30 #include "utilities/globalDefinitions.hpp"
  31 
<a name="3" id="anc3"></a><span class="changed">  32 class MetachunkTest;</span>

  33 
  34 namespace metaspace {
  35 
  36 class VirtualSpaceNode;
  37 
<a name="4" id="anc4"></a>

  38 //  Metachunk - Quantum of allocation from a Virtualspace
  39 //    Metachunks are reused (when freed are put on a global freelist) and
  40 //    have no permanent association to a SpaceManager.
  41 
<a name="5" id="anc5"></a><span class="changed">  42 //            +--------------+ &lt;- end    --+       --+</span>
  43 //            |              |             |         |
  44 //            |              |             | free    |
<a name="6" id="anc6"></a>

  45 //            |              |             |         |
<a name="7" id="anc7"></a><span class="changed">  46 //            |              |             |         | size | capacity</span>
<span class="changed">  47 //            |              |             |         |</span>
<span class="changed">  48 //            |              | &lt;- top   -- +         |</span>
  49 //            |              |             |         |
  50 //            |              |             | used    |
<a name="8" id="anc8"></a><span class="changed">  51 //            |              |             |         |</span>
<span class="changed">  52 //            |              |             |         |</span>
<span class="changed">  53 //            +--------------+ &lt;- bottom --+       --+</span>
<span class="changed">  54 </span>
<span class="changed">  55 enum ChunkOrigin {</span>
<span class="changed">  56   // Chunk normally born (via take_from_committed)</span>
<span class="changed">  57   origin_normal = 1,</span>
<span class="changed">  58   // Chunk was born as padding chunk</span>
<span class="changed">  59   origin_pad = 2,</span>
<span class="changed">  60   // Chunk was born as leftover chunk in VirtualSpaceNode::retire</span>
<span class="changed">  61   origin_leftover = 3,</span>
<span class="changed">  62   // Chunk was born as result of a merge of smaller chunks</span>
<span class="changed">  63   origin_merge = 4,</span>
<span class="changed">  64   // Chunk was born as result of a split of a larger chunk</span>
<span class="changed">  65   origin_split = 5,</span>
<span class="changed">  66 </span>
<span class="changed">  67   origin_minimum = origin_normal,</span>
<span class="changed">  68   origin_maximum = origin_split,</span>
<span class="changed">  69   origins_count = origin_maximum + 1</span>
<span class="changed">  70 };</span>
  71 
<a name="9" id="anc9"></a><span class="changed">  72 inline bool is_valid_chunkorigin(ChunkOrigin origin) {</span>
<span class="changed">  73   return origin == origin_normal ||</span>
<span class="changed">  74     origin == origin_pad ||</span>
<span class="changed">  75     origin == origin_leftover ||</span>
<span class="changed">  76     origin == origin_merge ||</span>
<span class="changed">  77     origin == origin_split;</span>
<span class="changed">  78 }</span>
<span class="changed">  79 </span>
<span class="changed">  80 class Metachunk : public Metabase&lt;Metachunk&gt; {</span>
<span class="changed">  81 </span>
<span class="changed">  82   friend class ::MetachunkTest;</span>
<span class="changed">  83 </span>
<span class="changed">  84   // The VirtualSpaceNode containing this chunk.</span>
<span class="changed">  85   VirtualSpaceNode* const _container;</span>
<span class="changed">  86 </span>
<span class="changed">  87   // Current allocation top.</span>
<span class="changed">  88   MetaWord* _top;</span>
<span class="changed">  89 </span>
<span class="changed">  90   // A 32bit sentinel for debugging purposes.</span>
<span class="changed">  91   enum { CHUNK_SENTINEL = 0x4d4554EF,  // "MET"</span>
<span class="changed">  92          CHUNK_SENTINEL_INVALID = 0xFEEEEEEF</span>






  93   };
<a name="10" id="anc10"></a>
  94 
<a name="11" id="anc11"></a><span class="changed">  95   uint32_t _sentinel;</span>
<span class="changed">  96 </span>
<span class="changed">  97   const ChunkIndex _chunk_type;</span>
<span class="changed">  98   const bool _is_class;</span>
<span class="changed">  99   // Whether the chunk is free (in freelist) or in use by some class loader.</span>
<span class="changed"> 100   bool _is_tagged_free;</span>
<span class="changed"> 101 </span>
<span class="changed"> 102   ChunkOrigin _origin;</span>
<span class="changed"> 103   int _use_count;</span>
<span class="changed"> 104 </span>
<span class="changed"> 105   MetaWord* initial_top() const { return (MetaWord*)this + overhead(); }</span>
<span class="changed"> 106   MetaWord* top() const         { return _top; }</span>
<span class="changed"> 107 </span>
<span class="changed"> 108  public:</span>
<span class="changed"> 109   // Metachunks are allocated out of a MetadataVirtualSpace and</span>
<span class="changed"> 110   // and use some of its space to describe itself (plus alignment</span>
<span class="changed"> 111   // considerations).  Metadata is allocated in the rest of the chunk.</span>
<span class="changed"> 112   // This size is the overhead of maintaining the Metachunk within</span>
<span class="changed"> 113   // the space.</span>
<span class="changed"> 114 </span>
<span class="changed"> 115   // Alignment of each allocation in the chunks.</span>
<span class="changed"> 116   static size_t object_alignment();</span>
<span class="changed"> 117 </span>
<span class="changed"> 118   // Size of the Metachunk header, in words, including alignment.</span>
<span class="changed"> 119   static size_t overhead();</span>















































































































































 120 
<a name="12" id="anc12"></a><span class="changed"> 121   Metachunk(ChunkIndex chunktype, bool is_class, size_t word_size, VirtualSpaceNode* container);</span>
<span class="changed"> 122 </span>
<span class="changed"> 123   MetaWord* allocate(size_t word_size);</span>
<span class="changed"> 124 </span>
<span class="changed"> 125   VirtualSpaceNode* container() const { return _container; }</span>
<span class="changed"> 126 </span>
<span class="changed"> 127   MetaWord* bottom() const { return (MetaWord*) this; }</span>
<span class="changed"> 128 </span>
<span class="changed"> 129   // Reset top to bottom so chunk can be reused.</span>
<span class="changed"> 130   void reset_empty() { _top = initial_top(); clear_next(); clear_prev(); }</span>
<span class="changed"> 131   bool is_empty() { return _top == initial_top(); }</span>
<span class="changed"> 132 </span>
<span class="changed"> 133   // used (has been allocated)</span>
<span class="changed"> 134   // free (available for future allocations)</span>
<span class="changed"> 135   size_t word_size() const { return size(); }</span>
<span class="changed"> 136   size_t used_word_size() const;</span>
<span class="changed"> 137   size_t free_word_size() const;</span>
<span class="changed"> 138 </span>
<span class="changed"> 139   bool is_tagged_free() { return _is_tagged_free; }</span>
<span class="changed"> 140   void set_is_tagged_free(bool v) { _is_tagged_free = v; }</span>
<span class="changed"> 141 </span>
<span class="changed"> 142   bool contains(const void* ptr) { return bottom() &lt;= ptr &amp;&amp; ptr &lt; _top; }</span>
 143 
 144   void print_on(outputStream* st) const;
 145 
<a name="13" id="anc13"></a><span class="removed"> 146   bool is_valid_sentinel() const        { return _sentinel == CHUNK_SENTINEL; }</span>
<span class="removed"> 147   void remove_sentinel()                { _sentinel = CHUNK_SENTINEL_INVALID; }</span>
<span class="removed"> 148 </span>
<span class="removed"> 149   int get_use_count() const             { return _use_count; }</span>
<span class="removed"> 150   void inc_use_count()                  { _use_count ++; }</span>
<span class="removed"> 151 </span>
<span class="removed"> 152   ChunkOrigin get_origin() const        { return _origin; }</span>
<span class="removed"> 153   void set_origin(ChunkOrigin orig)     { _origin = orig; }</span>
<span class="removed"> 154 </span>
<span class="removed"> 155   ChunkIndex get_chunk_type() const     { return _chunk_type; }</span>
<span class="removed"> 156   bool is_class() const                 { return _is_class; }</span>
<span class="removed"> 157 </span>
<span class="removed"> 158   DEBUG_ONLY(void mangle(juint word_value);)</span>
<span class="removed"> 159   DEBUG_ONLY(void verify() const;)</span>
<span class="removed"> 160 </span>
 161 };
 162 
<a name="14" id="anc14"></a>


 163 
<a name="15" id="anc15"></a><span class="changed"> 164 // Helper function that does a bunch of checks for a chunk.</span>
<span class="changed"> 165 DEBUG_ONLY(void do_verify_chunk(Metachunk* chunk);)</span>
<span class="changed"> 166 </span>
<span class="changed"> 167 // Given a Metachunk, update its in-use information (both in the</span>
<span class="changed"> 168 // chunk and the occupancy map).</span>
<span class="changed"> 169 void do_update_in_use_info_for_chunk(Metachunk* chunk, bool inuse);</span>
 170 
 171 } // namespace metaspace
 172 
 173 #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="16" type="hidden" /></form></body></html>
