<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/arenaGrowthPolicy.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 #include "precompiled.hpp"
   2 
   3 #include "memory/metaspace/arenaGrowthPolicy.hpp"
   4 #include "memory/metaspace/chunkLevel.hpp"
   5 #include "utilities/globalDefinitions.hpp"
   6 
   7 namespace metaspace {
   8 
   9 // Todo: simplify?
  10 // This used to contain more logic in the first prototypes, but now it is basically
  11 // a set of hard-wired integer arrays. We may do away with the implementation hiding.
  12 
  13 // A chunk allocation sequence which can be encoded with a simple const array.
  14 class ConstantArenaGrowthPolicy : public ArenaGrowthPolicy {
  15 
  16   // integer array specifying chunk level allocation progression.
  17   // Last chunk is to be an endlessly repeated allocation.
  18   const chunklevel_t* const _entries;
  19   const int _num_entries;
  20 
  21 public:
  22 
  23   ConstantArenaGrowthPolicy(const chunklevel_t* array, int num_entries)
  24     : _entries(array)
  25     , _num_entries(num_entries)
  26   {
  27     assert(_num_entries &gt; 0, "must not be empty.");
  28   }
  29 
  30   chunklevel_t get_level_at_step(int num_allocated) const {
  31     if (num_allocated &gt;= _num_entries) {
  32       // Caller shall repeat last allocation
  33       return _entries[_num_entries - 1];
  34     }
  35     return _entries[num_allocated];
  36   }
  37 
  38 };
  39 
  40 // hard-coded chunk allocation sequences for various space types
  41 // (Note: no sudden jumps please)
  42 
  43 static const chunklevel_t g_sequ_standard_non_class[] = {
  44     chunklevel::CHUNK_LEVEL_4K,
  45     chunklevel::CHUNK_LEVEL_4K,
  46     chunklevel::CHUNK_LEVEL_4K,
  47     chunklevel::CHUNK_LEVEL_8K,
  48     chunklevel::CHUNK_LEVEL_16K
  49     // .. repeat last
  50 };
  51 
  52 static const chunklevel_t g_sequ_standard_class[] = {
  53     chunklevel::CHUNK_LEVEL_2K,
  54     chunklevel::CHUNK_LEVEL_2K,
  55     chunklevel::CHUNK_LEVEL_4K,
  56     chunklevel::CHUNK_LEVEL_8K,
  57     chunklevel::CHUNK_LEVEL_16K
  58     // .. repeat last
  59 };
  60 
  61 static const chunklevel_t g_sequ_anon_non_class[] = {
  62    chunklevel::CHUNK_LEVEL_1K,
  63    // .. repeat last
  64 };
  65 
  66 static const chunklevel_t g_sequ_anon_class[] = {
  67     chunklevel::CHUNK_LEVEL_1K,
  68     // .. repeat last
  69 };
  70 
  71 static const chunklevel_t g_sequ_refl_non_class[] = {
  72     chunklevel::CHUNK_LEVEL_2K,
  73     chunklevel::CHUNK_LEVEL_1K
  74     // .. repeat last
  75 };
  76 
  77 static const chunklevel_t g_sequ_refl_class[] = {
  78     chunklevel::CHUNK_LEVEL_1K,
  79     // .. repeat last
  80 };
  81 
  82 // Boot class loader: give it large chunks: beyond commit granule size
  83 // (typically 64K) the costs for large chunks largely diminishes since
  84 // they are committed on the fly.
  85 static const chunklevel_t g_sequ_boot_non_class[] = {
  86     chunklevel::CHUNK_LEVEL_4M,
  87     chunklevel::CHUNK_LEVEL_1M
  88     // .. repeat last
  89 };
  90 
  91 static const chunklevel_t g_sequ_boot_class[] = {
  92     chunklevel::CHUNK_LEVEL_1M,
  93     chunklevel::CHUNK_LEVEL_256K
  94     // .. repeat last
  95 };
  96 
  97 #define DEFINE_CLASS_FOR_ARRAY(what) \
  98   static ConstantArenaGrowthPolicy g_chunk_alloc_sequence_##what (g_sequ_##what, sizeof(g_sequ_##what)/sizeof(chunklevel_t));
  99 
 100 DEFINE_CLASS_FOR_ARRAY(standard_non_class)
 101 DEFINE_CLASS_FOR_ARRAY(standard_class)
 102 DEFINE_CLASS_FOR_ARRAY(anon_non_class)
 103 DEFINE_CLASS_FOR_ARRAY(anon_class)
 104 DEFINE_CLASS_FOR_ARRAY(refl_non_class)
 105 DEFINE_CLASS_FOR_ARRAY(refl_class)
 106 DEFINE_CLASS_FOR_ARRAY(boot_non_class)
 107 DEFINE_CLASS_FOR_ARRAY(boot_class)
 108 
 109 const ArenaGrowthPolicy* ArenaGrowthPolicy::policy_for_space_type(MetaspaceType space_type, bool is_class) {
 110 
 111   if (is_class) {
 112     switch(space_type) {
 113     case StandardMetaspaceType:          return &amp;g_chunk_alloc_sequence_standard_class;
 114     case ReflectionMetaspaceType:        return &amp;g_chunk_alloc_sequence_refl_class;
 115     case ClassMirrorHolderMetaspaceType: return &amp;g_chunk_alloc_sequence_anon_class;
 116     case BootMetaspaceType:              return &amp;g_chunk_alloc_sequence_boot_class;
 117     default: ShouldNotReachHere();
 118     }
 119   } else {
 120     switch(space_type) {
 121     case StandardMetaspaceType:          return &amp;g_chunk_alloc_sequence_standard_non_class;
 122     case ReflectionMetaspaceType:        return &amp;g_chunk_alloc_sequence_refl_non_class;
 123     case ClassMirrorHolderMetaspaceType: return &amp;g_chunk_alloc_sequence_anon_non_class;
 124     case BootMetaspaceType:              return &amp;g_chunk_alloc_sequence_boot_non_class;
 125     default: ShouldNotReachHere();
 126     }
 127   }
 128 
 129   return NULL;
 130 
 131 }
 132 
 133 } // namespace
 134 
</pre></body></html>
