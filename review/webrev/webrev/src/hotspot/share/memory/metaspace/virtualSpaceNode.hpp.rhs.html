<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="new">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  27 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  28 
<a name="2" id="anc2"></a><span class="changed">  29 </span>
<span class="changed">  30 #include "memory/allocation.hpp"</span>
<span class="changed">  31 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/commitMask.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/rootChunkArea.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/settings.hpp"</span>
  35 #include "memory/memRegion.hpp"
<a name="3" id="anc3"></a><span class="new">  36 #include "memory/virtualspace.hpp"</span>
  37 #include "utilities/debug.hpp"
<a name="4" id="anc4"></a><span class="new">  38 #include "utilities/bitMap.hpp"</span>
  39 #include "utilities/globalDefinitions.hpp"
  40 
<a name="5" id="anc5"></a><span class="new">  41 </span>
  42 class outputStream;
  43 
  44 namespace metaspace {
  45 
<a name="6" id="anc6"></a><span class="changed">  46 class CommitLimiter;</span>
<span class="changed">  47 class FreeChunkListVector;</span>

  48 
<a name="7" id="anc7"></a><span class="changed">  49 // VirtualSpaceNode manages a single address range of the Metaspace.</span>
<span class="changed">  50 //</span>
<span class="changed">  51 // That address range may contain interleaved committed and uncommitted</span>
<span class="changed">  52 // regions. It keeps track of which regions have committed and offers</span>
<span class="changed">  53 // functions to commit and uncommit regions.</span>
<span class="changed">  54 //</span>
<span class="changed">  55 // It allocates and hands out memory ranges, starting at the bottom.</span>
<span class="changed">  56 //</span>
<span class="changed">  57 // Address range must be aligned to root chunk size.</span>
<span class="changed">  58 //</span>
  59 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
<a name="8" id="anc8"></a>
  60 
  61   // Link to next VirtualSpaceNode
  62   VirtualSpaceNode* _next;
  63 
<a name="9" id="anc9"></a>



  64   ReservedSpace _rs;
<a name="10" id="anc10"></a>












































  65 
<a name="11" id="anc11"></a><span class="changed">  66   // Start pointer of the area.</span>
<span class="changed">  67   MetaWord* const _base;</span>
  68 
<a name="12" id="anc12"></a><span class="changed">  69   // Size, in words, of the whole node</span>
<span class="changed">  70   const size_t _word_size;</span>


  71 
<a name="13" id="anc13"></a><span class="changed">  72   // Size, in words, of the range of this node which has been handed out in</span>
<span class="changed">  73   // the form of chunks.</span>
<span class="changed">  74   size_t _used_words;</span>
<span class="changed">  75 </span>
<span class="changed">  76   // The bitmap describing the commit state of the region:</span>
<span class="changed">  77   // Each bit covers a region of 64K (see constants::commit_granule_size).</span>
<span class="changed">  78   CommitMask _commit_mask;</span>
<span class="changed">  79 </span>
<span class="changed">  80   // An array/LUT of RootChunkArea objects. Each one describes</span>
<span class="changed">  81   // fragmentation inside a root chunk.</span>
<span class="changed">  82   RootChunkAreaLUT _root_chunk_area_lut;</span>
<span class="changed">  83 </span>
<span class="changed">  84   // Limiter object to ask before expanding the committed size of this node.</span>
<span class="changed">  85   CommitLimiter* const _commit_limiter;</span>
<span class="changed">  86 </span>
<span class="changed">  87   // Points to outside size counters which we are to increase/decrease when we commit/uncommit</span>
<span class="changed">  88   // space from this node.</span>
<span class="changed">  89   SizeCounter* const _total_reserved_words_counter;</span>
<span class="changed">  90   SizeCounter* const _total_committed_words_counter;</span>
<span class="changed">  91 </span>
<span class="changed">  92   // For debug and tracing purposes</span>
<span class="changed">  93   const int _node_id;</span>
<span class="changed">  94 </span>
<span class="changed">  95   /// committing, uncommitting ///</span>
<span class="changed">  96 </span>
<span class="changed">  97   // Given a pointer into this node, calculate the start of the commit granule</span>
<span class="changed">  98   // the pointer points into.</span>
<span class="changed">  99   MetaWord* calc_start_of_granule(MetaWord* p) const {</span>
<span class="changed"> 100     DEBUG_ONLY(check_pointer(p));</span>
<span class="changed"> 101     return align_down(p, Settings::commit_granule_bytes());</span>
<span class="changed"> 102   }</span>
<span class="changed"> 103 </span>
<span class="changed"> 104   // Given an address range, ensure it is committed.</span>
<span class="changed"> 105   //</span>
<span class="changed"> 106   // The range has to be aligned to granule size.</span>
<span class="changed"> 107   //</span>
<span class="changed"> 108   // Function will:</span>
<span class="changed"> 109   // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="changed"> 110   //    returns true immediately.</span>
<span class="changed"> 111   // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="changed"> 112   //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="changed"> 113   // - commit the memory.</span>
<span class="changed"> 114   // - mark the range as committed in the commit mask</span>
<span class="changed"> 115   //</span>
<span class="changed"> 116   // Returns true if success, false if it did hit a commit limit.</span>
<span class="changed"> 117   bool commit_range(MetaWord* p, size_t word_size);</span>
<span class="changed"> 118 </span>
<span class="changed"> 119   //// creation ////</span>
<span class="changed"> 120 </span>
<span class="changed"> 121   // Create a new empty node spanning the given reserved space.</span>
<span class="changed"> 122   VirtualSpaceNode(int node_id,</span>
<span class="changed"> 123                    ReservedSpace rs,</span>
<span class="changed"> 124                    CommitLimiter* limiter,</span>
<span class="changed"> 125                    SizeCounter* reserve_counter,</span>
<span class="changed"> 126                    SizeCounter* commit_counter);</span>
<span class="changed"> 127 </span>
<span class="changed"> 128 public:</span>
<span class="changed"> 129 </span>
<span class="changed"> 130   // Create a node of a given size</span>
<span class="changed"> 131   static VirtualSpaceNode* create_node(int node_id,</span>
<span class="changed"> 132                                        size_t word_size,</span>
<span class="changed"> 133                                        CommitLimiter* limiter,</span>
<span class="changed"> 134                                        SizeCounter* reserve_words_counter,</span>
<span class="changed"> 135                                        SizeCounter* commit_words_counter);</span>
<span class="changed"> 136 </span>
<span class="changed"> 137   // Create a node over an existing space</span>
<span class="changed"> 138   static VirtualSpaceNode* create_node(int node_id,</span>
<span class="changed"> 139                                        ReservedSpace rs,</span>
<span class="changed"> 140                                        CommitLimiter* limiter,</span>
<span class="changed"> 141                                        SizeCounter* reserve_words_counter,</span>
<span class="changed"> 142                                        SizeCounter* commit_words_counter);</span>
 143 
<a name="14" id="anc14"></a><span class="changed"> 144   ~VirtualSpaceNode();</span>


























 145 
<a name="15" id="anc15"></a><span class="changed"> 146   // Note: public for gtests only, could be private.</span>
<span class="changed"> 147   MetaWord* base() const        { return _base; }</span>

 148 
<a name="16" id="anc16"></a><span class="changed"> 149   // Reserved size of the whole node.</span>
<span class="changed"> 150   size_t word_size() const      { return _word_size; }</span>




 151 
<a name="17" id="anc17"></a><span class="changed"> 152   //// Chunk allocation, splitting, merging /////</span>


 153 
<a name="18" id="anc18"></a><span class="changed"> 154   // Allocate a root chunk from this node. Will fail and return NULL</span>
<span class="changed"> 155   // if the node is full.</span>
<span class="changed"> 156   // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 157   // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 158   // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 159   Metachunk* allocate_root_chunk();</span>
<span class="changed"> 160 </span>
<span class="changed"> 161   // Given a chunk c, split it recursively until you get a chunk of the given target_level.</span>
<span class="changed"> 162   //</span>
<span class="changed"> 163   // The resulting target chunk resides at the same address as the original chunk.</span>
<span class="changed"> 164   // The resulting splinters are added to freelists.</span>
<span class="changed"> 165   void split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="changed"> 166 </span>
<span class="changed"> 167   // Given a chunk, attempt to merge it recursively with its neighboring chunks.</span>
<span class="changed"> 168   //</span>
<span class="changed"> 169   // If successful (merged at least once), returns address of</span>
<span class="changed"> 170   // the merged chunk; NULL otherwise.</span>
<span class="changed"> 171   //</span>
<span class="changed"> 172   // The merged chunks are removed from the freelists.</span>
<span class="changed"> 173   //</span>
<span class="changed"> 174   // !!! Please note that if this method returns a non-NULL value, the</span>
<span class="changed"> 175   // original chunk will be invalid and should not be accessed anymore! !!!</span>
<span class="changed"> 176   Metachunk* merge(Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="changed"> 177 </span>
<span class="changed"> 178   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to</span>
<span class="changed"> 179   // enlarge it in place by claiming its trailing buddy.</span>
<span class="changed"> 180   //</span>
<span class="changed"> 181   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="changed"> 182   //</span>
<span class="changed"> 183   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="changed"> 184   // double in size (level decreased by one).</span>
<span class="changed"> 185   //</span>
<span class="changed"> 186   // On success, true is returned, false otherwise.</span>
<span class="changed"> 187   bool attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="changed"> 188 </span>
<span class="changed"> 189   // Attempts to purge the node:</span>
<span class="changed"> 190   //</span>
<span class="changed"> 191   // If all chunks living in this node are free, they will all be removed from their freelists</span>
<span class="changed"> 192   //   and deletes the node.</span>
<span class="changed"> 193   //</span>
<span class="changed"> 194   // Returns true if the node has been deleted, false if not.</span>
<span class="changed"> 195   // !! If this returns true, do not access the node from this point on. !!</span>
<span class="changed"> 196   bool attempt_purge(FreeChunkListVector* freelists);</span>
<span class="changed"> 197 </span>
<span class="changed"> 198   // Attempts to uncommit free areas according to the rules set in settings.</span>
<span class="changed"> 199   // Returns number of words uncommitted.</span>
<span class="changed"> 200   size_t uncommit_free_areas();</span>
<span class="changed"> 201 </span>
<span class="changed"> 202   /// misc /////</span>
<span class="changed"> 203 </span>
<span class="changed"> 204   // Returns size, in words, of the used space in this node alone.</span>
<span class="changed"> 205   // (Notes:</span>
<span class="changed"> 206   //  - This is the space handed out to the ChunkManager, so it is "used" from the viewpoint of this node,</span>
<span class="changed"> 207   //    but not necessarily used for Metadata.</span>
<span class="changed"> 208   //  - This may or may not be committed memory.</span>
<span class="changed"> 209   size_t used_words() const             { return _used_words; }</span>
<span class="changed"> 210 </span>
<span class="changed"> 211   // Returns size, in words, of how much space is left in this node alone.</span>
<span class="changed"> 212   size_t free_words() const             { return _word_size - _used_words; }</span>
<span class="changed"> 213 </span>
<span class="changed"> 214   // Returns size, in words, of committed space in this node alone.</span>
<span class="changed"> 215   // Note: iterates over commit mask and hence may be a tad expensive on large nodes.</span>
<span class="changed"> 216   size_t committed_words() const;</span>
<span class="changed"> 217 </span>
<span class="changed"> 218   //// Committing/uncommitting memory /////</span>
<span class="changed"> 219 </span>
<span class="changed"> 220   // Given an address range, ensure it is committed.</span>
<span class="changed"> 221   //</span>
<span class="changed"> 222   // The range does not have to be aligned to granule size. However, the function will always commit</span>
<span class="changed"> 223   // whole granules.</span>
<span class="changed"> 224   //</span>
<span class="changed"> 225   // Function will:</span>
<span class="changed"> 226   // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="changed"> 227   //    returns true immediately.</span>
<span class="changed"> 228   // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="changed"> 229   //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="changed"> 230   // - commit the memory.</span>
<span class="changed"> 231   // - mark the range as committed in the commit mask</span>
<span class="changed"> 232   //</span>
<span class="changed"> 233   // Returns true if success, false if it did hit a commit limit.</span>
<span class="changed"> 234   bool ensure_range_is_committed(MetaWord* p, size_t word_size);</span>
<span class="changed"> 235 </span>
<span class="changed"> 236   // Given an address range (which has to be aligned to commit granule size):</span>
<span class="changed"> 237   //  - uncommit it</span>
<span class="changed"> 238   //  - mark it as uncommitted in the commit mask</span>
<span class="changed"> 239   void uncommit_range(MetaWord* p, size_t word_size);</span>
<span class="changed"> 240 </span>
<span class="changed"> 241   //// List stuff ////</span>
<span class="changed"> 242   VirtualSpaceNode* next() const        { return _next; }</span>
<span class="changed"> 243   void set_next(VirtualSpaceNode* vsn)  { _next = vsn; }</span>
<span class="changed"> 244 </span>
<span class="changed"> 245 </span>
<span class="changed"> 246   /// Debug stuff ////</span>
<span class="changed"> 247 </span>
<span class="changed"> 248   // Print a description about this node.</span>
<span class="changed"> 249   void print_on(outputStream* st) const;</span>
<span class="changed"> 250 </span>
<span class="changed"> 251   // Verify counters and basic structure. Slow mode: verify all chunks in depth</span>
<span class="changed"> 252   bool contains(const MetaWord* p) const {</span>
<span class="changed"> 253     return p &gt;= _base &amp;&amp; p &lt; _base + _used_words;</span>
<span class="changed"> 254   }</span>
<span class="changed"> 255 </span>
<span class="changed"> 256 #ifdef ASSERT</span>
<span class="changed"> 257   void check_pointer(const MetaWord* p) const {</span>
<span class="changed"> 258     assert(contains(p), "invalid pointer");</span>
<span class="changed"> 259   }</span>
<span class="changed"> 260   void verify(bool slow) const;</span>
<span class="changed"> 261 #endif</span>
 262 
 263 };
<a name="19" id="anc19"></a><span class="new"> 264 </span>
 265 
 266 } // namespace metaspace
 267 
 268 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="20" type="hidden" /></form></body></html>
