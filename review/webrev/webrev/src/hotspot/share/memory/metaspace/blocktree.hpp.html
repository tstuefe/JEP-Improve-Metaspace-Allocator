<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/blocktree.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 
   2 /*
   3  * Copyright (c) 2020, SAP SE. All rights reserved.
   4  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  *
  25  */
  26 
  27 #ifndef SHARE_MEMORY_METASPACE_BLOCKTREE_HPP
  28 #define SHARE_MEMORY_METASPACE_BLOCKTREE_HPP
  29 
  30 #include "memory/allocation.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "utilities/debug.hpp"
  33 #include "utilities/globalDefinitions.hpp"
  34 
  35 namespace metaspace {
  36 
  37 
  38 // BlockTree is a rather simple binary search tree. It is used to
  39 // manage small to medium free memory blocks.
  40 //
  41 // There is no separation between payload (managed blocks) and nodes: the
  42 // memory blocks themselves are the nodes. Since they are considered to
  43 // be free when added to the structure, they are used to store the node
  44 // information directly. That also imposes a minimum size to the managed
  45 // memory blocks, which have to be able to hold at least a tree node.
  46 //
  47 // Each node corresponds to a memory block of a unique size. Subsequent memory
  48 // blocks of the same size are stacked below that node.
  49 //
  50 // Todo: this tree is unbalanced. It would be a good fit for a rb-tree.
  51 
  52 class BlockTree: public CHeapObj&lt;mtMetaspace&gt; {
  53 
  54 
  55   struct node_t {
  56 
  57     // Normal tree node stuff...
  58     node_t* parent;
  59     node_t* left;
  60     node_t* right;
  61 
  62     // blocks with the same size are put in a list with this node as head.
  63     node_t* next;
  64 
  65     // word size of node. Note that size cannot be larger than max metaspace size,
  66     // so this could be very well a 32bit value (in case we ever make this a balancing
  67     // tree and need additional space for weighting information).
  68     size_t size;
  69 
  70   };
  71 
  72 public:
  73 
  74   // Largest node size, (bit arbitrarily) capped at 4M since we know this to
  75   // be the max possible metaspace allocation size. TODO. Do this better.
  76   const static size_t maximal_word_size = 4 * M;
  77 
  78   // We need nodes to be at least large enough to hold a node_t
  79   const static size_t minimal_word_size =
  80       (sizeof(node_t) + sizeof(MetaWord) - 1) / sizeof(MetaWord);
  81 
  82 private:
  83 
  84   node_t* _root;
  85 
  86   // As a performance optimization, we keep the size of the largest node.
  87   size_t _largest_size_added;
  88 
  89   MemRangeCounter _counter;
  90 
  91   // given a node n, add it to the list starting at head
  92   static void add_to_list(node_t* n, node_t* head) {
  93     assert(head-&gt;size == n-&gt;size, "sanity");
  94     n-&gt;next = head-&gt;next;
  95     head-&gt;next = n;
  96     DEBUG_ONLY(n-&gt;left = n-&gt;right = n-&gt;parent = NULL;)
  97   }
  98 
  99   // given a node list starting at head, remove one node from it and return it.
 100   // List must contain at least one other node.
 101   static node_t* remove_from_list(node_t* head) {
 102     assert(head-&gt;next != NULL, "sanity");
 103     node_t* n = head-&gt;next;
 104     if (n != NULL) {
 105       head-&gt;next = n-&gt;next;
 106     }
 107     return n;
 108   }
 109 
 110   // Given a node n and a node p, wire up n as left child of p.
 111   static void set_left_child(node_t* p, node_t* c) {
 112     p-&gt;left = c;
 113     if (c != NULL) {
 114       assert(c-&gt;size &lt; p-&gt;size, "sanity");
 115       c-&gt;parent = p;
 116     }
 117   }
 118 
 119   // Given a node n and a node p, wire up n as right child of p.
 120   static void set_right_child(node_t* p, node_t* c) {
 121     p-&gt;right = c;
 122     if (c != NULL) {
 123       assert(c-&gt;size &gt; p-&gt;size, "sanity");
 124       c-&gt;parent = p;
 125     }
 126   }
 127 
 128   // Given a node n, return its predecessor in the tree
 129   // (node with the next-smaller size).
 130   static node_t* predecessor(node_t* n) {
 131     node_t* pred = NULL;
 132     if (n-&gt;left != NULL) {
 133       pred = n-&gt;left;
 134       while (pred-&gt;right != NULL) {
 135         pred = pred-&gt;right;
 136       }
 137     } else {
 138       pred = n-&gt;parent;
 139       node_t* n2 = n;
 140       while (pred != NULL &amp;&amp; n2 == pred-&gt;left) {
 141         n2 = pred;
 142         pred = pred-&gt;parent;
 143       }
 144     }
 145     return pred;
 146   }
 147 
 148   // Given a node n, return its predecessor in the tree
 149   // (node with the next-smaller size).
 150   static node_t* successor(node_t* n) {
 151     node_t* succ = NULL;
 152     if (n-&gt;right != NULL) {
 153       // If there is a right child, search the left-most
 154       // child of that child.
 155       succ = n-&gt;right;
 156       while (succ-&gt;left != NULL) {
 157         succ = succ-&gt;left;
 158       }
 159     } else {
 160       succ = n-&gt;parent;
 161       node_t* n2 = n;
 162       // As long as I am the right child of my parent, search upward
 163       while (succ != NULL &amp;&amp; n2 == succ-&gt;right) {
 164         n2 = succ;
 165         succ = succ-&gt;parent;
 166       }
 167     }
 168     return succ;
 169   }
 170 
 171   // Given a node, replace it with a replacement node as a child for its parent.
 172   // If the node is root and has no parent, sets it as root.
 173   void replace_node_in_parent(node_t* child, node_t* replace) {
 174     node_t* parent = child-&gt;parent;
 175     if (parent != NULL) {
 176       if (parent-&gt;left == child) { // I am a left child
 177         set_left_child(parent, replace);
 178       } else {
 179         set_right_child(parent, replace);
 180       }
 181     } else {
 182       assert(child == _root, "must be root");
 183       _root = replace;
 184       if (replace != NULL) {
 185         replace-&gt;parent = NULL;
 186       }
 187     }
 188     return;
 189   }
 190 
 191   // Given a node n and a node forebear, insert n under forebear
 192   void insert(node_t* forebear, node_t* n) {
 193     if (n-&gt;size == forebear-&gt;size) {
 194       add_to_list(n, forebear); // parent stays NULL in this case.
 195     } else {
 196       if (n-&gt;size &lt; forebear-&gt;size) {
 197         if (forebear-&gt;left == NULL) {
 198           set_left_child(forebear, n);
 199         } else {
 200           insert(forebear-&gt;left, n);
 201         }
 202       } else {
 203         assert(n-&gt;size &gt; forebear-&gt;size, "sanity");
 204         if (forebear-&gt;right == NULL) {
 205           set_right_child(forebear, n);
 206           if (_largest_size_added &lt; n-&gt;size) {
 207             _largest_size_added = n-&gt;size;
 208           }
 209         } else {
 210           insert(forebear-&gt;right, n);
 211         }
 212       }
 213     }
 214   }
 215 
 216   // Given a node and a wish size, search this node and all children for
 217   // the node closest (equal or larger sized) to the size s.
 218   static node_t* find_closest_fit(node_t* n, size_t s) {
 219 
 220     if (n-&gt;size == s) {
 221       // Perfect fit.
 222       return n;
 223 
 224     } else if (n-&gt;size &lt; s) {
 225       // too small, dive down right side
 226       if (n-&gt;right != NULL) {
 227         return find_closest_fit(n-&gt;right, s);
 228       } else {
 229         return NULL;
 230       }
 231     } else {
 232       // n is a possible fit
 233       assert(n-&gt;size &gt; s, "Sanity");
 234       if (n-&gt;left != NULL &amp;&amp; n-&gt;left-&gt;size &gt;= s) {
 235         // but not the best - dive down left side.
 236         return find_closest_fit(n-&gt;left, s);
 237       } else {
 238         // n is the best fit.
 239         return n;
 240       }
 241     }
 242 
 243   }
 244 
 245   // Given a wish size, search the whole tree for a
 246   // node closest (equal or larger sized) to the size s.
 247   node_t* find_closest_fit(size_t s) {
 248     if (_root != NULL) {
 249       return find_closest_fit(_root, s);
 250     }
 251     return NULL;
 252   }
 253 
 254   // Given a node n, remove it from the tree and repair tree.
 255   void remove_node_from_tree(node_t* n) {
 256 
 257     assert(n-&gt;next == NULL, "do not delete a node which has a non-empty list");
 258 
 259     // Maintain largest size node to speed up lookup
 260     if (n-&gt;size == _largest_size_added) {
 261       node_t* pred = predecessor(n);
 262       if (pred != NULL) {
 263         _largest_size_added = pred-&gt;size;
 264       } else {
 265         _largest_size_added = 0;
 266       }
 267     }
 268 
 269     if (n-&gt;left == NULL &amp;&amp; n-&gt;right == NULL) {
 270       replace_node_in_parent(n, NULL);
 271 
 272     } else if (n-&gt;left == NULL &amp;&amp; n-&gt;right != NULL) {
 273       replace_node_in_parent(n, n-&gt;right);
 274 
 275     } else if (n-&gt;left != NULL &amp;&amp; n-&gt;right == NULL) {
 276       replace_node_in_parent(n, n-&gt;left);
 277 
 278     } else {
 279 
 280       // Node has two children.
 281 
 282       // 1) Find direct successor (the next larger node).
 283       node_t* succ = successor(n);
 284 
 285       // There has to be a successor since n-&gt;right was != NULL...
 286       assert(succ != NULL, "must be");
 287 
 288       // ... and it should not have a left child since successor
 289       //     is supposed to be the next larger node, so it must be the mostleft node
 290       //     in the sub tree rooted at n-&gt;right
 291       assert(succ-&gt;left == NULL, "must be");
 292 
 293       assert(succ-&gt;size &gt; n-&gt;size, "sanity");
 294 
 295       node_t* successor_parent = succ-&gt;parent;
 296       node_t* successor_right_child = succ-&gt;right;
 297 
 298       // Remove successor from its parent.
 299       if (successor_parent == n) {
 300 
 301         // special case: successor is a direct child of n. Has to be the right child then.
 302         assert(n-&gt;right == succ, "sanity");
 303 
 304         // Just replace n with this successor.
 305         replace_node_in_parent(n, succ);
 306 
 307         // Take over n's old left child, too.
 308         // We keep the successor's right child.
 309         set_left_child(succ, n-&gt;left);
 310 
 311       } else {
 312 
 313         // If the successors parent is not n, we are deeper in the tree,
 314         // the successor has to be the left child of its parent.
 315         assert(successor_parent-&gt;left == succ, "sanity");
 316 
 317         // The right child of the successor (if there was one) replaces the successor at its parent's left child.
 318         set_left_child(successor_parent, succ-&gt;right);
 319 
 320         // and the successor replaces n at its parent
 321         replace_node_in_parent(n, succ);
 322 
 323         // and takes over n's old children
 324         set_left_child(succ, n-&gt;left);
 325         set_right_child(succ, n-&gt;right);
 326 
 327       }
 328     }
 329   }
 330 
 331 #ifdef ASSERT
 332 
 333   struct veri_data_t;
 334   void verify_node_siblings(node_t* n, veri_data_t* vd) const;
 335   void verify_node(node_t* n, size_t left_limit, size_t right_limit, veri_data_t* vd, int lvl) const;
 336   void verify_tree() const;
 337 
 338   void zap_range(MetaWord* p, size_t word_size);
 339 
 340 #endif // ASSERT
 341 
 342 
 343   static void print_node(outputStream* st, node_t* n, int lvl);
 344 
 345 public:
 346 
 347   BlockTree() : _root(NULL), _largest_size_added(0) {}
 348 
 349   // Add a memory block to the tree. Memory block will be used to store
 350   // node information.
 351   void add_block(MetaWord* p, size_t word_size) {
 352     DEBUG_ONLY(zap_range(p, word_size));
 353     assert(word_size &gt;= minimal_word_size &amp;&amp; word_size &lt; maximal_word_size,
 354            "invalid block size " SIZE_FORMAT, word_size);
 355     node_t* n = (node_t*)p;
 356     n-&gt;size = word_size;
 357     n-&gt;next = n-&gt;left = n-&gt;right = n-&gt;parent = NULL;
 358     if (_root == NULL) {
 359       _root = n;
 360     } else {
 361       insert(_root, n);
 362     }
 363     _counter.add(word_size);
 364 
 365     // Maintain largest node to speed up lookup
 366     if (_largest_size_added &lt; n-&gt;size) {
 367       _largest_size_added = n-&gt;size;
 368     }
 369 
 370   }
 371 
 372   // Given a word_size, searches and returns a block of at least that size.
 373   // Block may be larger. Real block size is returned in *p_real_word_size.
 374   MetaWord* get_block(size_t word_size, size_t* p_real_word_size) {
 375     assert(word_size &gt;= minimal_word_size &amp;&amp; word_size &lt; maximal_word_size,
 376            "invalid block size " SIZE_FORMAT, word_size);
 377 
 378     if (_largest_size_added &lt; word_size) {
 379       return NULL;
 380     }
 381 
 382     node_t* n = find_closest_fit(word_size);
 383 
 384     if (n != NULL) {
 385       assert(n-&gt;size &gt;= word_size, "sanity");
 386 
 387       // If the node has siblings, remove one of them,
 388       // otherwise remove this node from the tree.
 389       if (n-&gt;next != NULL) {
 390         n = remove_from_list(n);
 391       } else {
 392         remove_node_from_tree(n);
 393       }
 394 
 395       MetaWord* p = (MetaWord*)n;
 396       *p_real_word_size = n-&gt;size;
 397 
 398       _counter.sub(n-&gt;size);
 399 
 400       DEBUG_ONLY(zap_range(p, n-&gt;size));
 401 
 402       return p;
 403     }
 404     return NULL;
 405   }
 406 
 407 
 408   // Returns number of blocks in this structure
 409   unsigned count() const { return _counter.count(); }
 410 
 411   // Returns total size, in words, of all elements.
 412   size_t total_size() const { return _counter.total_size(); }
 413 
 414   bool is_empty() const { return _root == NULL; }
 415 
 416   void print_tree(outputStream* st) const;
 417 
 418   DEBUG_ONLY(void verify() const { verify_tree(); })
 419 
 420 };
 421 
 422 } // namespace metaspace
 423 
 424 #endif // SHARE_MEMORY_METASPACE_BLOCKTREE_HPP
</pre></body></html>
