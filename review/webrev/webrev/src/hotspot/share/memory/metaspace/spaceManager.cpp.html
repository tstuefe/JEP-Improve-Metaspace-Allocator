<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/spaceManager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "logging/logStream.hpp"
  29 #include "memory/metaspace/allocationGuard.hpp"
  30 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  31 #include "memory/metaspace/freeBlocks.hpp"
  32 #include "memory/metaspace/chunkManager.hpp"
  33 #include "memory/metaspace/internStat.hpp"
  34 #include "memory/metaspace/metachunk.hpp"
  35 #include "memory/metaspace/metaspaceCommon.hpp"
  36 #include "memory/metaspace/metaspaceStatistics.hpp"
  37 #include "memory/metaspace/spaceManager.hpp"
  38 #include "memory/metaspace/virtualSpaceList.hpp"
  39 #include "runtime/atomic.hpp"
  40 #include "runtime/init.hpp"
  41 #include "services/memoryService.hpp"
  42 #include "utilities/align.hpp"
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
  45 
  46 namespace metaspace {
  47 
  48 #define LOGFMT         "SpcMgr @" PTR_FORMAT " (%s)"
  49 #define LOGFMT_ARGS    p2i(this), this-&gt;_name
  50 
  51 // Given a net allocation word size, return the raw word size we actually allocate.
  52 // Note: externally visible for gtests.
  53 //static
  54 size_t get_raw_allocation_word_size(size_t net_word_size) {
  55 
  56   size_t byte_size = net_word_size * BytesPerWord;
  57 
  58   // Deallocated metablocks are kept in a binlist which limits their minimal
  59   //  size to at least the size of a binlist item (2 words).
  60   byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);
  61 
  62   // Metaspace allocations are aligned to word size.
  63   byte_size = align_up(byte_size, allocation_alignment_bytes);
  64 
  65   // If we guard allocations, we need additional space for a prefix.
  66 #ifdef ASSERT
  67   if (Settings::use_allocation_guard()) {
  68     byte_size += align_up(prefix_size(), allocation_alignment_bytes);
  69   }
  70 #endif
  71 
  72   size_t word_size = byte_size / BytesPerWord;
  73 
  74   assert(word_size * BytesPerWord == byte_size, "Sanity");
  75 
  76   return word_size;
  77 
  78 }
  79 
  80 // Returns the level of the next chunk to be added, acc to growth policy.
  81 chunklevel_t SpaceManager::next_chunk_level() const {
  82   const int growth_step = _chunks.count();
  83   return _growth_policy-&gt;get_level_at_step(growth_step);
  84 }
  85 
  86 // Given a chunk, add its remaining free committed space to the free block list.
  87 void SpaceManager::salvage_chunk(Metachunk* c) {
  88 
  89   if (Settings::handle_deallocations() == false) {
  90     return;
  91   }
  92 
  93   assert_lock_strong(lock());
  94 
  95   // If the chunk is completely empty, just return it to the chunk manager.
  96   if (c-&gt;used_words() == 0) {
  97     UL2(trace, "salvage: returning empty chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
  98     _chunk_manager-&gt;return_chunk(c);
  99     return;
 100   }
 101 
 102   size_t remaining_words = c-&gt;free_below_committed_words();
 103 
 104   if (remaining_words &gt; FreeBlocks::minimal_word_size) {
 105 
 106     UL2(trace, "salvaging chunk " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));
 107 
 108     MetaWord* ptr = c-&gt;allocate(remaining_words);
 109     assert(ptr != NULL, "Should have worked");
 110     _total_used_words_counter-&gt;increment_by(remaining_words);
 111 
 112     add_allocation_to_fbl(ptr, remaining_words);
 113 
 114     // After this operation: the chunk should have no free committed space left.
 115     assert(c-&gt;free_below_committed_words() == 0,
 116            "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",
 117            METACHUNK_FULL_FORMAT_ARGS(c));
 118 
 119   }
 120 
 121 }
 122 
 123 // Allocate a new chunk from the underlying chunk manager able to hold at least
 124 // requested word size.
 125 Metachunk* SpaceManager::allocate_new_chunk(size_t requested_word_size) {
 126 
 127   assert_lock_strong(lock());
 128 
 129   // Should this ever happen, we need to increase the maximum possible chunk size.
 130   guarantee(requested_word_size &lt;= chunklevel::MAX_CHUNK_WORD_SIZE,
 131             "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",
 132             requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);
 133 
 134   const int growth_step = _chunks.count();
 135   const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);
 136   const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());
 137 
 138   Metachunk* c = _chunk_manager-&gt;get_chunk(preferred_level, max_level, requested_word_size);
 139   if (c == NULL) {
 140     return NULL;
 141   }
 142 
 143   assert(c-&gt;is_in_use(), "Wrong chunk state.");
 144   assert(c-&gt;free_below_committed_words() &gt;= requested_word_size, "Chunk not committed");
 145 
 146   return c;
 147 
 148 }
 149 
 150 void SpaceManager::add_allocation_to_fbl(MetaWord* p, size_t word_size) {
 151   assert(Settings::handle_deallocations(), "Sanity");
 152   if (_fbl == NULL) {
 153     _fbl = new FreeBlocks(); // Create only on demand
 154   }
 155   _fbl-&gt;add_block(p, word_size);
 156 }
 157 
 158 SpaceManager::SpaceManager(ChunkManager* chunk_manager,
 159              const ArenaGrowthPolicy* growth_policy,
 160              Mutex* lock,
 161              SizeAtomicCounter* total_used_words_counter,
 162              const char* name,
 163              bool is_micro_loader)
 164 : _lock(lock),
 165   _chunk_manager(chunk_manager),
 166   _growth_policy(growth_policy),
 167   _chunks(),
 168   _fbl(NULL),
 169   _total_used_words_counter(total_used_words_counter),
 170   _name(name),
 171   _is_micro_loader(is_micro_loader)
 172 {
 173   UL(debug, ": born.");
 174 }
 175 
 176 SpaceManager::~SpaceManager() {
 177 
 178   DEBUG_ONLY(verify(true);)
 179 
 180   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);
 181 
 182   MemRangeCounter return_counter;
 183 
 184   Metachunk* c = _chunks.first();
 185   Metachunk* c2 = NULL;
 186 
 187   while(c) {
 188     c2 = c-&gt;next();
 189     return_counter.add(c-&gt;used_words());
 190     DEBUG_ONLY(c-&gt;set_prev(NULL);)
 191     DEBUG_ONLY(c-&gt;set_next(NULL);)
 192     UL2(debug, "return chunk: " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 193     _chunk_manager-&gt;return_chunk(c);
 194     // c may be invalid after return_chunk(c) was called. Don't access anymore.
 195     c = c2;
 196   }
 197 
 198   UL2(info, "returned %d chunks, total capacity " SIZE_FORMAT " words.",
 199       return_counter.count(), return_counter.total_size());
 200 
 201   _total_used_words_counter-&gt;decrement_by(return_counter.total_size());
 202 
 203   DEBUG_ONLY(chunk_manager()-&gt;verify(true);)
 204 
 205   delete _fbl;
 206 
 207   UL(debug, ": dies.");
 208 
 209 }
 210 
 211 // Attempt to enlarge the current chunk to make it large enough to hold at least
 212 //  requested_word_size additional words.
 213 //
 214 // On success, true is returned, false otherwise.
 215 bool SpaceManager::attempt_enlarge_current_chunk(size_t requested_word_size) {
 216 
 217   Metachunk* c = current_chunk();
 218   assert(c-&gt;free_words() &lt; requested_word_size, "Sanity");
 219 
 220   // Not if chunk enlargment is switched off...
 221   if (Settings::enlarge_chunks_in_place() == false) {
 222     return false;
 223   }
 224 
 225   // ... we also disallow it for very large chunks...
 226   if (c-&gt;word_size() &gt; Settings::enlarge_chunks_in_place_max_word_size()) {
 227     return false;
 228   }
 229 
 230   // ... nor if we are already a root chunk ...
 231   if (c-&gt;is_root_chunk()) {
 232     return false;
 233   }
 234 
 235   // ... nor if the combined size of chunk content and new content would bring us above the size of a root chunk ...
 236   if ((c-&gt;used_words() + requested_word_size) &gt; metaspace::chunklevel::MAX_CHUNK_WORD_SIZE) {
 237     return false;
 238   }
 239 
 240   const chunklevel_t new_level =
 241       chunklevel::level_fitting_word_size(c-&gt;used_words() + requested_word_size);
 242   assert(new_level &lt; c-&gt;level(), "Sanity");
 243 
 244   // Atm we only enlarge by one level (so, doubling the chunk in size). So, if the requested enlargement
 245   // would require the chunk to more than double in size, we bail. But this covers about 99% of all cases,
 246   // so this is good enough.
 247   if (new_level &lt; c-&gt;level() - 1) {
 248     return false;
 249   }
 250 
 251   // This only works if chunk is the leader of its buddy pair (and also if buddy
 252   // is free and unsplit, but that we cannot check outside of metaspace lock).
 253   if (!c-&gt;is_leader()) {
 254     return false;
 255   }
 256 
 257   // If the size added to the chunk would be larger than allowed for the next growth step
 258   // dont enlarge.
 259   if (next_chunk_level() &gt; c-&gt;level()) {
 260     return false;
 261   }
 262 
 263   bool success = _chunk_manager-&gt;attempt_enlarge_chunk(c);
 264 
 265   assert(success == false || c-&gt;free_words() &gt;= requested_word_size, "Sanity");
 266 
 267   return success;
 268 
 269 }
 270 
 271 // Allocate memory from Metaspace.
 272 // 1) Attempt to allocate from the free block list.
 273 // 2) Attempt to allocate from the current chunk.
 274 // 3) Attempt to enlarge the current chunk in place if it is too small.
 275 // 4) Attempt to get a new chunk and allocate from that chunk.
 276 // At any point, if we hit a commit limit, we return NULL.
 277 MetaWord* SpaceManager::allocate(size_t requested_word_size) {
 278 
 279   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 280 
 281   UL2(trace, "requested " SIZE_FORMAT " words.", requested_word_size);
 282 
 283   MetaWord* p = NULL;
 284 
 285   const size_t raw_word_size = get_raw_allocation_word_size(requested_word_size);
 286 
 287   // 1) Attempt to allocate from the free blocks list
 288   if (Settings::handle_deallocations() &amp;&amp; _fbl != NULL &amp;&amp; !_fbl-&gt;is_empty()) {
 289     p = _fbl-&gt;get_block(raw_word_size);
 290     if (p != NULL) {
 291       DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)
 292       UL2(trace, "taken from fbl (now: %d, " SIZE_FORMAT ").",
 293           _fbl-&gt;count(), _fbl-&gt;total_size());
 294       // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -
 295       // that means that we do not modify any counters and therefore can skip the epilog.
 296       return p;
 297     }
 298   }
 299 
 300   bool current_chunk_too_small = false;
 301   bool commit_failure = false;
 302 
 303   if (current_chunk() != NULL) {
 304 
 305     // 2) Attempt to satisfy the allocation from the current chunk.
 306 
 307     // If the current chunk is too small to hold the requested size, attempt to enlarge it.
 308     // If that fails, retire the chunk.
 309     if (current_chunk()-&gt;free_words() &lt; raw_word_size) {
 310       if (!attempt_enlarge_current_chunk(raw_word_size)) {
 311         current_chunk_too_small = true;
 312       } else {
 313         DEBUG_ONLY(InternalStats::inc_num_chunks_enlarged();)
 314         UL(debug, "enlarged chunk.");
 315       }
 316     }
 317 
 318     // Commit the chunk far enough to hold the requested word size. If that fails, we
 319     // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the
 320     // chunk.
 321     if (!current_chunk_too_small) {
 322       if (!current_chunk()-&gt;ensure_committed_additional(raw_word_size)) {
 323         UL2(info, "commit failure (requested size: " SIZE_FORMAT ")", raw_word_size);
 324         commit_failure = true;
 325       }
 326     }
 327 
 328     // Allocate from the current chunk. This should work now.
 329     if (!current_chunk_too_small &amp;&amp; !commit_failure) {
 330       p = current_chunk()-&gt;allocate(raw_word_size);
 331       assert(p != NULL, "Allocation from chunk failed.");
 332     }
 333 
 334   }
 335 
 336   if (p == NULL) {
 337 
 338     // If we are here, we either had no current chunk to begin with or it was deemed insufficient.
 339     assert(current_chunk() == NULL ||
 340            current_chunk_too_small || commit_failure, "Sanity");
 341 
 342     Metachunk* new_chunk = allocate_new_chunk(raw_word_size);
 343 
 344     if (new_chunk != NULL) {
 345 
 346       UL2(debug, "allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",
 347           METACHUNK_FORMAT_ARGS(new_chunk), requested_word_size);
 348 
 349       assert(new_chunk-&gt;free_below_committed_words() &gt;= raw_word_size, "Sanity");
 350 
 351       // We have a new chunk. Before making it the current chunk, retire the old one.
 352       if (current_chunk() != NULL) {
 353         salvage_chunk(current_chunk());
 354         DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)
 355       }
 356 
 357       _chunks.add(new_chunk);
 358 
 359       // Now, allocate from that chunk. That should work.
 360       p = current_chunk()-&gt;allocate(raw_word_size);
 361       assert(p != NULL, "Allocation from chunk failed.");
 362 
 363     } else {
 364       UL2(info, "failed to allocate new chunk for requested word size " SIZE_FORMAT ".", requested_word_size);
 365     }
 366 
 367   }
 368 
 369 #ifdef ASSERT
 370   // When using allocation guards, establish a prefix.
 371   if (p != NULL &amp;&amp; Settings::use_allocation_guard()) {
 372     p = establish_prefix(p, raw_word_size);
 373   }
 374 #endif
 375 
 376   if (p == NULL) {
 377     DEBUG_ONLY(InternalStats::inc_num_allocs_failed_limit();)
 378   } else {
 379     DEBUG_ONLY(InternalStats::inc_num_allocs();)
 380     _total_used_words_counter-&gt;increment_by(raw_word_size);
 381   }
 382 
 383   SOMETIMES(verify_locked(true);)
 384 
 385   if (p == NULL) {
 386     UL(info, "allocation failed, returned NULL.");
 387   } else {
 388     UL2(trace, "returned " PTR_FORMAT ".", p2i(p));
 389   }
 390 
 391   return p;
 392 
 393 }
 394 
 395 // Prematurely returns a metaspace allocation to the _block_freelists
 396 // because it is not needed anymore (requires CLD lock to be active).
 397 void SpaceManager::deallocate_locked(MetaWord* p, size_t word_size) {
 398 
 399   if (Settings::handle_deallocations() == false) {
 400     return;
 401   }
 402 
 403   assert_lock_strong(lock());
 404 
 405   // At this point a current chunk must exist since we only deallocate if we did allocate before.
 406   assert(current_chunk() != NULL, "stray deallocation?");
 407 
 408   assert(is_valid_area(p, word_size),
 409          "Pointer range not part of this SpaceManager and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",
 410          p2i(p), p2i(p + word_size));
 411 
 412   UL2(trace, "deallocating " PTR_FORMAT ", word size: " SIZE_FORMAT ".",
 413       p2i(p), word_size);
 414 
 415   size_t raw_word_size = get_raw_allocation_word_size(word_size);
 416   add_allocation_to_fbl(p, raw_word_size);
 417 
 418   DEBUG_ONLY(verify_locked(false);)
 419 
 420 }
 421 
 422 // Prematurely returns a metaspace allocation to the _block_freelists because it is not
 423 // needed anymore.
 424 void SpaceManager::deallocate(MetaWord* p, size_t word_size) {
 425   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 426   deallocate_locked(p, word_size);
 427 }
 428 
 429 // Update statistics. This walks all in-use chunks.
 430 void SpaceManager::add_to_statistics(sm_stats_t* out) const {
 431 
 432   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 433 
 434   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 435     in_use_chunk_stats_t&amp; ucs = out-&gt;stats[c-&gt;level()];
 436     ucs.num ++;
 437     ucs.word_size += c-&gt;word_size();
 438     ucs.committed_words += c-&gt;committed_words();
 439     ucs.used_words += c-&gt;used_words();
 440     // Note: for free and waste, we only count what's committed.
 441     if (c == current_chunk()) {
 442       ucs.free_words += c-&gt;free_below_committed_words();
 443     } else {
 444       ucs.waste_words += c-&gt;free_below_committed_words();
 445     }
 446   }
 447 
 448   if (_fbl != NULL) {
 449     out-&gt;free_blocks_num += _fbl-&gt;count();
 450     out-&gt;free_blocks_word_size += _fbl-&gt;total_size();
 451   }
 452 
 453   SOMETIMES(out-&gt;verify();)
 454 
 455 }
 456 
 457 // Convenience method to get the most important usage statistics.
 458 // For deeper analysis use add_to_statistics().
 459 void SpaceManager::usage_numbers(size_t* p_used_words, size_t* p_committed_words, size_t* p_capacity_words) const {
 460   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 461   size_t used = 0, comm = 0, cap = 0;
 462   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 463     used += c-&gt;used_words();
 464     comm += c-&gt;committed_words();
 465     cap += c-&gt;word_size();
 466   }
 467   if (p_used_words != NULL) {
 468     *p_used_words = used;
 469   }
 470   if (p_committed_words != NULL) {
 471     *p_committed_words = comm;
 472   }
 473   if (p_capacity_words != NULL) {
 474     *p_capacity_words = cap;
 475   }
 476 }
 477 
 478 
 479 #ifdef ASSERT
 480 
 481 void SpaceManager::verify_locked(bool slow) const {
 482 
 483   assert_lock_strong(lock());
 484 
 485   assert(_growth_policy != NULL &amp;&amp; _chunk_manager != NULL, "Sanity");
 486 
 487   _chunks.verify();
 488 
 489   if (_fbl != NULL) {
 490     _fbl-&gt;verify();
 491   }
 492 
 493   // In slow mode, verify guard zones of all allocations
 494   if (slow &amp;&amp; Settings::use_allocation_guard()) {
 495     for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 496       const MetaWord* p = c-&gt;base();
 497       while (p &lt; c-&gt;top()) {
 498         const prefix_t* pp = (const prefix_t*)p;
 499         check_prefix(pp);
 500         p += pp-&gt;word_size;
 501       }
 502     }
 503   }
 504 
 505 }
 506 
 507 void SpaceManager::verify(bool slow) const {
 508 
 509   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 510   verify_locked(slow);
 511 
 512 }
 513 
 514 // Returns true if the area indicated by pointer and size have actually been allocated
 515 // from this space manager.
 516 bool SpaceManager::is_valid_area(MetaWord* p, size_t word_size) const {
 517   assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");
 518   bool found = false;
 519   if (!found) {
 520     for (const Metachunk* c = _chunks.first(); c != NULL &amp;&amp; !found; c = c-&gt;next()) {
 521       assert(c-&gt;is_valid_committed_pointer(p) ==
 522              c-&gt;is_valid_committed_pointer(p + word_size - 1), "range intersects");
 523       found = c-&gt;is_valid_committed_pointer(p);
 524     }
 525   }
 526   return found;
 527 }
 528 
 529 #endif // ASSERT
 530 
 531 void SpaceManager::print_on(outputStream* st) const {
 532   MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);
 533   print_on_locked(st);
 534 }
 535 
 536 void SpaceManager::print_on_locked(outputStream* st) const {
 537   assert_lock_strong(_lock);
 538   st-&gt;print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
 539                _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());
 540   _chunks.print_on(st);
 541   st-&gt;cr();
 542   st-&gt;print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,
 543                 _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));
 544 }
 545 
 546 
 547 
 548 } // namespace metaspace
 549 
</pre></body></html>
