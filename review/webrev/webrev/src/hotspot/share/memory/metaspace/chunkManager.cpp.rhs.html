<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2019, SAP SE. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
<a name="2" id="anc2"></a><span class="new">  25 </span>
  26 #include "precompiled.hpp"
  27 
<a name="3" id="anc3"></a><span class="new">  28 </span>
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
<a name="4" id="anc4"></a><span class="changed">  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/chunkLevel.hpp"</span>
  33 #include "memory/metaspace/chunkManager.hpp"
<a name="5" id="anc5"></a><span class="new">  34 #include "memory/metaspace/internStat.hpp"</span>
  35 #include "memory/metaspace/metachunk.hpp"
<a name="6" id="anc6"></a>
  36 #include "memory/metaspace/metaspaceCommon.hpp"
  37 #include "memory/metaspace/metaspaceStatistics.hpp"
<a name="7" id="anc7"></a><span class="changed">  38 #include "memory/metaspace/settings.hpp"</span>
  39 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="8" id="anc8"></a><span class="new">  40 #include "memory/metaspace/virtualSpaceList.hpp"</span>
  41 #include "runtime/mutexLocker.hpp"
  42 #include "utilities/debug.hpp"
  43 #include "utilities/globalDefinitions.hpp"
<a name="9" id="anc9"></a>
  44 
  45 namespace metaspace {
  46 
<a name="10" id="anc10"></a><span class="changed">  47 #define LOGFMT         "ChkMgr @" PTR_FORMAT " (%s)"</span>
<span class="changed">  48 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>




  49 
<a name="11" id="anc11"></a><span class="changed">  50 // Return a single chunk to the freelist and adjust accounting. No merge is attempted.</span>
<span class="changed">  51 void ChunkManager::return_chunk_simple(Metachunk* c) {</span>










  52 
<a name="12" id="anc12"></a>
  53   assert_lock_strong(MetaspaceExpand_lock);
<a name="13" id="anc13"></a>
















































































  54 
<a name="14" id="anc14"></a><span class="changed">  55   DEBUG_ONLY(c-&gt;verify(false));</span>






  56 
<a name="15" id="anc15"></a><span class="changed">  57   const chunklevel_t lvl = c-&gt;level();</span>
<span class="changed">  58   _chunks.add(c);</span>
<span class="changed">  59   c-&gt;reset_used_words();</span>
  60 
<a name="16" id="anc16"></a><span class="changed">  61   // Tracing</span>
<span class="changed">  62   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",</span>
<span class="changed">  63                        _name, METACHUNK_FORMAT_ARGS(c));</span>
  64 
<a name="17" id="anc17"></a>
  65 }
  66 
<a name="18" id="anc18"></a><span class="changed">  67 // Creates a chunk manager with a given name (which is for debug purposes only)</span>
<span class="changed">  68 // and an associated space list which will be used to request new chunks from</span>
<span class="changed">  69 // (see get_chunk())</span>
<span class="changed">  70 ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)</span>
<span class="changed">  71   : _vslist(space_list),</span>
<span class="changed">  72     _name(name),</span>
<span class="changed">  73     _chunks()</span>
<span class="changed">  74 {</span>


























  75 }
  76 
<a name="19" id="anc19"></a><span class="changed">  77 // Given a chunk we are about to handout to the caller, make sure it is committed</span>
<span class="changed">  78 // according to constants::committed_words_on_fresh_chunks</span>
<span class="changed">  79 bool ChunkManager::commit_chunk_before_handout(Metachunk* c) {</span>
  80   assert_lock_strong(MetaspaceExpand_lock);
<a name="20" id="anc20"></a><span class="changed">  81   const size_t must_be_committed = MIN2(c-&gt;word_size(), Settings::committed_words_on_fresh_chunks());</span>
<span class="changed">  82   return c-&gt;ensure_committed_locked(must_be_committed);</span>
  83 }
  84 
<a name="21" id="anc21"></a><span class="changed">  85 // Given a chunk, split it into a target chunk of a smaller size (higher target level)</span>
<span class="changed">  86 //  and at least one, possible several splinter chunks.</span>
<span class="changed">  87 // The original chunk must be outside of the freelist and its state must be free.</span>
<span class="changed">  88 // The splinter chunks are added to the freelist.</span>
<span class="changed">  89 // The resulting target chunk will be located at the same address as the original</span>
<span class="changed">  90 //  chunk, but it will of course be smaller (of a higher level).</span>
<span class="changed">  91 // The committed areas within the original chunk carry over to the resulting</span>
<span class="changed">  92 //  chunks.</span>
<span class="changed">  93 void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {</span>
<span class="changed">  94 </span>
  95   assert_lock_strong(MetaspaceExpand_lock);
<a name="22" id="anc22"></a>

















  96 
<a name="23" id="anc23"></a><span class="new">  97   assert(c-&gt;is_free(), "chunk to be split must be free.");</span>
<span class="new">  98   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");</span>
<span class="new">  99   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");</span>
<span class="new"> 100 </span>
<span class="new"> 101   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)</span>
<span class="new"> 102   DEBUG_ONLY(c-&gt;verify(true);)</span>
<span class="new"> 103 </span>
<span class="new"> 104   UL2(debug, "splitting chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",</span>
<span class="new"> 105       METACHUNK_FORMAT_ARGS(c), target_level);</span>
<span class="new"> 106 </span>
<span class="new"> 107   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)</span>
<span class="new"> 108 </span>
<span class="new"> 109   const chunklevel_t orig_level = c-&gt;level();</span>
<span class="new"> 110   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);</span>
<span class="new"> 111 </span>
<span class="new"> 112   // Splitting should never fail.</span>
<span class="new"> 113   assert(c-&gt;level() == target_level, "Sanity");</span>
<span class="new"> 114 </span>
<span class="new"> 115   // The size of the committed portion should not change (subject to the reduced chunk size of course)</span>
 116 #ifdef ASSERT
<a name="24" id="anc24"></a><span class="changed"> 117   if (committed_words_before &gt; c-&gt;word_size()) {</span>
<span class="changed"> 118     assert(c-&gt;is_fully_committed(), "Sanity");</span>
<span class="changed"> 119   } else {</span>
<span class="changed"> 120     assert(c-&gt;committed_words() == committed_words_before, "Sanity");</span>
<span class="changed"> 121   }</span>
<span class="changed"> 122 #endif</span>
<span class="changed"> 123 </span>
<span class="changed"> 124   DEBUG_ONLY(c-&gt;verify(false));</span>
<span class="changed"> 125 </span>
<span class="changed"> 126   DEBUG_ONLY(verify_locked(true);)</span>
<span class="changed"> 127 </span>
<span class="changed"> 128   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)</span>
<span class="changed"> 129 </span>
 130 }
 131 
<a name="25" id="anc25"></a><span class="changed"> 132 // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.</span>
<span class="changed"> 133 //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.</span>
<span class="changed"> 134 // On error, will return NULL.</span>
<span class="changed"> 135 //</span>
<span class="changed"> 136 // This function may fail for two reasons:</span>
<span class="changed"> 137 // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList</span>
<span class="changed"> 138 //   is non-expandable but needs expanding - aka out of compressed class space).</span>
<span class="changed"> 139 // - Or, if the necessary space cannot be committed because we hit a commit limit.</span>
<span class="changed"> 140 //   This may be either the GC threshold or MaxMetaspaceSize.</span>
<span class="changed"> 141 Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {</span>
 142 
<a name="26" id="anc26"></a><span class="changed"> 143   assert(preferred_level &lt;= max_level, "Sanity");</span>
<span class="changed"> 144   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");</span>
 145 
<a name="27" id="anc27"></a><span class="changed"> 146   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 147 </span>
<span class="changed"> 148   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed"> 149 </span>
<span class="changed"> 150   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)</span>
<span class="changed"> 151   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)</span>
<span class="changed"> 152   assert(max_level &gt;= preferred_level, "invalid level.");</span>
<span class="changed"> 153 </span>
<span class="changed"> 154   UL2(debug, "requested chunk: pref_level: " CHKLVL_FORMAT</span>
<span class="changed"> 155      ", max_level: " CHKLVL_FORMAT ", min committed size: " SIZE_FORMAT ".",</span>
<span class="changed"> 156      preferred_level, max_level, min_committed_words);</span>
<span class="changed"> 157 </span>
<span class="changed"> 158   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.</span>
<span class="changed"> 159 </span>
<span class="changed"> 160   // 1) Search best or smaller committed chunks (first attempt):</span>
<span class="changed"> 161   //    Start at the preferred chunk size and work your way down (level up).</span>
<span class="changed"> 162   //    But for now, only consider chunks larger than a certain threshold -</span>
<span class="changed"> 163   //    this is to prevent large loaders (eg boot) from unnecessarily gobbling up</span>
<span class="changed"> 164   //    all the tiny splinter chunks lambdas leave around.</span>
<span class="changed"> 165   Metachunk* c = NULL;</span>
<span class="changed"> 166   c = _chunks.search_chunk_ascending(preferred_level, MIN2((chunklevel_t)(preferred_level + 2), max_level), min_committed_words);</span>
<span class="changed"> 167 </span>
<span class="changed"> 168   // 2) Search larger committed chunks:</span>
<span class="changed"> 169   //    If that did not yield anything, look at larger chunks, which may be committed. We would have to split</span>
<span class="changed"> 170   //    them first, of course.</span>
<span class="changed"> 171   if (c == NULL) {</span>
<span class="changed"> 172     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);</span>
 173   }
<a name="28" id="anc28"></a><span class="new"> 174 </span>
<span class="new"> 175   // 3) Search best or smaller committed chunks (second attempt):</span>
<span class="new"> 176   //    Repeat (1) but now consider even the tiniest chunks as long as they are large enough to hold the</span>
<span class="new"> 177   //    committed min size.</span>
<span class="new"> 178   if (c == NULL) {</span>
<span class="new"> 179     c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);</span>
 180   }
<a name="29" id="anc29"></a><span class="new"> 181 </span>
<span class="new"> 182   // if we did not get anything yet, there are no free chunks commmitted enough. Repeat search but look for uncommitted chunks too:</span>
<span class="new"> 183 </span>
<span class="new"> 184   // 4) Search best or smaller chunks, can be uncommitted:</span>
<span class="new"> 185   if (c == NULL) {</span>
<span class="new"> 186     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);</span>
 187   }
 188 
<a name="30" id="anc30"></a><span class="changed"> 189   // 5) Search a larger uncommitted chunk:</span>
<span class="changed"> 190   if (c == NULL) {</span>
<span class="changed"> 191     c = _chunks.search_chunk_descending(preferred_level, 0);</span>
<span class="changed"> 192   }</span>







 193 
<a name="31" id="anc31"></a><span class="changed"> 194   if (c != NULL) {</span>
<span class="changed"> 195     UL(trace, "taken from freelist.");</span>
<span class="changed"> 196   }</span>


 197 
<a name="32" id="anc32"></a><span class="changed"> 198   // Failing all that, allocate a new root chunk from the connected virtual space.</span>
<span class="changed"> 199   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)</span>
<span class="changed"> 200   if (c == NULL) {</span>
<span class="changed"> 201     c = _vslist-&gt;allocate_root_chunk();</span>
<span class="changed"> 202     if (c == NULL) {</span>
<span class="changed"> 203       UL(info, "failed to get new root chunk.");</span>


































































 204     } else {
<a name="33" id="anc33"></a><span class="changed"> 205       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");</span>
<span class="changed"> 206       UL(debug, "allocated new root chunk.");</span>
 207     }
 208   }
 209 
<a name="34" id="anc34"></a><span class="changed"> 210   if (c == NULL) {</span>
<span class="changed"> 211     UL2(info, "failed to get chunk (preferred level: " CHKLVL_FORMAT</span>
<span class="changed"> 212        ", max level " CHKLVL_FORMAT ".", preferred_level, max_level);</span>
<span class="changed"> 213     return NULL;</span>
<span class="changed"> 214   }</span>





 215 
<a name="35" id="anc35"></a><span class="changed"> 216   // Now we have a chunk. It may be too large for the callers needs. It also may not be committed enough.</span>
<span class="changed"> 217   // So we may have to split it, and commit its starting granules.</span>
<span class="changed"> 218   //</span>
<span class="changed"> 219   // Note that we, as step 1, commit the chunk. Committing may fail and by doing the committing before</span>
<span class="changed"> 220   // the split we can easily add the still unsplit chunk back to the freelist without having to re-merge.</span>
<span class="changed"> 221   //</span>
<span class="changed"> 222   // As step 2 we split the chunk. Splitting preserves the committed regions underlying the chunk, and</span>
<span class="changed"> 223   // since the target chunk is the first in the original chunk area, the target chunk will be committed</span>
<span class="changed"> 224   // enough.</span>
<span class="changed"> 225 </span>
<span class="changed"> 226   const size_t need_to_commit = MAX2(Settings::committed_words_on_fresh_chunks(), min_committed_words);</span>
<span class="changed"> 227   if (c-&gt;committed_words() &lt; need_to_commit) {</span>
<span class="changed"> 228     if (c-&gt;ensure_committed_locked(need_to_commit) == false) {</span>
<span class="changed"> 229       UL2(info, "failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",</span>
<span class="changed"> 230           need_to_commit,  METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 231       _chunks.add(c);</span>
<span class="changed"> 232       return NULL;</span>
<span class="changed"> 233     }</span>
<span class="changed"> 234   }</span>
 235 
<a name="36" id="anc36"></a><span class="changed"> 236   // If too large, split chunk and add the splinter chunks back to the freelist.</span>
<span class="changed"> 237   if (c-&gt;level() &lt; preferred_level) {</span>
<span class="changed"> 238     split_chunk_and_add_splinters(c, preferred_level);</span>
<span class="changed"> 239     assert(c-&gt;level() == preferred_level, "split failed?");</span>
<span class="changed"> 240   }</span>
 241 
<a name="37" id="anc37"></a><span class="changed"> 242   // Any chunk returned from ChunkManager shall be marked as in use.</span>
<span class="changed"> 243   c-&gt;set_in_use();</span>


 244 
<a name="38" id="anc38"></a><span class="changed"> 245   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed"> 246   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)</span>
 247 
<a name="39" id="anc39"></a><span class="changed"> 248   UL2(debug, "handing out chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
 249 
<a name="40" id="anc40"></a><span class="changed"> 250   DEBUG_ONLY(InternalStats::inc_num_chunks_taken_from_freelist();)</span>


 251 
<a name="41" id="anc41"></a><span class="changed"> 252   return c;</span>
 253 
<a name="42" id="anc42"></a>
 254 }
 255 
<a name="43" id="anc43"></a><span class="changed"> 256 // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk</span>
<span class="changed"> 257 //  with neighbors.</span>
<span class="changed"> 258 // As a side effect this removes the chunk from whatever list it has been in previously.</span>
<span class="changed"> 259 // Happens after a Classloader was unloaded and releases its metaspace chunks.</span>
<span class="changed"> 260 // !! Note: this may invalidate the chunk. Do not access the chunk after</span>
<span class="changed"> 261 //    this function returns !!</span>
<span class="changed"> 262 void ChunkManager::return_chunk(Metachunk* c) {</span>
 263 
<a name="44" id="anc44"></a><span class="changed"> 264   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>

 265 
<a name="45" id="anc45"></a><span class="changed"> 266   UL2(debug, ": returning chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
 267 
<a name="46" id="anc46"></a><span class="changed"> 268   DEBUG_ONLY(c-&gt;verify(true);)</span>

 269 
<a name="47" id="anc47"></a><span class="changed"> 270   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");</span>
 271 
<a name="48" id="anc48"></a><span class="changed"> 272   assert(c-&gt;is_in_use(), "Unexpected chunk state");</span>
<span class="changed"> 273   assert(!c-&gt;in_list(), "Remove from list first");</span>
<span class="changed"> 274   c-&gt;set_free();</span>
<span class="changed"> 275   c-&gt;reset_used_words();</span>
 276 
<a name="49" id="anc49"></a><span class="changed"> 277   const chunklevel_t orig_lvl = c-&gt;level();</span>
 278 
<a name="50" id="anc50"></a><span class="changed"> 279   Metachunk* merged = NULL;</span>
<span class="changed"> 280   if (!c-&gt;is_root_chunk()) {</span>
<span class="changed"> 281     // Only attempt merging if we are not of the lowest level already.</span>
<span class="changed"> 282     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);</span>




 283   }
 284 
<a name="51" id="anc51"></a><span class="changed"> 285   if (merged != NULL) {</span>


 286 
<a name="52" id="anc52"></a><span class="changed"> 287     DEBUG_ONLY(merged-&gt;verify(false));</span>







 288 
<a name="53" id="anc53"></a><span class="changed"> 289     // We did merge our chunk into a different chunk.</span>



 290 
<a name="54" id="anc54"></a><span class="changed"> 291     // We did merge chunks and now have a bigger chunk.</span>
<span class="changed"> 292     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");</span>
 293 
<a name="55" id="anc55"></a><span class="changed"> 294     UL2(debug, "merged into chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(merged));</span>



 295 
<a name="56" id="anc56"></a><span class="changed"> 296     c = merged;</span>
 297 
 298   }
<a name="57" id="anc57"></a>
 299 
<a name="58" id="anc58"></a><span class="changed"> 300   if (Settings::uncommit_on_return() &amp;&amp;</span>
<span class="changed"> 301       Settings::uncommit_on_return_min_word_size() &lt;= c-&gt;word_size())</span>
<span class="changed"> 302   {</span>
<span class="changed"> 303 </span>
<span class="changed"> 304     UL2(debug, "uncommitting free chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 305     c-&gt;uncommit_locked();</span>
 306   }
 307 
<a name="59" id="anc59"></a><span class="changed"> 308   return_chunk_simple(c);</span>

 309 
<a name="60" id="anc60"></a><span class="changed"> 310   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed"> 311   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)</span>
 312 
<a name="61" id="anc61"></a><span class="changed"> 313   DEBUG_ONLY(InternalStats::inc_num_chunks_returned_to_freelist();)</span>

 314 
<a name="62" id="anc62"></a><span class="changed"> 315 }</span>


 316 
<a name="63" id="anc63"></a><span class="changed"> 317 // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to</span>
<span class="changed"> 318 // enlarge it in place by claiming its trailing buddy.</span>
<span class="changed"> 319 //</span>
<span class="changed"> 320 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="changed"> 321 //</span>
<span class="changed"> 322 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="changed"> 323 // double in size (level decreased by one).</span>
<span class="changed"> 324 //</span>
<span class="changed"> 325 // On success, true is returned, false otherwise.</span>
<span class="changed"> 326 bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {</span>
<span class="changed"> 327   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 328   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);</span>
<span class="changed"> 329 }</span>
<span class="changed"> 330 </span>
<span class="changed"> 331 static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {</span>
<span class="changed"> 332   if (word_size_1 == word_size_2) {</span>
<span class="changed"> 333     print_scaled_words(st, word_size_1);</span>
<span class="changed"> 334     st-&gt;print (" (no change)");</span>
<span class="changed"> 335   } else {</span>
<span class="changed"> 336     print_scaled_words(st, word_size_1);</span>
<span class="changed"> 337     st-&gt;print("-&gt;");</span>
<span class="changed"> 338     print_scaled_words(st, word_size_2);</span>
<span class="changed"> 339     st-&gt;print(" (");</span>
<span class="changed"> 340     if (word_size_2 &lt;= word_size_1) {</span>
<span class="changed"> 341       st-&gt;print("-");</span>
<span class="changed"> 342       print_scaled_words(st, word_size_1 - word_size_2);</span>
<span class="changed"> 343     } else {</span>
<span class="changed"> 344       st-&gt;print("+");</span>
<span class="changed"> 345       print_scaled_words(st, word_size_2 - word_size_1);</span>
<span class="changed"> 346     }</span>
<span class="changed"> 347     st-&gt;print(")");</span>
 348   }
<a name="64" id="anc64"></a><span class="new"> 349 }</span>
 350 
<a name="65" id="anc65"></a><span class="changed"> 351 // Attempt to reclaim free areas in metaspace wholesale:</span>
<span class="changed"> 352 // - first, attempt to purge nodes of the backing virtual space. This can only be successful</span>
<span class="changed"> 353 //   if whole nodes are only containing free chunks, so it highly depends on fragmentation.</span>
<span class="changed"> 354 // - then, it will uncommit areas of free chunks according to the rules laid down in</span>
<span class="changed"> 355 //   settings (see settings.hpp).</span>
<span class="changed"> 356 void ChunkManager::wholesale_reclaim() {</span>
 357 
<a name="66" id="anc66"></a><span class="changed"> 358   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>


 359 
<a name="67" id="anc67"></a><span class="changed"> 360   UL(info, ": reclaiming memory...");</span>

 361 
<a name="68" id="anc68"></a><span class="changed"> 362   const size_t reserved_before = _vslist-&gt;reserved_words();</span>
<span class="changed"> 363   const size_t committed_before = _vslist-&gt;committed_words();</span>
<span class="changed"> 364   int num_nodes_purged = 0;</span>
<span class="changed"> 365 </span>
<span class="changed"> 366   if (Settings::delete_nodes_on_purge()) {</span>
<span class="changed"> 367     num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);</span>
<span class="changed"> 368     DEBUG_ONLY(InternalStats::inc_num_purges();)</span>
 369   }
<a name="69" id="anc69"></a>
 370 
<a name="70" id="anc70"></a><span class="changed"> 371   if (Settings::uncommit_on_purge()) {</span>
<span class="changed"> 372     const chunklevel_t max_level =</span>
<span class="changed"> 373         chunklevel::level_fitting_word_size(Settings::uncommit_on_purge_min_word_size());</span>
<span class="changed"> 374     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;</span>
<span class="changed"> 375          l &lt;= max_level;</span>
<span class="changed"> 376          l ++)</span>
<span class="changed"> 377     {</span>
<span class="changed"> 378       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 379         c-&gt;uncommit_locked();</span>
<span class="changed"> 380       }</span>
<span class="changed"> 381     }</span>
<span class="changed"> 382     DEBUG_ONLY(InternalStats::inc_num_wholesale_uncommits();)</span>
<span class="changed"> 383   }</span>
 384 
<a name="71" id="anc71"></a><span class="changed"> 385   const size_t reserved_after = _vslist-&gt;reserved_words();</span>
<span class="changed"> 386   const size_t committed_after = _vslist-&gt;committed_words();</span>
 387 
<a name="72" id="anc72"></a><span class="changed"> 388   // Print a nice report.</span>
<span class="changed"> 389   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {</span>
<span class="changed"> 390     UL(info, "nothing reclaimed.");</span>
<span class="changed"> 391   } else {</span>
<span class="changed"> 392     LogTarget(Info, metaspace) lt;</span>
<span class="changed"> 393     if (lt.is_enabled()) {</span>
<span class="changed"> 394       LogStream ls(lt);</span>
<span class="changed"> 395       ls.print_cr(LOGFMT ": finished reclaiming memory: ", LOGFMT_ARGS);</span>
 396 
<a name="73" id="anc73"></a><span class="changed"> 397       ls.print("reserved: ");</span>
<span class="changed"> 398       print_word_size_delta(&amp;ls, reserved_before, reserved_after);</span>
<span class="changed"> 399       ls.cr();</span>
 400 
<a name="74" id="anc74"></a><span class="changed"> 401       ls.print("committed: ");</span>
<span class="changed"> 402       print_word_size_delta(&amp;ls, committed_before, committed_after);</span>
<span class="changed"> 403       ls.cr();</span>


 404 
<a name="75" id="anc75"></a><span class="changed"> 405       ls.print_cr("full nodes purged: %d", num_nodes_purged);</span>










 406     }
<a name="76" id="anc76"></a>




 407   }
 408 
<a name="77" id="anc77"></a><span class="changed"> 409   DEBUG_ONLY(_vslist-&gt;verify_locked(true));</span>
<span class="changed"> 410   DEBUG_ONLY(verify_locked(true));</span>
<span class="changed"> 411 </span>
 412 }
 413 
<a name="78" id="anc78"></a>
 414 
<a name="79" id="anc79"></a><span class="changed"> 415 ChunkManager* ChunkManager::_chunkmanager_class = NULL;</span>
<span class="changed"> 416 ChunkManager* ChunkManager::_chunkmanager_nonclass = NULL;</span>




 417 
<a name="80" id="anc80"></a><span class="changed"> 418 void ChunkManager::set_chunkmanager_class(ChunkManager* cm) {</span>
<span class="changed"> 419   assert(_chunkmanager_class == NULL, "Sanity");</span>
<span class="changed"> 420   _chunkmanager_class = cm;</span>
<span class="changed"> 421 }</span>






























 422 
<a name="81" id="anc81"></a><span class="changed"> 423 void ChunkManager::set_chunkmanager_nonclass(ChunkManager* cm) {</span>
<span class="changed"> 424   assert(_chunkmanager_nonclass == NULL, "Sanity");</span>
<span class="changed"> 425   _chunkmanager_nonclass = cm;</span>
<span class="changed"> 426 }</span>
 427 
<a name="82" id="anc82"></a><span class="changed"> 428 </span>
<span class="changed"> 429 </span>
<span class="changed"> 430 // Update statistics.</span>
<span class="changed"> 431 void ChunkManager::add_to_statistics(cm_stats_t* out) const {</span>
<span class="changed"> 432 </span>
<span class="changed"> 433   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 434 </span>
<span class="changed"> 435   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {</span>
<span class="changed"> 436     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);</span>
<span class="changed"> 437     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);</span>

 438   }
 439 
<a name="83" id="anc83"></a><span class="changed"> 440   DEBUG_ONLY(out-&gt;verify();)</span>
<span class="changed"> 441 </span>
<span class="changed"> 442 }</span>
 443 
 444 #ifdef ASSERT
<a name="84" id="anc84"></a>





 445 
<a name="85" id="anc85"></a><span class="new"> 446 void ChunkManager::verify(bool slow) const {</span>
<span class="new"> 447   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new"> 448   verify_locked(slow);</span>
 449 }
 450 
<a name="86" id="anc86"></a><span class="changed"> 451 void ChunkManager::verify_locked(bool slow) const {</span>
<span class="changed"> 452   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 453   assert(_vslist != NULL, "No vslist");</span>
<span class="changed"> 454   _chunks.verify();</span>






















 455 }
 456 
<a name="87" id="anc87"></a><span class="changed"> 457 bool ChunkManager::contains_chunk(Metachunk* c) const {</span>
<span class="changed"> 458   return _chunks.contains(c);</span>
<span class="changed"> 459 }</span>
<span class="changed"> 460 </span>
<span class="changed"> 461 #endif // ASSERT</span>
<span class="changed"> 462 </span>
<span class="changed"> 463 void ChunkManager::print_on(outputStream* st) const {</span>
<span class="changed"> 464   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 465   print_on_locked(st);</span>
<span class="changed"> 466 }</span>
<span class="changed"> 467 </span>
<span class="changed"> 468 void ChunkManager::print_on_locked(outputStream* st) const {</span>
<span class="changed"> 469   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 470   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="changed"> 471                total_num_chunks(), total_word_size(), _chunks.committed_word_size());</span>
<span class="changed"> 472   _chunks.print_on(st);</span>
 473 }
 474 
 475 } // namespace metaspace
 476 
 477 
 478 
<a name="88" id="anc88"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="88" type="hidden" /></form></body></html>
