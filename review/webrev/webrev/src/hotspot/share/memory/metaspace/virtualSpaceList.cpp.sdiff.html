<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/memory/metaspace </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>

<table><tr valign="top">
<td><pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 
  26 #include "precompiled.hpp"
  27 #include "logging/log.hpp"
<span class="removed">  28 #include "logging/logStream.hpp"</span>
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<span class="changed">  31 #include "memory/metaspace/metachunk.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/metaspaceCommon.hpp"</span>


  33 #include "memory/metaspace/virtualSpaceList.hpp"
  34 #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="removed">  35 #include "runtime/atomic.hpp"</span>
<span class="removed">  36 #include "runtime/orderAccess.hpp"</span>
  37 #include "runtime/mutexLocker.hpp"
<span class="changed">  38 #include "runtime/safepoint.hpp"</span>
  39 
  40 namespace metaspace {
  41 


  42 
<span class="removed">  43 VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="removed">  44   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="removed">  45   while (iter.repeat()) {</span>
<span class="removed">  46     VirtualSpaceNode* vsl = iter.get_next();</span>
<span class="removed">  47     delete vsl;</span>
<span class="removed">  48   }</span>
<span class="removed">  49 }</span>
  50 
<span class="changed">  51 void VirtualSpaceList::inc_reserved_words(size_t v) {</span>
<span class="changed">  52   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  53   _reserved_words = _reserved_words + v;</span>
<span class="changed">  54 }</span>
<span class="changed">  55 void VirtualSpaceList::dec_reserved_words(size_t v) {</span>
<span class="changed">  56   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  57   _reserved_words = _reserved_words - v;</span>
<span class="changed">  58 }</span>
<span class="changed">  59 </span>
<span class="changed">  60 #define assert_committed_below_limit()                        \</span>
<span class="changed">  61   assert(MetaspaceUtils::committed_bytes() &lt;= MaxMetaspaceSize, \</span>
<span class="changed">  62          "Too much committed memory. Committed: " SIZE_FORMAT \</span>
<span class="changed">  63          " limit (MaxMetaspaceSize): " SIZE_FORMAT,           \</span>
<span class="changed">  64           MetaspaceUtils::committed_bytes(), MaxMetaspaceSize);</span>
<span class="changed">  65 </span>
<span class="changed">  66 void VirtualSpaceList::inc_committed_words(size_t v) {</span>
<span class="changed">  67   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  68   _committed_words = _committed_words + v;</span>
  69 
<span class="changed">  70   assert_committed_below_limit();</span>































  71 }
<span class="removed">  72 void VirtualSpaceList::dec_committed_words(size_t v) {</span>
<span class="removed">  73   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed">  74   _committed_words = _committed_words - v;</span>
  75 
<span class="changed">  76   assert_committed_below_limit();</span>









  77 }
  78 
<span class="changed">  79 void VirtualSpaceList::inc_virtual_space_count() {</span>




  80   assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">  81   _virtual_space_count++;</span>
<span class="removed">  82 }</span>
  83 
<span class="changed">  84 void VirtualSpaceList::dec_virtual_space_count() {</span>
<span class="changed">  85   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  86   _virtual_space_count--;</span>





  87 }
  88 
<span class="changed">  89 // Walk the list of VirtualSpaceNodes and delete</span>
<span class="changed">  90 // nodes with a 0 container_count.  Remove Metachunks in</span>
<span class="changed">  91 // the node from their respective freelists.</span>
<span class="changed">  92 void VirtualSpaceList::purge(ChunkManager* chunk_manager) {</span>

  93   assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">  94   // Don't use a VirtualSpaceListIterator because this</span>
<span class="removed">  95   // list is being changed and a straightforward use of an iterator is not safe.</span>
<span class="removed">  96   VirtualSpaceNode* prev_vsl = virtual_space_list();</span>
<span class="removed">  97   VirtualSpaceNode* next_vsl = prev_vsl;</span>
<span class="removed">  98   int num_purged_nodes = 0;</span>
<span class="removed">  99   while (next_vsl != NULL) {</span>
<span class="removed"> 100     VirtualSpaceNode* vsl = next_vsl;</span>
<span class="removed"> 101     DEBUG_ONLY(vsl-&gt;verify(false);)</span>
<span class="removed"> 102     next_vsl = vsl-&gt;next();</span>
<span class="removed"> 103     // Don't free the current virtual space since it will likely</span>
<span class="removed"> 104     // be needed soon.</span>
<span class="removed"> 105     if (vsl-&gt;container_count() == 0 &amp;&amp; vsl != current_virtual_space()) {</span>
<span class="removed"> 106       log_trace(gc, metaspace, freelist)("Purging VirtualSpaceNode " PTR_FORMAT " (capacity: " SIZE_FORMAT</span>
<span class="removed"> 107                                          ", used: " SIZE_FORMAT ").", p2i(vsl), vsl-&gt;capacity_words_in_vs(), vsl-&gt;used_words_in_vs());</span>
<span class="removed"> 108       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_purged));</span>
<span class="removed"> 109       // Unlink it from the list</span>
<span class="removed"> 110       if (prev_vsl == vsl) {</span>
<span class="removed"> 111         // This is the case of the current node being the first node.</span>
<span class="removed"> 112         assert(vsl == virtual_space_list(), "Expected to be the first node");</span>
<span class="removed"> 113         set_virtual_space_list(vsl-&gt;next());</span>
<span class="removed"> 114       } else {</span>
<span class="removed"> 115         prev_vsl-&gt;set_next(vsl-&gt;next());</span>
<span class="removed"> 116       }</span>
<span class="removed"> 117 </span>
<span class="removed"> 118       vsl-&gt;purge(chunk_manager);</span>
<span class="removed"> 119       dec_reserved_words(vsl-&gt;reserved_words());</span>
<span class="removed"> 120       dec_committed_words(vsl-&gt;committed_words());</span>
<span class="removed"> 121       dec_virtual_space_count();</span>
<span class="removed"> 122       delete vsl;</span>
<span class="removed"> 123       num_purged_nodes ++;</span>
<span class="removed"> 124     } else {</span>
<span class="removed"> 125       prev_vsl = vsl;</span>
<span class="removed"> 126     }</span>
<span class="removed"> 127   }</span>
<span class="removed"> 128 </span>
<span class="removed"> 129   // Verify list</span>
<span class="removed"> 130 #ifdef ASSERT</span>
<span class="removed"> 131   if (num_purged_nodes &gt; 0) {</span>
<span class="removed"> 132     verify(false);</span>
<span class="removed"> 133   }</span>
<span class="removed"> 134 #endif</span>
<span class="removed"> 135 }</span>
 136 


 137 
<span class="changed"> 138 // This function looks at the mmap regions in the metaspace without locking.</span>
<span class="changed"> 139 // The chunks are added with store ordering and not deleted except for at</span>
<span class="changed"> 140 // unloading time during a safepoint.</span>
<span class="changed"> 141 VirtualSpaceNode* VirtualSpaceList::find_enclosing_space(const void* ptr) {</span>
<span class="changed"> 142   // List should be stable enough to use an iterator here because removing virtual</span>
<span class="changed"> 143   // space nodes is only allowed at a safepoint.</span>
<span class="changed"> 144   if (is_within_envelope((address)ptr)) {</span>
<span class="changed"> 145     VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed"> 146     while (iter.repeat()) {</span>
<span class="changed"> 147       VirtualSpaceNode* vsn = iter.get_next();</span>
<span class="changed"> 148       if (vsn-&gt;contains(ptr)) {</span>
<span class="changed"> 149         return vsn;</span>
<span class="changed"> 150       }</span>
 151     }
 152   }
<span class="removed"> 153   return NULL;</span>
<span class="removed"> 154 }</span>
 155 
<span class="changed"> 156 void VirtualSpaceList::retire_current_virtual_space() {</span>
<span class="changed"> 157   assert_lock_strong(MetaspaceExpand_lock);</span>
 158 
<span class="changed"> 159   VirtualSpaceNode* vsn = current_virtual_space();</span>
 160 
<span class="changed"> 161   ChunkManager* cm = is_class() ? Metaspace::chunk_manager_class() :</span>
<span class="changed"> 162                                   Metaspace::chunk_manager_metadata();</span>
 163 
<span class="removed"> 164   vsn-&gt;retire(cm);</span>
 165 }
 166 
<span class="changed"> 167 VirtualSpaceList::VirtualSpaceList(size_t word_size) :</span>
<span class="changed"> 168                                    _virtual_space_list(NULL),</span>
<span class="changed"> 169                                    _current_virtual_space(NULL),</span>
<span class="changed"> 170                                    _is_class(false),</span>
<span class="changed"> 171                                    _reserved_words(0),</span>
<span class="changed"> 172                                    _committed_words(0),</span>
<span class="changed"> 173                                    _virtual_space_count(0),</span>
<span class="changed"> 174                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 175                                    _envelope_hi(NULL) {</span>
<span class="changed"> 176   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 177   create_new_virtual_space(word_size);</span>
<span class="changed"> 178 }</span>
<span class="changed"> 179 </span>
<span class="changed"> 180 VirtualSpaceList::VirtualSpaceList(ReservedSpace rs) :</span>
<span class="changed"> 181                                    _virtual_space_list(NULL),</span>
<span class="changed"> 182                                    _current_virtual_space(NULL),</span>
<span class="changed"> 183                                    _is_class(true),</span>
<span class="changed"> 184                                    _reserved_words(0),</span>
<span class="changed"> 185                                    _committed_words(0),</span>
<span class="changed"> 186                                    _virtual_space_count(0),</span>
<span class="changed"> 187                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 188                                    _envelope_hi(NULL) {</span>
<span class="changed"> 189   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 190   VirtualSpaceNode* class_entry = new VirtualSpaceNode(is_class(), rs);</span>
<span class="changed"> 191   bool succeeded = class_entry-&gt;initialize();</span>
<span class="changed"> 192   if (succeeded) {</span>
<span class="changed"> 193     expand_envelope_to_include_node(class_entry);</span>
<span class="changed"> 194     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 195     OrderAccess::storestore();</span>
<span class="changed"> 196     link_vs(class_entry);</span>
<span class="changed"> 197   }</span>
<span class="changed"> 198 }</span>
 199 
<span class="changed"> 200 size_t VirtualSpaceList::free_bytes() {</span>
<span class="changed"> 201   return current_virtual_space()-&gt;free_words_in_vs() * BytesPerWord;</span>
<span class="changed"> 202 }</span>
 203 
<span class="removed"> 204 // Allocate another meta virtual space and add it to the list.</span>
<span class="removed"> 205 bool VirtualSpaceList::create_new_virtual_space(size_t vs_word_size) {</span>
 206   assert_lock_strong(MetaspaceExpand_lock);
 207 
<span class="changed"> 208   if (is_class()) {</span>
<span class="changed"> 209     assert(false, "We currently don't support more than one VirtualSpace for"</span>
<span class="changed"> 210                   " the compressed class space. The initialization of the"</span>
<span class="changed"> 211                   " CCS uses another code path and should not hit this path.");</span>
<span class="changed"> 212     return false;</span>
 213   }
 214 
<span class="changed"> 215   if (vs_word_size == 0) {</span>
<span class="changed"> 216     assert(false, "vs_word_size should always be at least _reserve_alignment large.");</span>
<span class="changed"> 217     return false;</span>
<span class="changed"> 218   }</span>
 219 
<span class="changed"> 220   // Reserve the space</span>
<span class="changed"> 221   size_t vs_byte_size = vs_word_size * BytesPerWord;</span>
<span class="changed"> 222   assert_is_aligned(vs_byte_size, Metaspace::reserve_alignment());</span>
<span class="changed"> 223 </span>
<span class="changed"> 224   // Allocate the meta virtual space and initialize it.</span>
<span class="changed"> 225   VirtualSpaceNode* new_entry = new VirtualSpaceNode(is_class(), vs_byte_size);</span>
<span class="changed"> 226   if (!new_entry-&gt;initialize()) {</span>
<span class="changed"> 227     delete new_entry;</span>
<span class="changed"> 228     return false;</span>
<span class="changed"> 229   } else {</span>
<span class="changed"> 230     assert(new_entry-&gt;reserved_words() == vs_word_size,</span>
<span class="changed"> 231         "Reserved memory size differs from requested memory size");</span>
<span class="changed"> 232     expand_envelope_to_include_node(new_entry);</span>
<span class="changed"> 233     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 234     OrderAccess::storestore();</span>
<span class="changed"> 235     link_vs(new_entry);</span>
<span class="changed"> 236     DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_created));</span>
<span class="changed"> 237     return true;</span>
 238   }
<span class="changed"> 239 </span>
<span class="changed"> 240   DEBUG_ONLY(verify(false);)</span>
<span class="changed"> 241 </span>
<span class="changed"> 242 }</span>
<span class="changed"> 243 </span>
<span class="changed"> 244 void VirtualSpaceList::link_vs(VirtualSpaceNode* new_entry) {</span>
<span class="changed"> 245   if (virtual_space_list() == NULL) {</span>
<span class="changed"> 246       set_virtual_space_list(new_entry);</span>
 247   } else {
<span class="changed"> 248     current_virtual_space()-&gt;set_next(new_entry);</span>
 249   }
<span class="changed"> 250   set_current_virtual_space(new_entry);</span>
<span class="changed"> 251   inc_reserved_words(new_entry-&gt;reserved_words());</span>
<span class="changed"> 252   inc_committed_words(new_entry-&gt;committed_words());</span>
<span class="changed"> 253   inc_virtual_space_count();</span>
<span class="changed"> 254 #ifdef ASSERT</span>
<span class="changed"> 255   new_entry-&gt;mangle();</span>
<span class="changed"> 256 #endif</span>
<span class="changed"> 257   LogTarget(Trace, gc, metaspace) lt;</span>
<span class="changed"> 258   if (lt.is_enabled()) {</span>
<span class="changed"> 259     LogStream ls(lt);</span>
<span class="changed"> 260     VirtualSpaceNode* vsl = current_virtual_space();</span>
<span class="changed"> 261     ResourceMark rm;</span>
<span class="changed"> 262     vsl-&gt;print_on(&amp;ls);</span>
 263   }
<span class="removed"> 264 }</span>
 265 
<span class="changed"> 266 bool VirtualSpaceList::expand_node_by(VirtualSpaceNode* node,</span>
<span class="changed"> 267                                       size_t min_words,</span>
<span class="changed"> 268                                       size_t preferred_words) {</span>
<span class="changed"> 269   size_t before = node-&gt;committed_words();</span>
 270 
<span class="changed"> 271   bool result = node-&gt;expand_by(min_words, preferred_words);</span>
 272 
<span class="removed"> 273   size_t after = node-&gt;committed_words();</span>
<span class="removed"> 274 </span>
<span class="removed"> 275   // after and before can be the same if the memory was pre-committed.</span>
<span class="removed"> 276   assert(after &gt;= before, "Inconsistency");</span>
<span class="removed"> 277   inc_committed_words(after - before);</span>
<span class="removed"> 278 </span>
<span class="removed"> 279   return result;</span>
 280 }
 281 
<span class="changed"> 282 bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {</span>
<span class="changed"> 283   assert_is_aligned(min_words,       Metaspace::commit_alignment_words());</span>
<span class="changed"> 284   assert_is_aligned(preferred_words, Metaspace::commit_alignment_words());</span>
<span class="changed"> 285   assert(min_words &lt;= preferred_words, "Invalid arguments");</span>
<span class="changed"> 286 </span>
<span class="changed"> 287   const char* const class_or_not = (is_class() ? "class" : "non-class");</span>
<span class="changed"> 288 </span>
<span class="changed"> 289   if (!MetaspaceGC::can_expand(min_words, this-&gt;is_class())) {</span>
<span class="changed"> 290     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list.",</span>
<span class="changed"> 291               class_or_not);</span>
<span class="changed"> 292     return  false;</span>
<span class="changed"> 293   }</span>
<span class="changed"> 294 </span>
<span class="changed"> 295   size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();</span>
<span class="changed"> 296   if (allowed_expansion_words &lt; min_words) {</span>
<span class="changed"> 297     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list (must try gc first).",</span>
<span class="changed"> 298               class_or_not);</span>
<span class="changed"> 299     return false;</span>
<span class="changed"> 300   }</span>
<span class="changed"> 301 </span>
<span class="changed"> 302   size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);</span>
<span class="changed"> 303 </span>
<span class="changed"> 304   // Commit more memory from the the current virtual space.</span>
<span class="changed"> 305   bool vs_expanded = expand_node_by(current_virtual_space(),</span>
<span class="changed"> 306                                     min_words,</span>
<span class="changed"> 307                                     max_expansion_words);</span>
<span class="changed"> 308   if (vs_expanded) {</span>
<span class="changed"> 309      log_trace(gc, metaspace, freelist)("Expanded %s virtual space list.",</span>
<span class="changed"> 310                class_or_not);</span>
<span class="changed"> 311      return true;</span>
<span class="changed"> 312   }</span>
<span class="changed"> 313   log_trace(gc, metaspace, freelist)("%s virtual space list: retire current node.",</span>
<span class="changed"> 314             class_or_not);</span>
<span class="changed"> 315   retire_current_virtual_space();</span>
<span class="changed"> 316 </span>
<span class="changed"> 317   // Get another virtual space.</span>
<span class="changed"> 318   size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);</span>
<span class="changed"> 319   grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());</span>
<span class="changed"> 320 </span>
<span class="changed"> 321   if (create_new_virtual_space(grow_vs_words)) {</span>
<span class="changed"> 322     if (current_virtual_space()-&gt;is_pre_committed()) {</span>
<span class="changed"> 323       // The memory was pre-committed, so we are done here.</span>
<span class="changed"> 324       assert(min_words &lt;= current_virtual_space()-&gt;committed_words(),</span>
<span class="changed"> 325           "The new VirtualSpace was pre-committed, so it"</span>
<span class="changed"> 326           "should be large enough to fit the alloc request.");</span>
<span class="changed"> 327       return true;</span>
<span class="changed"> 328     }</span>
 329 
<span class="changed"> 330     return expand_node_by(current_virtual_space(),</span>
<span class="changed"> 331                           min_words,</span>
<span class="changed"> 332                           max_expansion_words);</span>





 333   }
<span class="changed"> 334 </span>
<span class="changed"> 335   return false;</span>
 336 }
 337 
<span class="changed"> 338 // Given a chunk, calculate the largest possible padding space which</span>
<span class="changed"> 339 // could be required when allocating it.</span>
<span class="changed"> 340 static size_t largest_possible_padding_size_for_chunk(size_t chunk_word_size, bool is_class) {</span>
<span class="changed"> 341   const ChunkIndex chunk_type = get_chunk_type_by_size(chunk_word_size, is_class);</span>
<span class="changed"> 342   if (chunk_type != HumongousIndex) {</span>
<span class="changed"> 343     // Normal, non-humongous chunks are allocated at chunk size</span>
<span class="changed"> 344     // boundaries, so the largest padding space required would be that</span>
<span class="changed"> 345     // minus the smallest chunk size.</span>
<span class="changed"> 346     const size_t smallest_chunk_size = is_class ? ClassSpecializedChunk : SpecializedChunk;</span>
<span class="changed"> 347     return chunk_word_size - smallest_chunk_size;</span>
<span class="changed"> 348   } else {</span>
<span class="changed"> 349     // Humongous chunks are allocated at smallest-chunksize</span>
<span class="changed"> 350     // boundaries, so there is no padding required.</span>
<span class="changed"> 351     return 0;</span>
<span class="changed"> 352   }</span>
<span class="changed"> 353 }</span>
 354 

 355 
<span class="changed"> 356 Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {</span>
 357 
<span class="changed"> 358   // Allocate a chunk out of the current virtual space.</span>
<span class="changed"> 359   Metachunk* next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
 360 
<span class="changed"> 361   if (next != NULL) {</span>
<span class="changed"> 362     return next;</span>
<span class="changed"> 363   }</span>
 364 
<span class="changed"> 365   // The expand amount is currently only determined by the requested sizes</span>
<span class="changed"> 366   // and not how much committed memory is left in the current virtual space.</span>












 367 
<span class="changed"> 368   // We must have enough space for the requested size and any</span>
<span class="changed"> 369   // additional reqired padding chunks.</span>
<span class="changed"> 370   const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this-&gt;is_class());</span>
 371 
<span class="changed"> 372   size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());</span>
<span class="changed"> 373   size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());</span>
<span class="changed"> 374   if (min_word_size &gt;= preferred_word_size) {</span>
<span class="changed"> 375     // Can happen when humongous chunks are allocated.</span>
<span class="changed"> 376     preferred_word_size = min_word_size;</span>
<span class="changed"> 377   }</span>
 378 
<span class="removed"> 379   bool expanded = expand_by(min_word_size, preferred_word_size);</span>
<span class="removed"> 380   if (expanded) {</span>
<span class="removed"> 381     next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
<span class="removed"> 382     assert(next != NULL, "The allocation was expected to succeed after the expansion");</span>
 383   }

 384 
<span class="changed"> 385    return next;</span>


 386 }

 387 
<span class="changed"> 388 void VirtualSpaceList::print_on(outputStream* st, size_t scale) const {</span>
<span class="changed"> 389   st-&gt;print_cr(SIZE_FORMAT " nodes, current node: " PTR_FORMAT,</span>
<span class="changed"> 390       _virtual_space_count, p2i(_current_virtual_space));</span>
<span class="changed"> 391   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed"> 392   while (iter.repeat()) {</span>
<span class="changed"> 393     st-&gt;cr();</span>
<span class="changed"> 394     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 395     node-&gt;print_on(st, scale);</span>
 396   }



 397 }
 398 
<span class="changed"> 399 void VirtualSpaceList::print_map(outputStream* st) const {</span>
<span class="changed"> 400   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="changed"> 401   VirtualSpaceListIterator iter(list);</span>
<span class="changed"> 402   unsigned i = 0;</span>
<span class="changed"> 403   while (iter.repeat()) {</span>
<span class="changed"> 404     st-&gt;print_cr("Node %u:", i);</span>
<span class="changed"> 405     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 406     node-&gt;print_map(st, this-&gt;is_class());</span>
<span class="changed"> 407     i ++;</span>
 408   }

 409 }
 410 
<span class="changed"> 411 // Given a node, expand range such that it includes the node.</span>
<span class="changed"> 412 void VirtualSpaceList::expand_envelope_to_include_node(const VirtualSpaceNode* node) {</span>
<span class="changed"> 413   _envelope_lo = MIN2(_envelope_lo, (address)node-&gt;low_boundary());</span>
<span class="changed"> 414   _envelope_hi = MAX2(_envelope_hi, (address)node-&gt;high_boundary());</span>
<span class="changed"> 415 }</span>
 416 




 417 
<span class="changed"> 418 #ifdef ASSERT</span>
<span class="changed"> 419 void VirtualSpaceList::verify(bool slow) {</span>
<span class="changed"> 420   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="changed"> 421   VirtualSpaceListIterator iter(list);</span>
<span class="changed"> 422   size_t reserved = 0;</span>
<span class="changed"> 423   size_t committed = 0;</span>
<span class="changed"> 424   size_t node_count = 0;</span>
<span class="changed"> 425   while (iter.repeat()) {</span>
<span class="changed"> 426     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 427     if (slow) {</span>
<span class="changed"> 428       node-&gt;verify(true);</span>
<span class="changed"> 429     }</span>
<span class="changed"> 430     // Check that the node resides fully within our envelope.</span>
<span class="changed"> 431     assert((address)node-&gt;low_boundary() &gt;= _envelope_lo &amp;&amp; (address)node-&gt;high_boundary() &lt;= _envelope_hi,</span>
<span class="changed"> 432            "Node " SIZE_FORMAT " [" PTR_FORMAT ", " PTR_FORMAT ") outside envelope [" PTR_FORMAT ", " PTR_FORMAT ").",</span>
<span class="changed"> 433            node_count, p2i(node-&gt;low_boundary()), p2i(node-&gt;high_boundary()), p2i(_envelope_lo), p2i(_envelope_hi));</span>
<span class="changed"> 434     reserved += node-&gt;reserved_words();</span>
<span class="changed"> 435     committed += node-&gt;committed_words();</span>
<span class="changed"> 436     node_count ++;</span>
<span class="changed"> 437   }</span>
<span class="changed"> 438   assert(reserved == reserved_words() &amp;&amp; committed == committed_words() &amp;&amp; node_count == _virtual_space_count,</span>
<span class="changed"> 439       "Mismatch: reserved real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="changed"> 440       ", committed real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="changed"> 441       ", node count real: " SIZE_FORMAT " expected: " SIZE_FORMAT ".",</span>
<span class="changed"> 442       reserved, reserved_words(), committed, committed_words(),</span>
<span class="changed"> 443       node_count, _virtual_space_count);</span>
 444 }
<span class="removed"> 445 #endif // ASSERT</span>
 446 
 447 } // namespace metaspace
</pre></td><td><pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="new">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 
  27 #include "precompiled.hpp"
  28 #include "logging/log.hpp"

  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<span class="changed">  31 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/freeChunkList.hpp"</span>
  35 #include "memory/metaspace/virtualSpaceList.hpp"
  36 #include "memory/metaspace/virtualSpaceNode.hpp"


  37 #include "runtime/mutexLocker.hpp"
<span class="changed">  38 </span>
  39 
  40 namespace metaspace {
  41 
<span class="new">  42 #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"</span>
<span class="new">  43 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  44 







  45 
<span class="changed">  46 static int next_node_id = 0;</span>

















  47 
<span class="changed">  48 // Create a new, empty, expandable list.</span>
<span class="changed">  49 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">  50   : _name(name),</span>
<span class="changed">  51     _first_node(NULL),</span>
<span class="changed">  52     _can_expand(true),</span>
<span class="changed">  53     _can_purge(true),</span>
<span class="changed">  54     _commit_limiter(commit_limiter),</span>
<span class="changed">  55     _reserved_words_counter(),</span>
<span class="changed">  56     _committed_words_counter()</span>
<span class="changed">  57 {</span>
<span class="changed">  58 }</span>
<span class="changed">  59 </span>
<span class="changed">  60 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">  61 // It will be not expandable beyond that first node.</span>
<span class="changed">  62 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">  63 : _name(name),</span>
<span class="changed">  64   _first_node(NULL),</span>
<span class="changed">  65   _can_expand(false),</span>
<span class="changed">  66   _can_purge(false),</span>
<span class="changed">  67   _commit_limiter(commit_limiter),</span>
<span class="changed">  68   _reserved_words_counter(),</span>
<span class="changed">  69   _committed_words_counter()</span>
<span class="changed">  70 {</span>
<span class="changed">  71   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">  72   // for this list since we cannot expand.</span>
<span class="changed">  73   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(next_node_id++,</span>
<span class="changed">  74                                                         rs, _commit_limiter,</span>
<span class="changed">  75                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">  76   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">  77   _first_node = vsn;</span>
<span class="changed">  78   _first_node-&gt;set_next(NULL);</span>
<span class="changed">  79   _nodes_counter.increment();</span>
  80 }



  81 
<span class="changed">  82 VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="changed">  83   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">  84   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">  85   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">  86   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">  87   while (vsn != NULL) {</span>
<span class="changed">  88     vsn2 = vsn-&gt;next();</span>
<span class="changed">  89     delete vsn;</span>
<span class="changed">  90     vsn = vsn2;</span>
<span class="changed">  91   }</span>
  92 }
  93 
<span class="changed">  94 // Create a new node and append it to the list. After</span>
<span class="changed">  95 // this function, _current_node shall point to a new empty node.</span>
<span class="changed">  96 // List must be expandable for this to work.</span>
<span class="changed">  97 void VirtualSpaceList::create_new_node() {</span>
<span class="changed">  98   assert(_can_expand, "List is not expandable");</span>
  99   assert_lock_strong(MetaspaceExpand_lock);


 100 
<span class="changed"> 101   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(next_node_id ++,</span>
<span class="changed"> 102                                                         Settings::virtual_space_node_default_word_size(),</span>
<span class="changed"> 103                                                         _commit_limiter,</span>
<span class="changed"> 104                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed"> 105   assert(vsn != NULL, "node creation failed");</span>
<span class="changed"> 106   vsn-&gt;set_next(_first_node);</span>
<span class="changed"> 107   _first_node = vsn;</span>
<span class="changed"> 108   _nodes_counter.increment();</span>
 109 }
 110 
<span class="changed"> 111 // Allocate a root chunk from this list.</span>
<span class="changed"> 112 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 113 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 114 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 115 Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
 116   assert_lock_strong(MetaspaceExpand_lock);










































 117 
<span class="new"> 118   if (_first_node == NULL ||</span>
<span class="new"> 119       _first_node-&gt;free_words() == 0) {</span>
 120 
<span class="changed"> 121     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="changed"> 122     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="changed"> 123     // we should never have left-over space.</span>
<span class="changed"> 124     assert(_first_node == NULL ||</span>
<span class="changed"> 125            _first_node-&gt;free_words() == 0, "Sanity");</span>
<span class="changed"> 126 </span>
<span class="changed"> 127     if (_can_expand) {</span>
<span class="changed"> 128       create_new_node();</span>
<span class="changed"> 129       UL2(debug, "added new node (now: %d).", num_nodes());</span>
<span class="changed"> 130     } else {</span>
<span class="changed"> 131       UL(debug, "list cannot expand.");</span>
<span class="changed"> 132       return NULL; // We cannot expand this list.</span>

 133     }
 134   }


 135 
<span class="changed"> 136   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>

 137 
<span class="changed"> 138   assert(c != NULL, "This should have worked");</span>
 139 
<span class="changed"> 140   return c;</span>

 141 

 142 }
 143 
<span class="changed"> 144 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed"> 145 // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed"> 146 // Return number of purged nodes.</span>
<span class="changed"> 147 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>




























 148 
<span class="changed"> 149   // Note: I am not sure all that purging business is even necessary anymore</span>
<span class="changed"> 150   // since we have a good reclaim mechanism in place. Need to measure.</span>

 151 


 152   assert_lock_strong(MetaspaceExpand_lock);
 153 
<span class="changed"> 154   if (_can_purge == false) {</span>
<span class="changed"> 155     return 0;</span>



 156   }
 157 
<span class="changed"> 158   UL(debug, "purging.");</span>



 159 
<span class="changed"> 160   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 161   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed"> 162   int num = 0, num_purged = 0;</span>
<span class="changed"> 163   while (vsn != NULL) {</span>
<span class="changed"> 164     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed"> 165     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed"> 166     if (purged) {</span>
<span class="changed"> 167       // Note: from now on do not dereference vsn!</span>
<span class="changed"> 168       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));</span>
<span class="changed"> 169       if (_first_node == vsn) {</span>
<span class="changed"> 170         _first_node = next_vsn;</span>
<span class="changed"> 171       }</span>
<span class="changed"> 172       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed"> 173       if (prev_vsn != NULL) {</span>
<span class="changed"> 174         prev_vsn-&gt;set_next(next_vsn);</span>



 175       }
<span class="changed"> 176       num_purged ++;</span>
<span class="changed"> 177       _nodes_counter.decrement();</span>






 178     } else {
<span class="changed"> 179       prev_vsn = vsn;</span>
 180     }
<span class="changed"> 181     vsn = next_vsn;</span>
<span class="changed"> 182     num ++;</span>











 183   }

 184 
<span class="changed"> 185   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());</span>



 186 
<span class="changed"> 187   return num_purged;</span>
 188 







 189 }
 190 
<span class="changed"> 191 // Print all nodes in this space list.</span>
<span class="changed"> 192 void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed"> 193   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>












































 194 
<span class="changed"> 195   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed"> 196   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 197   int n = 0;</span>
<span class="changed"> 198   while (vsn != NULL) {</span>
<span class="changed"> 199     st-&gt;print("- node #%d: ", n);</span>
<span class="changed"> 200     vsn-&gt;print_on(st);</span>
<span class="changed"> 201     vsn = vsn-&gt;next();</span>
<span class="changed"> 202     n ++;</span>
 203   }
<span class="changed"> 204   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="changed"> 205                n, reserved_words(), committed_words());</span>
 206 }
 207 
<span class="changed"> 208 #ifdef ASSERT</span>
<span class="changed"> 209 void VirtualSpaceList::verify_locked(bool slow) const {</span>














 210 
<span class="new"> 211   assert_lock_strong(MetaspaceExpand_lock);</span>
 212 
<span class="changed"> 213   assert(_name != NULL, "Sanity");</span>
 214 
<span class="changed"> 215   int n = 0;</span>

 216 
<span class="changed"> 217   if (_first_node != NULL) {</span>


 218 
<span class="changed"> 219     size_t total_reserved_words = 0;</span>
<span class="changed"> 220     size_t total_committed_words = 0;</span>
<span class="changed"> 221     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 222     while (vsn != NULL) {</span>
<span class="changed"> 223       n ++;</span>
<span class="changed"> 224       vsn-&gt;verify(slow);</span>
<span class="changed"> 225       total_reserved_words += vsn-&gt;word_size();</span>
<span class="changed"> 226       total_committed_words += vsn-&gt;committed_words();</span>
<span class="changed"> 227       vsn = vsn-&gt;next();</span>
<span class="changed"> 228     }</span>
<span class="changed"> 229 </span>
<span class="changed"> 230     _nodes_counter.check(n);</span>
<span class="changed"> 231     _reserved_words_counter.check(total_reserved_words);</span>
<span class="changed"> 232     _committed_words_counter.check(total_committed_words);</span>
 233 
<span class="changed"> 234   } else {</span>


 235 
<span class="changed"> 236     _reserved_words_counter.check(0);</span>
<span class="changed"> 237     _committed_words_counter.check(0);</span>




 238 




 239   }
<span class="new"> 240 }</span>
 241 
<span class="changed"> 242 void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed"> 243   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 244   verify_locked(slow);</span>
 245 }
<span class="new"> 246 #endif</span>
 247 
<span class="changed"> 248 // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed"> 249 bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed"> 250   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 251   while (vsn != NULL) {</span>
<span class="changed"> 252     if (vsn-&gt;contains(p)) {</span>
<span class="changed"> 253       return true;</span>


 254     }
<span class="new"> 255     vsn = vsn-&gt;next();</span>
<span class="new"> 256   }</span>
<span class="new"> 257   return false;</span>
 258 }
 259 
<span class="changed"> 260 // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed"> 261 // can be allocated.</span>
<span class="changed"> 262 bool VirtualSpaceList::is_full() const {</span>
<span class="changed"> 263   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed"> 264     return true;</span>




 265   }
<span class="new"> 266   return false;</span>
 267 }
 268 
<span class="changed"> 269 VirtualSpaceList* VirtualSpaceList::_vslist_class = NULL;</span>
<span class="changed"> 270 VirtualSpaceList* VirtualSpaceList::_vslist_nonclass = NULL;</span>



 271 
<span class="new"> 272 void VirtualSpaceList::set_vslist_class(VirtualSpaceList* vsl) {</span>
<span class="new"> 273   assert(_vslist_class == NULL, "Sanity");</span>
<span class="new"> 274   _vslist_class = vsl;</span>
<span class="new"> 275 }</span>
 276 
<span class="changed"> 277 void VirtualSpaceList::set_vslist_nonclass(VirtualSpaceList* vsl) {</span>
<span class="changed"> 278   assert(_vslist_nonclass == NULL, "Sanity");</span>
<span class="changed"> 279   _vslist_nonclass = vsl;</span>























 280 }

 281 
 282 } // namespace metaspace
</pre></td>
</tr></table>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
