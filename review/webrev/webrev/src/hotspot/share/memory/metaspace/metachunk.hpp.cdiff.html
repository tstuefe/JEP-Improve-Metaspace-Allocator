<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace/metachunk.hpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metaspaceCommon.cpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/metachunk.hpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60318">60318</a> : imported patch big.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
  /*
<span class="changed">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="newmarker">--- 1,8 ----</span>
  /*
<span class="changed">!  * Copyright (c) 2019, SAP SE. All rights reserved.</span>
<span class="changed">!  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<hr /><span class="oldmarker">*** 22,173 ****</span>
   *
   */
  #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  
<span class="changed">! #include "memory/metaspace/metabase.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceCommon.hpp"</span>
  #include "utilities/debug.hpp"
  #include "utilities/globalDefinitions.hpp"
  
<span class="changed">! class MetachunkTest;</span>
  
  namespace metaspace {
  
  class VirtualSpaceNode;
  
  //  Metachunk - Quantum of allocation from a Virtualspace
  //    Metachunks are reused (when freed are put on a global freelist) and
  //    have no permanent association to a SpaceManager.
  
<span class="changed">! //            +--------------+ &lt;- end    --+       --+</span>
  //            |              |             |         |
  //            |              |             | free    |
  //            |              |             |         |
<span class="changed">! //            |              |             |         | size | capacity</span>
<span class="changed">! //            |              |             |         |</span>
<span class="changed">! //            |              | &lt;- top   -- +         |</span>
  //            |              |             |         |
  //            |              |             | used    |
<span class="changed">! //            |              |             |         |</span>
<span class="changed">! //            |              |             |         |</span>
<span class="changed">! //            +--------------+ &lt;- bottom --+       --+</span>
<span class="changed">! </span>
<span class="changed">! enum ChunkOrigin {</span>
<span class="changed">!   // Chunk normally born (via take_from_committed)</span>
<span class="changed">!   origin_normal = 1,</span>
<span class="changed">!   // Chunk was born as padding chunk</span>
<span class="changed">!   origin_pad = 2,</span>
<span class="changed">!   // Chunk was born as leftover chunk in VirtualSpaceNode::retire</span>
<span class="changed">!   origin_leftover = 3,</span>
<span class="changed">!   // Chunk was born as result of a merge of smaller chunks</span>
<span class="changed">!   origin_merge = 4,</span>
<span class="changed">!   // Chunk was born as result of a split of a larger chunk</span>
<span class="changed">!   origin_split = 5,</span>
<span class="changed">! </span>
<span class="changed">!   origin_minimum = origin_normal,</span>
<span class="changed">!   origin_maximum = origin_split,</span>
<span class="changed">!   origins_count = origin_maximum + 1</span>
<span class="changed">! };</span>
  
<span class="changed">! inline bool is_valid_chunkorigin(ChunkOrigin origin) {</span>
<span class="changed">!   return origin == origin_normal ||</span>
<span class="changed">!     origin == origin_pad ||</span>
<span class="changed">!     origin == origin_leftover ||</span>
<span class="changed">!     origin == origin_merge ||</span>
<span class="changed">!     origin == origin_split;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! class Metachunk : public Metabase&lt;Metachunk&gt; {</span>
<span class="changed">! </span>
<span class="changed">!   friend class ::MetachunkTest;</span>
<span class="changed">! </span>
<span class="changed">!   // The VirtualSpaceNode containing this chunk.</span>
<span class="changed">!   VirtualSpaceNode* const _container;</span>
<span class="changed">! </span>
<span class="changed">!   // Current allocation top.</span>
<span class="changed">!   MetaWord* _top;</span>
<span class="changed">! </span>
<span class="changed">!   // A 32bit sentinel for debugging purposes.</span>
<span class="changed">!   enum { CHUNK_SENTINEL = 0x4d4554EF,  // "MET"</span>
<span class="changed">!          CHUNK_SENTINEL_INVALID = 0xFEEEEEEF</span>
    };
  
<span class="changed">!   uint32_t _sentinel;</span>
<span class="changed">! </span>
<span class="changed">!   const ChunkIndex _chunk_type;</span>
<span class="changed">!   const bool _is_class;</span>
<span class="changed">!   // Whether the chunk is free (in freelist) or in use by some class loader.</span>
<span class="changed">!   bool _is_tagged_free;</span>
<span class="changed">! </span>
<span class="changed">!   ChunkOrigin _origin;</span>
<span class="changed">!   int _use_count;</span>
<span class="changed">! </span>
<span class="changed">!   MetaWord* initial_top() const { return (MetaWord*)this + overhead(); }</span>
<span class="changed">!   MetaWord* top() const         { return _top; }</span>
<span class="changed">! </span>
<span class="changed">!  public:</span>
<span class="changed">!   // Metachunks are allocated out of a MetadataVirtualSpace and</span>
<span class="changed">!   // and use some of its space to describe itself (plus alignment</span>
<span class="changed">!   // considerations).  Metadata is allocated in the rest of the chunk.</span>
<span class="changed">!   // This size is the overhead of maintaining the Metachunk within</span>
<span class="changed">!   // the space.</span>
<span class="changed">! </span>
<span class="changed">!   // Alignment of each allocation in the chunks.</span>
<span class="changed">!   static size_t object_alignment();</span>
<span class="changed">! </span>
<span class="changed">!   // Size of the Metachunk header, in words, including alignment.</span>
<span class="changed">!   static size_t overhead();</span>
  
<span class="changed">!   Metachunk(ChunkIndex chunktype, bool is_class, size_t word_size, VirtualSpaceNode* container);</span>
<span class="changed">! </span>
<span class="changed">!   MetaWord* allocate(size_t word_size);</span>
<span class="changed">! </span>
<span class="changed">!   VirtualSpaceNode* container() const { return _container; }</span>
<span class="changed">! </span>
<span class="changed">!   MetaWord* bottom() const { return (MetaWord*) this; }</span>
<span class="changed">! </span>
<span class="changed">!   // Reset top to bottom so chunk can be reused.</span>
<span class="changed">!   void reset_empty() { _top = initial_top(); clear_next(); clear_prev(); }</span>
<span class="changed">!   bool is_empty() { return _top == initial_top(); }</span>
<span class="changed">! </span>
<span class="changed">!   // used (has been allocated)</span>
<span class="changed">!   // free (available for future allocations)</span>
<span class="changed">!   size_t word_size() const { return size(); }</span>
<span class="changed">!   size_t used_word_size() const;</span>
<span class="changed">!   size_t free_word_size() const;</span>
<span class="changed">! </span>
<span class="changed">!   bool is_tagged_free() { return _is_tagged_free; }</span>
<span class="changed">!   void set_is_tagged_free(bool v) { _is_tagged_free = v; }</span>
<span class="changed">! </span>
<span class="changed">!   bool contains(const void* ptr) { return bottom() &lt;= ptr &amp;&amp; ptr &lt; _top; }</span>
  
    void print_on(outputStream* st) const;
  
<span class="removed">-   bool is_valid_sentinel() const        { return _sentinel == CHUNK_SENTINEL; }</span>
<span class="removed">-   void remove_sentinel()                { _sentinel = CHUNK_SENTINEL_INVALID; }</span>
<span class="removed">- </span>
<span class="removed">-   int get_use_count() const             { return _use_count; }</span>
<span class="removed">-   void inc_use_count()                  { _use_count ++; }</span>
<span class="removed">- </span>
<span class="removed">-   ChunkOrigin get_origin() const        { return _origin; }</span>
<span class="removed">-   void set_origin(ChunkOrigin orig)     { _origin = orig; }</span>
<span class="removed">- </span>
<span class="removed">-   ChunkIndex get_chunk_type() const     { return _chunk_type; }</span>
<span class="removed">-   bool is_class() const                 { return _is_class; }</span>
<span class="removed">- </span>
<span class="removed">-   DEBUG_ONLY(void mangle(juint word_value);)</span>
<span class="removed">-   DEBUG_ONLY(void verify() const;)</span>
<span class="removed">- </span>
  };
  
  
<span class="changed">! // Helper function that does a bunch of checks for a chunk.</span>
<span class="changed">! DEBUG_ONLY(void do_verify_chunk(Metachunk* chunk);)</span>
<span class="changed">! </span>
<span class="changed">! // Given a Metachunk, update its in-use information (both in the</span>
<span class="changed">! // chunk and the occupancy map).</span>
<span class="changed">! void do_update_in_use_info_for_chunk(Metachunk* chunk, bool inuse);</span>
  
  } // namespace metaspace
  
  #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
<span class="newmarker">--- 23,272 ----</span>
   *
   */
  #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  
<span class="changed">! </span>
<span class="changed">! #include "memory/metaspace/counter.hpp"</span>
<span class="changed">! #include "memory/metaspace/chunkLevel.hpp"</span>
  #include "utilities/debug.hpp"
  #include "utilities/globalDefinitions.hpp"
  
<span class="changed">! </span>
<span class="changed">! class outputStream;</span>
  
  namespace metaspace {
  
  class VirtualSpaceNode;
  
<span class="new">+ // Todo: comment is outdated.</span>
<span class="new">+ </span>
  //  Metachunk - Quantum of allocation from a Virtualspace
  //    Metachunks are reused (when freed are put on a global freelist) and
  //    have no permanent association to a SpaceManager.
  
<span class="changed">! //            +--------------+ &lt;- end    ----+         --+</span>
  //            |              |               |           |
  //            |              |               | free      |
<span class="new">+ //            |              |               |</span>
<span class="new">+ //            |              |               |           | size (aka capacity)</span>
  //            |              |               |           |
<span class="changed">! //            | -----------  | &lt;- top     -- +           |</span>
  //            |              |               |           |
  //            |              |               | used      |
<span class="changed">! //            +--------------+ &lt;- start   -- +        -- +</span>
  
<span class="changed">! // Note: this is a chunk **descriptor**. The real Payload area lives in metaspace,</span>
<span class="changed">! // this class lives somewhere else.</span>
<span class="changed">! class Metachunk {</span>
<span class="changed">! </span>
<span class="changed">!   // start of chunk memory; NULL if dead.</span>
<span class="changed">!   MetaWord* _base;</span>
<span class="changed">! </span>
<span class="changed">!   // Used words.</span>
<span class="changed">!   size_t _used_words;</span>
<span class="changed">! </span>
<span class="changed">!   // Size of the region, starting from base, which is guaranteed to be committed. In words.</span>
<span class="changed">!   //  The actual size of committed regions may actually be larger.</span>
<span class="changed">!   //</span>
<span class="changed">!   //  (This is a performance optimization. The underlying VirtualSpaceNode knows</span>
<span class="changed">!   //   which granules are committed; but we want to avoid having to ask.)</span>
<span class="changed">!   size_t _committed_words;</span>
<span class="changed">! </span>
<span class="changed">!   chunklevel_t _level; // aka size.</span>
<span class="changed">! </span>
<span class="changed">!   // state_free:    free, owned by ChunkManager</span>
<span class="changed">!   // state_in_use:  in-use, owned by SpaceManager</span>
<span class="changed">!   // dead:          just a hollow chunk header without associated memory, owned</span>
<span class="changed">!   //                 by chunk header pool.</span>
<span class="changed">!   enum state_t {</span>
<span class="changed">!     state_free = 0,</span>
<span class="changed">!     state_in_use = 1,</span>
<span class="changed">!     state_dead = 2</span>
    };
<span class="new">+   state_t _state;</span>
  
<span class="changed">!   // We need unfortunately a back link to the virtual space node</span>
<span class="changed">!   // for splitting and merging nodes.</span>
<span class="changed">!   VirtualSpaceNode* _vsnode;</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!   // A chunk header is kept in a list:</span>
<span class="changed">!   // 1 in the list of used chunks inside a SpaceManager, if it is in use</span>
<span class="changed">!   // 2 in the list of free chunks inside a ChunkManager, if it is free</span>
<span class="changed">!   // 3 in the freelist of unused headers inside the ChunkHeaderPool,</span>
<span class="changed">!   //   if it is unused (e.g. result of chunk merging) and has no associated</span>
<span class="changed">!   //   memory area.</span>
<span class="changed">!   Metachunk* _prev;</span>
<span class="changed">!   Metachunk* _next;</span>
<span class="changed">! </span>
<span class="changed">!   // Furthermore, we keep, per chunk, information about the neighboring chunks.</span>
<span class="changed">!   // This is needed to split and merge chunks.</span>
<span class="changed">!   //</span>
<span class="changed">!   // Note: These members can be modified concurrently while a chunk is alive and in use.</span>
<span class="changed">!   // This can happen if a neighboring chunk is added or removed.</span>
<span class="changed">!   // This means only read or modify these members under expand lock protection.</span>
<span class="changed">!   Metachunk* _prev_in_vs;</span>
<span class="changed">!   Metachunk* _next_in_vs;</span>
<span class="changed">! </span>
<span class="changed">!   // Commit uncommitted section of the chunk.</span>
<span class="changed">!   // Fails if we hit a commit limit.</span>
<span class="changed">!   bool commit_up_to(size_t new_committed_words);</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(static void assert_have_expand_lock();)</span>
<span class="changed">! </span>
<span class="changed">! public:</span>
<span class="changed">! </span>
<span class="changed">!   Metachunk()</span>
<span class="changed">!     : _base(NULL),</span>
<span class="changed">!       _used_words(0),</span>
<span class="changed">!       _committed_words(0),</span>
<span class="changed">!       _level(chunklevel::ROOT_CHUNK_LEVEL),</span>
<span class="changed">!       _state(state_free),</span>
<span class="changed">!       _vsnode(NULL),</span>
<span class="changed">!       _prev(NULL), _next(NULL),</span>
<span class="changed">!       _prev_in_vs(NULL), _next_in_vs(NULL)</span>
<span class="changed">!   {}</span>
<span class="changed">! </span>
<span class="changed">!  void clear() {</span>
<span class="changed">!    _base = NULL;</span>
<span class="changed">!    _used_words = 0;</span>
<span class="changed">!    _committed_words = 0;</span>
<span class="changed">!    _level = chunklevel::ROOT_CHUNK_LEVEL;</span>
<span class="changed">!    _state = state_free;</span>
<span class="changed">!    _vsnode = NULL;</span>
<span class="changed">!    _prev = NULL;</span>
<span class="changed">!    _next = NULL;</span>
<span class="changed">!    _prev_in_vs = NULL;</span>
<span class="changed">!    _next_in_vs = NULL;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!   size_t word_size() const        { return chunklevel::word_size_for_level(_level); }</span>
<span class="changed">! </span>
<span class="changed">!   MetaWord* base() const          { return _base; }</span>
<span class="changed">!   MetaWord* top() const           { return base() + _used_words; }</span>
<span class="changed">!   MetaWord* committed_top() const { return base() + _committed_words; }</span>
<span class="changed">!   MetaWord* end() const           { return base() + word_size(); }</span>
<span class="changed">! </span>
<span class="changed">!   // Chunk list wiring</span>
<span class="changed">!   void set_prev(Metachunk* c)     { _prev = c; }</span>
<span class="changed">!   Metachunk* prev() const         { return _prev; }</span>
<span class="changed">!   void set_next(Metachunk* c)     { _next = c; }</span>
<span class="changed">!   Metachunk* next() const         { return _next; }</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(bool in_list() const { return _prev != NULL || _next != NULL; })</span>
<span class="changed">! </span>
<span class="changed">!   // Physical neighbors wiring</span>
<span class="changed">!   void set_prev_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _prev_in_vs = c; }</span>
<span class="changed">!   Metachunk* prev_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _prev_in_vs; }</span>
<span class="changed">!   void set_next_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _next_in_vs = c; }</span>
<span class="changed">!   Metachunk* next_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _next_in_vs; }</span>
<span class="changed">! </span>
<span class="changed">!   bool is_free() const            { return _state == state_free; }</span>
<span class="changed">!   bool is_in_use() const          { return _state == state_in_use; }</span>
<span class="changed">!   bool is_dead() const            { return _state == state_dead; }</span>
<span class="changed">!   void set_free()                 { _state = state_free; }</span>
<span class="changed">!   void set_in_use()               { _state = state_in_use; }</span>
<span class="changed">!   void set_dead()                 { _state = state_dead; }</span>
<span class="changed">! </span>
<span class="changed">!   // Return a single char presentation of the state ('f', 'u', 'd')</span>
<span class="changed">!   char get_state_char() const;</span>
<span class="changed">! </span>
<span class="changed">!   void inc_level()                { _level ++; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }</span>
<span class="changed">!   void dec_level()                { _level --; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }</span>
<span class="changed">!   chunklevel_t level() const          { return _level; }</span>
<span class="changed">! </span>
<span class="changed">!   // Convenience functions for extreme levels.</span>
<span class="changed">!   bool is_root_chunk() const      { return chunklevel::ROOT_CHUNK_LEVEL == _level; }</span>
<span class="changed">!   bool is_leaf_chunk() const      { return chunklevel::HIGHEST_CHUNK_LEVEL == _level; }</span>
<span class="changed">! </span>
<span class="changed">!   VirtualSpaceNode* vsnode() const        { return _vsnode; }</span>
<span class="changed">! </span>
<span class="changed">!   size_t used_words() const                   { return _used_words; }</span>
<span class="changed">!   size_t free_words() const                   { return word_size() - used_words(); }</span>
<span class="changed">!   size_t free_below_committed_words() const   { return committed_words() - used_words(); }</span>
<span class="changed">!   void reset_used_words()                     { _used_words = 0; }</span>
<span class="changed">! </span>
<span class="changed">!   size_t committed_words() const      { return _committed_words; }</span>
<span class="changed">!   void set_committed_words(size_t v);</span>
<span class="changed">!   bool is_fully_committed() const     { return committed_words() == word_size(); }</span>
<span class="changed">!   bool is_fully_uncommitted() const   { return committed_words() == 0; }</span>
<span class="changed">! </span>
<span class="changed">!   // Ensure that chunk is committed up to at least new_committed_words words.</span>
<span class="changed">!   // Fails if we hit a commit limit.</span>
<span class="changed">!   bool ensure_committed(size_t new_committed_words);</span>
<span class="changed">!   bool ensure_committed_locked(size_t new_committed_words);</span>
<span class="changed">! </span>
<span class="changed">!   bool ensure_fully_committed()           { return ensure_committed(word_size()); }</span>
<span class="changed">!   bool ensure_fully_committed_locked()    { return ensure_committed_locked(word_size()); }</span>
<span class="changed">! </span>
<span class="changed">!   // Ensure that the chunk is committed far enough to serve an additional allocation of word_size.</span>
<span class="changed">!   bool ensure_committed_additional(size_t additional_word_size)   {</span>
<span class="changed">!     return ensure_committed(used_words() + additional_word_size);</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Uncommit chunk area. The area must be a common multiple of the</span>
<span class="changed">!   // commit granule size (in other words, we cannot uncommit chunks smaller than</span>
<span class="changed">!   // a commit granule size).</span>
<span class="changed">!   void uncommit();</span>
<span class="changed">!   void uncommit_locked();</span>
<span class="changed">! </span>
<span class="changed">!   // Allocation from a chunk</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate word_size words from this chunk (word_size must be aligned to</span>
<span class="changed">!   //  allocation_alignment_words).</span>
<span class="changed">!   //</span>
<span class="changed">!   // Caller must make sure the chunk is both large enough and committed far enough</span>
<span class="changed">!   // to hold the allocation. Will always work.</span>
<span class="changed">!   //</span>
<span class="changed">!   MetaWord* allocate(size_t request_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Initialize structure for reuse.</span>
<span class="changed">!   void initialize(VirtualSpaceNode* node, MetaWord* base, chunklevel_t lvl) {</span>
<span class="changed">!     _vsnode = node; _base = base; _level = lvl;</span>
<span class="changed">!     _used_words = _committed_words = 0; _state = state_free;</span>
<span class="changed">!     _next = _prev = _next_in_vs = _prev_in_vs = NULL;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Returns true if this chunk is the leader in its buddy pair, false if not.</span>
<span class="changed">!   // Do not call for root chunks.</span>
<span class="changed">!   bool is_leader() const {</span>
<span class="changed">!     assert(!is_root_chunk(), "Root chunks have no buddy."); // Bit harsh?</span>
<span class="changed">!     return is_aligned(base(), chunklevel::word_size_for_level(level() - 1) * BytesPerWord);</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   //// Debug stuff ////</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   void verify(bool slow) const;</span>
<span class="changed">!   // Verifies linking with neighbors in virtual space. Needs expand lock protection.</span>
<span class="changed">!   void verify_neighborhood() const;</span>
<span class="changed">!   void zap_header(uint8_t c = 0x17);</span>
<span class="changed">!   void fill_with_pattern(MetaWord pattern, size_t word_size);</span>
<span class="changed">!   void check_pattern(MetaWord pattern, size_t word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Returns true if given pointer points into the payload area of this chunk.</span>
<span class="changed">!   bool is_valid_pointer(const MetaWord* p) const {</span>
<span class="changed">!     return base() &lt;= p &amp;&amp; p &lt; top();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Returns true if given pointer points into the commmitted payload area of this chunk.</span>
<span class="changed">!   bool is_valid_committed_pointer(const MetaWord* p) const {</span>
<span class="changed">!     return base() &lt;= p &amp;&amp; p &lt; committed_top();</span>
<span class="changed">!   }</span>
  
<span class="changed">! #endif // ASSERT</span>
  
    void print_on(outputStream* st) const;
  
  };
  
<span class="new">+ // Little print helpers: since we often print out chunks, here some convenience macros</span>
<span class="new">+ #define METACHUNK_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT</span>
<span class="new">+ #define METACHUNK_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level()</span>
  
<span class="changed">! #define METACHUNK_FULL_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT " (" SIZE_FORMAT "), used: " SIZE_FORMAT ", committed: " SIZE_FORMAT ", committed-free: " SIZE_FORMAT</span>
<span class="changed">! #define METACHUNK_FULL_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level(), chunk-&gt;word_size(), chunk-&gt;used_words(), chunk-&gt;committed_words(), chunk-&gt;free_below_committed_words()</span>
  
  } // namespace metaspace
  
  #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metaspaceCommon.cpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

