<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/metaspaceTestsCommon.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 #ifndef GTEST_METASPACE_METASPACETESTCOMMON_HPP
  26 #define GTEST_METASPACE_METASPACETESTCOMMON_HPP
  27 
  28 #include "memory/allocation.hpp"
  29 
  30 
  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  32 #include "memory/metaspace/binlist.hpp"
  33 #include "memory/metaspace/blocktree.hpp"
  34 #include "memory/metaspace/chunkHeaderPool.hpp"
  35 #include "memory/metaspace/chunkLevel.hpp"
  36 #include "memory/metaspace/chunkManager.hpp"
  37 #include "memory/metaspace/classLoaderMetaspace.hpp"
  38 #include "memory/metaspace/counter.hpp"
  39 #include "memory/metaspace/commitLimiter.hpp"
  40 #include "memory/metaspace/commitMask.hpp"
  41 #include "memory/metaspace/freeBlocks.hpp"
  42 #include "memory/metaspace/freeChunkList.hpp"
  43 #include "memory/metaspace/internStat.hpp"
  44 #include "memory/metaspace/metachunk.hpp"
  45 #include "memory/metaspace/metaspaceCommon.hpp"
  46 #include "memory/metaspace/metaspaceEnums.hpp"
  47 #include "memory/metaspace/metaspaceStatistics.hpp"
  48 #include "memory/metaspace/virtualSpaceList.hpp"
  49 #include "memory/metaspace/spaceManager.hpp"
  50 #include "memory/metaspace/settings.hpp"
  51 #include "runtime/mutexLocker.hpp"
  52 #include "runtime/os.hpp"
  53 
  54 #include "utilities/align.hpp"
  55 #include "utilities/debug.hpp"
  56 #include "utilities/globalDefinitions.hpp"
  57 
  58 #include "unittest.hpp"
  59 
  60 #include &lt;stdio.h&gt;
  61 
  62 
  63 //////////////////////////////////////////////////////////
  64 // handy aliases
  65 
  66 using metaspace::BinListImpl;
  67 using metaspace::BlockTree;
  68 using metaspace::ArenaGrowthPolicy;
  69 using metaspace::ChunkHeaderPool;
  70 using metaspace::ChunkManager;
  71 using metaspace::CommitLimiter;
  72 using metaspace::CommitMask;
  73 using metaspace::SizeCounter;
  74 using metaspace::SizeAtomicCounter;
  75 using metaspace::IntCounter;
  76 using metaspace::FreeBlocks;
  77 using metaspace::FreeChunkList;
  78 using metaspace::FreeChunkListVector;
  79 using metaspace::MemRangeCounter;
  80 using metaspace::Metachunk;
  81 using metaspace::MetachunkList;
  82 using metaspace::Settings;
  83 using metaspace::sm_stats_t;
  84 using metaspace::in_use_chunk_stats_t;
  85 using metaspace::cm_stats_t;
  86 using metaspace::SizeCounter;
  87 using metaspace::SpaceManager;
  88 using metaspace::VirtualSpaceList;
  89 using metaspace::VirtualSpaceNode;
  90 
  91 using metaspace::chunklevel_t;
  92 using namespace metaspace::chunklevel;
  93 
  94 using metaspace::MetaspaceType;
  95 using metaspace::ReflectionMetaspaceType;
  96 using metaspace::ClassMirrorHolderMetaspaceType;
  97 using metaspace::StandardMetaspaceType;
  98 using metaspace::BootMetaspaceType;
  99 
 100 
 101 /////////////////////////////////////////////////////////////////////
 102 // A little mockup to mimick and test the CommitMask in various tests
 103 
 104 class TestMap {
 105   const size_t _len;
 106   char* _arr;
 107 public:
 108   TestMap(size_t len) : _len(len), _arr(NULL) {
 109     _arr = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 110     memset(_arr, 0, _len);
 111   }
 112   ~TestMap() { FREE_C_HEAP_ARRAY(char, _arr); }
 113 
 114   int get_num_set(size_t from, size_t to) const {
 115     int result = 0;
 116     for(size_t i = from; i &lt; to; i ++) {
 117       if (_arr[i] &gt; 0) {
 118         result ++;
 119       }
 120     }
 121     return result;
 122   }
 123 
 124   size_t get_num_set() const { return get_num_set(0, _len); }
 125 
 126   void set_range(size_t from, size_t to) {
 127     memset(_arr + from, 1, to - from);
 128   }
 129 
 130   void clear_range(size_t from, size_t to) {
 131     memset(_arr + from, 0, to - from);
 132   }
 133 
 134   bool at(size_t pos) const {
 135     return _arr[pos] == 1;
 136   }
 137 
 138 };
 139 
 140 
 141 ///////////////////////////////////////////////////////////
 142 // Helper class for generating random allocation sizes
 143 class RandSizeGenerator {
 144   const size_t _min; // [
 145   const size_t _max; // )
 146   const float _outlier_chance; // 0.0 -- 1.0
 147   const size_t _outlier_min; // [
 148   const size_t _outlier_max; // )
 149 public:
 150   RandSizeGenerator(size_t min, size_t max)
 151     : _min(min), _max(max), _outlier_chance(0.0), _outlier_min(min), _outlier_max(max)
 152   {}
 153 
 154   RandSizeGenerator(size_t min, size_t max, float outlier_chance, size_t outlier_min, size_t outlier_max)
 155     : _min(min), _max(max), _outlier_chance(outlier_chance), _outlier_min(outlier_min), _outlier_max(outlier_max)
 156   {}
 157 
 158   size_t min() const { return _min; }
 159   size_t max() const { return _max; }
 160 
 161   size_t get() const {
 162     size_t l1 = _min;
 163     size_t l2 = _max;
 164     int r = os::random() % 1000;
 165     if ((float)r &lt; _outlier_chance * 1000.0) {
 166       l1 = _outlier_min;
 167       l2 = _outlier_max;
 168     }
 169     const size_t d = l2 - l1;
 170     return l1 + (os::random() % d);
 171   }
 172 
 173 }; // end RandSizeGenerator
 174 
 175 size_t get_random_size(size_t min, size_t max);
 176 
 177 ///////////////////////////////////////////////////////////
 178 // Function to test-access a memory range
 179 
 180 void zap_range(MetaWord* p, size_t word_size);
 181 
 182 // "fill_range_with_pattern" fills a range of heap words with pointers to itself.
 183 //
 184 // The idea is to fill a memory range with a pattern which is both marked clearly to the caller
 185 // and cannot be moved without becoming invalid.
 186 //
 187 // The filled range can be checked with check_range_for_pattern. One also can only check
 188 // a sub range of the original range.
 189 void fill_range_with_pattern(MetaWord* p, uintx pattern, size_t word_size);
 190 void check_range_for_pattern(const MetaWord* p, uintx pattern, size_t word_size);
 191 
 192 // Writes a uniqe pattern to p
 193 void mark_address(MetaWord* p, uintx pattern);
 194 // checks pattern at address
 195 void check_marked_address(const MetaWord* p, uintx pattern);
 196 
 197 // Similar to fill_range_with_pattern, but only marks start and end. This is optimized for cases
 198 // where fill_range_with_pattern just is too slow.
 199 // Use check_marked_range to check the range. In contrast to check_range_for_pattern, only the original
 200 // range can be checked.
 201 void mark_range(MetaWord* p, uintx pattern, size_t word_size);
 202 void check_marked_range(const MetaWord* p, uintx pattern, size_t word_size);
 203 
 204 void mark_range(MetaWord* p, size_t word_size);
 205 void check_marked_range(const MetaWord* p, size_t word_size);
 206 
 207 //////////////////////////////////////////////////////////
 208 // Some helpers to avoid typing out those annoying casts for NULL
 209 
 210 #define ASSERT_NOT_NULL(ptr)      ASSERT_NE((void*)NULL, (void*)ptr)
 211 #define ASSERT_NULL(ptr)          ASSERT_EQ((void*)NULL, (void*)ptr)
 212 #define EXPECT_NOT_NULL(ptr)      EXPECT_NE((void*)NULL, (void*)ptr)
 213 #define EXPECT_NULL(ptr)          EXPECT_EQ((void*)NULL, (void*)ptr)
 214 
 215 #define ASSERT_0(v)               ASSERT_EQ((intptr_t)0, (intptr_t)v)
 216 #define ASSERT_NOT_0(v)           ASSERT_NE((intptr_t)0, (intptr_t)v)
 217 #define EXPECT_0(v)               EXPECT_EQ((intptr_t)0, (intptr_t)v)
 218 #define EXPECT_NOT_0(v)           EXPECT_NE((intptr_t)0, (intptr_t)v)
 219 
 220 //////////////////////////////////////////////////////////
 221 // logging
 222 
 223 // Define "LOG_PLEASE" to switch on logging for a particular test before inclusion of this header.
 224 #ifdef LOG_PLEASE
 225   #define LOG(...) { printf(__VA_ARGS__); printf("\n"); fflush(stdout); }
 226 #else
 227   #define LOG(...)
 228 #endif
 229 
 230 //////////////////////////////////////////////////////////
 231 // Helper
 232 
 233 size_t get_workingset_size();
 234 
 235 // A simple preallocated buffer used to "feed" someone.
 236 // Mimicks chunk retirement leftover blocks.
 237 class FeederBuffer {
 238 
 239   MetaWord* _buf;
 240 
 241   // Buffer capacity in size of words.
 242   const size_t _cap;
 243 
 244   // Used words.
 245   size_t _used;
 246 
 247 public:
 248 
 249   FeederBuffer(size_t size) : _buf(NULL), _cap(size), _used(0) {
 250     _buf = NEW_C_HEAP_ARRAY(MetaWord, _cap, mtInternal);
 251   }
 252 
 253   ~FeederBuffer() {
 254     FREE_C_HEAP_ARRAY(MetaWord, _buf);
 255   }
 256 
 257   MetaWord* get(size_t word_size) {
 258     if (_used + word_size &gt; _cap) {
 259       return NULL;
 260     }
 261     MetaWord* p = _buf + _used;
 262     _used += word_size;
 263     return p;
 264   }
 265 
 266   bool is_valid_pointer(MetaWord* p) const {
 267     return p &gt;= _buf &amp;&amp; p &lt; _buf + _used;
 268   }
 269 
 270   bool is_valid_range(MetaWord* p, size_t word_size) const {
 271     return is_valid_pointer(p) &amp;&amp;
 272            word_size &gt; 0 ? is_valid_pointer(p + word_size - 1) : true;
 273   }
 274 
 275 };
 276 
 277 #endif // GTEST_METASPACE_METASPACETESTCOMMON_HPP
</pre></body></html>
