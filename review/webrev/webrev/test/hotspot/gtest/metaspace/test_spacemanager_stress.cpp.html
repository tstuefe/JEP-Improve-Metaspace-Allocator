<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_spacemanager_stress.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 
  27 #include "precompiled.hpp"
  28 
  29 //#define LOG_PLEASE
  30 
  31 #include "metaspace/metaspaceTestsCommon.hpp"
  32 #include "metaspace/metaspace_sparsearray.hpp"
  33 #include "metaspace/metaspace_testhelper.hpp"
  34 
  35 // Little randomness helper
  36 static bool fifty_fifty() {
  37   return IntRange(100).random_value() &lt; 50;
  38 }
  39 
  40 // See spaceManager.cpp : needed for predicting commit sizes.
  41 namespace metaspace {
  42   extern size_t get_raw_allocation_word_size(size_t net_word_size);
  43 }
  44 
  45 // A SpaceManagerTestBed contains a single SpaceManager and its lock.
  46 // It keeps track of allocations done from this SpaceManager.
  47 class SpaceManagerTestBed : public CHeapObj&lt;mtInternal&gt; {
  48 
  49   SpaceManager* _sm;
  50 
  51   Mutex* _lock;
  52 
  53   const SizeRange _allocation_range;
  54   size_t _size_of_last_failed_allocation;
  55 
  56   // We keep track of all allocations done thru the SpaceManager to
  57   // later check for overwriters.
  58   struct allocation_t {
  59     allocation_t* next;
  60     MetaWord* p; // NULL if deallocated
  61     size_t word_size;
  62     void mark() {
  63       mark_range(p, word_size);
  64     }
  65     void verify() const {
  66       if (p != NULL) {
  67         check_marked_range(p, word_size);
  68       }
  69     }
  70   };
  71 
  72   allocation_t* _allocations;
  73 
  74   // We count how much we did allocate and deallocate
  75   MemRangeCounter _alloc_count;
  76   MemRangeCounter _dealloc_count;
  77 
  78   // Check statistics returned by SpaceManager::add_to_statistics() against what
  79   // we know we allocated. This is a bit flaky since SpaceManager has internal
  80   // overhead.
  81   void verify_sm_statistics() const {
  82 
  83     sm_stats_t stats;
  84     _sm-&gt;add_to_statistics(&amp;stats);
  85     in_use_chunk_stats_t in_use_stats = stats.totals();
  86 
  87     assert(_dealloc_count.total_size() &lt;= _alloc_count.total_size() &amp;&amp;
  88            _dealloc_count.count() &lt;= _alloc_count.count(), "Sanity");
  89 
  90     // Check consistency of stats
  91     ASSERT_GE(in_use_stats.word_size, in_use_stats.committed_words);
  92     ASSERT_EQ(in_use_stats.committed_words,
  93               in_use_stats.used_words + in_use_stats.free_words + in_use_stats.waste_words);
  94     ASSERT_GE(in_use_stats.used_words, stats.free_blocks_word_size);
  95 
  96     // Note: reasons why the outside alloc counter and the inside used counter can differ:
  97     // - alignment/padding of allocations
  98     // - inside used counter contains blocks in free list
  99     // - free block list splinter threshold
 100 
 101     // Since what we deallocated may have been given back to us in a following allocation,
 102     // we only know fore sure we allocated what we did not give back.
 103     const size_t at_least_allocated = _alloc_count.total_size() - _dealloc_count.total_size();
 104 
 105     // At most we allocated this:
 106     const size_t max_word_overhead_per_alloc = 4;
 107     const size_t at_most_allocated = _alloc_count.total_size() + max_word_overhead_per_alloc * _alloc_count.count();
 108 
 109     ASSERT_LE(at_least_allocated, in_use_stats.used_words - stats.free_blocks_word_size);
 110     ASSERT_GE(at_most_allocated, in_use_stats.used_words - stats.free_blocks_word_size);
 111 
 112   }
 113 
 114 public:
 115 
 116   SpaceManager* sm() { return _sm; }
 117 
 118   SpaceManagerTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence,
 119                       SizeAtomicCounter* used_words_counter, SizeRange allocation_range)
 120     : _sm(NULL),
 121       _lock(NULL),
 122       _allocation_range(allocation_range),
 123       _size_of_last_failed_allocation(0),
 124       _allocations(NULL),
 125       _alloc_count(), _dealloc_count()
 126   {
 127     _lock = new Mutex(Monitor::native, "gtest-SpaceManagerTestBed-lock", false, Monitor::_safepoint_check_never);
 128     // Lock during space creation, since this is what happens in the VM too
 129     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
 130     MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
 131     _sm = new SpaceManager(cm, alloc_sequence, _lock, used_words_counter, "gtest-SpaceManagerTestBed-sm", false);
 132   }
 133 
 134   ~SpaceManagerTestBed() {
 135 
 136     verify_sm_statistics();
 137 
 138     allocation_t* a = _allocations;
 139     while (a != NULL) {
 140       allocation_t* b = a-&gt;next;
 141       a-&gt;verify();
 142       FREE_C_HEAP_OBJ(a);
 143       a = b;
 144     }
 145 
 146     DEBUG_ONLY(_sm-&gt;verify(true);)
 147 
 148     // Delete SpaceManager. That should clean up all metaspace.
 149     delete _sm;
 150     delete _lock;
 151 
 152   }
 153 
 154   size_t words_allocated() const        { return _alloc_count.total_size(); }
 155   int num_allocations() const           { return _alloc_count.count(); }
 156 
 157   size_t size_of_last_failed_allocation() const { return _size_of_last_failed_allocation; }
 158 
 159   // Allocate a random amount. Return false if the allocation failed.
 160   bool checked_random_allocate() {
 161     size_t word_size = 1 + _allocation_range.random_value();
 162     MetaWord* p = _sm-&gt;allocate(word_size);
 163     if (p != NULL) {
 164       EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));
 165       allocation_t* a = NEW_C_HEAP_OBJ(allocation_t, mtInternal);
 166       a-&gt;word_size = word_size;
 167       a-&gt;p = p;
 168       a-&gt;mark();
 169       a-&gt;next = _allocations;
 170       _allocations = a;
 171       _alloc_count.add(word_size);
 172       if ((_alloc_count.count() % 20) == 0) {
 173         verify_sm_statistics();
 174         DEBUG_ONLY(_sm-&gt;verify(true);)
 175       }
 176       return true;
 177     } else {
 178       _size_of_last_failed_allocation = word_size;
 179     }
 180     return false;
 181   }
 182 
 183   // Deallocate a random allocation
 184   void checked_random_deallocate() {
 185     allocation_t* a = _allocations;
 186     while (a &amp;&amp; a-&gt;p != NULL &amp;&amp; os::random() % 10 != 0) {
 187       a = a-&gt;next;
 188     }
 189     if (a != NULL &amp;&amp; a-&gt;p != NULL) {
 190       a-&gt;verify();
 191       _sm-&gt;deallocate(a-&gt;p, a-&gt;word_size);
 192       _dealloc_count.add(a-&gt;word_size);
 193       a-&gt;p = NULL; a-&gt;word_size = 0;
 194       if ((_dealloc_count.count() % 20) == 0) {
 195         verify_sm_statistics();
 196         DEBUG_ONLY(_sm-&gt;verify(true);)
 197       }
 198     }
 199   }
 200 
 201 }; // End: SpaceManagerTestBed
 202 
 203 
 204 class SpaceManagerTest {
 205 
 206   MetaspaceTestHelper _helper;
 207 
 208   SizeAtomicCounter _used_words_counter;
 209 
 210   const size_t _rss_at_start;
 211 
 212   SparseArray&lt;SpaceManagerTestBed*&gt; _testbeds;
 213   IntCounter _num_beds;
 214 
 215   //////// Bed creation, destruction ///////
 216 
 217   void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, SizeRange allocation_range) {
 218     DEBUG_ONLY(_testbeds.check_slot_is_null(slotindex));
 219     SpaceManagerTestBed* bed = new SpaceManagerTestBed(&amp;_helper.cm(), growth_policy,
 220                                                        &amp;_used_words_counter, allocation_range);
 221     _testbeds.set_at(slotindex, bed);
 222     _num_beds.increment();
 223   }
 224 
 225   void create_random_test_bed_at(int slotindex) {
 226     SizeRange allocation_range(1, 100); // randomize too?
 227     const ArenaGrowthPolicy* growth_policy = ArenaGrowthPolicy::policy_for_space_type(
 228         (fifty_fifty() ? metaspace::StandardMetaspaceType : metaspace::ReflectionMetaspaceType),
 229          fifty_fifty());
 230     create_new_test_bed_at(slotindex, growth_policy, allocation_range);
 231    }
 232 
 233   // Randomly create a random test bed at a random slot, and return its slot index
 234   // (returns false if we reached max number of test beds)
 235   bool create_random_test_bed() {
 236     const int slot = _testbeds.random_null_slot_index();
 237     if (slot != -1) {
 238       create_random_test_bed_at(slot);
 239     }
 240     return slot;
 241   }
 242 
 243   // Create test beds for all slots
 244   void create_all_test_beds() {
 245     for (int slot = 0; slot &lt; _testbeds.size(); slot ++) {
 246       if (_testbeds.slot_is_null(slot)) {
 247         create_random_test_bed_at(slot);
 248       }
 249     }
 250   }
 251 
 252   void delete_test_bed_at(int slotindex) {
 253     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex));
 254     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 255     delete bed; // This will return all its memory to the chunk manager
 256     _testbeds.set_at(slotindex, NULL);
 257     _num_beds.decrement();
 258   }
 259 
 260   // Randomly delete a random test bed at a random slot
 261   // Return false if there are no test beds to delete.
 262   bool delete_random_test_bed() {
 263     const int slotindex = _testbeds.random_non_null_slot_index();
 264     if (slotindex != -1) {
 265       delete_test_bed_at(slotindex);
 266       return true;
 267     }
 268     return false;
 269   }
 270 
 271   // Delete all test beds.
 272   void delete_all_test_beds() {
 273     for (int slot = _testbeds.first_non_null_slot(); slot != -1; slot = _testbeds.next_non_null_slot(slot)) {
 274       delete_test_bed_at(slot);
 275     }
 276   }
 277 
 278   //////// Allocating metaspace from test beds ///////
 279 
 280   bool random_allocate_from_testbed(int slotindex) {
 281     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex);)
 282     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 283     bool success = bed-&gt;checked_random_allocate();
 284     if (success == false) {
 285       // We must have hit a limit.
 286       EXPECT_LT(_helper.commit_limiter().possible_expansion_words(),
 287                 metaspace::get_raw_allocation_word_size(bed-&gt;size_of_last_failed_allocation()));
 288     }
 289     return success;
 290   }
 291 
 292   // Allocate multiple times random sizes from a single spacemanager.
 293   bool random_allocate_multiple_times_from_testbed(int slotindex, int num_allocations) {
 294     bool success = true;
 295     int n = 0;
 296     while (success &amp;&amp; n &lt; num_allocations) {
 297       success = random_allocate_from_testbed(slotindex);
 298       n ++;
 299     }
 300     return success;
 301   }
 302 
 303   // Allocate multiple times random sizes from a single random spacemanager.
 304   bool random_allocate_random_times_from_random_testbed() {
 305     int slot = _testbeds.random_non_null_slot_index();
 306     bool success = false;
 307     if (slot != -1) {
 308       const int n = IntRange(5, 20).random_value();
 309       success = random_allocate_multiple_times_from_testbed(slot, n);
 310     }
 311     return success;
 312   }
 313 
 314   /////// Deallocating from testbed ///////////////////
 315 
 316   void deallocate_from_testbed(int slotindex) {
 317     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex);)
 318     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 319     bed-&gt;checked_random_deallocate();
 320   }
 321 
 322   void deallocate_from_random_testbed() {
 323     int slot = _testbeds.random_non_null_slot_index();
 324     if (slot != -1) {
 325       deallocate_from_testbed(slot);
 326     }
 327   }
 328 
 329   /////// Stats ///////////////////////////////////////
 330 
 331   int get_total_number_of_allocations() const {
 332     int sum = 0;
 333     for (int i = _testbeds.first_non_null_slot(); i != -1; i = _testbeds.next_non_null_slot(i)) {
 334       sum += _testbeds.at(i)-&gt;num_allocations();
 335     }
 336     return sum;
 337   }
 338 
 339   size_t get_total_words_allocated() const {
 340     size_t sum = 0;
 341     for (int i = _testbeds.first_non_null_slot(); i != -1; i = _testbeds.next_non_null_slot(i)) {
 342       sum += _testbeds.at(i)-&gt;words_allocated();
 343     }
 344     return sum;
 345   }
 346 
 347 public:
 348 
 349   SpaceManagerTest(size_t commit_limit, int num_testbeds)
 350     : _helper(commit_limit),
 351       _rss_at_start(get_workingset_size()),
 352       _testbeds(num_testbeds),
 353       _num_beds()
 354   {}
 355 
 356   ~SpaceManagerTest () {
 357 
 358     // We compare our footprint now against what we had when the test started. Note that this is
 359     // of course fuzzy. We only do this to catch run-away leaks.
 360 
 361     const size_t rss_after_test = get_workingset_size();
 362 
 363     const size_t estimated_gtest_footprint = 4 * M;
 364 
 365     const size_t estimated_footprint = estimated_gtest_footprint +
 366                                        get_total_words_allocated() +
 367                                        get_total_number_of_allocations() * 10 +
 368                                        (sizeof(SpaceManagerTestBed) + sizeof(SpaceManagerTestBed*)) * _testbeds.size();
 369 
 370     const float margin_factor = 1.5f;
 371     EXPECT_LE(rss_after_test, _rss_at_start + estimated_footprint * margin_factor);
 372 
 373     delete_all_test_beds();
 374 
 375     const size_t rss_after_cleanup = get_workingset_size();
 376 
 377     // Check for memory leaks. We should ideally be at the baseline of _rss_at_start. However, this depends
 378     // on whether this gtest was executed as a first test in the suite, since gtest suite adds overhead of 2-4 MB.
 379     EXPECT_LE(rss_after_cleanup, _rss_at_start + estimated_gtest_footprint);
 380 
 381     LOG("rss at start: " INTX_FORMAT ", after test " INTX_FORMAT " (+" INTX_FORMAT "), after cleanup: " INTX_FORMAT " (+" INTX_FORMAT ").", \
 382         _rss_at_start, rss_after_test, rss_after_test - _rss_at_start, rss_after_cleanup, rss_after_cleanup - _rss_at_start); \
 383 
 384   }
 385 
 386 
 387   //////////////// Tests ////////////////////////
 388 
 389   void test() {
 390 
 391     // In a big loop, randomly chose one of these actions
 392     // - creating a test bed (simulates a new loader creation)
 393     // - allocating from a test bed (simulates allocating metaspace for a loader)
 394     // - (rarely) deallocate (simulates metaspace deallocation, e.g. class redefinitions)
 395     // - delete a test bed (simulates collection of a loader and subsequent return of metaspace to freelists)
 396 
 397     const int iterations = 0x4000;
 398 
 399     // Lets have a ceiling on number of words allocated (this is independent from the commit limit)
 400     const size_t max_allocation_size = 8 * M;
 401 
 402     bool force_bed_deletion = false;
 403 
 404     for (int niter = 0; niter &lt; iterations; niter ++) {
 405 
 406       const int r = IntRange(100).random_value();
 407 
 408       if (force_bed_deletion || r &lt; 10) {
 409 
 410         force_bed_deletion = false;
 411         delete_random_test_bed();
 412 
 413       } else if (r &lt; 20 || _num_beds.get() &lt; (unsigned)_testbeds.size() / 2) {
 414 
 415         create_random_test_bed();
 416 
 417       } else if (r &lt; 95) {
 418 
 419         // If allocation fails, we hit the commit limit and should delete some beds first
 420         force_bed_deletion = ! random_allocate_random_times_from_random_testbed();
 421 
 422       } else {
 423 
 424         // Note: does not affect the used words counter.
 425         deallocate_from_random_testbed();
 426 
 427       }
 428 
 429       // If we are close to our quota, start bed deletion
 430       if (_used_words_counter.get() &gt;= max_allocation_size) {
 431 
 432         force_bed_deletion = true;
 433 
 434       }
 435 
 436     }
 437 
 438   }
 439 
 440 
 441 };
 442 
 443 
 444 // 32 parallel space managers, random allocating without commit limit
 445 TEST_VM(metaspace, spacemanager_random_allocs_32_beds_no_commit_limit) {
 446   SpaceManagerTest test(max_uintx, 32);
 447   test.test();
 448 }
 449 
 450 // 32 parallel space managers, random allocating with commit limit
 451 TEST_VM(metaspace, spacemanager_random_allocs_32_beds_with_commit_limit) {
 452   SpaceManagerTest test(2 * M, 32);
 453   test.test();
 454 }
 455 
 456 // A single space manager, random allocating without commit limit. This should exercise
 457 //  chunk enlargement since allocation is undisturbed.
 458 TEST_VM(metaspace, spacemanager_random_allocs_1_bed_no_commit_limit) {
 459   SpaceManagerTest test(max_uintx, 1);
 460   test.test();
 461 }
 462 
 463 
 464 
 465 
 466 
</pre></body></html>
