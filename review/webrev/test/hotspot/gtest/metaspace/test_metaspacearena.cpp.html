<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_metaspacearena.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 
  27 #include "precompiled.hpp"
  28 
  29 //#define LOG_PLEASE
  30 
  31 #include "metaspace/metaspaceTestsCommon.hpp"
  32 #include "metaspace/metaspace_sparsearray.hpp"
  33 #include "metaspace/metaspace_testhelper.hpp"
  34 #include "utilities/ostream.hpp"
  35 
  36 
  37 // TODO: this class is very similar to MetaspaceArenaTestBed in test_metaspacearena_stress.cpp.
  38 // should be unified.
  39 class MetaspaceArenaTestHelper {
  40 
  41   MetaspaceTestHelper&amp; _helper;
  42 
  43   Mutex* _lock;
  44   const ArenaGrowthPolicy* _growth_policy;
  45   SizeAtomicCounter _used_words_counter;
  46   MetaspaceArena* _arena;
  47 
  48 public:
  49 
  50   MetaspaceArenaTestHelper(MetaspaceTestHelper&amp; helper, metaspace::MetaspaceType space_type, bool is_class,
  51                          const char* name = "gtest-MetaspaceArena")
  52     : _helper(helper),
  53       _lock(NULL),
  54       _growth_policy(NULL),
  55       _used_words_counter(),
  56       _arena(NULL)
  57   {
  58     _growth_policy = ArenaGrowthPolicy::policy_for_space_type(space_type, is_class);
  59     _lock = new Mutex(Monitor::native, "gtest-MetaspaceArenaTest-lock", false, Monitor::_safepoint_check_never);
  60     // Lock during space creation, since this is what happens in the VM too
  61     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
  62     {
  63       MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
  64       _arena = new MetaspaceArena(&amp;_helper.cm(), _growth_policy, _lock, &amp;_used_words_counter, name, false);
  65     }
  66     DEBUG_ONLY(_arena-&gt;verify(true));
  67   }
  68 
  69   ~MetaspaceArenaTestHelper() {
  70     delete_arena_with_tests();
  71     delete _lock;
  72   }
  73 
  74   const CommitLimiter&amp; limiter() const { return _helper.commit_limiter(); }
  75   MetaspaceArena* arena() const { return _arena; }
  76   SizeAtomicCounter&amp; used_words_counter() { return _used_words_counter; }
  77 
  78   // Note: all test functions return void due to gtests limitation that we cannot use ASSERT
  79   // in non-void returning tests.
  80 
  81   void delete_arena_with_tests() {
  82     if (_arena != NULL) {
  83       size_t used_words_before = _used_words_counter.get();
  84       size_t committed_words_before = limiter().committed_words();
  85       DEBUG_ONLY(_arena-&gt;verify(true));
  86       delete _arena;
  87       _arena = NULL;
  88       size_t used_words_after = _used_words_counter.get();
  89       size_t committed_words_after = limiter().committed_words();
  90       ASSERT_0(used_words_after);
  91       if (Settings::uncommit_free_chunks()) {
  92         ASSERT_LE(committed_words_after, committed_words_before);
  93       } else {
  94         ASSERT_EQ(committed_words_after, committed_words_before);
  95       }
  96     }
  97   }
  98 
  99   void usage_numbers_with_test(size_t* p_used, size_t* p_committed, size_t* p_capacity) const {
 100     _arena-&gt;usage_numbers(p_used, p_committed, p_capacity);
 101     if (p_used != NULL) {
 102       if (p_committed != NULL) {
 103         ASSERT_GE(*p_committed, *p_used);
 104       }
 105       // Since we own the used words counter, it should reflect our usage number 1:1
 106       ASSERT_EQ(_used_words_counter.get(), *p_used);
 107     }
 108     if (p_committed != NULL &amp;&amp; p_capacity != NULL) {
 109       ASSERT_GE(*p_capacity, *p_committed);
 110     }
 111   }
 112 
 113   // Allocate; caller expects success; return pointer in *p_return_value
 114   void allocate_from_arena_with_tests_expect_success(MetaWord** p_return_value, size_t word_size) {
 115     allocate_from_arena_with_tests(p_return_value, word_size);
 116     ASSERT_NOT_NULL(*p_return_value);
 117   }
 118 
 119   // Allocate; caller expects success but is not interested in return value
 120   void allocate_from_arena_with_tests_expect_success(size_t word_size) {
 121     MetaWord* dummy = NULL;
 122     allocate_from_arena_with_tests_expect_success(&amp;dummy, word_size);
 123   }
 124 
 125   // Allocate; caller expects failure
 126   void allocate_from_arena_with_tests_expect_failure(size_t word_size) {
 127     MetaWord* dummy = NULL;
 128     allocate_from_arena_with_tests(&amp;dummy, word_size);
 129     ASSERT_NULL(dummy);
 130   }
 131 
 132   // Allocate; it may or may not work; return value in *p_return_value
 133   void allocate_from_arena_with_tests(MetaWord** p_return_value, size_t word_size) {
 134 
 135     // Note: usage_numbers walks all chunks in use and counts.
 136     size_t used = 0, committed = 0, capacity = 0;
 137     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 138 
 139     size_t possible_expansion = limiter().possible_expansion_words();
 140 
 141     MetaWord* p = _arena-&gt;allocate(word_size);
 142 
 143     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify(true);))
 144 
 145     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 146     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 147 
 148     if (p == NULL) {
 149       // Allocation failed.
 150       if (Settings::newborn_root_chunks_are_fully_committed()) {
 151         ASSERT_LT(possible_expansion, MAX_CHUNK_WORD_SIZE);
 152       } else {
 153         ASSERT_LT(possible_expansion, word_size);
 154       }
 155 
 156       ASSERT_EQ(used, used2);
 157       ASSERT_EQ(committed, committed2);
 158       ASSERT_EQ(capacity, capacity2);
 159     } else {
 160       // Allocation succeeded. Should be correctly aligned.
 161       ASSERT_TRUE(is_aligned(p, sizeof(MetaWord)));
 162       // used: may go up or may not (since our request may have been satisfied from the freeblocklist
 163       //   whose content already counts as used).
 164       // committed: may go up, may not
 165       // capacity: ditto
 166       ASSERT_GE(used2, used);
 167       ASSERT_GE(committed2, committed);
 168       ASSERT_GE(capacity2, capacity);
 169     }
 170 
 171     *p_return_value = p;
 172   }
 173 
 174   // Allocate; it may or may not work; but caller does not care for the result value
 175   void allocate_from_arena_with_tests(size_t word_size) {
 176     MetaWord* dummy = NULL;
 177     allocate_from_arena_with_tests(&amp;dummy, word_size);
 178   }
 179 
 180 
 181   void deallocate_with_tests(MetaWord* p, size_t word_size) {
 182     size_t used = 0, committed = 0, capacity = 0;
 183     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 184 
 185     _arena-&gt;deallocate(p, word_size);
 186 
 187     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify(true);))
 188 
 189     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 190     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 191 
 192     // Nothing should have changed. Deallocated blocks are added to the free block list
 193     // which still counts as used.
 194     ASSERT_EQ(used2, used);
 195     ASSERT_EQ(committed2, committed);
 196     ASSERT_EQ(capacity2, capacity);
 197   }
 198 
 199 
 200 };
 201 
 202 
 203 static void test_basics(size_t commit_limit, bool is_micro) {
 204   MetaspaceTestHelper msthelper(commit_limit);
 205   MetaspaceArenaTestHelper helper(msthelper, is_micro ? metaspace::ReflectionMetaspaceType : metaspace::StandardMetaspaceType, false);
 206 
 207   helper.allocate_from_arena_with_tests(1);
 208   helper.allocate_from_arena_with_tests(128);
 209   helper.allocate_from_arena_with_tests(128 * K);
 210   helper.allocate_from_arena_with_tests(1);
 211   helper.allocate_from_arena_with_tests(128);
 212   helper.allocate_from_arena_with_tests(128 * K);
 213 }
 214 
 215 TEST_VM(metaspace, MetaspaceArena_basics_micro_nolimit) {
 216   test_basics(max_uintx, true);
 217 }
 218 
 219 TEST_VM(metaspace, MetaspaceArena_basics_micro_limit) {
 220   test_basics(256 * K, true);
 221 }
 222 
 223 TEST_VM(metaspace, MetaspaceArena_basics_standard_nolimit) {
 224   test_basics(max_uintx, false);
 225 }
 226 
 227 TEST_VM(metaspace, MetaspaceArena_basics_standard_limit) {
 228   test_basics(256 * K, false);
 229 }
 230 
 231 
 232 // Test: in a single undisturbed MetaspaceArena (so, we should have chunks enlarged in place)
 233 // we allocate a small amount, then the full amount possible. The sum of first and second
 234 // allocation bring us above root chunk size. This should work - chunk enlargement should
 235 // fail and a new root chunk should be allocated instead.
 236 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place) {
 237 
 238   if (Settings::use_allocation_guard()) {
 239     return;
 240   }
 241 
 242   MetaspaceTestHelper msthelper;
 243   MetaspaceArenaTestHelper helper(msthelper, metaspace::StandardMetaspaceType, false);
 244   helper.allocate_from_arena_with_tests_expect_success(1);
 245   helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE);
 246   helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE / 2);
 247   helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE);
 248 }
 249 
 250 // Test allocating from smallest to largest chunk size, and one step beyond.
 251 // The first n allocations should happen in place, the ladder should open a new chunk.
 252 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_ladder_1) {
 253 
 254   if (Settings::use_allocation_guard()) {
 255     return;
 256   }
 257 
 258   MetaspaceTestHelper msthelper;
 259   MetaspaceArenaTestHelper helper(msthelper, metaspace::StandardMetaspaceType, false);
 260   size_t size = MIN_CHUNK_WORD_SIZE;
 261   while (size &lt;= MAX_CHUNK_WORD_SIZE) {
 262     helper.allocate_from_arena_with_tests_expect_success(size);
 263     size *= 2;
 264   }
 265   helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE);
 266 }
 267 
 268 // Same as MetaspaceArena_test_enlarge_in_place_ladder_1, but increase in *4 step size;
 269 // this way chunk-in-place-enlargement does not work and we should have new chunks at each allocation.
 270 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_ladder_2) {
 271 
 272   if (Settings::use_allocation_guard()) {
 273     return;
 274   }
 275 
 276   MetaspaceTestHelper msthelper;
 277   MetaspaceArenaTestHelper helper(msthelper, metaspace::StandardMetaspaceType, false);
 278   size_t size = MIN_CHUNK_WORD_SIZE;
 279   while (size &lt;= MAX_CHUNK_WORD_SIZE) {
 280     helper.allocate_from_arena_with_tests_expect_success(size);
 281     size *= 4;
 282   }
 283   helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE);
 284 }
 285 
 286 // Test the MetaspaceArenas' free block list:
 287 // Allocate, deallocate, then allocate the same block again. The second allocate should
 288 // reuse the deallocated block.
 289 TEST_VM(metaspace, MetaspaceArena_deallocate) {
 290   if (Settings::use_allocation_guard()) {
 291     return;
 292   }
 293   for (size_t s = 2; s &lt;= MAX_CHUNK_WORD_SIZE; s *= 2) {
 294     MetaspaceTestHelper msthelper;
 295     MetaspaceArenaTestHelper helper(msthelper, metaspace::StandardMetaspaceType, false);
 296 
 297     MetaWord* p1 = NULL;
 298     helper.allocate_from_arena_with_tests_expect_success(&amp;p1, s);
 299 
 300     size_t used1 = 0, capacity1 = 0;
 301     helper.usage_numbers_with_test(&amp;used1, NULL, &amp;capacity1);
 302     ASSERT_EQ(used1, s);
 303 
 304     helper.deallocate_with_tests(p1, s);
 305 
 306     size_t used2 = 0, capacity2 = 0;
 307     helper.usage_numbers_with_test(&amp;used2, NULL, &amp;capacity2);
 308     ASSERT_EQ(used1, used2);
 309     ASSERT_EQ(capacity2, capacity2);
 310 
 311     MetaWord* p2 = NULL;
 312     helper.allocate_from_arena_with_tests_expect_success(&amp;p2, s);
 313 
 314     size_t used3 = 0, capacity3 = 0;
 315     helper.usage_numbers_with_test(&amp;used3, NULL, &amp;capacity3);
 316     ASSERT_EQ(used3, used2);
 317     ASSERT_EQ(capacity3, capacity2);
 318 
 319     // Actually, we should get the very same allocation back
 320     ASSERT_EQ(p1, p2);
 321   }
 322 }
 323 
 324 static void test_recover_from_commit_limit_hit() {
 325 
 326   if (Settings::newborn_root_chunks_are_fully_committed()) {
 327     return; // This would throw off the commit counting in this test.
 328   }
 329 
 330   // Test:
 331   // - Multiple MetaspaceArena allocate (operating under the same commit limiter).
 332   // - One, while attempting to commit parts of its current chunk on demand,
 333   //   triggers the limit and cannot commit its chunk further.
 334   // - We release the other MetaspaceArena - its content is put back to the
 335   //   freelists.
 336   // - We re-attempt allocation from the first manager. It should now succeed.
 337   //
 338   // This means if the first MetaspaceArena may have to let go of its current chunk and
 339   // retire it and take a fresh chunk from the freelist.
 340 
 341   const size_t commit_limit = Settings::commit_granule_words() * 10;
 342   MetaspaceTestHelper msthelper(commit_limit);
 343 
 344   // The first MetaspaceArena mimicks a micro loader. This will fill the free
 345   //  chunk list with very small chunks. We allocate from them in an interleaved
 346   //  way to cause fragmentation.
 347   MetaspaceArenaTestHelper helper1(msthelper, metaspace::ReflectionMetaspaceType, false);
 348   MetaspaceArenaTestHelper helper2(msthelper, metaspace::ReflectionMetaspaceType, false);
 349 
 350   // This MetaspaceArena should hit the limit. We use BootMetaspaceType here since
 351   // it gets a large initial chunk which is committed
 352   // on demand and we are likely to hit a commit limit while trying to expand it.
 353   MetaspaceArenaTestHelper helper3(msthelper, metaspace::BootMetaspaceType, false);
 354 
 355   // Allocate space until we have below two but above one granule left
 356   size_t allocated_from_1_and_2 = 0;
 357   while (msthelper.commit_limiter().possible_expansion_words() &gt;= Settings::commit_granule_words() * 2 &amp;&amp;
 358       allocated_from_1_and_2 &lt; commit_limit) {
 359     helper1.allocate_from_arena_with_tests_expect_success(1);
 360     helper2.allocate_from_arena_with_tests_expect_success(1);
 361     allocated_from_1_and_2 += 2;
 362   }
 363 
 364   // Now, allocating from helper3, creep up on the limit
 365   size_t allocated_from_3 = 0;
 366   MetaWord* p = NULL;
 367   while ( (helper3.allocate_from_arena_with_tests(&amp;p, 1), p != NULL) &amp;&amp;
 368          ++allocated_from_3 &lt; Settings::commit_granule_words() * 2);
 369 
 370   EXPECT_LE(allocated_from_3, Settings::commit_granule_words() * 2);
 371 
 372   // We expect the freelist to be empty of committed space...
 373   EXPECT_0(msthelper.cm().total_committed_word_size());
 374 
 375   //msthelper.cm().print_on(tty);
 376 
 377   // Release the first MetaspaceArena.
 378   helper1.delete_arena_with_tests();
 379 
 380   //msthelper.cm().print_on(tty);
 381 
 382   // Should have populated the freelist with committed space
 383   // We expect the freelist to be empty of committed space...
 384   EXPECT_GT(msthelper.cm().total_committed_word_size(), (size_t)0);
 385 
 386   // Repeat allocation from helper3, should now work.
 387   helper3.allocate_from_arena_with_tests_expect_success(1);
 388 
 389 }
 390 
 391 
 392 TEST_VM(metaspace, MetaspaceArena_recover_from_limit_hit) {
 393   test_recover_from_commit_limit_hit();
 394 }
 395 
 396 static void test_controlled_growth(metaspace::MetaspaceType type, bool is_class,
 397                                    size_t expected_starting_capacity,
 398                                    bool test_in_place_enlargement)
 399 {
 400 
 401   if (Settings::use_allocation_guard()) {
 402     return;
 403   }
 404 
 405   // From a MetaspaceArena in a clean room allocate tiny amounts;
 406   // watch it grow. Used/committed/capacity should not grow in
 407   // large jumps. Also, different types of MetaspaceArena should
 408   // have different initial capacities.
 409 
 410   MetaspaceTestHelper msthelper;
 411   MetaspaceArenaTestHelper smhelper(msthelper, type, is_class, "Grower");
 412 
 413   MetaspaceArenaTestHelper smhelper_harrasser(msthelper, metaspace::ReflectionMetaspaceType, true, "Harasser");
 414 
 415   size_t used = 0, committed = 0, capacity = 0;
 416   const size_t alloc_words = 16;
 417 
 418   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 419   ASSERT_0(used);
 420   ASSERT_0(committed);
 421   ASSERT_0(capacity);
 422 
 423   ///// First allocation //
 424 
 425   smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
 426 
 427   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 428 
 429   ASSERT_EQ(used, alloc_words);
 430   ASSERT_GE(committed, used);
 431   ASSERT_GE(capacity, committed);
 432 
 433   ASSERT_EQ(capacity, expected_starting_capacity);
 434 
 435   // Check context-wide commit numbers:
 436   // Initial commit charge for the whole context should be one granule, unless
 437   // newborn_root_chunks_are_fully_committed=true in which case it would be the
 438   // size of a root chunk.
 439   if (!Settings::newborn_root_chunks_are_fully_committed()) {
 440     ASSERT_EQ(msthelper.committed_words(), Settings::commit_granule_words());
 441   } else {
 442     ASSERT_EQ(msthelper.committed_words(), MAX_CHUNK_WORD_SIZE);
 443   }
 444 
 445   // Check arena-local commit numbers:
 446   // Same as above but arena-&gt;usage_numbers() only reports the part of commit charge
 447   // accounted to the arena, so it may be less than the total amount.
 448   if (!Settings::newborn_root_chunks_are_fully_committed()) {
 449     ASSERT_LE(committed, Settings::commit_granule_words());
 450   } else {
 451     ASSERT_LE(committed, MAX_CHUNK_WORD_SIZE);
 452   }
 453 
 454   ///// subsequent allocations //
 455 
 456   DEBUG_ONLY(const uintx num_chunk_enlarged = metaspace::InternalStats::num_chunks_enlarged();)
 457 
 458   size_t words_allocated = 0;
 459   int num_allocated = 0;
 460   const size_t safety = MAX_CHUNK_WORD_SIZE * 1.2;
 461   size_t highest_capacity_jump = capacity;
 462   int num_capacity_jumps = 0;
 463 
 464   while (words_allocated &lt; safety &amp;&amp; num_capacity_jumps &lt; 15) {
 465 
 466     // if we want to test growth with in-place chunk enlargement, leave MetaspaceArena
 467     // undisturbed; it will have all the place to grow. Otherwise allocate from a little
 468     // side arena to increase fragmentation.
 469     // (Note that this does not completely prevent in-place chunk enlargement but makes it
 470     //  rather improbable)
 471     if (!test_in_place_enlargement) {
 472       smhelper_harrasser.allocate_from_arena_with_tests_expect_success(alloc_words * 2);
 473     }
 474 
 475     smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
 476     words_allocated += alloc_words;
 477     num_allocated ++;
 478 
 479     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 480 
 481     smhelper.arena()-&gt;usage_numbers(&amp;used2, &amp;committed2, &amp;capacity2);
 482 
 483     // used should not grow larger than what we allocated, plus possible overhead.
 484     ASSERT_GE(used2, used);
 485     ASSERT_LE(used2, used + alloc_words * 2);
 486     ASSERT_LE(used2, words_allocated + 100);
 487     used = used2;
 488 
 489     // A jump in committed words should not be larger than commit granule size.
 490     // It can be smaller, since the current chunk of the MetaspaceArena may be
 491     // smaller than a commit granule.
 492     // (Note: unless root chunks are born fully committed)
 493     ASSERT_GE(committed2, used2);
 494     ASSERT_GE(committed2, committed);
 495     const size_t committed_jump = committed2 - committed;
 496     if (committed_jump &gt; 0 &amp;&amp; !Settings::newborn_root_chunks_are_fully_committed()) {
 497       ASSERT_LE(committed_jump, Settings::commit_granule_words());
 498     }
 499     committed = committed2;
 500 
 501     // Capacity jumps: Test that arenas capacity does not grow too fast.
 502     ASSERT_GE(capacity2, committed2);
 503     ASSERT_GE(capacity2, capacity);
 504     const size_t capacity_jump = capacity2 - capacity;
 505     if (capacity_jump &gt; 0) {
 506       LOG("&gt;" SIZE_FORMAT "-&gt;" SIZE_FORMAT "(+" SIZE_FORMAT ")", capacity, capacity2, capacity_jump)
 507       if (capacity_jump &gt; highest_capacity_jump) {
 508         /* Disabled for now since this is rather shaky. The way it is tested makes it too dependend
 509          * on allocation history. Need to rethink this.
 510         ASSERT_LE(capacity_jump, highest_capacity_jump * 2);
 511         ASSERT_GE(capacity_jump, MIN_CHUNK_WORD_SIZE);
 512         ASSERT_LE(capacity_jump, MAX_CHUNK_WORD_SIZE);
 513         */
 514         highest_capacity_jump = capacity_jump;
 515       }
 516       num_capacity_jumps ++;
 517     }
 518 
 519     capacity = capacity2;
 520 
 521   }
 522 
 523   // After all this work, we should see an increase in number of chunk-in-place-enlargements
 524   //  (this especially is vulnerable to regression: the decisions of when to do in-place-enlargements are somewhat
 525   //   complicated, see MetaspaceArena::attempt_enlarge_current_chunk())
 526 #ifdef ASSERT
 527   if (test_in_place_enlargement) {
 528     const uintx num_chunk_enlarged_2 = metaspace::InternalStats::num_chunks_enlarged();
 529     ASSERT_GT(num_chunk_enlarged_2, num_chunk_enlarged);
 530   }
 531 #endif
 532 }
 533 
 534 // these numbers have to be in sync with arena policy numbers (see memory/metaspace/arenaGrowthPolicy.cpp)
 535 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_inplace) {
 536   test_controlled_growth(metaspace::ReflectionMetaspaceType, true,
 537                          word_size_for_level(CHUNK_LEVEL_1K), true);
 538 }
 539 
 540 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_not_inplace) {
 541   test_controlled_growth(metaspace::ReflectionMetaspaceType, true,
 542                          word_size_for_level(CHUNK_LEVEL_1K), false);
 543 }
 544 
 545 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_inplace) {
 546   test_controlled_growth(metaspace::ClassMirrorHolderMetaspaceType, true,
 547                          word_size_for_level(CHUNK_LEVEL_1K), true);
 548 }
 549 
 550 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_not_inplace) {
 551   test_controlled_growth(metaspace::ClassMirrorHolderMetaspaceType, true,
 552                          word_size_for_level(CHUNK_LEVEL_1K), false);
 553 }
 554 
 555 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_inplace) {
 556   test_controlled_growth(metaspace::StandardMetaspaceType, true,
 557                          word_size_for_level(CHUNK_LEVEL_2K), true);
 558 }
 559 
 560 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_not_inplace) {
 561   test_controlled_growth(metaspace::StandardMetaspaceType, true,
 562                          word_size_for_level(CHUNK_LEVEL_2K), false);
 563 }
 564 
 565 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 566  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 567 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_inplace) {
 568   test_controlled_growth(metaspace::BootMetaspaceType, true,
 569                          word_size_for_level(CHUNK_LEVEL_1M), true);
 570 }
 571 
 572 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_not_inplace) {
 573   test_controlled_growth(metaspace::BootMetaspaceType, true,
 574                          word_size_for_level(CHUNK_LEVEL_1M), false);
 575 }
 576 */
 577 
 578 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_inplace) {
 579   test_controlled_growth(metaspace::ReflectionMetaspaceType, false,
 580                          word_size_for_level(CHUNK_LEVEL_2K), true);
 581 }
 582 
 583 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_not_inplace) {
 584   test_controlled_growth(metaspace::ReflectionMetaspaceType, false,
 585                          word_size_for_level(CHUNK_LEVEL_2K), false);
 586 }
 587 
 588 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_inplace) {
 589   test_controlled_growth(metaspace::ClassMirrorHolderMetaspaceType, false,
 590                          word_size_for_level(CHUNK_LEVEL_1K), true);
 591 }
 592 
 593 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_not_inplace) {
 594   test_controlled_growth(metaspace::ClassMirrorHolderMetaspaceType, false,
 595                          word_size_for_level(CHUNK_LEVEL_1K), false);
 596 }
 597 
 598 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_inplace) {
 599   test_controlled_growth(metaspace::StandardMetaspaceType, false,
 600                          word_size_for_level(CHUNK_LEVEL_4K), true);
 601 }
 602 
 603 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_not_inplace) {
 604   test_controlled_growth(metaspace::StandardMetaspaceType, false,
 605                          word_size_for_level(CHUNK_LEVEL_4K), false);
 606 }
 607 
 608 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 609  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 610 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_inplace) {
 611   test_controlled_growth(metaspace::BootMetaspaceType, false,
 612                          word_size_for_level(CHUNK_LEVEL_4M), true);
 613 }
 614 
 615 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_not_inplace) {
 616   test_controlled_growth(metaspace::BootMetaspaceType, false,
 617                          word_size_for_level(CHUNK_LEVEL_4M), false);
 618 }
 619 */
</pre></body></html>
