<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/metaspace_sparsearray.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 #ifndef GTEST_METASPACE_SPARSEARRAY_HPP
  26 #define GTEST_METASPACE_SPARSEARRAY_HPP
  27 
  28 #include "memory/allocation.hpp"
  29 #include "runtime/os.hpp"
  30 #include "metaspace/metaspaceTestsCommon.hpp"
  31 #include "metaspace/metaspace_rangehelpers.hpp"
  32 
  33 
  34 /////// SparseArray&lt;T&gt; ////////////////
  35 
  36 // Throughout these tests we need to keep track of allocated items (ranges of metaspace memory, metachunks, ..)
  37 //  and be able to random-access them. Makes sense to have a helper for that.
  38 template &lt;class T&gt;
  39 class SparseArray : public StackObj {
  40 
  41   T* const _slots;
  42   const int _num;
  43 
  44   // For convenience: a range covering all possible slot indices.
  45   const IntRange _index_range;
  46 
  47   bool contains(int index) const {
  48     return _index_range.contains(index);
  49   }
  50 
  51   // Check slot intex for oob
  52   void check_index(int i) const {
  53     assert(contains(i), "Sanity");
  54   }
  55 
  56   // Swap the content of two slots.
  57   void swap(int i1, int i2) {
  58     check_index(i1);
  59     check_index(i2);
  60     T tmp = _slots[i1];
  61     _slots[i1] = _slots[i2];
  62     _slots[i2] = tmp;
  63   }
  64 
  65   enum condition_t { cond_null = 0, cond_non_null = 1, cond_dontcare = 2 };
  66 
  67   // Helper for next_matching_slot
  68   bool slot_matches(int slot, condition_t c) const {
  69     switch(c) {
  70     case cond_null:     return _slots[slot] == NULL;
  71     case cond_non_null: return _slots[slot] != NULL;
  72     case cond_dontcare: return true;
  73     }
  74     ShouldNotReachHere();
  75     return false;
  76   }
  77 
  78   // Starting at (including) index, find the next matching slot. Returns index or -1 if none found.
  79   int next_matching_slot(int slot, condition_t c) const {
  80     while(slot &lt; _num) {
  81       if (slot_matches(slot, c)) {
  82         return slot;
  83       }
  84       slot ++;
  85     }
  86     return -1;
  87   }
  88 
  89 public:
  90 
  91   SparseArray(int num)
  92     : _slots(NEW_C_HEAP_ARRAY(T, num, mtInternal)),
  93       _num(num),
  94       _index_range(num)
  95   {
  96     for (int i = 0; i &lt; _num; i ++) {
  97       _slots[i] = NULL;
  98     }
  99   }
 100 
 101   T at(int i)              { return _slots[i]; }
 102   const T at(int i) const  { return _slots[i]; }
 103   void set_at(int i, T e)  { _slots[i] = e; }
 104 
 105   int size() const         { return _num; }
 106 
 107   bool slot_is_null(int i) const                      { check_index(i); return _slots[i] == NULL; }
 108 
 109   DEBUG_ONLY(void check_slot_is_null(int i) const     { assert(slot_is_null(i), "Slot %d is not null", i); })
 110   DEBUG_ONLY(void check_slot_is_not_null(int i) const { assert(!slot_is_null(i), "Slot %d is null", i); })
 111 
 112   // Shuffle all elements randomly
 113   void shuffle() {
 114     for (int i = 0; i &lt; _num; i ++) {
 115       swap(i, random_slot_index());
 116     }
 117   }
 118 
 119   // Reverse elements
 120   void reverse() {
 121     for (int i = 0; i &lt; _num / 2; i ++) {
 122       swap(i, _num - i);
 123     }
 124   }
 125 
 126   int first_slot() const            { return 0; }
 127   int next_slot(int index) const    { return index == _index_range.highest() ? -1 : index + 1; }
 128 
 129   int first_non_null_slot() const         { return next_matching_slot(0, cond_non_null); }
 130   int next_non_null_slot(int index) const { return next_matching_slot(index + 1, cond_non_null); }
 131 
 132   int first_null_slot() const             { return next_matching_slot(0, cond_null); }
 133   int next_null_slot(int index) const     { return next_matching_slot(index + 1, cond_null); }
 134 
 135   // Return a random slot index.
 136   int random_slot_index() const {
 137     return _index_range.random_value();
 138   }
 139 
 140   int random_non_null_slot_index() const {
 141     int i = next_non_null_slot(_index_range.random_value());
 142     if (i == -1) {
 143       i = first_non_null_slot();
 144     }
 145     return i;
 146   }
 147 
 148   int random_null_slot_index() const {
 149     int i = next_null_slot(_index_range.random_value());
 150     if (i == -1) {
 151       i = first_null_slot();
 152     }
 153     return i;
 154   }
 155 
 156   IntRange random_slot_range() const {
 157     return _index_range.random_subrange();
 158   }
 159 
 160 };
 161 
 162 
 163 #endif // GTEST_METASPACE_SPARSEARRAY_HPP
 164 
 165 
</pre></body></html>
