<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/metaspaceTestsCommon.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 #ifndef GTEST_METASPACE_METASPACETESTCOMMON_HPP
  26 #define GTEST_METASPACE_METASPACETESTCOMMON_HPP
  27 
  28 #include "memory/allocation.hpp"
  29 
  30 
  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  32 #include "memory/metaspace/binlist.hpp"
  33 #include "memory/metaspace/blocktree.hpp"
  34 #include "memory/metaspace/chunkHeaderPool.hpp"
  35 #include "memory/metaspace/chunkLevel.hpp"
  36 #include "memory/metaspace/chunkManager.hpp"
  37 #include "memory/metaspace/classLoaderMetaspace.hpp"
  38 #include "memory/metaspace/counter.hpp"
  39 #include "memory/metaspace/commitLimiter.hpp"
  40 #include "memory/metaspace/commitMask.hpp"
  41 #include "memory/metaspace/freeBlocks.hpp"
  42 #include "memory/metaspace/freeChunkList.hpp"
  43 #include "memory/metaspace/internStat.hpp"
  44 #include "memory/metaspace/metachunk.hpp"
  45 #include "memory/metaspace/metaspaceArena.hpp"
  46 #include "memory/metaspace/metaspaceCommon.hpp"
  47 #include "memory/metaspace/metaspaceEnums.hpp"
  48 #include "memory/metaspace/metaspaceStatistics.hpp"
  49 #include "memory/metaspace/metaspace_test.hpp"
  50 #include "memory/metaspace/virtualSpaceList.hpp"
  51 #include "memory/metaspace/settings.hpp"
  52 #include "runtime/mutexLocker.hpp"
  53 #include "runtime/os.hpp"
  54 
  55 #include "utilities/align.hpp"
  56 #include "utilities/debug.hpp"
  57 #include "utilities/globalDefinitions.hpp"
  58 
  59 #include "unittest.hpp"
  60 
  61 #include &lt;stdio.h&gt;
  62 
  63 
  64 //////////////////////////////////////////////////////////
  65 // handy aliases
  66 
  67 using metaspace::BinListImpl;
  68 using metaspace::BlockTree;
  69 using metaspace::ArenaGrowthPolicy;
  70 using metaspace::ChunkHeaderPool;
  71 using metaspace::ChunkManager;
  72 using metaspace::CommitLimiter;
  73 using metaspace::CommitMask;
  74 using metaspace::SizeCounter;
  75 using metaspace::SizeAtomicCounter;
  76 using metaspace::IntCounter;
  77 using metaspace::FreeBlocks;
  78 using metaspace::FreeChunkList;
  79 using metaspace::FreeChunkListVector;
  80 using metaspace::MemRangeCounter;
  81 using metaspace::Metachunk;
  82 using metaspace::MetachunkList;
  83 using metaspace::Settings;
  84 using metaspace::arena_stats_t;
  85 using metaspace::in_use_chunk_stats_t;
  86 using metaspace::cm_stats_t;
  87 using metaspace::SizeCounter;
  88 using metaspace::MetaspaceArena;
  89 using metaspace::VirtualSpaceList;
  90 using metaspace::VirtualSpaceNode;
  91 
  92 using metaspace::chunklevel_t;
  93 using namespace metaspace::chunklevel;
  94 
  95 using metaspace::MetaspaceType;
  96 using metaspace::ReflectionMetaspaceType;
  97 using metaspace::ClassMirrorHolderMetaspaceType;
  98 using metaspace::StandardMetaspaceType;
  99 using metaspace::BootMetaspaceType;
 100 
 101 
 102 /////////////////////////////////////////////////////////////////////
 103 // A little mockup to mimick and test the CommitMask in various tests
 104 
 105 class TestMap {
 106   const size_t _len;
 107   char* _arr;
 108 public:
 109   TestMap(size_t len) : _len(len), _arr(NULL) {
 110     _arr = NEW_C_HEAP_ARRAY(char, len, mtInternal);
 111     memset(_arr, 0, _len);
 112   }
 113   ~TestMap() { FREE_C_HEAP_ARRAY(char, _arr); }
 114 
 115   int get_num_set(size_t from, size_t to) const {
 116     int result = 0;
 117     for(size_t i = from; i &lt; to; i ++) {
 118       if (_arr[i] &gt; 0) {
 119         result ++;
 120       }
 121     }
 122     return result;
 123   }
 124 
 125   size_t get_num_set() const { return get_num_set(0, _len); }
 126 
 127   void set_range(size_t from, size_t to) {
 128     memset(_arr + from, 1, to - from);
 129   }
 130 
 131   void clear_range(size_t from, size_t to) {
 132     memset(_arr + from, 0, to - from);
 133   }
 134 
 135   bool at(size_t pos) const {
 136     return _arr[pos] == 1;
 137   }
 138 
 139 };
 140 
 141 
 142 ///////////////////////////////////////////////////////////
 143 // Helper class for generating random allocation sizes
 144 class RandSizeGenerator {
 145   const size_t _min; // [
 146   const size_t _max; // )
 147   const float _outlier_chance; // 0.0 -- 1.0
 148   const size_t _outlier_min; // [
 149   const size_t _outlier_max; // )
 150 public:
 151   RandSizeGenerator(size_t min, size_t max)
 152     : _min(min), _max(max), _outlier_chance(0.0), _outlier_min(min), _outlier_max(max)
 153   {}
 154 
 155   RandSizeGenerator(size_t min, size_t max, float outlier_chance, size_t outlier_min, size_t outlier_max)
 156     : _min(min), _max(max), _outlier_chance(outlier_chance), _outlier_min(outlier_min), _outlier_max(outlier_max)
 157   {}
 158 
 159   size_t min() const { return _min; }
 160   size_t max() const { return _max; }
 161 
 162   size_t get() const {
 163     size_t l1 = _min;
 164     size_t l2 = _max;
 165     int r = os::random() % 1000;
 166     if ((float)r &lt; _outlier_chance * 1000.0) {
 167       l1 = _outlier_min;
 168       l2 = _outlier_max;
 169     }
 170     const size_t d = l2 - l1;
 171     return l1 + (os::random() % d);
 172   }
 173 
 174 }; // end RandSizeGenerator
 175 
 176 size_t get_random_size(size_t min, size_t max);
 177 
 178 ///////////////////////////////////////////////////////////
 179 // Function to test-access a memory range
 180 
 181 void zap_range(MetaWord* p, size_t word_size);
 182 
 183 // "fill_range_with_pattern" fills a range of heap words with pointers to itself.
 184 //
 185 // The idea is to fill a memory range with a pattern which is both marked clearly to the caller
 186 // and cannot be moved without becoming invalid.
 187 //
 188 // The filled range can be checked with check_range_for_pattern. One also can only check
 189 // a sub range of the original range.
 190 void fill_range_with_pattern(MetaWord* p, uintx pattern, size_t word_size);
 191 void check_range_for_pattern(const MetaWord* p, uintx pattern, size_t word_size);
 192 
 193 // Writes a uniqe pattern to p
 194 void mark_address(MetaWord* p, uintx pattern);
 195 // checks pattern at address
 196 void check_marked_address(const MetaWord* p, uintx pattern);
 197 
 198 // Similar to fill_range_with_pattern, but only marks start and end. This is optimized for cases
 199 // where fill_range_with_pattern just is too slow.
 200 // Use check_marked_range to check the range. In contrast to check_range_for_pattern, only the original
 201 // range can be checked.
 202 void mark_range(MetaWord* p, uintx pattern, size_t word_size);
 203 void check_marked_range(const MetaWord* p, uintx pattern, size_t word_size);
 204 
 205 void mark_range(MetaWord* p, size_t word_size);
 206 void check_marked_range(const MetaWord* p, size_t word_size);
 207 
 208 //////////////////////////////////////////////////////////
 209 // Some helpers to avoid typing out those annoying casts for NULL
 210 
 211 #define ASSERT_NOT_NULL(ptr)      ASSERT_NE((void*)NULL, (void*)ptr)
 212 #define ASSERT_NULL(ptr)          ASSERT_EQ((void*)NULL, (void*)ptr)
 213 #define EXPECT_NOT_NULL(ptr)      EXPECT_NE((void*)NULL, (void*)ptr)
 214 #define EXPECT_NULL(ptr)          EXPECT_EQ((void*)NULL, (void*)ptr)
 215 
 216 #define ASSERT_0(v)               ASSERT_EQ((intptr_t)0, (intptr_t)v)
 217 #define ASSERT_NOT_0(v)           ASSERT_NE((intptr_t)0, (intptr_t)v)
 218 #define EXPECT_0(v)               EXPECT_EQ((intptr_t)0, (intptr_t)v)
 219 #define EXPECT_NOT_0(v)           EXPECT_NE((intptr_t)0, (intptr_t)v)
 220 
 221 //////////////////////////////////////////////////////////
 222 // logging
 223 
 224 // Define "LOG_PLEASE" to switch on logging for a particular test before inclusion of this header.
 225 #ifdef LOG_PLEASE
 226   #define LOG(...) { printf(__VA_ARGS__); printf("\n"); fflush(stdout); }
 227 #else
 228   #define LOG(...)
 229 #endif
 230 
 231 //////////////////////////////////////////////////////////
 232 // Helper
 233 
 234 size_t get_workingset_size();
 235 
 236 // A simple preallocated buffer used to "feed" someone.
 237 // Mimicks chunk retirement leftover blocks.
 238 class FeederBuffer {
 239 
 240   MetaWord* _buf;
 241 
 242   // Buffer capacity in size of words.
 243   const size_t _cap;
 244 
 245   // Used words.
 246   size_t _used;
 247 
 248 public:
 249 
 250   FeederBuffer(size_t size) : _buf(NULL), _cap(size), _used(0) {
 251     _buf = NEW_C_HEAP_ARRAY(MetaWord, _cap, mtInternal);
 252   }
 253 
 254   ~FeederBuffer() {
 255     FREE_C_HEAP_ARRAY(MetaWord, _buf);
 256   }
 257 
 258   MetaWord* get(size_t word_size) {
 259     if (_used + word_size &gt; _cap) {
 260       return NULL;
 261     }
 262     MetaWord* p = _buf + _used;
 263     _used += word_size;
 264     return p;
 265   }
 266 
 267   bool is_valid_pointer(MetaWord* p) const {
 268     return p &gt;= _buf &amp;&amp; p &lt; _buf + _used;
 269   }
 270 
 271   bool is_valid_range(MetaWord* p, size_t word_size) const {
 272     return is_valid_pointer(p) &amp;&amp;
 273            word_size &gt; 0 ? is_valid_pointer(p + word_size - 1) : true;
 274   }
 275 
 276 };
 277 
 278 #endif // GTEST_METASPACE_METASPACETESTCOMMON_HPP
</pre></body></html>
