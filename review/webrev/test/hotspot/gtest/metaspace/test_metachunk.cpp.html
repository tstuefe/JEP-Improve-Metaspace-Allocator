<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_metachunk.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "metaspace/metaspaceTestsCommon.hpp"
  27 #include "metaspace/metaspace_testhelper.hpp"
  28 #include "runtime/mutexLocker.hpp"
  29 
  30 using namespace metaspace::chunklevel;
  31 
  32 // Test ChunkManager::get_chunk
  33 TEST_VM(metaspace, get_chunk) {
  34 
  35   MetaspaceTestHelper helper(8 * M);
  36   Metachunk* c = NULL;
  37 
  38   for (chunklevel_t pref_lvl = LOWEST_CHUNK_LEVEL; pref_lvl &lt;= HIGHEST_CHUNK_LEVEL; pref_lvl ++) {
  39 
  40     for (chunklevel_t max_lvl = pref_lvl; max_lvl &lt;= HIGHEST_CHUNK_LEVEL; max_lvl ++) {
  41 
  42       for (size_t min_committed_words = Settings::commit_granule_words();
  43            min_committed_words &lt;= word_size_for_level(max_lvl); min_committed_words *= 2) {
  44         helper.alloc_chunk_expect_success(&amp;c, pref_lvl, max_lvl, min_committed_words);
  45         helper.return_chunk(c);
  46       }
  47     }
  48   }
  49 }
  50 
  51 // Test ChunkManager::get_chunk, but with a commit limit.
  52 TEST_VM(metaspace, get_chunk_with_commit_limit) {
  53 
  54   const size_t commit_limit_words = 1 * M;
  55   MetaspaceTestHelper helper(commit_limit_words);
  56   Metachunk* c = NULL;
  57 
  58   for (chunklevel_t pref_lvl = LOWEST_CHUNK_LEVEL; pref_lvl &lt;= HIGHEST_CHUNK_LEVEL; pref_lvl ++) {
  59 
  60     for (chunklevel_t max_lvl = pref_lvl; max_lvl &lt;= HIGHEST_CHUNK_LEVEL; max_lvl ++) {
  61 
  62       for (size_t min_committed_words = Settings::commit_granule_words();
  63            min_committed_words &lt;= word_size_for_level(max_lvl); min_committed_words *= 2) {
  64 
  65         if (min_committed_words &lt;= commit_limit_words) {
  66           helper.alloc_chunk_expect_success(&amp;c, pref_lvl, max_lvl, min_committed_words);
  67           helper.return_chunk(c);
  68         } else {
  69           helper.alloc_chunk_expect_failure(pref_lvl, max_lvl, min_committed_words);
  70         }
  71 
  72       }
  73     }
  74   }
  75 }
  76 
  77 // Test that recommitting the used portion of a chunk will preserve the original content.
  78 TEST_VM(metaspace, get_chunk_recommit) {
  79 
  80   MetaspaceTestHelper helper;
  81   Metachunk* c = NULL;
  82   helper.alloc_chunk_expect_success(&amp;c, ROOT_CHUNK_LEVEL, ROOT_CHUNK_LEVEL, 0);
  83   helper.uncommit_chunk_with_test(c);
  84 
  85   helper.commit_chunk_with_test(c, Settings::commit_granule_words());
  86   helper.allocate_from_chunk(c, Settings::commit_granule_words());
  87 
  88   c-&gt;ensure_committed(Settings::commit_granule_words());
  89   check_range_for_pattern(c-&gt;base(), c-&gt;used_words(), (uintx)c);
  90 
  91   c-&gt;ensure_committed(Settings::commit_granule_words() * 2);
  92   check_range_for_pattern(c-&gt;base(), c-&gt;used_words(), (uintx)c);
  93 
  94   helper.return_chunk(c);
  95 
  96 }
  97 
  98 // Test ChunkManager::get_chunk, but with a reserve limit.
  99 // (meaning, the underlying VirtualSpaceList cannot expand, like compressed class space).
 100 TEST_VM(metaspace, get_chunk_with_reserve_limit) {
 101 
 102   const size_t reserve_limit_words = word_size_for_level(ROOT_CHUNK_LEVEL);
 103   const size_t commit_limit_words = 1024 * M; // just very high
 104   MetaspaceTestHelper helper(commit_limit_words, reserve_limit_words);
 105 
 106   // Reserve limit works at root chunk size granularity: if the chunk manager cannot satisfy
 107   //  a request for a chunk from its freelists, it will acquire a new root chunk from the
 108   //  underlying virtual space list. If that list is full and cannot be expanded (think ccs)
 109   //  we should get an error.
 110   // Testing this is simply testing a chunk allocation which should cause allocation of a new
 111   //  root chunk.
 112 
 113   // Cause allocation of the firstone root chunk, should still work:
 114   Metachunk* c = NULL;
 115   helper.alloc_chunk_expect_success(&amp;c, HIGHEST_CHUNK_LEVEL);
 116 
 117   // and this should need a new root chunk and hence fail:
 118   helper.alloc_chunk_expect_failure(ROOT_CHUNK_LEVEL);
 119 
 120   helper.return_chunk(c);
 121 
 122 }
 123 
 124 // Test MetaChunk::allocate
 125 TEST_VM(metaspace, chunk_allocate_full) {
 126 
 127   MetaspaceTestHelper helper;
 128 
 129   for (chunklevel_t lvl = LOWEST_CHUNK_LEVEL; lvl &lt;= HIGHEST_CHUNK_LEVEL; lvl ++) {
 130     Metachunk* c = NULL;
 131     helper.alloc_chunk_expect_success(&amp;c, lvl);
 132     helper.allocate_from_chunk(c, c-&gt;word_size());
 133     helper.return_chunk(c);
 134   }
 135 
 136 }
 137 
 138 // Test MetaChunk::allocate
 139 TEST_VM(metaspace, chunk_allocate_random) {
 140 
 141   MetaspaceTestHelper helper;
 142 
 143   for (chunklevel_t lvl = LOWEST_CHUNK_LEVEL; lvl &lt;= HIGHEST_CHUNK_LEVEL; lvl ++) {
 144 
 145     Metachunk* c = NULL;
 146     helper.alloc_chunk_expect_success(&amp;c, lvl);
 147     helper.uncommit_chunk_with_test(c); // start out fully uncommitted
 148 
 149     RandSizeGenerator rgen(1, c-&gt;word_size() / 30);
 150     bool stop = false;
 151 
 152     while (!stop) {
 153       const size_t s = rgen.get();
 154       if (s &lt;= c-&gt;free_words()) {
 155         helper.commit_chunk_with_test(c, s);
 156         helper.allocate_from_chunk(c, s);
 157       } else {
 158         stop = true;
 159       }
 160 
 161     }
 162     helper.return_chunk(c);
 163 
 164   }
 165 
 166 }
 167 
 168 TEST_VM(metaspace, chunk_buddy_stuff) {
 169 
 170   for (chunklevel_t l = ROOT_CHUNK_LEVEL + 1; l &lt;= HIGHEST_CHUNK_LEVEL; l ++) {
 171 
 172     MetaspaceTestHelper helper;
 173 
 174     // Allocate two chunks; since we know the first chunk is the first in its area,
 175     // it has to be a leader, and the next one of the same size its buddy.
 176 
 177     // (Note: strictly speaking the ChunkManager does not promise any placement but
 178     //  we know how the placement works so these tests make sense).
 179 
 180     Metachunk* c1 = NULL;
 181     helper.alloc_chunk(&amp;c1, CHUNK_LEVEL_1K);
 182     EXPECT_TRUE(c1-&gt;is_leader());
 183 
 184     Metachunk* c2 = NULL;
 185     helper.alloc_chunk(&amp;c2, CHUNK_LEVEL_1K);
 186     EXPECT_FALSE(c2-&gt;is_leader());
 187 
 188     // buddies are adjacent in memory
 189     // (next/prev_in_vs needs lock)
 190     {
 191       MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 192       EXPECT_EQ(c1-&gt;next_in_vs(), c2);
 193       EXPECT_EQ(c1-&gt;end(), c2-&gt;base());
 194       EXPECT_NULL(c1-&gt;prev_in_vs()); // since we know this is the first in the area
 195       EXPECT_EQ(c2-&gt;prev_in_vs(), c1);
 196     }
 197 
 198     helper.return_chunk(c1);
 199     helper.return_chunk(c2);
 200 
 201   }
 202 
 203 }
 204 
 205 
 206 TEST_VM(metaspace, chunk_allocate_with_commit_limit) {
 207 
 208   // This test does not make sense if commit-on-demand is off
 209   if (Settings::newborn_root_chunks_are_fully_committed()) {
 210     return;
 211   }
 212 
 213   const size_t granule_sz = Settings::commit_granule_words();
 214   const size_t commit_limit = granule_sz * 3;
 215   MetaspaceTestHelper helper(commit_limit);
 216 
 217   // A big chunk, but uncommitted.
 218   Metachunk* c = NULL;
 219   helper.alloc_chunk_expect_success(&amp;c, ROOT_CHUNK_LEVEL, ROOT_CHUNK_LEVEL, 0);
 220   helper.uncommit_chunk_with_test(c); // ... just to make sure.
 221 
 222   // first granule...
 223   helper.commit_chunk_with_test(c, granule_sz);
 224   helper.allocate_from_chunk(c, granule_sz);
 225 
 226   // second granule...
 227   helper.commit_chunk_with_test(c, granule_sz);
 228   helper.allocate_from_chunk(c, granule_sz);
 229 
 230   // third granule...
 231   helper.commit_chunk_with_test(c, granule_sz);
 232   helper.allocate_from_chunk(c, granule_sz);
 233 
 234   // This should fail now.
 235   helper.commit_chunk_expect_failure(c, granule_sz);
 236 
 237   helper.return_chunk(c);
 238 
 239 }
 240 
 241 // Test splitting a chunk
 242 TEST_VM(metaspace, chunk_split_and_merge) {
 243 
 244   // Split works like this:
 245   //
 246   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 247   // |                                  A                                            |
 248   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 249   //
 250   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 251   // | A' | b  |    c    |         d         |                   e                   |
 252   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 253   //
 254   // A original chunk (A) is split to form a target chunk (A') and as a result splinter
 255   // chunks form (b..e). A' is the leader of the (A',b) pair, which is the leader of the
 256   // ((A',b), c) pair and so on. In other words, A' will be a leader chunk, all splinter
 257   // chunks are follower chunks.
 258   //
 259   // Merging reverses this operation:
 260   //
 261   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 262   // | A  | b  |    c    |         d         |                   e                   |
 263   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 264   //
 265   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 266   // |                                  A'                                           |
 267   //  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
 268   //
 269   // (A) will be merged with its buddy b, (A+b) with its buddy c and so on. The result
 270   // chunk is A'.
 271   // Note that merging also works, of course, if we were to start the merge at (b) (so,
 272   // with a follower chunk, not a leader). Also, at any point in the merge
 273   // process we may arrive at a follower chunk. So, the fact that in this test
 274   // we only expect a leader merge is a feature of the test, and of the fact that we
 275   // start each split test with a fresh MetaspaceTestHelper.
 276 
 277   // Note: Splitting and merging chunks is usually done from within the ChunkManager and
 278   //  subject to a lot of assumptions and hence asserts. Here, we have to explicitly use
 279   //  VirtualSpaceNode::split/::merge and therefore have to observe rules:
 280   // - both split and merge expect free chunks, so state has to be "free"
 281   // - but that would trigger the "ideally merged" assertion in the RootChunkArea, so the
 282   //   original chunk has to be a root chunk, we cannot just split any chunk manually.
 283   // - Also, after the split we have to completely re-merge to avoid triggering asserts
 284   //   in ~RootChunkArea()
 285   // - finally we have to lock manually
 286 
 287   MetaspaceTestHelper helper;
 288 
 289   const chunklevel_t orig_lvl = ROOT_CHUNK_LEVEL;
 290   for (chunklevel_t target_lvl = orig_lvl + 1; target_lvl &lt;= HIGHEST_CHUNK_LEVEL; target_lvl ++) {
 291 
 292     // Split a fully committed chunk. The resulting chunk should be fully
 293     //  committed as well, and have its content preserved.
 294     Metachunk* c = NULL;
 295     helper.alloc_chunk_expect_success(&amp;c, orig_lvl);
 296 
 297     // We allocate from this chunk to be able to completely paint the payload.
 298     helper.allocate_from_chunk(c, c-&gt;word_size());
 299 
 300     const uintx canary = os::random();
 301     fill_range_with_pattern(c-&gt;base(), c-&gt;word_size(), canary);
 302 
 303     FreeChunkListVector splinters;
 304 
 305     {
 306       // Splitting/Merging chunks is usually done by the chunkmanager, and no explicit
 307       // outside API exists. So we split/merge chunks via the underlying vs node, directly.
 308       // This means that we have to go through some extra hoops to not trigger any asserts.
 309       MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 310       c-&gt;reset_used_words();
 311       c-&gt;set_free();
 312       c-&gt;vsnode()-&gt;split(target_lvl, c, &amp;splinters);
 313     }
 314 
 315     DEBUG_ONLY(helper.verify();)
 316 
 317     EXPECT_EQ(c-&gt;level(), target_lvl);
 318     EXPECT_TRUE(c-&gt;is_fully_committed());
 319     EXPECT_FALSE(c-&gt;is_root_chunk());
 320     EXPECT_TRUE(c-&gt;is_leader());
 321 
 322     check_range_for_pattern(c-&gt;base(), c-&gt;word_size(), canary);
 323 
 324     // I expect splinter chunks (one for each splinter level:
 325     //  e.g. splitting a 1M chunk to get a 64K chunk should yield splinters: [512K, 256K, 128K, 64K]
 326     for (chunklevel_t l = LOWEST_CHUNK_LEVEL; l &lt; HIGHEST_CHUNK_LEVEL; l ++) {
 327       const Metachunk* c2 = splinters.first_at_level(l);
 328       if (l &gt; orig_lvl &amp;&amp; l &lt;= target_lvl) {
 329         EXPECT_NOT_NULL(c2);
 330         EXPECT_EQ(c2-&gt;level(), l);
 331         EXPECT_TRUE(c2-&gt;is_free());
 332         EXPECT_TRUE(!c2-&gt;is_leader());
 333         DEBUG_ONLY(c2-&gt;verify(false));
 334         check_range_for_pattern(c2-&gt;base(), c2-&gt;word_size(), canary);
 335       } else {
 336         EXPECT_NULL(c2);
 337       }
 338     }
 339 
 340     // Revert the split by using merge. This should result in all splinters coalescing
 341     // to one chunk.
 342     {
 343       MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 344       Metachunk* merged = c-&gt;vsnode()-&gt;merge(c, &amp;splinters);
 345 
 346       // the merged chunk should occupy the same address as the splinter
 347       // since it should have been the leader in the split.
 348       EXPECT_EQ(merged, c);
 349       EXPECT_TRUE(merged-&gt;is_root_chunk() || merged-&gt;is_leader());
 350 
 351       // Splitting should have arrived at the original chunk since none of the splinters are in use.
 352       EXPECT_EQ(c-&gt;level(), orig_lvl);
 353 
 354       // All splinters should have been removed from the list
 355       EXPECT_EQ(splinters.num_chunks(), 0);
 356     }
 357 
 358     helper.return_chunk(c);
 359 
 360   }
 361 
 362 }
 363 
 364 TEST_VM(metaspace, chunk_enlarge_in_place) {
 365 
 366   MetaspaceTestHelper helper;
 367 
 368   // Starting with the smallest chunk size, attempt to enlarge the chunk in place until we arrive
 369   // at root chunk size. Since the state is clean, this should work.
 370 
 371   Metachunk* c = NULL;
 372   helper.alloc_chunk_expect_success(&amp;c, HIGHEST_CHUNK_LEVEL);
 373 
 374   chunklevel_t l = c-&gt;level();
 375 
 376   while (l != ROOT_CHUNK_LEVEL) {
 377 
 378     // commit and allocate from chunk to pattern it...
 379     const size_t original_chunk_size = c-&gt;word_size();
 380     helper.commit_chunk_with_test(c, c-&gt;free_words());
 381     helper.allocate_from_chunk(c, c-&gt;free_words());
 382 
 383     size_t used_before = c-&gt;used_words();
 384     size_t free_before = c-&gt;free_words();
 385     size_t free_below_committed_before = c-&gt;free_below_committed_words();
 386     const MetaWord* top_before = c-&gt;top();
 387 
 388     EXPECT_TRUE(helper.cm().attempt_enlarge_chunk(c));
 389     EXPECT_EQ(l - 1, c-&gt;level());
 390     EXPECT_EQ(c-&gt;word_size(), original_chunk_size * 2);
 391 
 392     // Used words should not have changed
 393     EXPECT_EQ(c-&gt;used_words(), used_before);
 394     EXPECT_EQ(c-&gt;top(), top_before);
 395 
 396     // free words should be expanded by the old size (since old chunk is doubled in size)
 397     EXPECT_EQ(c-&gt;free_words(), free_before + original_chunk_size);
 398 
 399     // free below committed can be larger but never smaller
 400     EXPECT_GE(c-&gt;free_below_committed_words(), free_below_committed_before);
 401 
 402     // Old content should be preserved
 403     check_range_for_pattern(c-&gt;base(), original_chunk_size, (uintx)c);
 404 
 405     l = c-&gt;level();
 406   }
 407 
 408   helper.return_chunk(c);
 409 
 410 }
 411 
</pre></body></html>
