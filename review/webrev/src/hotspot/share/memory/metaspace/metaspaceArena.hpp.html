<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metaspaceArena.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_METASPACEARENA_HPP
  27 #define SHARE_MEMORY_METASPACE_METASPACEARENA_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace.hpp"
  31 #include "memory/metaspace/chunkManager.hpp"
  32 #include "memory/metaspace/metachunk.hpp"
  33 #include "memory/metaspace/metachunkList.hpp"
  34 #include "memory/metaspace/metaspaceCommon.hpp"
  35 
  36 
  37 class outputStream;
  38 class Mutex;
  39 
  40 namespace metaspace {
  41 
  42 
  43 class ArenaGrowthPolicy;
  44 class FreeBlocks;
  45 
  46 struct arena_stats_t;
  47 
  48 // The MetaspaceArena:
  49 // - keeps a list of chunks-in-use by the class loader, as well as a current chunk used
  50 //   to allocate from
  51 // - keeps a dictionary of free MetaBlocks. Those can be remnants of a retired chunk or
  52 //   allocations which were not needed anymore for some reason (e.g. releasing half-allocated
  53 //   structures when class loading fails)
  54 
  55 class MetaspaceArena : public CHeapObj&lt;mtClass&gt; {
  56 
  57   // Reference to an outside lock to use for synchronizing access to this arena.
  58   //  This lock is normally owned by the CLD which owns the ClassLoaderMetaspace which
  59   //  owns this arena.
  60   // Todo: This should be changed. Either the CLD should synchronize access to the
  61   //       CLMS and its arenas itself, or the arena should have an own lock. The latter
  62   //       would allow for more fine granular locking since it would allow access to
  63   //       both class- and non-class arena in the CLMS independently.
  64   Mutex* const _lock;
  65 
  66   // Reference to the chunk manager to allocate chunks from.
  67   ChunkManager* const _chunk_manager;
  68 
  69   // Reference to the chunk allocation strategy to use.
  70   const ArenaGrowthPolicy* const _growth_policy;
  71 
  72   // List of chunks. Head of the list is the current chunk.
  73   MetachunkList _chunks;
  74 
  75   // Structure to take care of leftover/deallocated space in used chunks.
  76   // Owned by the Arena. Gets allocated on demand only.
  77   FreeBlocks* _fbl;
  78 
  79   Metachunk* current_chunk()              { return _chunks.first(); }
  80   const Metachunk* current_chunk() const  { return _chunks.first(); }
  81 
  82   // Reference to an outside counter to keep track of used space.
  83   SizeAtomicCounter* const _total_used_words_counter;
  84 
  85   // A name for purely debugging/logging purposes.
  86   const char* const _name;
  87 
  88   // Whether or not this is a "micro loader" which is not expected to load more than one class.
  89   const bool _is_micro_loader;
  90 
  91   Mutex* lock() const                           { return _lock; }
  92   ChunkManager* chunk_manager() const           { return _chunk_manager; }
  93 
  94   // free block list
  95   FreeBlocks* fbl() const                       { return _fbl; }
  96   void add_allocation_to_fbl(MetaWord* p, size_t word_size);
  97 
  98   // Given a chunk, add its remaining free committed space to the free block list.
  99   void salvage_chunk(Metachunk* c);
 100 
 101   // Allocate a new chunk from the underlying chunk manager able to hold at least
 102   // requested word size.
 103   Metachunk* allocate_new_chunk(size_t requested_word_size);
 104 
 105   // Returns the level of the next chunk to be added, acc to growth policy.
 106   chunklevel_t next_chunk_level() const;
 107 
 108   // Attempt to enlarge the current chunk to make it large enough to hold at least
 109   //  requested_word_size additional words.
 110   //
 111   // On success, true is returned, false otherwise.
 112   bool attempt_enlarge_current_chunk(size_t requested_word_size);
 113 
 114   // Prematurely returns a metaspace allocation to the _block_freelists
 115   // because it is not needed anymore (requires CLD lock to be active).
 116   void deallocate_locked(MetaWord* p, size_t word_size);
 117 
 118   // Returns true if the area indicated by pointer and size have actually been allocated
 119   // from this arena.
 120   DEBUG_ONLY(bool is_valid_area(MetaWord* p, size_t word_size) const;)
 121 
 122 public:
 123 
 124   MetaspaceArena(ChunkManager* chunk_manager,
 125                const ArenaGrowthPolicy* growth_policy,
 126                Mutex* lock,
 127                SizeAtomicCounter* total_used_words_counter,
 128                const char* name,
 129                bool is_micro_loader);
 130 
 131   ~MetaspaceArena();
 132 
 133   // Allocate memory from Metaspace.
 134   // 1) Attempt to allocate from the dictionary of deallocated blocks.
 135   // 2) Attempt to allocate from the current chunk.
 136   // 3) Attempt to enlarge the current chunk in place if it is too small.
 137   // 4) Attempt to get a new chunk and allocate from that chunk.
 138   // At any point, if we hit a commit limit, we return NULL.
 139   MetaWord* allocate(size_t word_size);
 140 
 141   // Prematurely returns a metaspace allocation to the _block_freelists because it is not
 142   // needed anymore.
 143   void deallocate(MetaWord* p, size_t word_size);
 144 
 145   // Update statistics. This walks all in-use chunks.
 146   void add_to_statistics(arena_stats_t* out) const;
 147 
 148   // Convenience method to get the most important usage statistics.
 149   // For deeper analysis use add_to_statistics().
 150   void usage_numbers(size_t* p_used_words, size_t* p_committed_words, size_t* p_capacity_words) const;
 151 
 152   DEBUG_ONLY(void verify(bool slow) const;)
 153   DEBUG_ONLY(void verify_locked(bool slow) const;)
 154 
 155   void print_on(outputStream* st) const;
 156   void print_on_locked(outputStream* st) const;
 157 
 158 };
 159 
 160 } // namespace metaspace
 161 
 162 #endif // SHARE_MEMORY_METASPACE_METASPACEARENA_HPP
 163 
</pre></body></html>
