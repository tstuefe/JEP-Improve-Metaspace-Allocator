<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  27 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  28 
  29 
  30 #include "memory/allocation.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "memory/metaspace/commitMask.hpp"
  33 #include "memory/metaspace/rootChunkArea.hpp"
  34 #include "memory/metaspace/settings.hpp"
  35 #include "memory/memRegion.hpp"
  36 #include "memory/virtualspace.hpp"
  37 #include "utilities/debug.hpp"
  38 #include "utilities/bitMap.hpp"
  39 #include "utilities/globalDefinitions.hpp"
  40 
  41 
  42 class outputStream;
  43 
  44 namespace metaspace {
  45 
  46 class CommitLimiter;
  47 class FreeChunkListVector;
  48 
  49 // VirtualSpaceNode manages a single address range of the Metaspace.
  50 //
  51 // That address range may contain interleaved committed and uncommitted
  52 // regions. It keeps track of which regions have committed and offers
  53 // functions to commit and uncommit regions.
  54 //
  55 // It allocates and hands out memory ranges, starting at the bottom.
  56 //
  57 // Address range must be aligned to root chunk size.
  58 //
  59 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
  60 
  61   // Link to next VirtualSpaceNode
  62   VirtualSpaceNode* _next;
  63 
  64   // The underlying space. This has been either created by this node
  65   //  and is owned by it, or has been handed in from outside (e.g. in
  66   //  case of CompressedClassSpace).
  67   ReservedSpace _rs;
  68 
  69   // True if the node owns the reserved space, false if not.
  70   const bool _owns_rs;
  71 
  72   // Start pointer of the area.
  73   MetaWord* const _base;
  74 
  75   // Size, in words, of the whole node
  76   const size_t _word_size;
  77 
  78   // Size, in words, of the range of this node which has been handed out in
  79   // the form of root chunks.
  80   size_t _used_words;
  81 
  82   // The bitmap describing the commit state of the region:
  83   // Each bit covers a region of 64K (see constants::commit_granule_size).
  84   CommitMask _commit_mask;
  85 
  86   // An array/LUT of RootChunkArea objects. Each one describes
  87   // fragmentation inside a root chunk.
  88   RootChunkAreaLUT _root_chunk_area_lut;
  89 
  90   // Limiter object to ask before expanding the committed size of this node.
  91   CommitLimiter* const _commit_limiter;
  92 
  93   // Points to outside size counters which we are to increase/decrease when we commit/uncommit
  94   // space from this node.
  95   SizeCounter* const _total_reserved_words_counter;
  96   SizeCounter* const _total_committed_words_counter;
  97 
  98   /// committing, uncommitting ///
  99 
 100   // Given a pointer into this node, calculate the start of the commit granule
 101   // the pointer points into.
 102   MetaWord* calc_start_of_granule(MetaWord* p) const {
 103     DEBUG_ONLY(check_pointer(p));
 104     return align_down(p, Settings::commit_granule_bytes());
 105   }
 106 
 107   // Given an address range, ensure it is committed.
 108   //
 109   // The range has to be aligned to granule size.
 110   //
 111   // Function will:
 112   // - check how many granules in that region are uncommitted; If all are committed, it
 113   //    returns true immediately.
 114   // - check if committing those uncommitted granules would bring us over the commit limit
 115   //    (GC threshold, MaxMetaspaceSize). If true, it returns false.
 116   // - commit the memory.
 117   // - mark the range as committed in the commit mask
 118   //
 119   // Returns true if success, false if it did hit a commit limit.
 120   bool commit_range(MetaWord* p, size_t word_size);
 121 
 122   //// creation ////
 123 
 124   // Create a new empty node spanning the given given reserved space.
 125   VirtualSpaceNode(ReservedSpace rs, bool owns_rs, CommitLimiter* limiter,
 126                    SizeCounter* reserve_counter, SizeCounter* commit_counter);
 127 
 128 public:
 129 
 130   // Create a node of a given size (it will create its own space).
 131   static VirtualSpaceNode* create_node(size_t word_size, CommitLimiter* limiter, SizeCounter* reserve_words_counter,
 132                                        SizeCounter* commit_words_counter);
 133 
 134   // Create a node over an existing space
 135   static VirtualSpaceNode* create_node(ReservedSpace rs, CommitLimiter* limiter, SizeCounter* reserve_words_counter,
 136                                        SizeCounter* commit_words_counter);
 137 
 138   ~VirtualSpaceNode();
 139 
 140   // Note: public for gtests only, could be private.
 141   MetaWord* base() const        { return _base; }
 142 
 143   // Reserved size of the whole node.
 144   size_t word_size() const      { return _word_size; }
 145 
 146   //// Chunk allocation, splitting, merging /////
 147 
 148   // Allocate a root chunk from this node. Will fail and return NULL
 149   // if the node is full.
 150   // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.
 151   // Hence, before using this chunk, it must be committed.
 152   // Also, no limits are checked, since no committing takes place.
 153   Metachunk* allocate_root_chunk();
 154 
 155   // Given a chunk c, split it recursively until you get a chunk of the given target_level.
 156   //
 157   // The resulting target chunk resides at the same address as the original chunk.
 158   // The resulting splinters are added to freelists.
 159   void split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists);
 160 
 161   // Given a chunk, attempt to merge it recursively with its neighboring chunks.
 162   //
 163   // If successful (merged at least once), returns address of
 164   // the merged chunk; NULL otherwise.
 165   //
 166   // The merged chunks are removed from the freelists.
 167   //
 168   // !!! Please note that if this method returns a non-NULL value, the
 169   // original chunk will be invalid and should not be accessed anymore! !!!
 170   Metachunk* merge(Metachunk* c, FreeChunkListVector* freelists);
 171 
 172   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
 173   // enlarge it in place by claiming its trailing buddy.
 174   //
 175   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 176   //
 177   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 178   // double in size (level decreased by one).
 179   //
 180   // On success, true is returned, false otherwise.
 181   bool attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists);
 182 
 183   // Attempts to purge the node:
 184   //
 185   // If all chunks living in this node are free, they will all be removed from
 186   //  the freelist they currently reside in. Then, the node will be deleted.
 187   //
 188   // Returns true if the node has been deleted, false if not.
 189   // !! If this returns true, do not access the node from this point on. !!
 190   bool attempt_purge(FreeChunkListVector* freelists);
 191 
 192   // Attempts to uncommit free areas according to the rules set in settings.
 193   // Returns number of words uncommitted.
 194   size_t uncommit_free_areas();
 195 
 196   /// misc /////
 197 
 198   // Returns size, in words, of the used space in this node alone.
 199   // (Notes:
 200   //  - This is the space handed out to the ChunkManager, so it is "used" from the viewpoint of this node,
 201   //    but not necessarily used for Metadata.
 202   //  - This may or may not be committed memory.
 203   size_t used_words() const             { return _used_words; }
 204 
 205   // Returns size, in words, of how much space is left in this node alone.
 206   size_t free_words() const             { return _word_size - _used_words; }
 207 
 208   // Returns size, in words, of committed space in this node alone.
 209   // Note: iterates over commit mask and hence may be a tad expensive on large nodes.
 210   size_t committed_words() const;
 211 
 212   //// Committing/uncommitting memory /////
 213 
 214   // Given an address range, ensure it is committed.
 215   //
 216   // The range does not have to be aligned to granule size. However, the function will always commit
 217   // whole granules.
 218   //
 219   // Function will:
 220   // - check how many granules in that region are uncommitted; If all are committed, it
 221   //    returns true immediately.
 222   // - check if committing those uncommitted granules would bring us over the commit limit
 223   //    (GC threshold, MaxMetaspaceSize). If true, it returns false.
 224   // - commit the memory.
 225   // - mark the range as committed in the commit mask
 226   //
 227   // Returns true if success, false if it did hit a commit limit.
 228   bool ensure_range_is_committed(MetaWord* p, size_t word_size);
 229 
 230   // Given an address range (which has to be aligned to commit granule size):
 231   //  - uncommit it
 232   //  - mark it as uncommitted in the commit mask
 233   void uncommit_range(MetaWord* p, size_t word_size);
 234 
 235   //// List stuff ////
 236   VirtualSpaceNode* next() const        { return _next; }
 237   void set_next(VirtualSpaceNode* vsn)  { _next = vsn; }
 238 
 239 
 240   /// Debug stuff ////
 241 
 242   // Print a description about this node.
 243   void print_on(outputStream* st) const;
 244 
 245   // Verify counters and basic structure. Slow mode: verify all chunks in depth
 246   bool contains(const MetaWord* p) const {
 247     return p &gt;= _base &amp;&amp; p &lt; _base + _used_words;
 248   }
 249 
 250 #ifdef ASSERT
 251   void check_pointer(const MetaWord* p) const {
 252     assert(contains(p), "invalid pointer");
 253   }
 254   void verify(bool slow) const;
 255   void verify_locked(bool slow) const;
 256 #endif
 257 
 258 };
 259 
 260 
 261 } // namespace metaspace
 262 
 263 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
</pre></body></html>
