<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
<span class="newmarker">--- 1,8 ----</span>
  /*
   * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="new">+  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<hr /><span class="oldmarker">*** 23,447 ****</span>
   */
  
  
  #include "precompiled.hpp"
  #include "logging/log.hpp"
<span class="removed">- #include "logging/logStream.hpp"</span>
  #include "memory/metaspace.hpp"
  #include "memory/metaspace/chunkManager.hpp"
<span class="changed">! #include "memory/metaspace/metachunk.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceCommon.hpp"</span>
  #include "memory/metaspace/virtualSpaceList.hpp"
  #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="removed">- #include "runtime/atomic.hpp"</span>
<span class="removed">- #include "runtime/orderAccess.hpp"</span>
  #include "runtime/mutexLocker.hpp"
<span class="changed">! #include "runtime/safepoint.hpp"</span>
  
  namespace metaspace {
  
  
<span class="changed">! VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="changed">!   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed">!   while (iter.repeat()) {</span>
<span class="changed">!     VirtualSpaceNode* vsl = iter.get_next();</span>
<span class="changed">!     delete vsl;</span>
<span class="changed">!   }</span>
  }
  
<span class="changed">! void VirtualSpaceList::inc_reserved_words(size_t v) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   _reserved_words = _reserved_words + v;</span>
<span class="changed">! }</span>
<span class="changed">! void VirtualSpaceList::dec_reserved_words(size_t v) {</span>
    assert_lock_strong(MetaspaceExpand_lock);
<span class="changed">!   _reserved_words = _reserved_words - v;</span>
  }
  
<span class="changed">! #define assert_committed_below_limit()                        \</span>
<span class="changed">!   assert(MetaspaceUtils::committed_bytes() &lt;= MaxMetaspaceSize, \</span>
<span class="changed">!          "Too much committed memory. Committed: " SIZE_FORMAT \</span>
<span class="changed">!          " limit (MaxMetaspaceSize): " SIZE_FORMAT,           \</span>
<span class="changed">!           MetaspaceUtils::committed_bytes(), MaxMetaspaceSize);</span>
<span class="changed">! </span>
<span class="changed">! void VirtualSpaceList::inc_committed_words(size_t v) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   _committed_words = _committed_words + v;</span>
<span class="changed">! </span>
<span class="changed">!   assert_committed_below_limit();</span>
<span class="changed">! }</span>
<span class="changed">! void VirtualSpaceList::dec_committed_words(size_t v) {</span>
    assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">-   _committed_words = _committed_words - v;</span>
  
<span class="changed">!   assert_committed_below_limit();</span>
  }
  
<span class="changed">! void VirtualSpaceList::inc_virtual_space_count() {</span>
    assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">-   _virtual_space_count++;</span>
<span class="removed">- }</span>
  
<span class="changed">! void VirtualSpaceList::dec_virtual_space_count() {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   _virtual_space_count--;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Walk the list of VirtualSpaceNodes and delete</span>
<span class="changed">! // nodes with a 0 container_count.  Remove Metachunks in</span>
<span class="changed">! // the node from their respective freelists.</span>
<span class="changed">! void VirtualSpaceList::purge(ChunkManager* chunk_manager) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   // Don't use a VirtualSpaceListIterator because this</span>
<span class="changed">!   // list is being changed and a straightforward use of an iterator is not safe.</span>
<span class="changed">!   VirtualSpaceNode* prev_vsl = virtual_space_list();</span>
<span class="changed">!   VirtualSpaceNode* next_vsl = prev_vsl;</span>
<span class="changed">!   int num_purged_nodes = 0;</span>
<span class="changed">!   while (next_vsl != NULL) {</span>
<span class="changed">!     VirtualSpaceNode* vsl = next_vsl;</span>
<span class="changed">!     DEBUG_ONLY(vsl-&gt;verify(false);)</span>
<span class="changed">!     next_vsl = vsl-&gt;next();</span>
<span class="changed">!     // Don't free the current virtual space since it will likely</span>
<span class="changed">!     // be needed soon.</span>
<span class="changed">!     if (vsl-&gt;container_count() == 0 &amp;&amp; vsl != current_virtual_space()) {</span>
<span class="changed">!       log_trace(gc, metaspace, freelist)("Purging VirtualSpaceNode " PTR_FORMAT " (capacity: " SIZE_FORMAT</span>
<span class="changed">!                                          ", used: " SIZE_FORMAT ").", p2i(vsl), vsl-&gt;capacity_words_in_vs(), vsl-&gt;used_words_in_vs());</span>
<span class="changed">!       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_purged));</span>
<span class="changed">!       // Unlink it from the list</span>
<span class="changed">!       if (prev_vsl == vsl) {</span>
<span class="changed">!         // This is the case of the current node being the first node.</span>
<span class="changed">!         assert(vsl == virtual_space_list(), "Expected to be the first node");</span>
<span class="changed">!         set_virtual_space_list(vsl-&gt;next());</span>
<span class="changed">!       } else {</span>
<span class="changed">!         prev_vsl-&gt;set_next(vsl-&gt;next());</span>
<span class="changed">!       }</span>
  
<span class="changed">!       vsl-&gt;purge(chunk_manager);</span>
<span class="changed">!       dec_reserved_words(vsl-&gt;reserved_words());</span>
<span class="changed">!       dec_committed_words(vsl-&gt;committed_words());</span>
<span class="changed">!       dec_virtual_space_count();</span>
<span class="changed">!       delete vsl;</span>
<span class="changed">!       num_purged_nodes ++;</span>
      } else {
<span class="changed">!       prev_vsl = vsl;</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Verify list</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   if (num_purged_nodes &gt; 0) {</span>
<span class="changed">!     verify(false);</span>
<span class="changed">!   }</span>
<span class="changed">! #endif</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">! // This function looks at the mmap regions in the metaspace without locking.</span>
<span class="changed">! // The chunks are added with store ordering and not deleted except for at</span>
<span class="changed">! // unloading time during a safepoint.</span>
<span class="changed">! VirtualSpaceNode* VirtualSpaceList::find_enclosing_space(const void* ptr) {</span>
<span class="changed">!   // List should be stable enough to use an iterator here because removing virtual</span>
<span class="changed">!   // space nodes is only allowed at a safepoint.</span>
<span class="changed">!   if (is_within_envelope((address)ptr)) {</span>
<span class="changed">!     VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed">!     while (iter.repeat()) {</span>
<span class="changed">!       VirtualSpaceNode* vsn = iter.get_next();</span>
<span class="changed">!       if (vsn-&gt;contains(ptr)) {</span>
<span class="changed">!         return vsn;</span>
        }
      }
<span class="removed">-   }</span>
<span class="removed">-   return NULL;</span>
<span class="removed">- }</span>
  
<span class="changed">! void VirtualSpaceList::retire_current_virtual_space() {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   VirtualSpaceNode* vsn = current_virtual_space();</span>
  
<span class="changed">!   ChunkManager* cm = is_class() ? Metaspace::chunk_manager_class() :</span>
<span class="changed">!                                   Metaspace::chunk_manager_metadata();</span>
  
<span class="removed">-   vsn-&gt;retire(cm);</span>
  }
  
<span class="changed">! VirtualSpaceList::VirtualSpaceList(size_t word_size) :</span>
<span class="changed">!                                    _virtual_space_list(NULL),</span>
<span class="changed">!                                    _current_virtual_space(NULL),</span>
<span class="changed">!                                    _is_class(false),</span>
<span class="changed">!                                    _reserved_words(0),</span>
<span class="changed">!                                    _committed_words(0),</span>
<span class="changed">!                                    _virtual_space_count(0),</span>
<span class="changed">!                                    _envelope_lo((address)max_uintx),</span>
<span class="changed">!                                    _envelope_hi(NULL) {</span>
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   create_new_virtual_space(word_size);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! VirtualSpaceList::VirtualSpaceList(ReservedSpace rs) :</span>
<span class="changed">!                                    _virtual_space_list(NULL),</span>
<span class="changed">!                                    _current_virtual_space(NULL),</span>
<span class="changed">!                                    _is_class(true),</span>
<span class="changed">!                                    _reserved_words(0),</span>
<span class="changed">!                                    _committed_words(0),</span>
<span class="changed">!                                    _virtual_space_count(0),</span>
<span class="changed">!                                    _envelope_lo((address)max_uintx),</span>
<span class="changed">!                                    _envelope_hi(NULL) {</span>
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   VirtualSpaceNode* class_entry = new VirtualSpaceNode(is_class(), rs);</span>
<span class="changed">!   bool succeeded = class_entry-&gt;initialize();</span>
<span class="changed">!   if (succeeded) {</span>
<span class="changed">!     expand_envelope_to_include_node(class_entry);</span>
<span class="changed">!     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed">!     OrderAccess::storestore();</span>
<span class="changed">!     link_vs(class_entry);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
  
<span class="removed">- size_t VirtualSpaceList::free_bytes() {</span>
<span class="removed">-   return current_virtual_space()-&gt;free_words_in_vs() * BytesPerWord;</span>
<span class="removed">- }</span>
<span class="removed">- </span>
<span class="removed">- // Allocate another meta virtual space and add it to the list.</span>
<span class="removed">- bool VirtualSpaceList::create_new_virtual_space(size_t vs_word_size) {</span>
    assert_lock_strong(MetaspaceExpand_lock);
  
<span class="changed">!   if (is_class()) {</span>
<span class="changed">!     assert(false, "We currently don't support more than one VirtualSpace for"</span>
<span class="changed">!                   " the compressed class space. The initialization of the"</span>
<span class="changed">!                   " CCS uses another code path and should not hit this path.");</span>
<span class="changed">!     return false;</span>
    }
  
<span class="changed">!   if (vs_word_size == 0) {</span>
<span class="changed">!     assert(false, "vs_word_size should always be at least _reserve_alignment large.");</span>
<span class="changed">!     return false;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   // Reserve the space</span>
<span class="changed">!   size_t vs_byte_size = vs_word_size * BytesPerWord;</span>
<span class="changed">!   assert_is_aligned(vs_byte_size, Metaspace::reserve_alignment());</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate the meta virtual space and initialize it.</span>
<span class="changed">!   VirtualSpaceNode* new_entry = new VirtualSpaceNode(is_class(), vs_byte_size);</span>
<span class="changed">!   if (!new_entry-&gt;initialize()) {</span>
<span class="changed">!     delete new_entry;</span>
<span class="changed">!     return false;</span>
<span class="changed">!   } else {</span>
<span class="changed">!     assert(new_entry-&gt;reserved_words() == vs_word_size,</span>
<span class="changed">!         "Reserved memory size differs from requested memory size");</span>
<span class="changed">!     expand_envelope_to_include_node(new_entry);</span>
<span class="changed">!     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed">!     OrderAccess::storestore();</span>
<span class="changed">!     link_vs(new_entry);</span>
<span class="changed">!     DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_created));</span>
<span class="changed">!     return true;</span>
    }
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(verify(false);)</span>
<span class="changed">! </span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void VirtualSpaceList::link_vs(VirtualSpaceNode* new_entry) {</span>
<span class="changed">!   if (virtual_space_list() == NULL) {</span>
<span class="changed">!       set_virtual_space_list(new_entry);</span>
    } else {
<span class="changed">!     current_virtual_space()-&gt;set_next(new_entry);</span>
    }
<span class="changed">!   set_current_virtual_space(new_entry);</span>
<span class="changed">!   inc_reserved_words(new_entry-&gt;reserved_words());</span>
<span class="changed">!   inc_committed_words(new_entry-&gt;committed_words());</span>
<span class="changed">!   inc_virtual_space_count();</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   new_entry-&gt;mangle();</span>
<span class="changed">! #endif</span>
<span class="changed">!   LogTarget(Trace, gc, metaspace) lt;</span>
<span class="changed">!   if (lt.is_enabled()) {</span>
<span class="changed">!     LogStream ls(lt);</span>
<span class="changed">!     VirtualSpaceNode* vsl = current_virtual_space();</span>
<span class="changed">!     ResourceMark rm;</span>
<span class="changed">!     vsl-&gt;print_on(&amp;ls);</span>
    }
<span class="removed">- }</span>
  
<span class="changed">! bool VirtualSpaceList::expand_node_by(VirtualSpaceNode* node,</span>
<span class="changed">!                                       size_t min_words,</span>
<span class="changed">!                                       size_t preferred_words) {</span>
<span class="changed">!   size_t before = node-&gt;committed_words();</span>
  
<span class="changed">!   bool result = node-&gt;expand_by(min_words, preferred_words);</span>
  
<span class="removed">-   size_t after = node-&gt;committed_words();</span>
<span class="removed">- </span>
<span class="removed">-   // after and before can be the same if the memory was pre-committed.</span>
<span class="removed">-   assert(after &gt;= before, "Inconsistency");</span>
<span class="removed">-   inc_committed_words(after - before);</span>
<span class="removed">- </span>
<span class="removed">-   return result;</span>
  }
  
<span class="changed">! bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {</span>
<span class="changed">!   assert_is_aligned(min_words,       Metaspace::commit_alignment_words());</span>
<span class="changed">!   assert_is_aligned(preferred_words, Metaspace::commit_alignment_words());</span>
<span class="changed">!   assert(min_words &lt;= preferred_words, "Invalid arguments");</span>
<span class="changed">! </span>
<span class="changed">!   const char* const class_or_not = (is_class() ? "class" : "non-class");</span>
  
<span class="changed">!   if (!MetaspaceGC::can_expand(min_words, this-&gt;is_class())) {</span>
<span class="changed">!     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list.",</span>
<span class="changed">!               class_or_not);</span>
<span class="changed">!     return  false;</span>
    }
  
<span class="changed">!   size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();</span>
<span class="changed">!   if (allowed_expansion_words &lt; min_words) {</span>
<span class="changed">!     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list (must try gc first).",</span>
<span class="changed">!               class_or_not);</span>
<span class="changed">!     return false;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);</span>
  
<span class="changed">!   // Commit more memory from the the current virtual space.</span>
<span class="changed">!   bool vs_expanded = expand_node_by(current_virtual_space(),</span>
<span class="changed">!                                     min_words,</span>
<span class="changed">!                                     max_expansion_words);</span>
<span class="changed">!   if (vs_expanded) {</span>
<span class="changed">!      log_trace(gc, metaspace, freelist)("Expanded %s virtual space list.",</span>
<span class="changed">!                class_or_not);</span>
<span class="changed">!      return true;</span>
<span class="changed">!   }</span>
<span class="changed">!   log_trace(gc, metaspace, freelist)("%s virtual space list: retire current node.",</span>
<span class="changed">!             class_or_not);</span>
<span class="changed">!   retire_current_virtual_space();</span>
<span class="changed">! </span>
<span class="changed">!   // Get another virtual space.</span>
<span class="changed">!   size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);</span>
<span class="changed">!   grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());</span>
<span class="changed">! </span>
<span class="changed">!   if (create_new_virtual_space(grow_vs_words)) {</span>
<span class="changed">!     if (current_virtual_space()-&gt;is_pre_committed()) {</span>
<span class="changed">!       // The memory was pre-committed, so we are done here.</span>
<span class="changed">!       assert(min_words &lt;= current_virtual_space()-&gt;committed_words(),</span>
<span class="changed">!           "The new VirtualSpace was pre-committed, so it"</span>
<span class="changed">!           "should be large enough to fit the alloc request.");</span>
<span class="changed">!       return true;</span>
<span class="changed">!     }</span>
  
<span class="changed">!     return expand_node_by(current_virtual_space(),</span>
<span class="changed">!                           min_words,</span>
<span class="changed">!                           max_expansion_words);</span>
<span class="changed">!   }</span>
  
<span class="changed">!   return false;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Given a chunk, calculate the largest possible padding space which</span>
<span class="changed">! // could be required when allocating it.</span>
<span class="changed">! static size_t largest_possible_padding_size_for_chunk(size_t chunk_word_size, bool is_class) {</span>
<span class="changed">!   const ChunkIndex chunk_type = get_chunk_type_by_size(chunk_word_size, is_class);</span>
<span class="changed">!   if (chunk_type != HumongousIndex) {</span>
<span class="changed">!     // Normal, non-humongous chunks are allocated at chunk size</span>
<span class="changed">!     // boundaries, so the largest padding space required would be that</span>
<span class="changed">!     // minus the smallest chunk size.</span>
<span class="changed">!     const size_t smallest_chunk_size = is_class ? ClassSpecializedChunk : SpecializedChunk;</span>
<span class="changed">!     return chunk_word_size - smallest_chunk_size;</span>
<span class="changed">!   } else {</span>
<span class="changed">!     // Humongous chunks are allocated at smallest-chunksize</span>
<span class="changed">!     // boundaries, so there is no padding required.</span>
<span class="changed">!     return 0;</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
  
  
<span class="changed">! Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {</span>
  
<span class="changed">!   // Allocate a chunk out of the current virtual space.</span>
<span class="changed">!   Metachunk* next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
  
<span class="removed">-   if (next != NULL) {</span>
<span class="removed">-     return next;</span>
    }
  
<span class="changed">!   // The expand amount is currently only determined by the requested sizes</span>
<span class="changed">!   // and not how much committed memory is left in the current virtual space.</span>
<span class="changed">! </span>
<span class="changed">!   // We must have enough space for the requested size and any</span>
<span class="changed">!   // additional reqired padding chunks.</span>
<span class="changed">!   const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this-&gt;is_class());</span>
  
<span class="changed">!   size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());</span>
<span class="changed">!   size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());</span>
<span class="changed">!   if (min_word_size &gt;= preferred_word_size) {</span>
<span class="changed">!     // Can happen when humongous chunks are allocated.</span>
<span class="changed">!     preferred_word_size = min_word_size;</span>
    }
<span class="changed">! </span>
<span class="changed">!   bool expanded = expand_by(min_word_size, preferred_word_size);</span>
<span class="changed">!   if (expanded) {</span>
<span class="changed">!     next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
<span class="changed">!     assert(next != NULL, "The allocation was expected to succeed after the expansion");</span>
    }
<span class="changed">! </span>
<span class="changed">!    return next;</span>
  }
  
<span class="changed">! void VirtualSpaceList::print_on(outputStream* st, size_t scale) const {</span>
<span class="changed">!   st-&gt;print_cr(SIZE_FORMAT " nodes, current node: " PTR_FORMAT,</span>
<span class="changed">!       _virtual_space_count, p2i(_current_virtual_space));</span>
<span class="changed">!   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed">!   while (iter.repeat()) {</span>
<span class="changed">!     st-&gt;cr();</span>
<span class="changed">!     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed">!     node-&gt;print_on(st, scale);</span>
    }
  }
  
<span class="changed">! void VirtualSpaceList::print_map(outputStream* st) const {</span>
<span class="changed">!   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="changed">!   VirtualSpaceListIterator iter(list);</span>
<span class="changed">!   unsigned i = 0;</span>
<span class="changed">!   while (iter.repeat()) {</span>
<span class="changed">!     st-&gt;print_cr("Node %u:", i);</span>
<span class="changed">!     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed">!     node-&gt;print_map(st, this-&gt;is_class());</span>
<span class="changed">!     i ++;</span>
<span class="changed">!   }</span>
  }
  
<span class="changed">! // Given a node, expand range such that it includes the node.</span>
<span class="changed">! void VirtualSpaceList::expand_envelope_to_include_node(const VirtualSpaceNode* node) {</span>
<span class="changed">!   _envelope_lo = MIN2(_envelope_lo, (address)node-&gt;low_boundary());</span>
<span class="changed">!   _envelope_hi = MAX2(_envelope_hi, (address)node-&gt;high_boundary());</span>
  }
  
  
<span class="removed">- #ifdef ASSERT</span>
<span class="removed">- void VirtualSpaceList::verify(bool slow) {</span>
<span class="removed">-   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="removed">-   VirtualSpaceListIterator iter(list);</span>
<span class="removed">-   size_t reserved = 0;</span>
<span class="removed">-   size_t committed = 0;</span>
<span class="removed">-   size_t node_count = 0;</span>
<span class="removed">-   while (iter.repeat()) {</span>
<span class="removed">-     VirtualSpaceNode* node = iter.get_next();</span>
<span class="removed">-     if (slow) {</span>
<span class="removed">-       node-&gt;verify(true);</span>
<span class="removed">-     }</span>
<span class="removed">-     // Check that the node resides fully within our envelope.</span>
<span class="removed">-     assert((address)node-&gt;low_boundary() &gt;= _envelope_lo &amp;&amp; (address)node-&gt;high_boundary() &lt;= _envelope_hi,</span>
<span class="removed">-            "Node " SIZE_FORMAT " [" PTR_FORMAT ", " PTR_FORMAT ") outside envelope [" PTR_FORMAT ", " PTR_FORMAT ").",</span>
<span class="removed">-            node_count, p2i(node-&gt;low_boundary()), p2i(node-&gt;high_boundary()), p2i(_envelope_lo), p2i(_envelope_hi));</span>
<span class="removed">-     reserved += node-&gt;reserved_words();</span>
<span class="removed">-     committed += node-&gt;committed_words();</span>
<span class="removed">-     node_count ++;</span>
<span class="removed">-   }</span>
<span class="removed">-   assert(reserved == reserved_words() &amp;&amp; committed == committed_words() &amp;&amp; node_count == _virtual_space_count,</span>
<span class="removed">-       "Mismatch: reserved real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed">-       ", committed real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed">-       ", node count real: " SIZE_FORMAT " expected: " SIZE_FORMAT ".",</span>
<span class="removed">-       reserved, reserved_words(), committed, committed_words(),</span>
<span class="removed">-       node_count, _virtual_space_count);</span>
<span class="removed">- }</span>
<span class="removed">- #endif // ASSERT</span>
  
  } // namespace metaspace
<span class="newmarker">--- 24,275 ----</span>
   */
  
  
  #include "precompiled.hpp"
  #include "logging/log.hpp"
  #include "memory/metaspace.hpp"
  #include "memory/metaspace/chunkManager.hpp"
<span class="changed">! #include "memory/metaspace/counter.hpp"</span>
<span class="changed">! #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">! #include "memory/metaspace/counter.hpp"</span>
<span class="changed">! #include "memory/metaspace/freeChunkList.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceContext.hpp"</span>
  #include "memory/metaspace/virtualSpaceList.hpp"
  #include "memory/metaspace/virtualSpaceNode.hpp"
  #include "runtime/mutexLocker.hpp"
<span class="changed">! </span>
  
  namespace metaspace {
  
<span class="new">+ #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"</span>
<span class="new">+ #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  
<span class="changed">! // Create a new, empty, expandable list.</span>
<span class="changed">! VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">!   : _name(name),</span>
<span class="changed">!     _first_node(NULL),</span>
<span class="changed">!     _can_expand(true),</span>
<span class="changed">!     _can_purge(true),</span>
<span class="changed">!     _commit_limiter(commit_limiter),</span>
<span class="changed">!     _reserved_words_counter(),</span>
<span class="changed">!     _committed_words_counter()</span>
<span class="changed">! {</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">! // It will be not expandable beyond that first node.</span>
<span class="changed">! VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">! : _name(name),</span>
<span class="changed">!   _first_node(NULL),</span>
<span class="changed">!   _can_expand(false),</span>
<span class="changed">!   _can_purge(false),</span>
<span class="changed">!   _commit_limiter(commit_limiter),</span>
<span class="changed">!   _reserved_words_counter(),</span>
<span class="changed">!   _committed_words_counter()</span>
<span class="changed">! {</span>
<span class="changed">!   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">!   // for this list since we cannot expand.</span>
<span class="changed">!   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(rs, _commit_limiter,</span>
<span class="changed">!                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">!   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">!   _first_node = vsn;</span>
<span class="changed">!   _first_node-&gt;set_next(NULL);</span>
<span class="changed">!   _nodes_counter.increment();</span>
  }
  
<span class="changed">! VirtualSpaceList::~VirtualSpaceList() {</span>
    assert_lock_strong(MetaspaceExpand_lock);
<span class="changed">!   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">!   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">!   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">!   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">!   while (vsn != NULL) {</span>
<span class="changed">!     vsn2 = vsn-&gt;next();</span>
<span class="changed">!     delete vsn;</span>
<span class="changed">!     vsn = vsn2;</span>
<span class="changed">!   }</span>
  }
  
<span class="changed">! // Create a new node and append it to the list. After</span>
<span class="changed">! // this function, _current_node shall point to a new empty node.</span>
<span class="changed">! // List must be expandable for this to work.</span>
<span class="changed">! void VirtualSpaceList::create_new_node() {</span>
<span class="changed">!   assert(_can_expand, "List is not expandable");</span>
    assert_lock_strong(MetaspaceExpand_lock);
  
<span class="changed">!   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(Settings::virtual_space_node_default_word_size(),</span>
<span class="changed">!                                                         _commit_limiter,</span>
<span class="changed">!                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">!   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">!   vsn-&gt;set_next(_first_node);</span>
<span class="changed">!   _first_node = vsn;</span>
<span class="changed">!   _nodes_counter.increment();</span>
  }
  
<span class="changed">! // Allocate a root chunk from this list.</span>
<span class="changed">! // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed">! // Hence, before using this chunk, it must be committed.</span>
<span class="changed">! // Also, no limits are checked, since no committing takes place.</span>
<span class="changed">! Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
    assert_lock_strong(MetaspaceExpand_lock);
  
<span class="changed">!   if (_first_node == NULL ||</span>
<span class="changed">!       _first_node-&gt;free_words() == 0) {</span>
  
<span class="changed">!     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="changed">!     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="changed">!     // we should never have left-over space.</span>
<span class="changed">!     assert(_first_node == NULL ||</span>
<span class="changed">!            _first_node-&gt;free_words() == 0, "Sanity");</span>
<span class="changed">! </span>
<span class="changed">!     if (_can_expand) {</span>
<span class="changed">!       create_new_node();</span>
<span class="changed">!       UL2(debug, "added new node (now: %d).", num_nodes());</span>
      } else {
<span class="changed">!       UL(debug, "list cannot expand.");</span>
<span class="changed">!       return NULL; // We cannot expand this list.</span>
      }
    }
  
<span class="changed">!   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>
  
<span class="changed">!   assert(c != NULL, "This should have worked");</span>
  
<span class="changed">!   return c;</span>
  
  }
  
<span class="changed">! // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed">! // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed">! // Return number of purged nodes.</span>
<span class="changed">! int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>
  
    assert_lock_strong(MetaspaceExpand_lock);
  
<span class="changed">!   if (_can_purge == false) {</span>
<span class="changed">!     return 0;</span>
    }
  
<span class="changed">!   UL(debug, "purging.");</span>
  
<span class="changed">!   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">!   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed">!   int num = 0, num_purged = 0;</span>
<span class="changed">!   while (vsn != NULL) {</span>
<span class="changed">!     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed">!     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed">!     if (purged) {</span>
<span class="changed">!       // Note: from now on do not dereference vsn!</span>
<span class="changed">!       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));</span>
<span class="changed">!       if (_first_node == vsn) {</span>
<span class="changed">!         _first_node = next_vsn;</span>
<span class="changed">!       }</span>
<span class="changed">!       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed">!       if (prev_vsn != NULL) {</span>
<span class="changed">!         prev_vsn-&gt;set_next(next_vsn);</span>
        }
<span class="changed">!       num_purged ++;</span>
<span class="changed">!       _nodes_counter.decrement();</span>
      } else {
<span class="changed">!       prev_vsn = vsn;</span>
      }
<span class="changed">!     vsn = next_vsn;</span>
<span class="changed">!     num ++;</span>
    }
  
<span class="changed">!   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());</span>
  
<span class="changed">!   return num_purged;</span>
  
  }
  
<span class="changed">! // Print all nodes in this space list.</span>
<span class="changed">! void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="changed">!   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed">!   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">!   int n = 0;</span>
<span class="changed">!   while (vsn != NULL) {</span>
<span class="changed">!     st-&gt;print("- node #%d: ", n);</span>
<span class="changed">!     vsn-&gt;print_on(st);</span>
<span class="changed">!     vsn = vsn-&gt;next();</span>
<span class="changed">!     n ++;</span>
    }
<span class="new">+   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="new">+                n, reserved_words(), committed_words());</span>
<span class="new">+ }</span>
  
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">! void VirtualSpaceList::verify_locked(bool slow) const {</span>
  
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   assert(_name != NULL, "Sanity");</span>
  
<span class="changed">!   int n = 0;</span>
  
<span class="changed">!   if (_first_node != NULL) {</span>
  
<span class="new">+     size_t total_reserved_words = 0;</span>
<span class="new">+     size_t total_committed_words = 0;</span>
<span class="new">+     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="new">+     while (vsn != NULL) {</span>
<span class="new">+       n ++;</span>
<span class="new">+       vsn-&gt;verify_locked(slow);</span>
<span class="new">+       total_reserved_words += vsn-&gt;word_size();</span>
<span class="new">+       total_committed_words += vsn-&gt;committed_words();</span>
<span class="new">+       vsn = vsn-&gt;next();</span>
<span class="new">+     }</span>
<span class="new">+ </span>
<span class="new">+     _nodes_counter.check(n);</span>
<span class="new">+     _reserved_words_counter.check(total_reserved_words);</span>
<span class="new">+     _committed_words_counter.check(total_committed_words);</span>
  
<span class="changed">!   } else {</span>
  
<span class="changed">!     _reserved_words_counter.check(0);</span>
<span class="changed">!     _committed_words_counter.check(0);</span>
  
    }
<span class="new">+ }</span>
  
<span class="changed">! void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   verify_locked(slow);</span>
<span class="changed">! }</span>
<span class="changed">! #endif</span>
  
<span class="changed">! // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed">! bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed">!   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">!   while (vsn != NULL) {</span>
<span class="changed">!     if (vsn-&gt;contains(p)) {</span>
<span class="changed">!       return true;</span>
      }
<span class="changed">!     vsn = vsn-&gt;next();</span>
    }
<span class="changed">!   return false;</span>
  }
  
<span class="changed">! // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed">! // can be allocated.</span>
<span class="changed">! bool VirtualSpaceList::is_full() const {</span>
<span class="changed">!   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed">!     return true;</span>
    }
<span class="new">+   return false;</span>
  }
  
<span class="changed">! // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed">! //  and non-class chunkmanager, respectively.</span>
<span class="changed">! VirtualSpaceList* VirtualSpaceList::vslist_class() {</span>
<span class="changed">!   return MetaspaceContext::contect_class() == NULL ? NULL : MetaspaceContext::contect_class()-&gt;vslist();</span>
  }
  
<span class="changed">! VirtualSpaceList* VirtualSpaceList::vslist_nonclass() {</span>
<span class="changed">!   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;vslist();</span>
  }
  
  
  
  } // namespace metaspace
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

