<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2019, SAP SE. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
<a name="2" id="anc2"></a><span class="new">  26 </span>
  27 #include "precompiled.hpp"
<a name="3" id="anc3"></a><span class="changed">  28 </span>
<span class="changed">  29 #include "logging/log.hpp"</span>
<span class="changed">  30 #include "memory/metaspace/chunkLevel.hpp"</span>
  31 #include "memory/metaspace/metachunk.hpp"
<a name="4" id="anc4"></a><span class="changed">  32 #include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/settings.hpp"</span>
  34 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="5" id="anc5"></a><span class="new">  35 #include "runtime/mutexLocker.hpp"</span>
<span class="new">  36 </span>
  37 #include "utilities/align.hpp"
  38 #include "utilities/copy.hpp"
  39 #include "utilities/debug.hpp"
  40 
  41 namespace metaspace {
  42 
<a name="6" id="anc6"></a><span class="changed">  43 // Return a single char presentation of the state ('f', 'u', 'd')</span>
<span class="changed">  44 char Metachunk::get_state_char() const {</span>
<span class="changed">  45   switch (_state) {</span>
<span class="changed">  46   case state_free:    return 'f';</span>
<span class="changed">  47   case state_in_use:  return 'u';</span>
<span class="changed">  48   case state_dead:    return 'd';</span>
<span class="changed">  49   }</span>
<span class="changed">  50   return '?';</span>
<span class="changed">  51 }</span>
<span class="changed">  52 </span>




















  53 #ifdef ASSERT
<a name="7" id="anc7"></a><span class="changed">  54 void Metachunk::assert_have_expand_lock() {</span>
<span class="changed">  55   assert_lock_strong(MetaspaceExpand_lock);</span>

  56 }
<a name="8" id="anc8"></a><span class="new">  57 #endif</span>
<span class="new">  58 </span>
<span class="new">  59 // Commit uncommitted section of the chunk.</span>
<span class="new">  60 // Fails if we hit a commit limit.</span>
<span class="new">  61 bool Metachunk::commit_up_to(size_t new_committed_words) {</span>
<span class="new">  62 </span>
<span class="new">  63   // Please note:</span>
<span class="new">  64   //</span>
<span class="new">  65   // VirtualSpaceNode::ensure_range_is_committed(), when called over a range containing both committed and uncommitted parts,</span>
<span class="new">  66   // will replace the whole range with a new mapping, thus erasing the existing content in the committed parts. Therefore</span>
<span class="new">  67   // we must make sure never to call VirtualSpaceNode::ensure_range_is_committed() over a range containing live data.</span>
<span class="new">  68   //</span>
<span class="new">  69   // Luckily, this cannot happen by design. We have two cases:</span>
<span class="new">  70   //</span>
<span class="new">  71   // 1) chunks equal or larger than a commit granule.</span>
<span class="new">  72   //    In this case, due to chunk geometry, the chunk should cover whole commit granules (in other words, a chunk equal or larger than</span>
<span class="new">  73   //    a commit granule will never share a granule with a neighbor). That means whatever we commit or uncommit here does not affect</span>
<span class="new">  74   //    neighboring chunks. We only have to take care not to re-commit used parts of ourself. We do this by moving the committed_words</span>
<span class="new">  75   //    limit in multiple of commit granules.</span>
<span class="new">  76   //</span>
<span class="new">  77   // 2) chunks smaller than a commit granule.</span>
<span class="new">  78   //    In this case, a chunk shares a single commit granule with its neighbors. But this never can be a problem:</span>
<span class="new">  79   //    - Either the commit granule is already committed (and maybe the neighbors contain live data). In that case calling</span>
<span class="new">  80   //      ensure_range_is_committed() will do nothing.</span>
<span class="new">  81   //    - Or the commit granule is not committed, but in this case, the neighbors are uncommitted too and cannot contain live data.</span>
<span class="new">  82 </span>
<span class="new">  83 #ifdef ASSERT</span>
<span class="new">  84   if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="new">  85     // case (1)</span>
<span class="new">  86     assert(is_aligned(base(), Settings::commit_granule_bytes()) &amp;&amp;</span>
<span class="new">  87            is_aligned(end(), Settings::commit_granule_bytes()),</span>
<span class="new">  88            "Chunks larger than a commit granule must cover whole granules.");</span>
<span class="new">  89     assert(is_aligned(_committed_words, Settings::commit_granule_words()),</span>
<span class="new">  90            "The commit boundary must be aligned to commit granule size");</span>
<span class="new">  91     assert(_used_words &lt;= _committed_words, "Sanity");</span>
<span class="new">  92   } else {</span>
<span class="new">  93     // case (2)</span>
<span class="new">  94     assert(_committed_words == 0 || _committed_words == word_size(), "Sanity");</span>
<span class="new">  95   }</span>
<span class="new">  96 #endif</span>
<span class="new">  97 </span>
<span class="new">  98   // We should hold the expand lock at this point.</span>
<span class="new">  99   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new"> 100 </span>
<span class="new"> 101   const size_t commit_from = _committed_words;</span>
<span class="new"> 102   const size_t commit_to =   MIN2(align_up(new_committed_words, Settings::commit_granule_words()), word_size());</span>
 103 
<a name="9" id="anc9"></a><span class="changed"> 104   assert(commit_from &gt;= used_words(), "Sanity");</span>
<span class="changed"> 105   assert(commit_to &lt;= word_size(), "Sanity");</span>
<span class="changed"> 106 </span>
<span class="changed"> 107   if (commit_to &gt; commit_from) {</span>
<span class="changed"> 108     log_debug(metaspace)("Chunk " METACHUNK_FORMAT ": attempting to move commit line to "</span>
<span class="changed"> 109                          SIZE_FORMAT " words.", METACHUNK_FORMAT_ARGS(this), commit_to);</span>
<span class="changed"> 110 </span>
<span class="changed"> 111     if (!_vsnode-&gt;ensure_range_is_committed(base() + commit_from, commit_to - commit_from)) {</span>
<span class="changed"> 112       DEBUG_ONLY(verify(true);)</span>
<span class="changed"> 113       return false;</span>
<span class="changed"> 114     }</span>
 115   }
<a name="10" id="anc10"></a><span class="changed"> 116 </span>
<span class="changed"> 117   // Remember how far we have committed.</span>
<span class="changed"> 118   _committed_words = commit_to;</span>
<span class="changed"> 119 </span>
<span class="changed"> 120   DEBUG_ONLY(verify(true);)</span>
<span class="changed"> 121 </span>
<span class="changed"> 122   return true;</span>
<span class="changed"> 123 </span>
 124 }
 125 
<a name="11" id="anc11"></a><span class="changed"> 126 </span>
<span class="changed"> 127 // Ensure that chunk is committed up to at least new_committed_words words.</span>
<span class="changed"> 128 // Fails if we hit a commit limit.</span>
<span class="changed"> 129 bool Metachunk::ensure_committed(size_t new_committed_words) {</span>
<span class="changed"> 130 </span>
<span class="changed"> 131   bool rc = true;</span>
<span class="changed"> 132 </span>
<span class="changed"> 133   if (new_committed_words &gt; committed_words()) {</span>
<span class="changed"> 134     MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 135     rc = commit_up_to(new_committed_words);</span>
<span class="changed"> 136   }</span>
<span class="changed"> 137 </span>
<span class="changed"> 138   return rc;</span>
<span class="changed"> 139 </span>
 140 }
 141 
<a name="12" id="anc12"></a><span class="changed"> 142 bool Metachunk::ensure_committed_locked(size_t new_committed_words) {</span>
<span class="changed"> 143 </span>
<span class="changed"> 144   // the .._locked() variant should be called if we own the lock already.</span>
<span class="changed"> 145   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 146 </span>
<span class="changed"> 147   bool rc = true;</span>
<span class="changed"> 148 </span>
<span class="changed"> 149   if (new_committed_words &gt; committed_words()) {</span>
<span class="changed"> 150     rc = commit_up_to(new_committed_words);</span>
<span class="changed"> 151   }</span>
<span class="changed"> 152 </span>
<span class="changed"> 153   return rc;</span>
<span class="changed"> 154 </span>
 155 }
 156 
<a name="13" id="anc13"></a><span class="changed"> 157 // Uncommit chunk area. The area must be a common multiple of the</span>
<span class="changed"> 158 // commit granule size (in other words, we cannot uncommit chunks smaller than</span>
<span class="changed"> 159 // a commit granule size).</span>
<span class="changed"> 160 void Metachunk::uncommit() {</span>
<span class="changed"> 161   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 162   uncommit_locked();</span>
<span class="changed"> 163 }</span>
<span class="changed"> 164 </span>
<span class="changed"> 165 void Metachunk::uncommit_locked() {</span>
<span class="changed"> 166   // Only uncommit chunks which are free, have no used words set (extra precaution) and are equal or larger in size than a single commit granule.</span>
<span class="changed"> 167   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 168   assert(_state == state_free &amp;&amp; _used_words == 0 &amp;&amp; word_size() &gt;= Settings::commit_granule_words(),</span>
<span class="changed"> 169          "Only free chunks equal or larger than commit granule size can be uncommitted "</span>
<span class="changed"> 170          "(chunk " METACHUNK_FULL_FORMAT ").", METACHUNK_FULL_FORMAT_ARGS(this));</span>
<span class="changed"> 171   if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="changed"> 172     _vsnode-&gt;uncommit_range(base(), word_size());</span>
<span class="changed"> 173     _committed_words = 0;</span>
 174   }
 175 }
<a name="14" id="anc14"></a><span class="new"> 176 void Metachunk::set_committed_words(size_t v) {</span>
<span class="new"> 177   // Set committed words. Since we know that we only commit whole commit granules, we can round up v here.</span>
<span class="new"> 178   v = MIN2(align_up(v, Settings::commit_granule_words()), word_size());</span>
<span class="new"> 179  _committed_words = v;</span>
<span class="new"> 180 }</span>
<span class="new"> 181 </span>
<span class="new"> 182 </span>
<span class="new"> 183 // Allocate word_size words from this chunk (word_size must be aligned to</span>
<span class="new"> 184 //  allocation_alignment_words).</span>
<span class="new"> 185 //</span>
<span class="new"> 186 // Caller must make sure the chunk is both large enough and committed far enough</span>
<span class="new"> 187 // to hold the allocation. Will always work.</span>
<span class="new"> 188 //</span>
<span class="new"> 189 MetaWord* Metachunk::allocate(size_t request_word_size) {</span>
<span class="new"> 190 </span>
<span class="new"> 191   log_trace(metaspace)("Chunk " METACHUNK_FULL_FORMAT ": allocating " SIZE_FORMAT " words.",</span>
<span class="new"> 192                        METACHUNK_FULL_FORMAT_ARGS(this), request_word_size);</span>
<span class="new"> 193 </span>
<span class="new"> 194   // Caller must have made sure this works</span>
<span class="new"> 195   assert(free_words() &gt;= request_word_size, "Chunk too small.");</span>
<span class="new"> 196   assert(free_below_committed_words() &gt;= request_word_size, "Chunk not committed.");</span>
<span class="new"> 197 </span>
<span class="new"> 198   MetaWord* const p = top();</span>
<span class="new"> 199 </span>
<span class="new"> 200   _used_words += request_word_size;</span>
<span class="new"> 201 </span>
<span class="new"> 202   SOMETIMES(verify(false);)</span>
<span class="new"> 203 </span>
<span class="new"> 204   return p;</span>
<span class="new"> 205 </span>
<span class="new"> 206 }</span>
 207 
 208 #ifdef ASSERT
<a name="15" id="anc15"></a><span class="changed"> 209 </span>
<span class="changed"> 210 // Zap this structure.</span>
<span class="changed"> 211 void Metachunk::zap_header(uint8_t c) {</span>
<span class="changed"> 212   memset(this, c, sizeof(Metachunk));</span>

























 213 }
 214 
<a name="16" id="anc16"></a><span class="changed"> 215 void Metachunk::fill_with_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="changed"> 216   assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="changed"> 217   for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="changed"> 218     _base[l] = pattern;</span>
<span class="changed"> 219   }</span>
<span class="changed"> 220 }</span>
<span class="changed"> 221 </span>
<span class="changed"> 222 void Metachunk::check_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="changed"> 223   assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="changed"> 224   for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="changed"> 225     assert(_base[l] == pattern,</span>
<span class="changed"> 226            "chunk " METACHUNK_FULL_FORMAT ": pattern change at " PTR_FORMAT ": expected " UINTX_FORMAT " but got " UINTX_FORMAT ".",</span>
<span class="changed"> 227            METACHUNK_FULL_FORMAT_ARGS(this), p2i(_base + l), (uintx)pattern, (uintx)_base[l]);</span>
<span class="changed"> 228 </span>
<span class="changed"> 229     ////////////////////////////////////////////</span>
<span class="changed"> 230     // A double-headed list of Metachunks.</span>
<span class="changed"> 231 </span>
<span class="changed"> 232     class AbstractMetachunkList {</span>
<span class="changed"> 233 </span>
<span class="changed"> 234       Metachunk* _first;</span>
<span class="changed"> 235       Metachunk* _last;</span>
<span class="changed"> 236 </span>
<span class="changed"> 237       // Number of chunks</span>
<span class="changed"> 238       IntCounter _num;</span>
<span class="changed"> 239 </span>
<span class="changed"> 240     protected:</span>
<span class="changed"> 241 </span>
<span class="changed"> 242       AbstractMetachunkList() : _first(NULL), _last(NULL), _num() {}</span>
<span class="changed"> 243 </span>
<span class="changed"> 244       Metachunk* first() const { return _first; }</span>
<span class="changed"> 245       int count() const { return _num.get(); }</span>
<span class="changed"> 246 </span>
<span class="changed"> 247       // Add chunk to the front of the list.</span>
<span class="changed"> 248       void add_front(Metachunk* c) {</span>
<span class="changed"> 249         if (_first == NULL) {</span>
<span class="changed"> 250           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 251           _first = _last = c;</span>
<span class="changed"> 252           c-&gt;set_prev(NULL);</span>
<span class="changed"> 253           c-&gt;set_next(NULL);</span>
<span class="changed"> 254         } else {</span>
<span class="changed"> 255           assert(_last != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="changed"> 256           c-&gt;set_next(_first);</span>
<span class="changed"> 257           c-&gt;set_prev(NULL);</span>
<span class="changed"> 258           _first-&gt;set_prev(c);</span>
<span class="changed"> 259           _first = c;</span>
<span class="changed"> 260         }</span>
<span class="changed"> 261         _num.increment();</span>
<span class="changed"> 262       }</span>
<span class="changed"> 263 </span>
<span class="changed"> 264       // Add chunk to the back of the list.</span>
<span class="changed"> 265       void add_back(Metachunk* c) {</span>
<span class="changed"> 266         if (_last == NULL) {</span>
<span class="changed"> 267           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 268           _last = _first = c;</span>
<span class="changed"> 269           c-&gt;set_prev(NULL);</span>
<span class="changed"> 270           c-&gt;set_next(NULL);</span>
<span class="changed"> 271         } else {</span>
<span class="changed"> 272           assert(_first != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="changed"> 273           c-&gt;set_next(NULL);</span>
<span class="changed"> 274           c-&gt;set_prev(_last);</span>
<span class="changed"> 275           _last-&gt;set_next(c);</span>
<span class="changed"> 276           _last = c;</span>
<span class="changed"> 277         }</span>
<span class="changed"> 278         _num.increment();</span>
<span class="changed"> 279       }</span>
<span class="changed"> 280 </span>
<span class="changed"> 281       // Remove chunk from the front of the list. Returns NULL if list is empty.</span>
<span class="changed"> 282       Metachunk* remove_front() {</span>
<span class="changed"> 283         Metachunk* c = NULL;</span>
<span class="changed"> 284         if (_first == NULL) {</span>
<span class="changed"> 285           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 286         } else {</span>
<span class="changed"> 287           c = _first;</span>
<span class="changed"> 288           assert(c-&gt;prev() == NULL, "Sanity");</span>
<span class="changed"> 289           if (_first == _last) {</span>
<span class="changed"> 290             assert(_num.get() == 1, "Sanity");</span>
<span class="changed"> 291             _first = _last = NULL;</span>
<span class="changed"> 292           } else {</span>
<span class="changed"> 293             assert(_num.get() &gt; 1, "Sanity");</span>
<span class="changed"> 294             _first = _first-&gt;next();</span>
<span class="changed"> 295             _first-&gt;set_prev(NULL);</span>
<span class="changed"> 296           }</span>
<span class="changed"> 297           _num.decrement();</span>
<span class="changed"> 298           c-&gt;set_next(NULL);</span>
<span class="changed"> 299         }</span>
<span class="changed"> 300         return c;</span>
<span class="changed"> 301       }</span>
<span class="changed"> 302 </span>
<span class="changed"> 303       // Remove chunk from the back of the list. Returns NULL if list is empty.</span>
<span class="changed"> 304       Metachunk* remove_back() {</span>
<span class="changed"> 305         Metachunk* c = NULL;</span>
<span class="changed"> 306         if (_last == NULL) {</span>
<span class="changed"> 307           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 308         } else {</span>
<span class="changed"> 309           c = _last;</span>
<span class="changed"> 310           assert(c-&gt;next() == NULL, "Sanity");</span>
<span class="changed"> 311           if (_first == _last) {</span>
<span class="changed"> 312             assert(_num.get() == 1, "Sanity");</span>
<span class="changed"> 313             _first = _last = NULL;</span>
<span class="changed"> 314           } else {</span>
<span class="changed"> 315             assert(_num.get() &gt; 1, "Sanity");</span>
<span class="changed"> 316             _last = _last-&gt;prev();</span>
<span class="changed"> 317             _last-&gt;set_next(NULL);</span>
<span class="changed"> 318           }</span>
<span class="changed"> 319           _num.decrement();</span>
<span class="changed"> 320           c-&gt;set_prev(NULL);</span>
<span class="changed"> 321         }</span>
<span class="changed"> 322         return c;</span>
<span class="changed"> 323       }</span>
<span class="changed"> 324 </span>
<span class="changed"> 325     public:</span>
<span class="changed"> 326 </span>
<span class="changed"> 327     #ifdef ASSERT</span>
<span class="changed"> 328       bool contains(const Metachunk* c) const;</span>
<span class="changed"> 329       void verify() const;</span>
<span class="changed"> 330     #endif</span>
<span class="changed"> 331 </span>
<span class="changed"> 332       // Returns size, in words, of committed space of all chunks in this list.</span>
<span class="changed"> 333       // Note: walks list.</span>
<span class="changed"> 334       size_t committed_word_size() const {</span>
<span class="changed"> 335         size_t l = 0;</span>
<span class="changed"> 336         for (const Metachunk* c = _first; c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 337           l += c-&gt;committed_words();</span>
<span class="changed"> 338         }</span>
<span class="changed"> 339         return l;</span>
<span class="changed"> 340       }</span>
<span class="changed"> 341 </span>
<span class="changed"> 342       void print_on(outputStream* st) const;</span>
<span class="changed"> 343 </span>
<span class="changed"> 344     };</span>
<span class="changed"> 345 </span>
<span class="changed"> 346     class UnsortedMetachunkList : public AbstractMetachunkList {</span>
<span class="changed"> 347     public:</span>
<span class="changed"> 348 </span>
<span class="changed"> 349 </span>
<span class="changed"> 350 </span>
<span class="changed"> 351 </span>
<span class="changed"> 352 </span>
<span class="changed"> 353     };</span>
<span class="changed"> 354 </span>
 355 
<a name="17" id="anc17"></a>












 356   }
 357 }
 358 
<a name="18" id="anc18"></a><span class="changed"> 359 </span>
<span class="changed"> 360 // Verifies linking with neighbors in virtual space.</span>
<span class="changed"> 361 // Can only be done under expand lock protection.</span>
<span class="changed"> 362 void Metachunk::verify_neighborhood() const {</span>
<span class="changed"> 363 </span>
<span class="changed"> 364   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 365   assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="changed"> 366 </span>
<span class="changed"> 367   if (is_root_chunk()) {</span>
<span class="changed"> 368 </span>
<span class="changed"> 369     // Root chunks are all alone in the world.</span>
<span class="changed"> 370     assert(next_in_vs() == NULL || prev_in_vs() == NULL, "Root chunks should have no neighbors");</span>
<span class="changed"> 371 </span>
<span class="changed"> 372   } else {</span>
<span class="changed"> 373 </span>
<span class="changed"> 374     // Non-root chunks have neighbors, at least one, possibly two.</span>
<span class="changed"> 375 </span>
<span class="changed"> 376     assert(next_in_vs() != NULL || prev_in_vs() != NULL,</span>
<span class="changed"> 377            "A non-root chunk should have neighbors (chunk @" PTR_FORMAT</span>
<span class="changed"> 378            ", base " PTR_FORMAT ", level " CHKLVL_FORMAT ".",</span>
<span class="changed"> 379            p2i(this), p2i(base()), level());</span>
<span class="changed"> 380 </span>
<span class="changed"> 381     if (prev_in_vs() != NULL) {</span>
<span class="changed"> 382       assert(prev_in_vs()-&gt;end() == base(),</span>
<span class="changed"> 383              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to predecessor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="changed"> 384              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()));</span>
<span class="changed"> 385       assert(prev_in_vs()-&gt;next_in_vs() == this,</span>
<span class="changed"> 386              "Chunk " METACHUNK_FULL_FORMAT ": broken link to left neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="changed"> 387              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()), p2i(prev_in_vs()-&gt;next_in_vs()));</span>
<span class="changed"> 388     }</span>
<span class="changed"> 389 </span>
<span class="changed"> 390     if (next_in_vs() != NULL) {</span>
<span class="changed"> 391       assert(end() == next_in_vs()-&gt;base(),</span>
<span class="changed"> 392              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to successor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="changed"> 393              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()));</span>
<span class="changed"> 394       assert(next_in_vs()-&gt;prev_in_vs() == this,</span>
<span class="changed"> 395              "Chunk " METACHUNK_FULL_FORMAT ": broken link to right neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="changed"> 396              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()), p2i(next_in_vs()-&gt;prev_in_vs()));</span>
<span class="changed"> 397     }</span>
<span class="changed"> 398 </span>
<span class="changed"> 399     // One of the neighbors must be the buddy. It can be whole or splintered.</span>
<span class="changed"> 400 </span>
<span class="changed"> 401     // The chunk following us or preceeding us may be our buddy or a splintered part of it.</span>
<span class="changed"> 402     Metachunk* buddy = is_leader() ? next_in_vs() : prev_in_vs();</span>
<span class="changed"> 403 </span>
<span class="changed"> 404     assert(buddy != NULL, "Missing neighbor.");</span>
<span class="changed"> 405     assert(!buddy-&gt;is_dead(), "Invalid buddy state.");</span>
<span class="changed"> 406 </span>
<span class="changed"> 407     // This neighbor is either or buddy (same level) or a splinter of our buddy - hence</span>
<span class="changed"> 408     // the level can never be smaller (aka the chunk size cannot be larger).</span>
<span class="changed"> 409     assert(buddy-&gt;level() &gt;= level(), "Wrong level.");</span>
<span class="changed"> 410 </span>
<span class="changed"> 411     if (buddy-&gt;level() == level()) {</span>
<span class="changed"> 412 </span>
<span class="changed"> 413       // If the buddy is of the same size as us, it is unsplintered.</span>
<span class="changed"> 414       assert(buddy-&gt;is_leader() == !is_leader(),</span>
<span class="changed"> 415              "Only one chunk can be leader in a pair");</span>
<span class="changed"> 416 </span>
<span class="changed"> 417       // When direct buddies are neighbors, one or both should be in use, otherwise they should</span>
<span class="changed"> 418       // have been merged.</span>
<span class="changed"> 419 </span>
<span class="changed"> 420       // But since we call this verification function from internal functions where we are about to merge or just did split,</span>
<span class="changed"> 421       // do not test this. We have RootChunkArea::verify_area_is_ideally_merged() for testing that.</span>
<span class="changed"> 422 </span>
<span class="changed"> 423       // assert(buddy-&gt;is_in_use() || is_in_use(), "incomplete merging?");</span>
<span class="changed"> 424 </span>
<span class="changed"> 425       if (is_leader()) {</span>
<span class="changed"> 426         assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="changed"> 427         assert(is_aligned(base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="changed"> 428       } else {</span>
<span class="changed"> 429         assert(buddy-&gt;end() == base(), "Sanity");</span>
<span class="changed"> 430         assert(is_aligned(buddy-&gt;base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="changed"> 431       }</span>
<span class="changed"> 432 </span>
<span class="changed"> 433     } else {</span>
<span class="changed"> 434 </span>
<span class="changed"> 435       // Buddy, but splintered, and this is a part of it.</span>
<span class="changed"> 436       if (is_leader()) {</span>
<span class="changed"> 437         assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="changed"> 438       } else {</span>
<span class="changed"> 439         assert(buddy-&gt;end() &gt; (base() - word_size()), "Sanity");</span>
<span class="changed"> 440       }</span>
<span class="changed"> 441 </span>
<span class="changed"> 442     }</span>
<span class="changed"> 443   }</span>
 444 }
<a name="19" id="anc19"></a>
 445 
<a name="20" id="anc20"></a><span class="changed"> 446 volatile MetaWord dummy = 0;</span>
<span class="changed"> 447 </span>
<span class="changed"> 448 void Metachunk::verify(bool slow) const {</span>
<span class="changed"> 449 </span>
<span class="changed"> 450   // Note. This should be called under CLD lock protection.</span>
<span class="changed"> 451 </span>
<span class="changed"> 452   // We can verify everything except the _prev_in_vs/_next_in_vs pair.</span>
<span class="changed"> 453   // This is because neighbor chunks may be added concurrently, so we cannot rely</span>
<span class="changed"> 454   //  on the content of _next_in_vs/_prev_in_vs unless we have the expand lock.</span>
<span class="changed"> 455 </span>
<span class="changed"> 456   assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="changed"> 457 </span>
<span class="changed"> 458   if (is_free()) {</span>
<span class="changed"> 459     assert(used_words() == 0, "free chunks are not used.");</span>
<span class="changed"> 460   }</span>
<span class="changed"> 461 </span>
<span class="changed"> 462   // Note: only call this on a life Metachunk.</span>
<span class="changed"> 463   chunklevel::check_valid_level(level());</span>
<span class="changed"> 464 </span>
<span class="changed"> 465   assert(base() != NULL, "No base ptr");</span>
<span class="changed"> 466 </span>
<span class="changed"> 467   assert(committed_words() &gt;= used_words(),</span>
<span class="changed"> 468          "mismatch: committed: " SIZE_FORMAT ", used: " SIZE_FORMAT ".",</span>
<span class="changed"> 469          committed_words(), used_words());</span>
<span class="changed"> 470 </span>
<span class="changed"> 471   assert(word_size() &gt;= committed_words(),</span>
<span class="changed"> 472          "mismatch: word_size: " SIZE_FORMAT ", committed: " SIZE_FORMAT ".",</span>
<span class="changed"> 473          word_size(), committed_words());</span>
<span class="changed"> 474 </span>
<span class="changed"> 475   // Test base pointer</span>
<span class="changed"> 476   assert(base() != NULL, "Base pointer NULL");</span>
<span class="changed"> 477   assert(vsnode() != NULL, "No space");</span>
<span class="changed"> 478   vsnode()-&gt;check_pointer(base());</span>
<span class="changed"> 479 </span>
<span class="changed"> 480   // Starting address shall be aligned to chunk size.</span>
<span class="changed"> 481   const size_t required_alignment = word_size() * sizeof(MetaWord);</span>
<span class="changed"> 482   assert_is_aligned(base(), required_alignment);</span>
<span class="changed"> 483 </span>
<span class="changed"> 484   // If slow, test the committed area</span>
<span class="changed"> 485   if (slow &amp;&amp; _committed_words &gt; 0) {</span>
<span class="changed"> 486     for (const MetaWord* p = _base; p &lt; _base + _committed_words; p += os::vm_page_size()) {</span>
<span class="changed"> 487       dummy = *p;</span>
<span class="changed"> 488     }</span>
<span class="changed"> 489     dummy = *(_base + _committed_words - 1);</span>
<span class="changed"> 490   }</span>
<span class="changed"> 491 </span>
<span class="changed"> 492 }</span>
<span class="changed"> 493 #endif // ASSERT</span>
<span class="changed"> 494 </span>
<span class="changed"> 495 void Metachunk::print_on(outputStream* st) const {</span>
<span class="changed"> 496 </span>
<span class="changed"> 497   // Note: must also work with invalid/random data. (e.g. do not call word_size())</span>
<span class="changed"> 498   st-&gt;print("Chunk @" PTR_FORMAT ", state %c, base " PTR_FORMAT ", "</span>
<span class="changed"> 499             "level " CHKLVL_FORMAT " (" SIZE_FORMAT " words), "</span>
<span class="changed"> 500             "used " SIZE_FORMAT " words, committed " SIZE_FORMAT " words.",</span>
<span class="changed"> 501             p2i(this), get_state_char(), p2i(base()), level(),</span>
<span class="changed"> 502             (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : (size_t)-1),</span>
<span class="changed"> 503             used_words(), committed_words());</span>
<span class="changed"> 504 </span>
 505 }
 506 
 507 } // namespace metaspace
 508 
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="21" type="hidden" /></form></body></html>
