<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 
  26 #include "precompiled.hpp"
  27 #include "logging/log.hpp"
<a name="2" id="anc2"></a><span class="removed">  28 #include "logging/logStream.hpp"</span>
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<a name="3" id="anc3"></a><span class="changed">  31 #include "memory/metaspace/metachunk.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/metaspaceCommon.hpp"</span>



  33 #include "memory/metaspace/virtualSpaceList.hpp"
  34 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="4" id="anc4"></a><span class="removed">  35 #include "runtime/atomic.hpp"</span>
<span class="removed">  36 #include "runtime/orderAccess.hpp"</span>
  37 #include "runtime/mutexLocker.hpp"
<a name="5" id="anc5"></a><span class="changed">  38 #include "runtime/safepoint.hpp"</span>
  39 
  40 namespace metaspace {
  41 
<a name="6" id="anc6"></a>

  42 
<a name="7" id="anc7"></a><span class="changed">  43 VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="changed">  44   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed">  45   while (iter.repeat()) {</span>
<span class="changed">  46     VirtualSpaceNode* vsl = iter.get_next();</span>
<span class="changed">  47     delete vsl;</span>
<span class="changed">  48   }</span>

























  49 }
  50 
<a name="8" id="anc8"></a><span class="changed">  51 void VirtualSpaceList::inc_reserved_words(size_t v) {</span>
<span class="changed">  52   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  53   _reserved_words = _reserved_words + v;</span>
<span class="changed">  54 }</span>
<span class="changed">  55 void VirtualSpaceList::dec_reserved_words(size_t v) {</span>
  56   assert_lock_strong(MetaspaceExpand_lock);
<a name="9" id="anc9"></a><span class="changed">  57   _reserved_words = _reserved_words - v;</span>








  58 }
  59 
<a name="10" id="anc10"></a><span class="changed">  60 #define assert_committed_below_limit()                        \</span>
<span class="changed">  61   assert(MetaspaceUtils::committed_bytes() &lt;= MaxMetaspaceSize, \</span>
<span class="changed">  62          "Too much committed memory. Committed: " SIZE_FORMAT \</span>
<span class="changed">  63          " limit (MaxMetaspaceSize): " SIZE_FORMAT,           \</span>
<span class="changed">  64           MetaspaceUtils::committed_bytes(), MaxMetaspaceSize);</span>
<span class="changed">  65 </span>
<span class="changed">  66 void VirtualSpaceList::inc_committed_words(size_t v) {</span>
<span class="changed">  67   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  68   _committed_words = _committed_words + v;</span>
<span class="changed">  69 </span>
<span class="changed">  70   assert_committed_below_limit();</span>
<span class="changed">  71 }</span>
<span class="changed">  72 void VirtualSpaceList::dec_committed_words(size_t v) {</span>
  73   assert_lock_strong(MetaspaceExpand_lock);
<a name="11" id="anc11"></a><span class="removed">  74   _committed_words = _committed_words - v;</span>
  75 
<a name="12" id="anc12"></a><span class="changed">  76   assert_committed_below_limit();</span>






  77 }
  78 
<a name="13" id="anc13"></a><span class="changed">  79 void VirtualSpaceList::inc_virtual_space_count() {</span>




  80   assert_lock_strong(MetaspaceExpand_lock);
<a name="14" id="anc14"></a><span class="removed">  81   _virtual_space_count++;</span>
<span class="removed">  82 }</span>
  83 
<a name="15" id="anc15"></a><span class="changed">  84 void VirtualSpaceList::dec_virtual_space_count() {</span>
<span class="changed">  85   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  86   _virtual_space_count--;</span>
<span class="changed">  87 }</span>
<span class="changed">  88 </span>
<span class="changed">  89 // Walk the list of VirtualSpaceNodes and delete</span>
<span class="changed">  90 // nodes with a 0 container_count.  Remove Metachunks in</span>
<span class="changed">  91 // the node from their respective freelists.</span>
<span class="changed">  92 void VirtualSpaceList::purge(ChunkManager* chunk_manager) {</span>
<span class="changed">  93   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  94   // Don't use a VirtualSpaceListIterator because this</span>
<span class="changed">  95   // list is being changed and a straightforward use of an iterator is not safe.</span>
<span class="changed">  96   VirtualSpaceNode* prev_vsl = virtual_space_list();</span>
<span class="changed">  97   VirtualSpaceNode* next_vsl = prev_vsl;</span>
<span class="changed">  98   int num_purged_nodes = 0;</span>
<span class="changed">  99   while (next_vsl != NULL) {</span>
<span class="changed"> 100     VirtualSpaceNode* vsl = next_vsl;</span>
<span class="changed"> 101     DEBUG_ONLY(vsl-&gt;verify(false);)</span>
<span class="changed"> 102     next_vsl = vsl-&gt;next();</span>
<span class="changed"> 103     // Don't free the current virtual space since it will likely</span>
<span class="changed"> 104     // be needed soon.</span>
<span class="changed"> 105     if (vsl-&gt;container_count() == 0 &amp;&amp; vsl != current_virtual_space()) {</span>
<span class="changed"> 106       log_trace(gc, metaspace, freelist)("Purging VirtualSpaceNode " PTR_FORMAT " (capacity: " SIZE_FORMAT</span>
<span class="changed"> 107                                          ", used: " SIZE_FORMAT ").", p2i(vsl), vsl-&gt;capacity_words_in_vs(), vsl-&gt;used_words_in_vs());</span>
<span class="changed"> 108       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_purged));</span>
<span class="changed"> 109       // Unlink it from the list</span>
<span class="changed"> 110       if (prev_vsl == vsl) {</span>
<span class="changed"> 111         // This is the case of the current node being the first node.</span>
<span class="changed"> 112         assert(vsl == virtual_space_list(), "Expected to be the first node");</span>
<span class="changed"> 113         set_virtual_space_list(vsl-&gt;next());</span>
<span class="changed"> 114       } else {</span>
<span class="changed"> 115         prev_vsl-&gt;set_next(vsl-&gt;next());</span>
<span class="changed"> 116       }</span>
 117 
<a name="16" id="anc16"></a><span class="changed"> 118       vsl-&gt;purge(chunk_manager);</span>
<span class="changed"> 119       dec_reserved_words(vsl-&gt;reserved_words());</span>
<span class="changed"> 120       dec_committed_words(vsl-&gt;committed_words());</span>
<span class="changed"> 121       dec_virtual_space_count();</span>
<span class="changed"> 122       delete vsl;</span>
<span class="changed"> 123       num_purged_nodes ++;</span>



 124     } else {
<a name="17" id="anc17"></a><span class="changed"> 125       prev_vsl = vsl;</span>
<span class="changed"> 126     }</span>
<span class="changed"> 127   }</span>
<span class="changed"> 128 </span>
<span class="changed"> 129   // Verify list</span>
<span class="changed"> 130 #ifdef ASSERT</span>
<span class="changed"> 131   if (num_purged_nodes &gt; 0) {</span>
<span class="changed"> 132     verify(false);</span>
<span class="changed"> 133   }</span>
<span class="changed"> 134 #endif</span>
<span class="changed"> 135 }</span>
<span class="changed"> 136 </span>
<span class="changed"> 137 </span>
<span class="changed"> 138 // This function looks at the mmap regions in the metaspace without locking.</span>
<span class="changed"> 139 // The chunks are added with store ordering and not deleted except for at</span>
<span class="changed"> 140 // unloading time during a safepoint.</span>
<span class="changed"> 141 VirtualSpaceNode* VirtualSpaceList::find_enclosing_space(const void* ptr) {</span>
<span class="changed"> 142   // List should be stable enough to use an iterator here because removing virtual</span>
<span class="changed"> 143   // space nodes is only allowed at a safepoint.</span>
<span class="changed"> 144   if (is_within_envelope((address)ptr)) {</span>
<span class="changed"> 145     VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed"> 146     while (iter.repeat()) {</span>
<span class="changed"> 147       VirtualSpaceNode* vsn = iter.get_next();</span>
<span class="changed"> 148       if (vsn-&gt;contains(ptr)) {</span>
<span class="changed"> 149         return vsn;</span>
 150       }
 151     }
<a name="18" id="anc18"></a><span class="removed"> 152   }</span>
<span class="removed"> 153   return NULL;</span>
<span class="removed"> 154 }</span>
 155 
<a name="19" id="anc19"></a><span class="changed"> 156 void VirtualSpaceList::retire_current_virtual_space() {</span>
<span class="changed"> 157   assert_lock_strong(MetaspaceExpand_lock);</span>
 158 
<a name="20" id="anc20"></a><span class="changed"> 159   VirtualSpaceNode* vsn = current_virtual_space();</span>
 160 
<a name="21" id="anc21"></a><span class="changed"> 161   ChunkManager* cm = is_class() ? Metaspace::chunk_manager_class() :</span>
<span class="changed"> 162                                   Metaspace::chunk_manager_metadata();</span>
 163 
<a name="22" id="anc22"></a><span class="removed"> 164   vsn-&gt;retire(cm);</span>
 165 }
 166 
<a name="23" id="anc23"></a><span class="changed"> 167 VirtualSpaceList::VirtualSpaceList(size_t word_size) :</span>
<span class="changed"> 168                                    _virtual_space_list(NULL),</span>
<span class="changed"> 169                                    _current_virtual_space(NULL),</span>
<span class="changed"> 170                                    _is_class(false),</span>
<span class="changed"> 171                                    _reserved_words(0),</span>
<span class="changed"> 172                                    _committed_words(0),</span>
<span class="changed"> 173                                    _virtual_space_count(0),</span>
<span class="changed"> 174                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 175                                    _envelope_hi(NULL) {</span>
<span class="changed"> 176   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 177   create_new_virtual_space(word_size);</span>
<span class="changed"> 178 }</span>
<span class="changed"> 179 </span>
<span class="changed"> 180 VirtualSpaceList::VirtualSpaceList(ReservedSpace rs) :</span>
<span class="changed"> 181                                    _virtual_space_list(NULL),</span>
<span class="changed"> 182                                    _current_virtual_space(NULL),</span>
<span class="changed"> 183                                    _is_class(true),</span>
<span class="changed"> 184                                    _reserved_words(0),</span>
<span class="changed"> 185                                    _committed_words(0),</span>
<span class="changed"> 186                                    _virtual_space_count(0),</span>
<span class="changed"> 187                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 188                                    _envelope_hi(NULL) {</span>
<span class="changed"> 189   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 190   VirtualSpaceNode* class_entry = new VirtualSpaceNode(is_class(), rs);</span>
<span class="changed"> 191   bool succeeded = class_entry-&gt;initialize();</span>
<span class="changed"> 192   if (succeeded) {</span>
<span class="changed"> 193     expand_envelope_to_include_node(class_entry);</span>
<span class="changed"> 194     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 195     OrderAccess::storestore();</span>
<span class="changed"> 196     link_vs(class_entry);</span>
<span class="changed"> 197   }</span>
<span class="changed"> 198 }</span>
 199 
<a name="24" id="anc24"></a><span class="removed"> 200 size_t VirtualSpaceList::free_bytes() {</span>
<span class="removed"> 201   return current_virtual_space()-&gt;free_words_in_vs() * BytesPerWord;</span>
<span class="removed"> 202 }</span>
<span class="removed"> 203 </span>
<span class="removed"> 204 // Allocate another meta virtual space and add it to the list.</span>
<span class="removed"> 205 bool VirtualSpaceList::create_new_virtual_space(size_t vs_word_size) {</span>
 206   assert_lock_strong(MetaspaceExpand_lock);
 207 
<a name="25" id="anc25"></a><span class="changed"> 208   if (is_class()) {</span>
<span class="changed"> 209     assert(false, "We currently don't support more than one VirtualSpace for"</span>
<span class="changed"> 210                   " the compressed class space. The initialization of the"</span>
<span class="changed"> 211                   " CCS uses another code path and should not hit this path.");</span>
<span class="changed"> 212     return false;</span>
 213   }
 214 
<a name="26" id="anc26"></a><span class="changed"> 215   if (vs_word_size == 0) {</span>
<span class="changed"> 216     assert(false, "vs_word_size should always be at least _reserve_alignment large.");</span>
<span class="changed"> 217     return false;</span>
<span class="changed"> 218   }</span>
 219 
<a name="27" id="anc27"></a><span class="changed"> 220   // Reserve the space</span>
<span class="changed"> 221   size_t vs_byte_size = vs_word_size * BytesPerWord;</span>
<span class="changed"> 222   assert_is_aligned(vs_byte_size, Metaspace::reserve_alignment());</span>
<span class="changed"> 223 </span>
<span class="changed"> 224   // Allocate the meta virtual space and initialize it.</span>
<span class="changed"> 225   VirtualSpaceNode* new_entry = new VirtualSpaceNode(is_class(), vs_byte_size);</span>
<span class="changed"> 226   if (!new_entry-&gt;initialize()) {</span>
<span class="changed"> 227     delete new_entry;</span>
<span class="changed"> 228     return false;</span>
<span class="changed"> 229   } else {</span>
<span class="changed"> 230     assert(new_entry-&gt;reserved_words() == vs_word_size,</span>
<span class="changed"> 231         "Reserved memory size differs from requested memory size");</span>
<span class="changed"> 232     expand_envelope_to_include_node(new_entry);</span>
<span class="changed"> 233     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 234     OrderAccess::storestore();</span>
<span class="changed"> 235     link_vs(new_entry);</span>
<span class="changed"> 236     DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_created));</span>
<span class="changed"> 237     return true;</span>
 238   }
<a name="28" id="anc28"></a><span class="changed"> 239 </span>
<span class="changed"> 240   DEBUG_ONLY(verify(false);)</span>
<span class="changed"> 241 </span>
<span class="changed"> 242 }</span>
<span class="changed"> 243 </span>
<span class="changed"> 244 void VirtualSpaceList::link_vs(VirtualSpaceNode* new_entry) {</span>
<span class="changed"> 245   if (virtual_space_list() == NULL) {</span>
<span class="changed"> 246       set_virtual_space_list(new_entry);</span>
 247   } else {
<a name="29" id="anc29"></a><span class="changed"> 248     current_virtual_space()-&gt;set_next(new_entry);</span>
 249   }
<a name="30" id="anc30"></a><span class="changed"> 250   set_current_virtual_space(new_entry);</span>
<span class="changed"> 251   inc_reserved_words(new_entry-&gt;reserved_words());</span>
<span class="changed"> 252   inc_committed_words(new_entry-&gt;committed_words());</span>
<span class="changed"> 253   inc_virtual_space_count();</span>
<span class="changed"> 254 #ifdef ASSERT</span>
<span class="changed"> 255   new_entry-&gt;mangle();</span>
<span class="changed"> 256 #endif</span>
<span class="changed"> 257   LogTarget(Trace, gc, metaspace) lt;</span>
<span class="changed"> 258   if (lt.is_enabled()) {</span>
<span class="changed"> 259     LogStream ls(lt);</span>
<span class="changed"> 260     VirtualSpaceNode* vsl = current_virtual_space();</span>
<span class="changed"> 261     ResourceMark rm;</span>
<span class="changed"> 262     vsl-&gt;print_on(&amp;ls);</span>
 263   }
<a name="31" id="anc31"></a><span class="removed"> 264 }</span>
 265 
<a name="32" id="anc32"></a><span class="changed"> 266 bool VirtualSpaceList::expand_node_by(VirtualSpaceNode* node,</span>
<span class="changed"> 267                                       size_t min_words,</span>
<span class="changed"> 268                                       size_t preferred_words) {</span>
<span class="changed"> 269   size_t before = node-&gt;committed_words();</span>
 270 
<a name="33" id="anc33"></a><span class="changed"> 271   bool result = node-&gt;expand_by(min_words, preferred_words);</span>
 272 
<a name="34" id="anc34"></a><span class="removed"> 273   size_t after = node-&gt;committed_words();</span>
<span class="removed"> 274 </span>
<span class="removed"> 275   // after and before can be the same if the memory was pre-committed.</span>
<span class="removed"> 276   assert(after &gt;= before, "Inconsistency");</span>
<span class="removed"> 277   inc_committed_words(after - before);</span>
<span class="removed"> 278 </span>
<span class="removed"> 279   return result;</span>
 280 }
 281 
<a name="35" id="anc35"></a><span class="changed"> 282 bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {</span>
<span class="changed"> 283   assert_is_aligned(min_words,       Metaspace::commit_alignment_words());</span>
<span class="changed"> 284   assert_is_aligned(preferred_words, Metaspace::commit_alignment_words());</span>
<span class="changed"> 285   assert(min_words &lt;= preferred_words, "Invalid arguments");</span>
<span class="changed"> 286 </span>
<span class="changed"> 287   const char* const class_or_not = (is_class() ? "class" : "non-class");</span>
 288 
<a name="36" id="anc36"></a><span class="changed"> 289   if (!MetaspaceGC::can_expand(min_words, this-&gt;is_class())) {</span>
<span class="changed"> 290     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list.",</span>
<span class="changed"> 291               class_or_not);</span>
<span class="changed"> 292     return  false;</span>




 293   }
<a name="37" id="anc37"></a>


 294 
<a name="38" id="anc38"></a><span class="changed"> 295   size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();</span>
<span class="changed"> 296   if (allowed_expansion_words &lt; min_words) {</span>
<span class="changed"> 297     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list (must try gc first).",</span>
<span class="changed"> 298               class_or_not);</span>
<span class="changed"> 299     return false;</span>
<span class="changed"> 300   }</span>
 301 
<a name="39" id="anc39"></a><span class="changed"> 302   size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);</span>
 303 
<a name="40" id="anc40"></a><span class="changed"> 304   // Commit more memory from the the current virtual space.</span>
<span class="changed"> 305   bool vs_expanded = expand_node_by(current_virtual_space(),</span>
<span class="changed"> 306                                     min_words,</span>
<span class="changed"> 307                                     max_expansion_words);</span>
<span class="changed"> 308   if (vs_expanded) {</span>
<span class="changed"> 309      log_trace(gc, metaspace, freelist)("Expanded %s virtual space list.",</span>
<span class="changed"> 310                class_or_not);</span>
<span class="changed"> 311      return true;</span>
<span class="changed"> 312   }</span>
<span class="changed"> 313   log_trace(gc, metaspace, freelist)("%s virtual space list: retire current node.",</span>
<span class="changed"> 314             class_or_not);</span>
<span class="changed"> 315   retire_current_virtual_space();</span>
<span class="changed"> 316 </span>
<span class="changed"> 317   // Get another virtual space.</span>
<span class="changed"> 318   size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);</span>
<span class="changed"> 319   grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());</span>
<span class="changed"> 320 </span>
<span class="changed"> 321   if (create_new_virtual_space(grow_vs_words)) {</span>
<span class="changed"> 322     if (current_virtual_space()-&gt;is_pre_committed()) {</span>
<span class="changed"> 323       // The memory was pre-committed, so we are done here.</span>
<span class="changed"> 324       assert(min_words &lt;= current_virtual_space()-&gt;committed_words(),</span>
<span class="changed"> 325           "The new VirtualSpace was pre-committed, so it"</span>
<span class="changed"> 326           "should be large enough to fit the alloc request.");</span>
<span class="changed"> 327       return true;</span>
<span class="changed"> 328     }</span>
 329 
<a name="41" id="anc41"></a><span class="changed"> 330     return expand_node_by(current_virtual_space(),</span>
<span class="changed"> 331                           min_words,</span>
<span class="changed"> 332                           max_expansion_words);</span>
<span class="changed"> 333   }</span>
 334 
<a name="42" id="anc42"></a><span class="changed"> 335   return false;</span>
<span class="changed"> 336 }</span>
<span class="changed"> 337 </span>
<span class="changed"> 338 // Given a chunk, calculate the largest possible padding space which</span>
<span class="changed"> 339 // could be required when allocating it.</span>
<span class="changed"> 340 static size_t largest_possible_padding_size_for_chunk(size_t chunk_word_size, bool is_class) {</span>
<span class="changed"> 341   const ChunkIndex chunk_type = get_chunk_type_by_size(chunk_word_size, is_class);</span>
<span class="changed"> 342   if (chunk_type != HumongousIndex) {</span>
<span class="changed"> 343     // Normal, non-humongous chunks are allocated at chunk size</span>
<span class="changed"> 344     // boundaries, so the largest padding space required would be that</span>
<span class="changed"> 345     // minus the smallest chunk size.</span>
<span class="changed"> 346     const size_t smallest_chunk_size = is_class ? ClassSpecializedChunk : SpecializedChunk;</span>
<span class="changed"> 347     return chunk_word_size - smallest_chunk_size;</span>
<span class="changed"> 348   } else {</span>
<span class="changed"> 349     // Humongous chunks are allocated at smallest-chunksize</span>
<span class="changed"> 350     // boundaries, so there is no padding required.</span>
<span class="changed"> 351     return 0;</span>
<span class="changed"> 352   }</span>
<span class="changed"> 353 }</span>
 354 
<a name="43" id="anc43"></a>













 355 
<a name="44" id="anc44"></a><span class="changed"> 356 Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {</span>
 357 
<a name="45" id="anc45"></a><span class="changed"> 358   // Allocate a chunk out of the current virtual space.</span>
<span class="changed"> 359   Metachunk* next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
 360 
<a name="46" id="anc46"></a><span class="removed"> 361   if (next != NULL) {</span>
<span class="removed"> 362     return next;</span>
 363   }
<a name="47" id="anc47"></a>
 364 
<a name="48" id="anc48"></a><span class="changed"> 365   // The expand amount is currently only determined by the requested sizes</span>
<span class="changed"> 366   // and not how much committed memory is left in the current virtual space.</span>
<span class="changed"> 367 </span>
<span class="changed"> 368   // We must have enough space for the requested size and any</span>
<span class="changed"> 369   // additional reqired padding chunks.</span>
<span class="changed"> 370   const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this-&gt;is_class());</span>
 371 
<a name="49" id="anc49"></a><span class="changed"> 372   size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());</span>
<span class="changed"> 373   size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());</span>
<span class="changed"> 374   if (min_word_size &gt;= preferred_word_size) {</span>
<span class="changed"> 375     // Can happen when humongous chunks are allocated.</span>
<span class="changed"> 376     preferred_word_size = min_word_size;</span>

 377   }
<a name="50" id="anc50"></a><span class="changed"> 378 </span>
<span class="changed"> 379   bool expanded = expand_by(min_word_size, preferred_word_size);</span>
<span class="changed"> 380   if (expanded) {</span>
<span class="changed"> 381     next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
<span class="changed"> 382     assert(next != NULL, "The allocation was expected to succeed after the expansion");</span>
 383   }
<a name="51" id="anc51"></a><span class="changed"> 384 </span>
<span class="changed"> 385    return next;</span>
 386 }
 387 
<a name="52" id="anc52"></a><span class="changed"> 388 void VirtualSpaceList::print_on(outputStream* st, size_t scale) const {</span>
<span class="changed"> 389   st-&gt;print_cr(SIZE_FORMAT " nodes, current node: " PTR_FORMAT,</span>
<span class="changed"> 390       _virtual_space_count, p2i(_current_virtual_space));</span>
<span class="changed"> 391   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed"> 392   while (iter.repeat()) {</span>
<span class="changed"> 393     st-&gt;cr();</span>
<span class="changed"> 394     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 395     node-&gt;print_on(st, scale);</span>
 396   }
<a name="53" id="anc53"></a>
 397 }
 398 
<a name="54" id="anc54"></a><span class="changed"> 399 void VirtualSpaceList::print_map(outputStream* st) const {</span>
<span class="changed"> 400   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="changed"> 401   VirtualSpaceListIterator iter(list);</span>
<span class="changed"> 402   unsigned i = 0;</span>
<span class="changed"> 403   while (iter.repeat()) {</span>
<span class="changed"> 404     st-&gt;print_cr("Node %u:", i);</span>
<span class="changed"> 405     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 406     node-&gt;print_map(st, this-&gt;is_class());</span>
<span class="changed"> 407     i ++;</span>
<span class="changed"> 408   }</span>
 409 }
 410 
<a name="55" id="anc55"></a><span class="changed"> 411 // Given a node, expand range such that it includes the node.</span>
<span class="changed"> 412 void VirtualSpaceList::expand_envelope_to_include_node(const VirtualSpaceNode* node) {</span>
<span class="changed"> 413   _envelope_lo = MIN2(_envelope_lo, (address)node-&gt;low_boundary());</span>
<span class="changed"> 414   _envelope_hi = MAX2(_envelope_hi, (address)node-&gt;high_boundary());</span>
 415 }
 416 
 417 
<a name="56" id="anc56"></a><span class="removed"> 418 #ifdef ASSERT</span>
<span class="removed"> 419 void VirtualSpaceList::verify(bool slow) {</span>
<span class="removed"> 420   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="removed"> 421   VirtualSpaceListIterator iter(list);</span>
<span class="removed"> 422   size_t reserved = 0;</span>
<span class="removed"> 423   size_t committed = 0;</span>
<span class="removed"> 424   size_t node_count = 0;</span>
<span class="removed"> 425   while (iter.repeat()) {</span>
<span class="removed"> 426     VirtualSpaceNode* node = iter.get_next();</span>
<span class="removed"> 427     if (slow) {</span>
<span class="removed"> 428       node-&gt;verify(true);</span>
<span class="removed"> 429     }</span>
<span class="removed"> 430     // Check that the node resides fully within our envelope.</span>
<span class="removed"> 431     assert((address)node-&gt;low_boundary() &gt;= _envelope_lo &amp;&amp; (address)node-&gt;high_boundary() &lt;= _envelope_hi,</span>
<span class="removed"> 432            "Node " SIZE_FORMAT " [" PTR_FORMAT ", " PTR_FORMAT ") outside envelope [" PTR_FORMAT ", " PTR_FORMAT ").",</span>
<span class="removed"> 433            node_count, p2i(node-&gt;low_boundary()), p2i(node-&gt;high_boundary()), p2i(_envelope_lo), p2i(_envelope_hi));</span>
<span class="removed"> 434     reserved += node-&gt;reserved_words();</span>
<span class="removed"> 435     committed += node-&gt;committed_words();</span>
<span class="removed"> 436     node_count ++;</span>
<span class="removed"> 437   }</span>
<span class="removed"> 438   assert(reserved == reserved_words() &amp;&amp; committed == committed_words() &amp;&amp; node_count == _virtual_space_count,</span>
<span class="removed"> 439       "Mismatch: reserved real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed"> 440       ", committed real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed"> 441       ", node count real: " SIZE_FORMAT " expected: " SIZE_FORMAT ".",</span>
<span class="removed"> 442       reserved, reserved_words(), committed, committed_words(),</span>
<span class="removed"> 443       node_count, _virtual_space_count);</span>
<span class="removed"> 444 }</span>
<span class="removed"> 445 #endif // ASSERT</span>
 446 
 447 } // namespace metaspace
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="57" type="hidden" /></form></body></html>
