<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metachunk.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 
  27 #include "precompiled.hpp"
  28 
  29 #include "logging/log.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "memory/metaspace/metachunk.hpp"
  32 #include "memory/metaspace/metaspaceCommon.hpp"
  33 #include "memory/metaspace/settings.hpp"
  34 #include "memory/metaspace/virtualSpaceNode.hpp"
  35 #include "runtime/mutexLocker.hpp"
  36 
  37 #include "utilities/align.hpp"
  38 #include "utilities/copy.hpp"
  39 #include "utilities/debug.hpp"
  40 
  41 namespace metaspace {
  42 
  43 // Return a single char presentation of the state ('f', 'u', 'd')
  44 char Metachunk::get_state_char() const {
  45   switch (_state) {
  46   case state_free:    return 'f';
  47   case state_in_use:  return 'u';
  48   case state_dead:    return 'd';
  49   }
  50   return '?';
  51 }
  52 
  53 #ifdef ASSERT
  54 void Metachunk::assert_have_expand_lock() {
  55   assert_lock_strong(MetaspaceExpand_lock);
  56 }
  57 #endif
  58 
  59 // Commit uncommitted section of the chunk.
  60 // Fails if we hit a commit limit.
  61 bool Metachunk::commit_up_to(size_t new_committed_words) {
  62 
  63   // Please note:
  64   //
  65   // VirtualSpaceNode::ensure_range_is_committed(), when called over a range containing both committed and uncommitted parts,
  66   // will replace the whole range with a new mapping, thus erasing the existing content in the committed parts. Therefore
  67   // we must make sure never to call VirtualSpaceNode::ensure_range_is_committed() over a range containing live data.
  68   //
  69   // Luckily, this cannot happen by design. We have two cases:
  70   //
  71   // 1) chunks equal or larger than a commit granule.
  72   //    In this case, due to chunk geometry, the chunk should cover whole commit granules (in other words, a chunk equal or larger than
  73   //    a commit granule will never share a granule with a neighbor). That means whatever we commit or uncommit here does not affect
  74   //    neighboring chunks. We only have to take care not to re-commit used parts of ourself. We do this by moving the committed_words
  75   //    limit in multiple of commit granules.
  76   //
  77   // 2) chunks smaller than a commit granule.
  78   //    In this case, a chunk shares a single commit granule with its neighbors. But this never can be a problem:
  79   //    - Either the commit granule is already committed (and maybe the neighbors contain live data). In that case calling
  80   //      ensure_range_is_committed() will do nothing.
  81   //    - Or the commit granule is not committed, but in this case, the neighbors are uncommitted too and cannot contain live data.
  82 
  83 #ifdef ASSERT
  84   if (word_size() &gt;= Settings::commit_granule_words()) {
  85     // case (1)
  86     assert(is_aligned(base(), Settings::commit_granule_bytes()) &amp;&amp;
  87            is_aligned(end(), Settings::commit_granule_bytes()),
  88            "Chunks larger than a commit granule must cover whole granules.");
  89     assert(is_aligned(_committed_words, Settings::commit_granule_words()),
  90            "The commit boundary must be aligned to commit granule size");
  91     assert(_used_words &lt;= _committed_words, "Sanity");
  92   } else {
  93     // case (2)
  94     assert(_committed_words == 0 || _committed_words == word_size(), "Sanity");
  95   }
  96 #endif
  97 
  98   // We should hold the expand lock at this point.
  99   assert_lock_strong(MetaspaceExpand_lock);
 100 
 101   const size_t commit_from = _committed_words;
 102   const size_t commit_to =   MIN2(align_up(new_committed_words, Settings::commit_granule_words()), word_size());
 103 
 104   assert(commit_from &gt;= used_words(), "Sanity");
 105   assert(commit_to &lt;= word_size(), "Sanity");
 106 
 107   if (commit_to &gt; commit_from) {
 108     log_debug(metaspace)("Chunk " METACHUNK_FORMAT ": attempting to move commit line to "
 109                          SIZE_FORMAT " words.", METACHUNK_FORMAT_ARGS(this), commit_to);
 110 
 111     if (!_vsnode-&gt;ensure_range_is_committed(base() + commit_from, commit_to - commit_from)) {
 112       DEBUG_ONLY(verify(true);)
 113       return false;
 114     }
 115   }
 116 
 117   // Remember how far we have committed.
 118   _committed_words = commit_to;
 119 
 120   DEBUG_ONLY(verify(true);)
 121 
 122   return true;
 123 
 124 }
 125 
 126 
 127 // Ensure that chunk is committed up to at least new_committed_words words.
 128 // Fails if we hit a commit limit.
 129 bool Metachunk::ensure_committed(size_t new_committed_words) {
 130 
 131   bool rc = true;
 132 
 133   if (new_committed_words &gt; committed_words()) {
 134     MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 135     rc = commit_up_to(new_committed_words);
 136   }
 137 
 138   return rc;
 139 
 140 }
 141 
 142 bool Metachunk::ensure_committed_locked(size_t new_committed_words) {
 143 
 144   // the .._locked() variant should be called if we own the lock already.
 145   assert_lock_strong(MetaspaceExpand_lock);
 146 
 147   bool rc = true;
 148 
 149   if (new_committed_words &gt; committed_words()) {
 150     rc = commit_up_to(new_committed_words);
 151   }
 152 
 153   return rc;
 154 
 155 }
 156 
 157 // Uncommit chunk area. The area must be a common multiple of the
 158 // commit granule size (in other words, we cannot uncommit chunks smaller than
 159 // a commit granule size).
 160 void Metachunk::uncommit() {
 161   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 162   uncommit_locked();
 163 }
 164 
 165 void Metachunk::uncommit_locked() {
 166   // Only uncommit chunks which are free, have no used words set (extra precaution) and are equal or larger in size than a single commit granule.
 167   assert_lock_strong(MetaspaceExpand_lock);
 168   assert(_state == state_free &amp;&amp; _used_words == 0 &amp;&amp; word_size() &gt;= Settings::commit_granule_words(),
 169          "Only free chunks equal or larger than commit granule size can be uncommitted "
 170          "(chunk " METACHUNK_FULL_FORMAT ").", METACHUNK_FULL_FORMAT_ARGS(this));
 171   if (word_size() &gt;= Settings::commit_granule_words()) {
 172     _vsnode-&gt;uncommit_range(base(), word_size());
 173     _committed_words = 0;
 174   }
 175 }
 176 void Metachunk::set_committed_words(size_t v) {
 177   // Set committed words. Since we know that we only commit whole commit granules, we can round up v here.
 178   v = MIN2(align_up(v, Settings::commit_granule_words()), word_size());
 179  _committed_words = v;
 180 }
 181 
 182 
 183 // Allocate word_size words from this chunk (word_size must be aligned to
 184 //  allocation_alignment_words).
 185 //
 186 // Caller must make sure the chunk is both large enough and committed far enough
 187 // to hold the allocation. Will always work.
 188 //
 189 MetaWord* Metachunk::allocate(size_t request_word_size) {
 190 
 191   log_trace(metaspace)("Chunk " METACHUNK_FULL_FORMAT ": allocating " SIZE_FORMAT " words.",
 192                        METACHUNK_FULL_FORMAT_ARGS(this), request_word_size);
 193 
 194   // Caller must have made sure this works
 195   assert(free_words() &gt;= request_word_size, "Chunk too small.");
 196   assert(free_below_committed_words() &gt;= request_word_size, "Chunk not committed.");
 197 
 198   MetaWord* const p = top();
 199 
 200   _used_words += request_word_size;
 201 
 202   SOMETIMES(verify(false);)
 203 
 204   return p;
 205 
 206 }
 207 
 208 #ifdef ASSERT
 209 
 210 // Zap this structure.
 211 void Metachunk::zap_header(uint8_t c) {
 212   memset(this, c, sizeof(Metachunk));
 213 }
 214 
 215 void Metachunk::fill_with_pattern(MetaWord pattern, size_t word_size) {
 216   assert(word_size &lt;= committed_words(), "Sanity");
 217   for (size_t l = 0; l &lt; word_size; l ++) {
 218     _base[l] = pattern;
 219   }
 220 }
 221 
 222 void Metachunk::check_pattern(MetaWord pattern, size_t word_size) {
 223   assert(word_size &lt;= committed_words(), "Sanity");
 224   for (size_t l = 0; l &lt; word_size; l ++) {
 225     assert(_base[l] == pattern,
 226            "chunk " METACHUNK_FULL_FORMAT ": pattern change at " PTR_FORMAT ": expected " UINTX_FORMAT " but got " UINTX_FORMAT ".",
 227            METACHUNK_FULL_FORMAT_ARGS(this), p2i(_base + l), (uintx)pattern, (uintx)_base[l]);
 228 
 229     ////////////////////////////////////////////
 230     // A double-headed list of Metachunks.
 231 
 232     class AbstractMetachunkList {
 233 
 234       Metachunk* _first;
 235       Metachunk* _last;
 236 
 237       // Number of chunks
 238       IntCounter _num;
 239 
 240     protected:
 241 
 242       AbstractMetachunkList() : _first(NULL), _last(NULL), _num() {}
 243 
 244       Metachunk* first() const { return _first; }
 245       int count() const { return _num.get(); }
 246 
 247       // Add chunk to the front of the list.
 248       void add_front(Metachunk* c) {
 249         if (_first == NULL) {
 250           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");
 251           _first = _last = c;
 252           c-&gt;set_prev(NULL);
 253           c-&gt;set_next(NULL);
 254         } else {
 255           assert(_last != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");
 256           c-&gt;set_next(_first);
 257           c-&gt;set_prev(NULL);
 258           _first-&gt;set_prev(c);
 259           _first = c;
 260         }
 261         _num.increment();
 262       }
 263 
 264       // Add chunk to the back of the list.
 265       void add_back(Metachunk* c) {
 266         if (_last == NULL) {
 267           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");
 268           _last = _first = c;
 269           c-&gt;set_prev(NULL);
 270           c-&gt;set_next(NULL);
 271         } else {
 272           assert(_first != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");
 273           c-&gt;set_next(NULL);
 274           c-&gt;set_prev(_last);
 275           _last-&gt;set_next(c);
 276           _last = c;
 277         }
 278         _num.increment();
 279       }
 280 
 281       // Remove chunk from the front of the list. Returns NULL if list is empty.
 282       Metachunk* remove_front() {
 283         Metachunk* c = NULL;
 284         if (_first == NULL) {
 285           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");
 286         } else {
 287           c = _first;
 288           assert(c-&gt;prev() == NULL, "Sanity");
 289           if (_first == _last) {
 290             assert(_num.get() == 1, "Sanity");
 291             _first = _last = NULL;
 292           } else {
 293             assert(_num.get() &gt; 1, "Sanity");
 294             _first = _first-&gt;next();
 295             _first-&gt;set_prev(NULL);
 296           }
 297           _num.decrement();
 298           c-&gt;set_next(NULL);
 299         }
 300         return c;
 301       }
 302 
 303       // Remove chunk from the back of the list. Returns NULL if list is empty.
 304       Metachunk* remove_back() {
 305         Metachunk* c = NULL;
 306         if (_last == NULL) {
 307           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");
 308         } else {
 309           c = _last;
 310           assert(c-&gt;next() == NULL, "Sanity");
 311           if (_first == _last) {
 312             assert(_num.get() == 1, "Sanity");
 313             _first = _last = NULL;
 314           } else {
 315             assert(_num.get() &gt; 1, "Sanity");
 316             _last = _last-&gt;prev();
 317             _last-&gt;set_next(NULL);
 318           }
 319           _num.decrement();
 320           c-&gt;set_prev(NULL);
 321         }
 322         return c;
 323       }
 324 
 325     public:
 326 
 327     #ifdef ASSERT
 328       bool contains(const Metachunk* c) const;
 329       void verify() const;
 330     #endif
 331 
 332       // Returns size, in words, of committed space of all chunks in this list.
 333       // Note: walks list.
 334       size_t committed_word_size() const {
 335         size_t l = 0;
 336         for (const Metachunk* c = _first; c != NULL; c = c-&gt;next()) {
 337           l += c-&gt;committed_words();
 338         }
 339         return l;
 340       }
 341 
 342       void print_on(outputStream* st) const;
 343 
 344     };
 345 
 346     class UnsortedMetachunkList : public AbstractMetachunkList {
 347     public:
 348 
 349 
 350 
 351 
 352 
 353     };
 354 
 355 
 356   }
 357 }
 358 
 359 
 360 // Verifies linking with neighbors in virtual space.
 361 // Can only be done under expand lock protection.
 362 void Metachunk::verify_neighborhood() const {
 363 
 364   assert_lock_strong(MetaspaceExpand_lock);
 365   assert(!is_dead(), "Do not call on dead chunks.");
 366 
 367   if (is_root_chunk()) {
 368 
 369     // Root chunks are all alone in the world.
 370     assert(next_in_vs() == NULL || prev_in_vs() == NULL, "Root chunks should have no neighbors");
 371 
 372   } else {
 373 
 374     // Non-root chunks have neighbors, at least one, possibly two.
 375 
 376     assert(next_in_vs() != NULL || prev_in_vs() != NULL,
 377            "A non-root chunk should have neighbors (chunk @" PTR_FORMAT
 378            ", base " PTR_FORMAT ", level " CHKLVL_FORMAT ".",
 379            p2i(this), p2i(base()), level());
 380 
 381     if (prev_in_vs() != NULL) {
 382       assert(prev_in_vs()-&gt;end() == base(),
 383              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to predecessor: " METACHUNK_FULL_FORMAT ".",
 384              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()));
 385       assert(prev_in_vs()-&gt;next_in_vs() == this,
 386              "Chunk " METACHUNK_FULL_FORMAT ": broken link to left neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",
 387              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()), p2i(prev_in_vs()-&gt;next_in_vs()));
 388     }
 389 
 390     if (next_in_vs() != NULL) {
 391       assert(end() == next_in_vs()-&gt;base(),
 392              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to successor: " METACHUNK_FULL_FORMAT ".",
 393              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()));
 394       assert(next_in_vs()-&gt;prev_in_vs() == this,
 395              "Chunk " METACHUNK_FULL_FORMAT ": broken link to right neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",
 396              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()), p2i(next_in_vs()-&gt;prev_in_vs()));
 397     }
 398 
 399     // One of the neighbors must be the buddy. It can be whole or splintered.
 400 
 401     // The chunk following us or preceeding us may be our buddy or a splintered part of it.
 402     Metachunk* buddy = is_leader() ? next_in_vs() : prev_in_vs();
 403 
 404     assert(buddy != NULL, "Missing neighbor.");
 405     assert(!buddy-&gt;is_dead(), "Invalid buddy state.");
 406 
 407     // This neighbor is either or buddy (same level) or a splinter of our buddy - hence
 408     // the level can never be smaller (aka the chunk size cannot be larger).
 409     assert(buddy-&gt;level() &gt;= level(), "Wrong level.");
 410 
 411     if (buddy-&gt;level() == level()) {
 412 
 413       // If the buddy is of the same size as us, it is unsplintered.
 414       assert(buddy-&gt;is_leader() == !is_leader(),
 415              "Only one chunk can be leader in a pair");
 416 
 417       // When direct buddies are neighbors, one or both should be in use, otherwise they should
 418       // have been merged.
 419 
 420       // But since we call this verification function from internal functions where we are about to merge or just did split,
 421       // do not test this. We have RootChunkArea::verify_area_is_ideally_merged() for testing that.
 422 
 423       // assert(buddy-&gt;is_in_use() || is_in_use(), "incomplete merging?");
 424 
 425       if (is_leader()) {
 426         assert(buddy-&gt;base() == end(), "Sanity");
 427         assert(is_aligned(base(), word_size() * 2 * BytesPerWord), "Sanity");
 428       } else {
 429         assert(buddy-&gt;end() == base(), "Sanity");
 430         assert(is_aligned(buddy-&gt;base(), word_size() * 2 * BytesPerWord), "Sanity");
 431       }
 432 
 433     } else {
 434 
 435       // Buddy, but splintered, and this is a part of it.
 436       if (is_leader()) {
 437         assert(buddy-&gt;base() == end(), "Sanity");
 438       } else {
 439         assert(buddy-&gt;end() &gt; (base() - word_size()), "Sanity");
 440       }
 441 
 442     }
 443   }
 444 }
 445 
 446 volatile MetaWord dummy = 0;
 447 
 448 void Metachunk::verify(bool slow) const {
 449 
 450   // Note. This should be called under CLD lock protection.
 451 
 452   // We can verify everything except the _prev_in_vs/_next_in_vs pair.
 453   // This is because neighbor chunks may be added concurrently, so we cannot rely
 454   //  on the content of _next_in_vs/_prev_in_vs unless we have the expand lock.
 455 
 456   assert(!is_dead(), "Do not call on dead chunks.");
 457 
 458   if (is_free()) {
 459     assert(used_words() == 0, "free chunks are not used.");
 460   }
 461 
 462   // Note: only call this on a life Metachunk.
 463   chunklevel::check_valid_level(level());
 464 
 465   assert(base() != NULL, "No base ptr");
 466 
 467   assert(committed_words() &gt;= used_words(),
 468          "mismatch: committed: " SIZE_FORMAT ", used: " SIZE_FORMAT ".",
 469          committed_words(), used_words());
 470 
 471   assert(word_size() &gt;= committed_words(),
 472          "mismatch: word_size: " SIZE_FORMAT ", committed: " SIZE_FORMAT ".",
 473          word_size(), committed_words());
 474 
 475   // Test base pointer
 476   assert(base() != NULL, "Base pointer NULL");
 477   assert(vsnode() != NULL, "No space");
 478   vsnode()-&gt;check_pointer(base());
 479 
 480   // Starting address shall be aligned to chunk size.
 481   const size_t required_alignment = word_size() * sizeof(MetaWord);
 482   assert_is_aligned(base(), required_alignment);
 483 
 484   // If slow, test the committed area
 485   if (slow &amp;&amp; _committed_words &gt; 0) {
 486     for (const MetaWord* p = _base; p &lt; _base + _committed_words; p += os::vm_page_size()) {
 487       dummy = *p;
 488     }
 489     dummy = *(_base + _committed_words - 1);
 490   }
 491 
 492 }
 493 #endif // ASSERT
 494 
 495 void Metachunk::print_on(outputStream* st) const {
 496 
 497   // Note: must also work with invalid/random data. (e.g. do not call word_size())
 498   st-&gt;print("Chunk @" PTR_FORMAT ", state %c, base " PTR_FORMAT ", "
 499             "level " CHKLVL_FORMAT " (" SIZE_FORMAT " words), "
 500             "used " SIZE_FORMAT " words, committed " SIZE_FORMAT " words.",
 501             p2i(this), get_state_char(), p2i(base()), level(),
 502             (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : (size_t)-1),
 503             used_words(), committed_words());
 504 
 505 }
 506 
 507 } // namespace metaspace
 508 
</pre></body></html>
