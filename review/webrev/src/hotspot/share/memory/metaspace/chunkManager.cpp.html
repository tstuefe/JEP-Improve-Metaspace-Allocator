<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 
  28 
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  32 #include "memory/metaspace/chunkLevel.hpp"
  33 #include "memory/metaspace/chunkManager.hpp"
  34 #include "memory/metaspace/internStat.hpp"
  35 #include "memory/metaspace/metachunk.hpp"
  36 #include "memory/metaspace/metaspaceCommon.hpp"
  37 #include "memory/metaspace/metaspaceContext.hpp"
  38 #include "memory/metaspace/metaspaceStatistics.hpp"
  39 #include "memory/metaspace/settings.hpp"
  40 #include "memory/metaspace/virtualSpaceNode.hpp"
  41 #include "memory/metaspace/virtualSpaceList.hpp"
  42 #include "runtime/mutexLocker.hpp"
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
  45 
  46 namespace metaspace {
  47 
  48 #define LOGFMT         "ChkMgr @" PTR_FORMAT " (%s)"
  49 #define LOGFMT_ARGS    p2i(this), this-&gt;_name
  50 
  51 // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
  52 void ChunkManager::return_chunk_simple(Metachunk* c) {
  53 
  54   assert_lock_strong(MetaspaceExpand_lock);
  55 
  56   DEBUG_ONLY(c-&gt;verify(false));
  57 
  58   const chunklevel_t lvl = c-&gt;level();
  59   _chunks.add(c);
  60   c-&gt;reset_used_words();
  61 
  62   // Tracing
  63   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",
  64                        _name, METACHUNK_FORMAT_ARGS(c));
  65 
  66 }
  67 
  68 // Creates a chunk manager with a given name (which is for debug purposes only)
  69 // and an associated space list which will be used to request new chunks from
  70 // (see get_chunk())
  71 ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)
  72   : _vslist(space_list),
  73     _name(name),
  74     _chunks()
  75 {
  76 }
  77 
  78 // Given a chunk, split it into a target chunk of a smaller size (higher target level)
  79 //  and at least one, possible several splinter chunks.
  80 // The original chunk must be outside of the freelist and its state must be free.
  81 // The splinter chunks are added to the freelist.
  82 // The resulting target chunk will be located at the same address as the original
  83 //  chunk, but it will of course be smaller (of a higher level).
  84 // The committed areas within the original chunk carry over to the resulting
  85 //  chunks.
  86 void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {
  87 
  88   assert_lock_strong(MetaspaceExpand_lock);
  89 
  90   assert(c-&gt;is_free(), "chunk to be split must be free.");
  91   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");
  92   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");
  93 
  94   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)
  95   DEBUG_ONLY(c-&gt;verify(true);)
  96 
  97   UL2(debug, "splitting chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",
  98       METACHUNK_FORMAT_ARGS(c), target_level);
  99 
 100   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)
 101 
 102   const chunklevel_t orig_level = c-&gt;level();
 103   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);
 104 
 105   // Splitting should never fail.
 106   assert(c-&gt;level() == target_level, "Sanity");
 107 
 108   // The size of the committed portion should not change (subject to the reduced chunk size of course)
 109 #ifdef ASSERT
 110   if (committed_words_before &gt; c-&gt;word_size()) {
 111     assert(c-&gt;is_fully_committed(), "Sanity");
 112   } else {
 113     assert(c-&gt;committed_words() == committed_words_before, "Sanity");
 114   }
 115 #endif
 116 
 117   DEBUG_ONLY(c-&gt;verify(false));
 118 
 119   DEBUG_ONLY(verify_locked(true);)
 120 
 121   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)
 122 
 123   InternalStats::inc_num_chunk_splits();
 124 
 125 }
 126 
 127 // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
 128 //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
 129 // On error, will return NULL.
 130 //
 131 // This function may fail for two reasons:
 132 // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
 133 //   is non-expandable but needs expanding - aka out of compressed class space).
 134 // - Or, if the necessary space cannot be committed because we hit a commit limit.
 135 //   This may be either the GC threshold or MaxMetaspaceSize.
 136 Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {
 137 
 138   assert(preferred_level &lt;= max_level, "Sanity");
 139   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");
 140 
 141   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 142 
 143   DEBUG_ONLY(verify_locked(false);)
 144 
 145   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)
 146   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)
 147   assert(max_level &gt;= preferred_level, "invalid level.");
 148 
 149   UL2(debug, "requested chunk: pref_level: " CHKLVL_FORMAT
 150      ", max_level: " CHKLVL_FORMAT ", min committed size: " SIZE_FORMAT ".",
 151      preferred_level, max_level, min_committed_words);
 152 
 153   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.
 154 
 155   // 1) Search best or smaller committed chunks (first attempt):
 156   //    Start at the preferred chunk size and work your way down (level up).
 157   //    But for now, only consider chunks larger than a certain threshold -
 158   //    this is to prevent large loaders (eg boot) from unnecessarily gobbling up
 159   //    all the tiny splinter chunks lambdas leave around.
 160   Metachunk* c = NULL;
 161   c = _chunks.search_chunk_ascending(preferred_level, MIN2((chunklevel_t)(preferred_level + 2), max_level), min_committed_words);
 162 
 163   // 2) Search larger committed chunks:
 164   //    If that did not yield anything, look at larger chunks, which may be committed. We would have to split
 165   //    them first, of course.
 166   if (c == NULL) {
 167     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);
 168   }
 169 
 170   // 3) Search best or smaller committed chunks (second attempt):
 171   //    Repeat (1) but now consider even the tiniest chunks as long as they are large enough to hold the
 172   //    committed min size.
 173   if (c == NULL) {
 174     c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);
 175   }
 176 
 177   // if we did not get anything yet, there are no free chunks commmitted enough. Repeat search but look for uncommitted chunks too:
 178 
 179   // 4) Search best or smaller chunks, can be uncommitted:
 180   if (c == NULL) {
 181     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);
 182   }
 183 
 184   // 5) Search a larger uncommitted chunk:
 185   if (c == NULL) {
 186     c = _chunks.search_chunk_descending(preferred_level, 0);
 187   }
 188 
 189   if (c != NULL) {
 190     UL(trace, "taken from freelist.");
 191   }
 192 
 193   // Failing all that, allocate a new root chunk from the connected virtual space.
 194   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)
 195   if (c == NULL) {
 196     c = _vslist-&gt;allocate_root_chunk();
 197     if (c == NULL) {
 198       UL(info, "failed to get new root chunk.");
 199     } else {
 200       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");
 201       UL(debug, "allocated new root chunk.");
 202     }
 203   }
 204 
 205   if (c == NULL) {
 206     UL2(info, "failed to get chunk (preferred level: " CHKLVL_FORMAT
 207        ", max level " CHKLVL_FORMAT ".", preferred_level, max_level);
 208     return NULL;
 209   }
 210 
 211   // Now we have a chunk. It may be too large for the callers needs. It also may not be committed enough.
 212   // So we may have to (a) split it and (b) commit the first portion of it to ensure min_committed_words
 213   // are committed.
 214   //
 215   // We start with (b) though: committing may fail while splitting cannot fail. By committing before
 216   // splitting, we avoid having to re-merge a split chunk in case of a commit error.
 217   //
 218   // (Note that the split operation always returns the first portion of the original chunk as target chunk;
 219   //  so it is guaranteed that the committed portion is carried over to the new chunk).
 220   if (c-&gt;committed_words() &lt; min_committed_words) {
 221     if (c-&gt;ensure_committed_locked(min_committed_words) == false) {
 222       UL2(info, "failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",
 223           min_committed_words,  METACHUNK_FORMAT_ARGS(c));
 224       _chunks.add(c);
 225       return NULL;
 226     }
 227   }
 228 
 229   // If too large, split chunk and add the splinter chunks back to the freelist.
 230   if (c-&gt;level() &lt; preferred_level) {
 231     split_chunk_and_add_splinters(c, preferred_level);
 232     assert(c-&gt;level() == preferred_level, "split failed?");
 233   }
 234 
 235   // Any chunk returned from ChunkManager shall be marked as in use.
 236   c-&gt;set_in_use();
 237 
 238   DEBUG_ONLY(verify_locked(false);)
 239   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)
 240 
 241   UL2(debug, "handing out chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 242 
 243   InternalStats::inc_num_chunks_taken_from_freelist();
 244 
 245   return c;
 246 
 247 }
 248 
 249 // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 250 //  with neighbors.
 251 // As a side effect this removes the chunk from whatever list it has been in previously.
 252 // Happens after a Classloader was unloaded and releases its metaspace chunks.
 253 // !! Note: this may invalidate the chunk. Do not access the chunk after
 254 //    this function returns !!
 255 void ChunkManager::return_chunk(Metachunk* c) {
 256 
 257   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 258 
 259   UL2(debug, ": returning chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 260 
 261   DEBUG_ONLY(c-&gt;verify(true);)
 262 
 263   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");
 264 
 265   assert(c-&gt;is_in_use(), "Unexpected chunk state");
 266   assert(!c-&gt;in_list(), "Remove from list first");
 267   c-&gt;set_free();
 268   c-&gt;reset_used_words();
 269 
 270   const chunklevel_t orig_lvl = c-&gt;level();
 271 
 272   Metachunk* merged = NULL;
 273   if (!c-&gt;is_root_chunk()) {
 274     // Only attempt merging if we are not of the lowest level already.
 275     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);
 276   }
 277 
 278   if (merged != NULL) {
 279 
 280     InternalStats::inc_num_chunk_merges();
 281 
 282     DEBUG_ONLY(merged-&gt;verify(false));
 283 
 284     // We did merge our chunk into a different chunk.
 285 
 286     // We did merge chunks and now have a bigger chunk.
 287     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");
 288 
 289     UL2(debug, "merged into chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(merged));
 290 
 291     c = merged;
 292 
 293   }
 294 
 295   if (Settings::uncommit_free_chunks() &amp;&amp;
 296       c-&gt;word_size() &gt;= Settings::commit_granule_words())
 297   {
 298     UL2(debug, "uncommitting free chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 299     c-&gt;uncommit_locked();
 300   }
 301 
 302   return_chunk_simple(c);
 303 
 304   DEBUG_ONLY(verify_locked(false);)
 305   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)
 306 
 307   InternalStats::inc_num_chunks_returned_to_freelist();
 308 
 309 }
 310 
 311 // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to
 312 // enlarge it in place by claiming its trailing buddy.
 313 //
 314 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 315 //
 316 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 317 // double in size (level decreased by one).
 318 //
 319 // On success, true is returned, false otherwise.
 320 bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {
 321   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 322   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);
 323 }
 324 
 325 static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {
 326   if (word_size_1 == word_size_2) {
 327     print_scaled_words(st, word_size_1);
 328     st-&gt;print (" (no change)");
 329   } else {
 330     print_scaled_words(st, word_size_1);
 331     st-&gt;print("-&gt;");
 332     print_scaled_words(st, word_size_2);
 333     st-&gt;print(" (");
 334     if (word_size_2 &lt;= word_size_1) {
 335       st-&gt;print("-");
 336       print_scaled_words(st, word_size_1 - word_size_2);
 337     } else {
 338       st-&gt;print("+");
 339       print_scaled_words(st, word_size_2 - word_size_1);
 340     }
 341     st-&gt;print(")");
 342   }
 343 }
 344 
 345 void ChunkManager::purge() {
 346 
 347   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 348 
 349   UL(info, ": reclaiming memory...");
 350 
 351   const size_t reserved_before = _vslist-&gt;reserved_words();
 352   const size_t committed_before = _vslist-&gt;committed_words();
 353   int num_nodes_purged = 0;
 354 
 355   // 1) purge virtual space list
 356   num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);
 357   InternalStats::inc_num_purges();
 358 
 359   // 2) uncommit free chunks
 360   if (Settings::uncommit_free_chunks()) {
 361     const chunklevel_t max_level =
 362         chunklevel::level_fitting_word_size(Settings::commit_granule_words());
 363     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;
 364          l &lt;= max_level;
 365          l ++)
 366     {
 367       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {
 368         c-&gt;uncommit_locked();
 369       }
 370     }
 371   }
 372 
 373   const size_t reserved_after = _vslist-&gt;reserved_words();
 374   const size_t committed_after = _vslist-&gt;committed_words();
 375 
 376   // Print a nice report.
 377   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {
 378     UL(info, "nothing reclaimed.");
 379   } else {
 380     LogTarget(Info, metaspace) lt;
 381     if (lt.is_enabled()) {
 382       LogStream ls(lt);
 383       ls.print_cr(LOGFMT ": finished reclaiming memory: ", LOGFMT_ARGS);
 384 
 385       ls.print("reserved: ");
 386       print_word_size_delta(&amp;ls, reserved_before, reserved_after);
 387       ls.cr();
 388 
 389       ls.print("committed: ");
 390       print_word_size_delta(&amp;ls, committed_before, committed_after);
 391       ls.cr();
 392 
 393       ls.print_cr("full nodes purged: %d", num_nodes_purged);
 394     }
 395   }
 396 
 397   DEBUG_ONLY(_vslist-&gt;verify_locked(true));
 398   DEBUG_ONLY(verify_locked(true));
 399 
 400 }
 401 
 402 // Convenience methods to return the global class-space chunkmanager
 403 //  and non-class chunkmanager, respectively.
 404 ChunkManager* ChunkManager::chunkmanager_class() {
 405   return MetaspaceContext::contect_class() == NULL ? NULL : MetaspaceContext::contect_class()-&gt;cm();
 406 }
 407 
 408 ChunkManager* ChunkManager::chunkmanager_nonclass() {
 409   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;cm();
 410 }
 411 
 412 // Update statistics.
 413 void ChunkManager::add_to_statistics(cm_stats_t* out) const {
 414 
 415   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 416 
 417   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 418     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);
 419     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);
 420   }
 421 
 422   DEBUG_ONLY(out-&gt;verify();)
 423 
 424 }
 425 
 426 #ifdef ASSERT
 427 
 428 void ChunkManager::verify(bool slow) const {
 429   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 430   verify_locked(slow);
 431 }
 432 
 433 void ChunkManager::verify_locked(bool slow) const {
 434   assert_lock_strong(MetaspaceExpand_lock);
 435   assert(_vslist != NULL, "No vslist");
 436   _chunks.verify();
 437 }
 438 
 439 bool ChunkManager::contains_chunk(Metachunk* c) const {
 440   return _chunks.contains(c);
 441 }
 442 
 443 #endif // ASSERT
 444 
 445 void ChunkManager::print_on(outputStream* st) const {
 446   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 447   print_on_locked(st);
 448 }
 449 
 450 void ChunkManager::print_on_locked(outputStream* st) const {
 451   assert_lock_strong(MetaspaceExpand_lock);
 452   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
 453                total_num_chunks(), total_word_size(), _chunks.committed_word_size());
 454   _chunks.print_on(st);
 455 }
 456 
 457 } // namespace metaspace
</pre></body></html>
