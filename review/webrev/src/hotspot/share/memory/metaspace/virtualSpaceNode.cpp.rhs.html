<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
<a name="2" id="anc2"></a><span class="new">  26 </span>
<span class="new">  27 </span>
  28 #include "precompiled.hpp"
  29 
  30 #include "logging/log.hpp"
<a name="3" id="anc3"></a><span class="changed">  31 </span>
<span class="changed">  32 #include "memory/metaspace/chunkLevel.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/chunkHeaderPool.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  35 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  36 #include "memory/metaspace/freeChunkList.hpp"</span>
<span class="changed">  37 #include "memory/metaspace/internStat.hpp"</span>
  38 #include "memory/metaspace/metachunk.hpp"
<a name="4" id="anc4"></a>


  39 #include "memory/metaspace/metaspaceCommon.hpp"
<a name="5" id="anc5"></a><span class="changed">  40 #include "memory/metaspace/rootChunkArea.hpp"</span>
<span class="changed">  41 #include "memory/metaspace/runningCounters.hpp"</span>
<span class="changed">  42 #include "memory/metaspace/settings.hpp"</span>
  43 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="6" id="anc6"></a><span class="changed">  44 #include "memory/metaspace.hpp"</span>
<span class="changed">  45 </span>
<span class="changed">  46 #include "runtime/globals.hpp"</span>
<span class="changed">  47 #include "runtime/mutexLocker.hpp"</span>
  48 #include "runtime/os.hpp"
<a name="7" id="anc7"></a><span class="changed">  49 </span>
<span class="changed">  50 #include "utilities/align.hpp"</span>
  51 #include "utilities/debug.hpp"
  52 #include "utilities/globalDefinitions.hpp"
<a name="8" id="anc8"></a><span class="new">  53 #include "utilities/ostream.hpp"</span>
  54 
  55 namespace metaspace {
  56 
<a name="9" id="anc9"></a><span class="changed">  57 #define LOGFMT         "VsListNode @" PTR_FORMAT " base " PTR_FORMAT " "</span>
<span class="changed">  58 #define LOGFMT_ARGS    p2i(this), p2i(_base)</span>








  59 
<a name="10" id="anc10"></a><span class="changed">  60 #ifdef ASSERT</span>
<span class="changed">  61 void check_pointer_is_aligned_to_commit_granule(const MetaWord* p) {</span>
<span class="changed">  62   assert(is_aligned(p, Settings::commit_granule_bytes()),</span>
<span class="changed">  63          "Pointer not aligned to commit granule size: " PTR_FORMAT ".",</span>
<span class="changed">  64          p2i(p));</span>
<span class="changed">  65 }</span>
<span class="changed">  66 void check_word_size_is_aligned_to_commit_granule(size_t word_size) {</span>
<span class="changed">  67   assert(is_aligned(word_size, Settings::commit_granule_words()),</span>
<span class="changed">  68          "Not aligned to commit granule size: " SIZE_FORMAT ".", word_size);</span>
  69 }
<a name="11" id="anc11"></a><span class="new">  70 #endif</span>
  71 
<a name="12" id="anc12"></a><span class="changed">  72 </span>
<span class="changed">  73 // Given an address range, ensure it is committed.</span>
<span class="changed">  74 //</span>
<span class="changed">  75 // The range has to be aligned to granule size.</span>
<span class="changed">  76 //</span>
<span class="changed">  77 // Function will:</span>
<span class="changed">  78 // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="changed">  79 //    returns true immediately.</span>
<span class="changed">  80 // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="changed">  81 //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="changed">  82 // - commit the memory.</span>
<span class="changed">  83 // - mark the range as committed in the commit mask</span>
<span class="changed">  84 //</span>
<span class="changed">  85 // Returns true if success, false if it did hit a commit limit.</span>
<span class="changed">  86 bool VirtualSpaceNode::commit_range(MetaWord* p, size_t word_size) {</span>
<span class="changed">  87 </span>
<span class="changed">  88   DEBUG_ONLY(check_pointer_is_aligned_to_commit_granule(p);)</span>
<span class="changed">  89   DEBUG_ONLY(check_word_size_is_aligned_to_commit_granule(word_size);)</span>
<span class="changed">  90   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  91 </span>
<span class="changed">  92   // First calculate how large the committed regions in this range are</span>
<span class="changed">  93   const size_t committed_words_in_range = _commit_mask.get_committed_size_in_range(p, word_size);</span>
<span class="changed">  94   DEBUG_ONLY(check_word_size_is_aligned_to_commit_granule(committed_words_in_range);)</span>
<span class="changed">  95 </span>
<span class="changed">  96   // By how much words we would increase commit charge</span>
<span class="changed">  97   //  were we to commit the given address range completely.</span>
<span class="changed">  98   const size_t commit_increase_words = word_size - committed_words_in_range;</span>
<span class="changed">  99 </span>
<span class="changed"> 100   UL2(debug, "committing range " PTR_FORMAT ".." PTR_FORMAT "(" SIZE_FORMAT " words)",</span>
<span class="changed"> 101       p2i(p), p2i(p + word_size), word_size);</span>
<span class="changed"> 102 </span>
<span class="changed"> 103   if (commit_increase_words == 0) {</span>
<span class="changed"> 104     UL(debug, "... already fully committed.");</span>
<span class="changed"> 105     return true; // Already fully committed, nothing to do.</span>



































 106   }
<a name="13" id="anc13"></a><span class="changed"> 107 </span>
<span class="changed"> 108   // Before committing any more memory, check limits.</span>
<span class="changed"> 109   if (_commit_limiter-&gt;possible_expansion_words() &lt; commit_increase_words) {</span>
<span class="changed"> 110     UL(debug, "... cannot commit (limit).");</span>
<span class="changed"> 111     return false;</span>

































 112   }
<a name="14" id="anc14"></a><span class="new"> 113 </span>
<span class="new"> 114   // Commit...</span>
<span class="new"> 115   if (os::commit_memory((char*)p, word_size * BytesPerWord, false) == false) {</span>
<span class="new"> 116     vm_exit_out_of_memory(word_size * BytesPerWord, OOM_MMAP_ERROR, "Failed to commit metaspace.");</span>
 117   }
<a name="15" id="anc15"></a><span class="changed"> 118 </span>
<span class="changed"> 119   if (AlwaysPreTouch) {</span>
<span class="changed"> 120     os::pretouch_memory(p, p + word_size);</span>
 121   }
<a name="16" id="anc16"></a>
 122 
<a name="17" id="anc17"></a><span class="new"> 123   UL2(debug, "... committed " SIZE_FORMAT " additional words.", commit_increase_words);</span>
 124 
<a name="18" id="anc18"></a><span class="changed"> 125   // ... tell commit limiter...</span>
<span class="changed"> 126   _commit_limiter-&gt;increase_committed(commit_increase_words);</span>
 127 
<a name="19" id="anc19"></a><span class="changed"> 128   // ... update counters in containing vslist ...</span>
<span class="changed"> 129   _total_committed_words_counter-&gt;increment_by(commit_increase_words);</span>
<span class="changed"> 130 </span>
<span class="changed"> 131   // ... and update the commit mask.</span>
<span class="changed"> 132   _commit_mask.mark_range_as_committed(p, word_size);</span>
















































































 133 
<a name="20" id="anc20"></a><span class="changed"> 134 #ifdef ASSERT</span>
<span class="changed"> 135   // The commit boundary maintained in the CommitLimiter should be equal the sum of committed words</span>
<span class="changed"> 136   // in both class and non-class vslist (outside gtests).</span>
<span class="changed"> 137   if (_commit_limiter == CommitLimiter::globalLimiter()) {</span>
<span class="changed"> 138     assert(_commit_limiter-&gt;committed_words() == RunningCounters::committed_words(), "counter mismatch");</span>
 139   }
<a name="21" id="anc21"></a><span class="new"> 140 #endif</span>
<span class="new"> 141 </span>
<span class="new"> 142   InternalStats::inc_num_space_committed();</span>
<span class="new"> 143 </span>
<span class="new"> 144   return true;</span>
<span class="new"> 145 </span>
 146 }
<a name="22" id="anc22"></a>
 147 
<a name="23" id="anc23"></a><span class="changed"> 148 // Given an address range, ensure it is committed.</span>
<span class="changed"> 149 //</span>
<span class="changed"> 150 // The range does not have to be aligned to granule size. However, the function will always commit</span>
<span class="changed"> 151 // whole granules.</span>
<span class="changed"> 152 //</span>
<span class="changed"> 153 // Function will:</span>
<span class="changed"> 154 // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="changed"> 155 //    returns true immediately.</span>
<span class="changed"> 156 // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="changed"> 157 //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="changed"> 158 // - commit the memory.</span>
<span class="changed"> 159 // - mark the range as committed in the commit mask</span>
<span class="changed"> 160 //</span>
<span class="changed"> 161 // !! Careful:</span>
<span class="changed"> 162 //    calling ensure_range_is_committed on a range which contains both committed and uncommitted</span>
<span class="changed"> 163 //    areas will commit the whole area, thus erase the content in the existing committed parts.</span>
<span class="changed"> 164 //    Make sure you never call this on an address range containing live data. !!</span>
<span class="changed"> 165 //</span>
<span class="changed"> 166 // Returns true if success, false if it did hit a commit limit.</span>
<span class="changed"> 167 bool VirtualSpaceNode::ensure_range_is_committed(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 168 </span>
 169   assert_lock_strong(MetaspaceExpand_lock);
<a name="24" id="anc24"></a><span class="changed"> 170   assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");</span>
<span class="changed"> 171 </span>
<span class="changed"> 172   MetaWord* p_start = align_down(p, Settings::commit_granule_bytes());</span>
<span class="changed"> 173   MetaWord* p_end = align_up(p + word_size, Settings::commit_granule_bytes());</span>
<span class="changed"> 174 </span>
<span class="changed"> 175   // Todo: simple for now. Make it more intelligent late</span>
<span class="changed"> 176   return commit_range(p_start, p_end - p_start);</span>
<span class="changed"> 177 </span>
 178 }
 179 
<a name="25" id="anc25"></a><span class="changed"> 180 // Given an address range (which has to be aligned to commit granule size):</span>
<span class="changed"> 181 //  - uncommit it</span>
<span class="changed"> 182 //  - mark it as uncommitted in the commit mask</span>
<span class="changed"> 183 void VirtualSpaceNode::uncommit_range(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 184 </span>
<span class="changed"> 185   DEBUG_ONLY(check_pointer_is_aligned_to_commit_granule(p);)</span>
<span class="changed"> 186   DEBUG_ONLY(check_word_size_is_aligned_to_commit_granule(word_size);)</span>
 187   assert_lock_strong(MetaspaceExpand_lock);
<a name="26" id="anc26"></a>

 188 
<a name="27" id="anc27"></a><span class="changed"> 189   // First calculate how large the committed regions in this range are</span>
<span class="changed"> 190   const size_t committed_words_in_range = _commit_mask.get_committed_size_in_range(p, word_size);</span>
<span class="changed"> 191   DEBUG_ONLY(check_word_size_is_aligned_to_commit_granule(committed_words_in_range);)</span>
<span class="changed"> 192 </span>
<span class="changed"> 193   UL2(debug, "uncommitting range " PTR_FORMAT ".." PTR_FORMAT "(" SIZE_FORMAT " words)",</span>
<span class="changed"> 194       p2i(p), p2i(p + word_size), word_size);</span>
<span class="changed"> 195 </span>
<span class="changed"> 196   if (committed_words_in_range == 0) {</span>
<span class="changed"> 197     UL(debug, "... already fully uncommitted.");</span>
<span class="changed"> 198     return; // Already fully uncommitted, nothing to do.</span>
<span class="changed"> 199   }</span>
<span class="changed"> 200 </span>
<span class="changed"> 201   // Uncommit...</span>
<span class="changed"> 202   if (os::uncommit_memory((char*)p, word_size * BytesPerWord) == false) {</span>
<span class="changed"> 203     // Note: this can actually happen, since uncommit may increase the number of mappings.</span>
<span class="changed"> 204     fatal("Failed to uncommit metaspace.");</span>
 205   }
<a name="28" id="anc28"></a><span class="new"> 206 </span>
<span class="new"> 207   UL2(debug, "... uncommitted " SIZE_FORMAT " words.", committed_words_in_range);</span>
<span class="new"> 208 </span>
<span class="new"> 209   // ... tell commit limiter...</span>
<span class="new"> 210   _commit_limiter-&gt;decrease_committed(committed_words_in_range);</span>
<span class="new"> 211 </span>
<span class="new"> 212   // ... and global counters...</span>
<span class="new"> 213   _total_committed_words_counter-&gt;decrement_by(committed_words_in_range);</span>
<span class="new"> 214 </span>
<span class="new"> 215    // ... and update the commit mask.</span>
<span class="new"> 216   _commit_mask.mark_range_as_uncommitted(p, word_size);</span>
<span class="new"> 217 </span>
 218 #ifdef ASSERT
<a name="29" id="anc29"></a><span class="changed"> 219   // The commit boundary maintained in the CommitLimiter should be equal the sum of committed words</span>
<span class="changed"> 220   // in both class and non-class vslist (outside gtests).</span>
<span class="changed"> 221   if (_commit_limiter == CommitLimiter::globalLimiter()) { // We are outside a test scenario</span>
<span class="changed"> 222     assert(_commit_limiter-&gt;committed_words() == RunningCounters::committed_words(), "counter mismatch");</span>
<span class="changed"> 223   }</span>
 224 #endif
<a name="30" id="anc30"></a><span class="new"> 225 </span>
<span class="new"> 226   InternalStats::inc_num_space_uncommitted();</span>
<span class="new"> 227 </span>
 228 }
 229 
<a name="31" id="anc31"></a><span class="changed"> 230 //// creation, destruction ////</span>
<span class="changed"> 231 </span>
<span class="changed"> 232 VirtualSpaceNode::VirtualSpaceNode(ReservedSpace rs, bool owns_rs, CommitLimiter* limiter,</span>
<span class="changed"> 233                                    SizeCounter* reserve_counter, SizeCounter* commit_counter)</span>
<span class="changed"> 234   : _next(NULL),</span>
<span class="changed"> 235     _rs(rs),</span>
<span class="changed"> 236     _owns_rs(owns_rs),</span>
<span class="changed"> 237     _base((MetaWord*)rs.base()),</span>
<span class="changed"> 238     _word_size(rs.size() / BytesPerWord),</span>
<span class="changed"> 239     _used_words(0),</span>
<span class="changed"> 240     _commit_mask((MetaWord*)rs.base(), rs.size() / BytesPerWord),</span>
<span class="changed"> 241     _root_chunk_area_lut((MetaWord*)rs.base(), rs.size() / BytesPerWord),</span>
<span class="changed"> 242     _commit_limiter(limiter),</span>
<span class="changed"> 243     _total_reserved_words_counter(reserve_counter),</span>
<span class="changed"> 244     _total_committed_words_counter(commit_counter)</span>
<span class="changed"> 245 {</span>
<span class="changed"> 246   UL2(debug, "born (word_size " SIZE_FORMAT ").", _word_size);</span>
<span class="changed"> 247 </span>
<span class="changed"> 248   // Update reserved counter in vslist</span>
<span class="changed"> 249   _total_reserved_words_counter-&gt;increment_by(_word_size);</span>
<span class="changed"> 250 </span>
<span class="changed"> 251   assert_is_aligned(_base, chunklevel::MAX_CHUNK_BYTE_SIZE);</span>
<span class="changed"> 252   assert_is_aligned(_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="changed"> 253 </span>
 254 }
 255 
<a name="32" id="anc32"></a>
























































































































































 256 
<a name="33" id="anc33"></a><span class="changed"> 257 // Create a node of a given size (it will create its own space).</span>
<span class="changed"> 258 VirtualSpaceNode* VirtualSpaceNode::create_node(size_t word_size,</span>
<span class="changed"> 259                                                 CommitLimiter* limiter, SizeCounter* reserve_words_counter,</span>
<span class="changed"> 260                                                 SizeCounter* commit_words_counter)</span>
<span class="changed"> 261 {</span>
<span class="changed"> 262 </span>
<span class="changed"> 263   DEBUG_ONLY(assert_is_aligned(word_size, chunklevel::MAX_CHUNK_WORD_SIZE);)</span>
 264 
 265 #ifdef ASSERT
<a name="34" id="anc34"></a><span class="changed"> 266   size_t alignment = chunklevel::MAX_CHUNK_BYTE_SIZE;</span>




 267 #endif
 268 
<a name="35" id="anc35"></a><span class="changed"> 269   ReservedSpace rs(word_size * BytesPerWord,</span>
<span class="changed"> 270                    Metaspace::reserve_alignment(),</span>
<span class="changed"> 271                    false // large</span>
<span class="changed"> 272                    );</span>
<span class="changed"> 273 </span>
<span class="changed"> 274   if (!rs.is_reserved()) {</span>
<span class="changed"> 275     vm_exit_out_of_memory(word_size * BytesPerWord, OOM_MMAP_ERROR, "Failed to reserve memory for metaspace");</span>
<span class="changed"> 276   }</span>
<span class="changed"> 277 </span>
<span class="changed"> 278   assert_is_aligned(rs.base(), chunklevel::MAX_CHUNK_BYTE_SIZE);</span>
<span class="changed"> 279 </span>
<span class="changed"> 280   InternalStats::inc_num_vsnodes_births();</span>
<span class="changed"> 281   return new VirtualSpaceNode(rs, true, limiter, reserve_words_counter, commit_words_counter);</span>
 282 
<a name="36" id="anc36"></a>
 283 }
 284 
<a name="37" id="anc37"></a><span class="new"> 285 // Create a node over an existing space</span>
<span class="new"> 286 VirtualSpaceNode* VirtualSpaceNode::create_node(ReservedSpace rs, CommitLimiter* limiter,</span>
<span class="new"> 287                                                 SizeCounter* reserve_words_counter, SizeCounter* commit_words_counter)</span>
<span class="new"> 288 {</span>
<span class="new"> 289   InternalStats::inc_num_vsnodes_births();</span>
<span class="new"> 290   return new VirtualSpaceNode(rs, false, limiter, reserve_words_counter, commit_words_counter);</span>
<span class="new"> 291 }</span>
 292 
<a name="38" id="anc38"></a><span class="changed"> 293 VirtualSpaceNode::~VirtualSpaceNode() {</span>



 294 
<a name="39" id="anc39"></a><span class="changed"> 295   DEBUG_ONLY(verify_locked(true);)</span>
 296 
<a name="40" id="anc40"></a><span class="changed"> 297   UL(debug, ": dies.");</span>
<span class="changed"> 298 </span>
<span class="changed"> 299   if (_owns_rs) {</span>
<span class="changed"> 300     _rs.release();</span>
 301   }
 302 
<a name="41" id="anc41"></a><span class="changed"> 303   // Update counters in vslist</span>
<span class="changed"> 304   size_t committed = committed_words();</span>
<span class="changed"> 305   _total_committed_words_counter-&gt;decrement_by(committed);</span>
<span class="changed"> 306   _total_reserved_words_counter-&gt;decrement_by(_word_size);</span>
 307 
<a name="42" id="anc42"></a><span class="changed"> 308   // ... and tell commit limiter</span>
<span class="changed"> 309   _commit_limiter-&gt;decrease_committed(committed);</span>
<span class="changed"> 310 </span>
<span class="changed"> 311   InternalStats::inc_num_vsnodes_deaths();</span>
<span class="changed"> 312 </span>
<span class="changed"> 313 }</span>
<span class="changed"> 314 </span>
<span class="changed"> 315 </span>
<span class="changed"> 316 </span>
<span class="changed"> 317 //// Chunk allocation, splitting, merging /////</span>
<span class="changed"> 318 </span>
<span class="changed"> 319 // Allocate a root chunk from this node. Will fail and return NULL</span>
<span class="changed"> 320 // if the node is full.</span>
<span class="changed"> 321 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 322 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 323 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 324 Metachunk* VirtualSpaceNode::allocate_root_chunk() {</span>
<span class="changed"> 325 </span>
<span class="changed"> 326   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 327 </span>
<span class="changed"> 328   assert_is_aligned(free_words(), chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="changed"> 329 </span>
<span class="changed"> 330   if (free_words() &gt;= chunklevel::MAX_CHUNK_WORD_SIZE) {</span>
<span class="changed"> 331 </span>
<span class="changed"> 332     MetaWord* loc = _base + _used_words;</span>
<span class="changed"> 333     _used_words += chunklevel::MAX_CHUNK_WORD_SIZE;</span>
<span class="changed"> 334 </span>
<span class="changed"> 335     RootChunkArea* rca = _root_chunk_area_lut.get_area_by_address(loc);</span>
<span class="changed"> 336 </span>
<span class="changed"> 337     // Create a root chunk header and initialize it;</span>
<span class="changed"> 338     Metachunk* c = rca-&gt;alloc_root_chunk_header(this);</span>
<span class="changed"> 339 </span>
<span class="changed"> 340     assert(c-&gt;base() == loc &amp;&amp; c-&gt;vsnode() == this &amp;&amp;</span>
<span class="changed"> 341            c-&gt;is_free(), "Sanity");</span>
<span class="changed"> 342 </span>
<span class="changed"> 343     DEBUG_ONLY(c-&gt;verify(true);)</span>
<span class="changed"> 344 </span>
<span class="changed"> 345     UL2(debug, "new root chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 346 </span>
<span class="changed"> 347     if (Settings::newborn_root_chunks_are_fully_committed()) {</span>
<span class="changed"> 348       // Note: use Metachunk::ensure_commit, do not commit directly. This makes sure the chunk knows</span>
<span class="changed"> 349       // its commit range and does not ask needlessly.</span>
<span class="changed"> 350       c-&gt;ensure_fully_committed_locked();</span>
 351     }
 352 
<a name="43" id="anc43"></a><span class="changed"> 353     return c;</span>
<span class="changed"> 354 </span>
<span class="changed"> 355   }</span>
<span class="changed"> 356 </span>
<span class="changed"> 357   return NULL; // Node is full.</span>
 358 
<a name="44" id="anc44"></a>
 359 }
 360 
<a name="45" id="anc45"></a><span class="changed"> 361 // Given a chunk c, split it recursively until you get a chunk of the given target_level.</span>
<span class="changed"> 362 //</span>
<span class="changed"> 363 // The resulting target chunk resides at the same address as the original chunk.</span>
<span class="changed"> 364 // The resulting splinters are added to freelists.</span>
<span class="changed"> 365 void VirtualSpaceNode::split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists) {</span>
<span class="changed"> 366 </span>
 367   assert_lock_strong(MetaspaceExpand_lock);
<a name="46" id="anc46"></a><span class="changed"> 368 </span>
<span class="changed"> 369   // Get the area associated with this chunk and let it handle the splitting</span>
<span class="changed"> 370   RootChunkArea* rca = _root_chunk_area_lut.get_area_by_address(c-&gt;base());</span>
<span class="changed"> 371 </span>
<span class="changed"> 372   DEBUG_ONLY(rca-&gt;verify_area_is_ideally_merged();)</span>
<span class="changed"> 373 </span>
<span class="changed"> 374   rca-&gt;split(target_level, c, freelists);</span>
<span class="changed"> 375 </span>
 376 }
 377 
<a name="47" id="anc47"></a><span class="changed"> 378 // Given a chunk, attempt to merge it recursively with its neighboring chunks.</span>
<span class="changed"> 379 //</span>
<span class="changed"> 380 // If successful (merged at least once), returns address of</span>
<span class="changed"> 381 // the merged chunk; NULL otherwise.</span>
<span class="changed"> 382 //</span>
<span class="changed"> 383 // The merged chunks are removed from the freelists.</span>
<span class="changed"> 384 //</span>
<span class="changed"> 385 // !!! Please note that if this method returns a non-NULL value, the</span>
<span class="changed"> 386 // original chunk will be invalid and should not be accessed anymore! !!!</span>
<span class="changed"> 387 Metachunk* VirtualSpaceNode::merge(Metachunk* c, FreeChunkListVector* freelists) {</span>
 388 
<a name="48" id="anc48"></a><span class="changed"> 389   assert(c != NULL &amp;&amp; c-&gt;is_free(), "Sanity");</span>
<span class="changed"> 390   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 391 </span>
<span class="changed"> 392   // Get the rca associated with this chunk and let it handle the merging</span>
<span class="changed"> 393   RootChunkArea* rca = _root_chunk_area_lut.get_area_by_address(c-&gt;base());</span>
<span class="changed"> 394 </span>
<span class="changed"> 395   Metachunk* c2 = rca-&gt;merge(c, freelists);</span>
<span class="changed"> 396 </span>
<span class="changed"> 397   DEBUG_ONLY(rca-&gt;verify_area_is_ideally_merged();)</span>
<span class="changed"> 398 </span>
<span class="changed"> 399   return c2;</span>
<span class="changed"> 400 </span>
<span class="changed"> 401 }</span>
<span class="changed"> 402 </span>
<span class="changed"> 403 // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to</span>
<span class="changed"> 404 // enlarge it in place by claiming its trailing buddy.</span>
<span class="changed"> 405 //</span>
<span class="changed"> 406 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="changed"> 407 //</span>
<span class="changed"> 408 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="changed"> 409 // double in size (level decreased by one).</span>
<span class="changed"> 410 //</span>
<span class="changed"> 411 // On success, true is returned, false otherwise.</span>
<span class="changed"> 412 bool VirtualSpaceNode::attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists) {</span>
<span class="changed"> 413 </span>
<span class="changed"> 414   assert(c != NULL &amp;&amp; c-&gt;is_in_use() &amp;&amp; !c-&gt;is_root_chunk(), "Sanity");</span>
<span class="changed"> 415   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 416 </span>
<span class="changed"> 417   // Get the rca associated with this chunk and let it handle the merging</span>
<span class="changed"> 418   RootChunkArea* rca = _root_chunk_area_lut.get_area_by_address(c-&gt;base());</span>
<span class="changed"> 419 </span>
<span class="changed"> 420   bool rc = rca-&gt;attempt_enlarge_chunk(c, freelists);</span>
<span class="changed"> 421 </span>
<span class="changed"> 422   DEBUG_ONLY(rca-&gt;verify_area_is_ideally_merged();)</span>
<span class="changed"> 423 </span>
<span class="changed"> 424   if (rc) {</span>
<span class="changed"> 425     InternalStats::inc_num_chunks_enlarged();</span>
 426   }
 427 
<a name="49" id="anc49"></a><span class="changed"> 428   return rc;</span>
<span class="changed"> 429 </span>
<span class="changed"> 430 }</span>
<span class="changed"> 431 </span>
<span class="changed"> 432 // Attempts to purge the node:</span>
<span class="changed"> 433 //</span>
<span class="changed"> 434 // If all chunks living in this node are free, they will all be removed from</span>
<span class="changed"> 435 //  the freelist they currently reside in. Then, the node will be deleted.</span>
<span class="changed"> 436 //</span>
<span class="changed"> 437 // Returns true if the node has been deleted, false if not.</span>
<span class="changed"> 438 // !! If this returns true, do not access the node from this point on. !!</span>
<span class="changed"> 439 bool VirtualSpaceNode::attempt_purge(FreeChunkListVector* freelists) {</span>
<span class="changed"> 440 </span>
<span class="changed"> 441   assert_lock_strong(MetaspaceExpand_lock);</span>
 442 
<a name="50" id="anc50"></a><span class="changed"> 443   if (!_owns_rs) {</span>
<span class="changed"> 444     // We do not allow purging of nodes if we do not own the</span>
<span class="changed"> 445     // underlying ReservedSpace (CompressClassSpace case).</span>
<span class="changed"> 446     return false;</span>
<span class="changed"> 447   }</span>
 448 
<a name="51" id="anc51"></a><span class="changed"> 449   // First find out if all areas are empty. Since empty chunks collapse to root chunk</span>
<span class="changed"> 450   // size, if all chunks in this node are free root chunks we are good to go.</span>
<span class="changed"> 451   if (!_root_chunk_area_lut.is_free()) {</span>
<span class="changed"> 452     return false;</span>
<span class="changed"> 453   }</span>
 454 
<a name="52" id="anc52"></a><span class="changed"> 455   UL(debug, ": purging.");</span>
<span class="changed"> 456 </span>
<span class="changed"> 457   // Okay, we can purge. Before we can do this, we need to remove all chunks from the freelist.</span>
<span class="changed"> 458   for (int narea = 0; narea &lt; _root_chunk_area_lut.number_of_areas(); narea ++) {</span>
<span class="changed"> 459     RootChunkArea* ra = _root_chunk_area_lut.get_area_by_index(narea);</span>
<span class="changed"> 460     Metachunk* c = ra-&gt;first_chunk();</span>
<span class="changed"> 461     if (c != NULL) {</span>
<span class="changed"> 462       UL2(trace, "removing chunk from to-be-purged node: "</span>
<span class="changed"> 463           METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));</span>
<span class="changed"> 464       assert(c-&gt;is_free() &amp;&amp; c-&gt;is_root_chunk(), "Sanity");</span>
<span class="changed"> 465       freelists-&gt;remove(c);</span>
<span class="changed"> 466     }</span>
 467   }
 468 
<a name="53" id="anc53"></a><span class="changed"> 469   // Now, delete the node, then right away return since this object is invalid.</span>
<span class="changed"> 470   delete this;</span>
<span class="changed"> 471 </span>
<span class="changed"> 472   return true;</span>
 473 
<a name="54" id="anc54"></a>
 474 }
 475 
<a name="55" id="anc55"></a>




 476 
<a name="56" id="anc56"></a><span class="changed"> 477 void VirtualSpaceNode::print_on(outputStream* st) const {</span>
<span class="changed"> 478 </span>
<span class="changed"> 479   size_t scale = K;</span>
<span class="changed"> 480 </span>
<span class="changed"> 481   st-&gt;print("base " PTR_FORMAT ": ", p2i(base()));</span>
 482   st-&gt;print("reserved=");
<a name="57" id="anc57"></a><span class="changed"> 483   print_scaled_words(st, word_size(), scale);</span>
 484   st-&gt;print(", committed=");
<a name="58" id="anc58"></a><span class="changed"> 485   print_scaled_words_and_percentage(st, committed_words(), word_size(), scale);</span>
 486   st-&gt;print(", used=");
<a name="59" id="anc59"></a><span class="changed"> 487   print_scaled_words_and_percentage(st, used_words(), word_size(), scale);</span>
<span class="changed"> 488 </span>
 489   st-&gt;cr();
<a name="60" id="anc60"></a><span class="changed"> 490   _root_chunk_area_lut.print_on(st);</span>
<span class="changed"> 491   _commit_mask.print_on(st);</span>
<span class="changed"> 492 </span>

 493 }
 494 
<a name="61" id="anc61"></a><span class="changed"> 495 // Returns size, in words, of committed space in this node alone.</span>
<span class="changed"> 496 // Note: iterates over commit mask and hence may be a tad expensive on large nodes.</span>
<span class="changed"> 497 size_t VirtualSpaceNode::committed_words() const {</span>
<span class="changed"> 498   return _commit_mask.get_committed_size();</span>
 499 }
<a name="62" id="anc62"></a>
 500 
<a name="63" id="anc63"></a>

 501 #ifdef ASSERT
<a name="64" id="anc64"></a><span class="changed"> 502 void VirtualSpaceNode::verify(bool slow) const {</span>
<span class="changed"> 503   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 504   verify_locked(slow);</span>





















 505 }
<a name="65" id="anc65"></a><span class="new"> 506 </span>
<span class="new"> 507 // Verify counters and basic structure. Slow mode: verify all chunks in depth</span>
<span class="new"> 508 void VirtualSpaceNode::verify_locked(bool slow) const {</span>
<span class="new"> 509 </span>
<span class="new"> 510   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new"> 511 </span>
<span class="new"> 512   assert(base() != NULL, "Invalid base");</span>
<span class="new"> 513   assert(base() == (MetaWord*)_rs.base() &amp;&amp;</span>
<span class="new"> 514          word_size() == _rs.size() / BytesPerWord,</span>
<span class="new"> 515          "Sanity");</span>
<span class="new"> 516   assert_is_aligned(base(), chunklevel::MAX_CHUNK_BYTE_SIZE);</span>
<span class="new"> 517   assert(used_words() &lt;= word_size(), "Sanity");</span>
<span class="new"> 518 </span>
<span class="new"> 519   // Since we only ever hand out root chunks from a vsnode, top should always be aligned</span>
<span class="new"> 520   // to root chunk size.</span>
<span class="new"> 521   assert_is_aligned(used_words(), chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="new"> 522 </span>
<span class="new"> 523   _commit_mask.verify(slow);</span>
<span class="new"> 524   assert(committed_words() &lt;= word_size(), "Sanity");</span>
<span class="new"> 525   assert_is_aligned(committed_words(), Settings::commit_granule_words());</span>
<span class="new"> 526   _root_chunk_area_lut.verify(slow);</span>
<span class="new"> 527 </span>
<span class="new"> 528 }</span>
<span class="new"> 529 </span>
<span class="new"> 530 #endif</span>
<span class="new"> 531 </span>
 532 
 533 } // namespace metaspace
<a name="66" id="anc66"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="66" type="hidden" /></form></body></html>
