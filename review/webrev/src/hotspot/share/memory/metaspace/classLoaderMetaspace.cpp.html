<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/classLoaderMetaspace.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspaceTracer.hpp"
  31 #include "memory/metaspace/chunkManager.hpp"
  32 #include "memory/metaspace/classLoaderMetaspace.hpp"
  33 #include "memory/metaspace/internStat.hpp"
  34 #include "memory/metaspace/metaspaceArena.hpp"
  35 #include "memory/metaspace/metaspaceEnums.hpp"
  36 #include "memory/metaspace/metaspaceStatistics.hpp"
  37 #include "memory/metaspace/runningCounters.hpp"
  38 #include "memory/metaspace/settings.hpp"
  39 #include "runtime/atomic.hpp"
  40 #include "utilities/debug.hpp"
  41 
  42 namespace metaspace {
  43 
  44 #define LOGFMT         "CLMS @" PTR_FORMAT " "
  45 #define LOGFMT_ARGS    p2i(this)
  46 
  47 static bool use_class_space(bool is_class) {
  48   if (Metaspace::using_class_space() &amp;&amp; is_class) {
  49     return true;
  50   }
  51   return false;
  52 }
  53 
  54 static bool use_class_space(Metaspace::MetadataType mdType) {
  55   return use_class_space(is_class(mdType));
  56 }
  57 
  58 ClassLoaderMetaspace::ClassLoaderMetaspace(Mutex* lock, MetaspaceType space_type)
  59   : _lock(lock)
  60   , _space_type(space_type)
  61   , _non_class_space_arena(NULL)
  62   , _class_space_arena(NULL)
  63 {
  64   ChunkManager* const non_class_cm =
  65           ChunkManager::chunkmanager_nonclass();
  66 
  67   // Initialize non-class Arena
  68   _non_class_space_arena = new MetaspaceArena(
  69       non_class_cm,
  70       ArenaGrowthPolicy::policy_for_space_type(space_type, false),
  71       lock,
  72       RunningCounters::used_nonclass_counter(),
  73       "non-class sm",
  74       is_micro());
  75 
  76   // If needed, initialize class arena
  77   if (Metaspace::using_class_space()) {
  78     ChunkManager* const class_cm =
  79             ChunkManager::chunkmanager_class();
  80     _class_space_arena = new MetaspaceArena(
  81         class_cm,
  82         ArenaGrowthPolicy::policy_for_space_type(space_type, true),
  83         lock,
  84         RunningCounters::used_class_counter(),
  85         "class sm",
  86         is_micro());
  87   }
  88 
  89   UL2(debug, "born (SpcMgr nonclass: " PTR_FORMAT ", SpcMgr class: " PTR_FORMAT ".",
  90       p2i(_non_class_space_arena), p2i(_class_space_arena));
  91 }
  92 
  93 ClassLoaderMetaspace::~ClassLoaderMetaspace() {
  94   Metaspace::assert_not_frozen();
  95 
  96   UL(debug, "dies.");
  97 
  98   delete _non_class_space_arena;
  99   delete _class_space_arena;
 100 
 101 }
 102 
 103 // Allocate word_size words from Metaspace.
 104 MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdType) {
 105   Metaspace::assert_not_frozen();
 106   if (use_class_space(mdType)) {
 107     return class_space_arena()-&gt;allocate(word_size);
 108   } else {
 109     return non_class_space_arena()-&gt;allocate(word_size);
 110   }
 111 }
 112 
 113 // Attempt to expand the GC threshold to be good for at least another word_size words
 114 // and allocate. Returns NULL if failure. Used during Metaspace GC.
 115 MetaWord* ClassLoaderMetaspace::expand_and_allocate(size_t word_size, Metaspace::MetadataType mdType) {
 116   Metaspace::assert_not_frozen();
 117   size_t delta_bytes = MetaspaceGC::delta_capacity_until_GC(word_size * BytesPerWord);
 118   assert(delta_bytes &gt; 0, "Must be");
 119 
 120   size_t before = 0;
 121   size_t after = 0;
 122   bool can_retry = true;
 123   MetaWord* res;
 124   bool incremented;
 125 
 126   // Each thread increments the HWM at most once. Even if the thread fails to increment
 127   // the HWM, an allocation is still attempted. This is because another thread must then
 128   // have incremented the HWM and therefore the allocation might still succeed.
 129   do {
 130     incremented = MetaspaceGC::inc_capacity_until_GC(delta_bytes, &amp;after, &amp;before, &amp;can_retry);
 131     res = allocate(word_size, mdType);
 132   } while (!incremented &amp;&amp; res == NULL &amp;&amp; can_retry);
 133 
 134   if (incremented) {
 135     Metaspace::tracer()-&gt;report_gc_threshold(before, after,
 136                                   MetaspaceGCThresholdUpdater::ExpandAndAllocate);
 137     // Keeping both for now until I am sure the old variant (gc + metaspace) is not needed anymore
 138     log_trace(gc, metaspace)("Increase capacity to GC from " SIZE_FORMAT " to " SIZE_FORMAT, before, after);
 139     UL2(info, "GC threshold increased: " SIZE_FORMAT "-&gt;" SIZE_FORMAT ".", before, after);
 140   }
 141 
 142   return res;
 143 }
 144 
 145 // Prematurely returns a metaspace allocation to the _block_freelists
 146 // because it is not needed anymore.
 147 void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {
 148 
 149   Metaspace::assert_not_frozen();
 150 
 151   if (use_class_space(is_class)) {
 152     class_space_arena()-&gt;deallocate(ptr, word_size);
 153   } else {
 154     non_class_space_arena()-&gt;deallocate(ptr, word_size);
 155   }
 156 
 157   DEBUG_ONLY(InternalStats::inc_num_deallocs();)
 158 
 159 }
 160 
 161 // Update statistics. This walks all in-use chunks.
 162 void ClassLoaderMetaspace::add_to_statistics(clms_stats_t* out) const {
 163   if (non_class_space_arena() != NULL) {
 164     non_class_space_arena()-&gt;add_to_statistics(&amp;out-&gt;arena_stats_nonclass);
 165   }
 166   if (class_space_arena() != NULL) {
 167     class_space_arena()-&gt;add_to_statistics(&amp;out-&gt;arena_stats_class);
 168   }
 169 }
 170 
 171 #ifdef ASSERT
 172 void ClassLoaderMetaspace::verify() const {
 173   check_valid_spacetype(_space_type);
 174   if (non_class_space_arena() != NULL) {
 175     non_class_space_arena()-&gt;verify(false);
 176   }
 177   if (class_space_arena() != NULL) {
 178     class_space_arena()-&gt;verify(false);
 179   }
 180 }
 181 #endif // ASSERT
 182 
 183 
 184 // This only exists for JFR and jcmd VM.classloader_stats. We may want to
 185 //  change this. Capacity as a stat is of questionable use since it may
 186 //  contain committed and uncommitted areas. For now we do this to maintain
 187 //  backward compatibility with JFR.
 188 void ClassLoaderMetaspace::calculate_jfr_stats(size_t* p_used_bytes, size_t* p_capacity_bytes) const {
 189   // Implement this using the standard statistics objects.
 190   size_t used_c = 0, cap_c = 0, used_nc = 0, cap_nc = 0;
 191   if (non_class_space_arena() != NULL) {
 192     non_class_space_arena()-&gt;usage_numbers(&amp;used_nc, NULL, &amp;cap_nc);
 193   }
 194   if (class_space_arena() != NULL) {
 195     class_space_arena()-&gt;usage_numbers(&amp;used_c, NULL, &amp;cap_c);
 196   }
 197   if (p_used_bytes != NULL) {
 198     *p_used_bytes = used_c + used_nc;
 199   }
 200   if (p_capacity_bytes != NULL) {
 201     *p_capacity_bytes = cap_c + cap_nc;
 202   }
 203 }
 204 
 205 
 206 } // end namespace metaspace
 207 
 208 
 209 
 210 
</pre></body></html>
