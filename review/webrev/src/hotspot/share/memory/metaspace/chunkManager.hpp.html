<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  27 #define SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "memory/metaspace/freeChunkList.hpp"
  33 #include "memory/metaspace/metachunk.hpp"
  34 
  35 namespace metaspace {
  36 
  37 class VirtualSpaceList;
  38 struct cm_stats_t;
  39 
  40 // ChunkManager has a central role.
  41 
  42 // Arenas request chunks from it. It keeps the freelists for chunks.
  43 // If the freelist is exhausted it allocates new chunks from a connected
  44 // VirtualSpaceList.
  45 //
  46 class ChunkManager : public CHeapObj&lt;mtMetaspace&gt; {
  47 
  48   // A chunk manager is connected to a virtual space list which is used
  49   // to allocate new root chunks when no free chunks are found.
  50   VirtualSpaceList* const _vslist;
  51 
  52   // Name
  53   const char* const _name;
  54 
  55   // Freelists
  56   FreeChunkListVector _chunks;
  57 
  58   // Returns true if this manager contains the given chunk. Slow (walks free lists) and
  59   // only needed for verifications.
  60   DEBUG_ONLY(bool contains_chunk(Metachunk* c) const;)
  61 
  62   // Given a chunk, split it into a target chunk of a smaller size (target level)
  63   //  at least one, possible more splinter chunks. Splinter chunks are added to the
  64   //  freelist.
  65   // The original chunk must be outside of the freelist and its state must be free.
  66   // The resulting target chunk will be located at the same address as the original
  67   //  chunk, but it will of course be smaller (of a higher level).
  68   // The committed areas within the original chunk carry over to the resulting
  69   //  chunks.
  70   void split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level);
  71 
  72   // See get_chunk(s,s,s)
  73   Metachunk* get_chunk_locked(size_t preferred_word_size, size_t min_word_size, size_t min_committed_words);
  74 
  75   // Uncommit all chunks equal or below the given level.
  76   void uncommit_free_chunks(chunklevel_t max_level);
  77 
  78 public:
  79 
  80   // Creates a chunk manager with a given name (which is for debug purposes only)
  81   // and an associated space list which will be used to request new chunks from
  82   // (see get_chunk())
  83   ChunkManager(const char* name, VirtualSpaceList* space_list);
  84 
  85   // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
  86   //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
  87   // On error, will return NULL.
  88   //
  89   // This function may fail for two reasons:
  90   // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
  91   //   is non-expandable but needs expanding - aka out of compressed class space).
  92   // - Or, if the necessary space cannot be committed because we hit a commit limit.
  93   //   This may be either the GC threshold or MaxMetaspaceSize.
  94   Metachunk* get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words);
  95 
  96   // Convenience function - get a chunk of a given level, uncommitted.
  97   Metachunk* get_chunk(chunklevel_t lvl) { return get_chunk(lvl, lvl, 0); }
  98 
  99   // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 100   //  with neighbors.
 101   // Happens after a Classloader was unloaded and releases its metaspace chunks.
 102   // !! Notes:
 103   //    1) After this method returns, c may not be valid anymore. ** Do not access c after this function returns **.
 104   //    2) This function will not remove c from its current chunk list. This has to be done by the caller prior to
 105   //       calling this method.
 106   void return_chunk(Metachunk* c);
 107 
 108   // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
 109   void return_chunk_simple(Metachunk* c);
 110 
 111   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
 112   // enlarge it in place by claiming its trailing buddy.
 113   //
 114   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 115   //
 116   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 117   // double in size (level decreased by one).
 118   //
 119   // On success, true is returned, false otherwise.
 120   bool attempt_enlarge_chunk(Metachunk* c);
 121 
 122   // Attempt to reclaim free areas in metaspace wholesale:
 123   // - first, attempt to purge nodes of the backing virtual space list: nodes which are completely
 124   //   unused get unmapped and deleted completely.
 125   // - second, it will uncommit free chunks depending on commit granule size.
 126   void purge();
 127 
 128   // Run verifications. slow=true: verify chunk-internal integrity too.
 129   DEBUG_ONLY(void verify(bool slow) const;)
 130   DEBUG_ONLY(void verify_locked(bool slow) const;)
 131 
 132   // Returns the name of this chunk manager.
 133   const char* name() const                  { return _name; }
 134 
 135   // Returns total number of chunks
 136   int total_num_chunks() const              { return _chunks.num_chunks(); }
 137 
 138   // Returns number of words in all free chunks (regardless of commit state).
 139   size_t total_word_size() const            { return _chunks.word_size(); }
 140 
 141   // Returns number of committed words in all free chunks.
 142   size_t total_committed_word_size() const  { return _chunks.committed_word_size(); }
 143 
 144   // Update statistics.
 145   void add_to_statistics(cm_stats_t* out) const;
 146 
 147   void print_on(outputStream* st) const;
 148   void print_on_locked(outputStream* st) const;
 149 
 150 public:
 151 
 152   // Convenience methods to return the global class-space chunkmanager
 153   //  and non-class chunkmanager, respectively.
 154   static ChunkManager* chunkmanager_class();
 155   static ChunkManager* chunkmanager_nonclass();
 156 
 157 
 158 };
 159 
 160 } // namespace metaspace
 161 
 162 #endif // SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
</pre></body></html>
