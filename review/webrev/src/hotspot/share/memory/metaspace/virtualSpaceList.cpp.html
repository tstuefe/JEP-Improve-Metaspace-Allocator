<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 
  27 #include "precompiled.hpp"
  28 #include "logging/log.hpp"
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "memory/metaspace/commitLimiter.hpp"
  33 #include "memory/metaspace/counter.hpp"
  34 #include "memory/metaspace/freeChunkList.hpp"
  35 #include "memory/metaspace/metaspaceContext.hpp"
  36 #include "memory/metaspace/virtualSpaceList.hpp"
  37 #include "memory/metaspace/virtualSpaceNode.hpp"
  38 #include "runtime/mutexLocker.hpp"
  39 
  40 
  41 namespace metaspace {
  42 
  43 #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"
  44 #define LOGFMT_ARGS    p2i(this), this-&gt;_name
  45 
  46 // Create a new, empty, expandable list.
  47 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)
  48   : _name(name),
  49     _first_node(NULL),
  50     _can_expand(true),
  51     _can_purge(true),
  52     _commit_limiter(commit_limiter),
  53     _reserved_words_counter(),
  54     _committed_words_counter()
  55 {
  56 }
  57 
  58 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.
  59 // It will be not expandable beyond that first node.
  60 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)
  61 : _name(name),
  62   _first_node(NULL),
  63   _can_expand(false),
  64   _can_purge(false),
  65   _commit_limiter(commit_limiter),
  66   _reserved_words_counter(),
  67   _committed_words_counter()
  68 {
  69   // Create the first node spanning the existing ReservedSpace. This will be the only node created
  70   // for this list since we cannot expand.
  71   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(rs, _commit_limiter,
  72                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);
  73   assert(vsn != NULL, "node creation failed");
  74   _first_node = vsn;
  75   _first_node-&gt;set_next(NULL);
  76   _nodes_counter.increment();
  77 }
  78 
  79 VirtualSpaceList::~VirtualSpaceList() {
  80   assert_lock_strong(MetaspaceExpand_lock);
  81   // Note: normally, there is no reason ever to delete a vslist since they are
  82   // global objects, but for gtests it makes sense to allow this.
  83   VirtualSpaceNode* vsn = _first_node;
  84   VirtualSpaceNode* vsn2 = vsn;
  85   while (vsn != NULL) {
  86     vsn2 = vsn-&gt;next();
  87     delete vsn;
  88     vsn = vsn2;
  89   }
  90 }
  91 
  92 // Create a new node and append it to the list. After
  93 // this function, _current_node shall point to a new empty node.
  94 // List must be expandable for this to work.
  95 void VirtualSpaceList::create_new_node() {
  96   assert(_can_expand, "List is not expandable");
  97   assert_lock_strong(MetaspaceExpand_lock);
  98 
  99   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(Settings::virtual_space_node_default_word_size(),
 100                                                         _commit_limiter,
 101                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);
 102   assert(vsn != NULL, "node creation failed");
 103   vsn-&gt;set_next(_first_node);
 104   _first_node = vsn;
 105   _nodes_counter.increment();
 106 }
 107 
 108 // Allocate a root chunk from this list.
 109 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.
 110 // Hence, before using this chunk, it must be committed.
 111 // Also, no limits are checked, since no committing takes place.
 112 Metachunk*  VirtualSpaceList::allocate_root_chunk() {
 113   assert_lock_strong(MetaspaceExpand_lock);
 114 
 115   if (_first_node == NULL ||
 116       _first_node-&gt;free_words() == 0) {
 117 
 118     // Since all allocations from a VirtualSpaceNode happen in
 119     // root-chunk-size units, and the node size must be root-chunk-size aligned,
 120     // we should never have left-over space.
 121     assert(_first_node == NULL ||
 122            _first_node-&gt;free_words() == 0, "Sanity");
 123 
 124     if (_can_expand) {
 125       create_new_node();
 126       UL2(debug, "added new node (now: %d).", num_nodes());
 127     } else {
 128       UL(debug, "list cannot expand.");
 129       return NULL; // We cannot expand this list.
 130     }
 131   }
 132 
 133   Metachunk* c = _first_node-&gt;allocate_root_chunk();
 134 
 135   assert(c != NULL, "This should have worked");
 136 
 137   return c;
 138 
 139 }
 140 
 141 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.
 142 // The free chunks are removed from the freelists before the nodes are deleted.
 143 // Return number of purged nodes.
 144 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {
 145 
 146   assert_lock_strong(MetaspaceExpand_lock);
 147 
 148   if (_can_purge == false) {
 149     return 0;
 150   }
 151 
 152   UL(debug, "purging.");
 153 
 154   VirtualSpaceNode* vsn = _first_node;
 155   VirtualSpaceNode* prev_vsn = NULL;
 156   int num = 0, num_purged = 0;
 157   while (vsn != NULL) {
 158     VirtualSpaceNode* next_vsn = vsn-&gt;next();
 159     bool purged = vsn-&gt;attempt_purge(freelists);
 160     if (purged) {
 161       // Note: from now on do not dereference vsn!
 162       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));
 163       if (_first_node == vsn) {
 164         _first_node = next_vsn;
 165       }
 166       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)
 167       if (prev_vsn != NULL) {
 168         prev_vsn-&gt;set_next(next_vsn);
 169       }
 170       num_purged ++;
 171       _nodes_counter.decrement();
 172     } else {
 173       prev_vsn = vsn;
 174     }
 175     vsn = next_vsn;
 176     num ++;
 177   }
 178 
 179   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());
 180 
 181   return num_purged;
 182 
 183 }
 184 
 185 // Print all nodes in this space list.
 186 void VirtualSpaceList::print_on(outputStream* st) const {
 187   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 188 
 189   st-&gt;print_cr("vsl %s:", _name);
 190   const VirtualSpaceNode* vsn = _first_node;
 191   int n = 0;
 192   while (vsn != NULL) {
 193     st-&gt;print("- node #%d: ", n);
 194     vsn-&gt;print_on(st);
 195     vsn = vsn-&gt;next();
 196     n ++;
 197   }
 198   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",
 199                n, reserved_words(), committed_words());
 200 }
 201 
 202 #ifdef ASSERT
 203 void VirtualSpaceList::verify_locked(bool slow) const {
 204 
 205   assert_lock_strong(MetaspaceExpand_lock);
 206 
 207   assert(_name != NULL, "Sanity");
 208 
 209   int n = 0;
 210 
 211   if (_first_node != NULL) {
 212 
 213     size_t total_reserved_words = 0;
 214     size_t total_committed_words = 0;
 215     const VirtualSpaceNode* vsn = _first_node;
 216     while (vsn != NULL) {
 217       n ++;
 218       vsn-&gt;verify_locked(slow);
 219       total_reserved_words += vsn-&gt;word_size();
 220       total_committed_words += vsn-&gt;committed_words();
 221       vsn = vsn-&gt;next();
 222     }
 223 
 224     _nodes_counter.check(n);
 225     _reserved_words_counter.check(total_reserved_words);
 226     _committed_words_counter.check(total_committed_words);
 227 
 228   } else {
 229 
 230     _reserved_words_counter.check(0);
 231     _committed_words_counter.check(0);
 232 
 233   }
 234 }
 235 
 236 void VirtualSpaceList::verify(bool slow) const {
 237   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 238   verify_locked(slow);
 239 }
 240 #endif
 241 
 242 // Returns true if this pointer is contained in one of our nodes.
 243 bool VirtualSpaceList::contains(const MetaWord* p) const {
 244   const VirtualSpaceNode* vsn = _first_node;
 245   while (vsn != NULL) {
 246     if (vsn-&gt;contains(p)) {
 247       return true;
 248     }
 249     vsn = vsn-&gt;next();
 250   }
 251   return false;
 252 }
 253 
 254 // Returns true if the vslist is not expandable and no more root chunks
 255 // can be allocated.
 256 bool VirtualSpaceList::is_full() const {
 257   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {
 258     return true;
 259   }
 260   return false;
 261 }
 262 
 263 // Convenience methods to return the global class-space chunkmanager
 264 //  and non-class chunkmanager, respectively.
 265 VirtualSpaceList* VirtualSpaceList::vslist_class() {
 266   return MetaspaceContext::contect_class() == NULL ? NULL : MetaspaceContext::contect_class()-&gt;vslist();
 267 }
 268 
 269 VirtualSpaceList* VirtualSpaceList::vslist_nonclass() {
 270   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;vslist();
 271 }
 272 
 273 
 274 
 275 } // namespace metaspace
</pre></body></html>
