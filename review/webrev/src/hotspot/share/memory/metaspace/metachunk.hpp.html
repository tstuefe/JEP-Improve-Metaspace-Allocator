<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metachunk.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  26 #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  27 
  28 
  29 #include "memory/metaspace/counter.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "utilities/debug.hpp"
  32 #include "utilities/globalDefinitions.hpp"
  33 
  34 
  35 class outputStream;
  36 
  37 namespace metaspace {
  38 
  39 class VirtualSpaceNode;
  40 
  41 // A Metachunk is a contiguous metaspace memory region. It is part of
  42 // a MetaspaceArena, which keeps a list of MetaChunk and allocates via
  43 // pointer bump from the top element in the list.
  44 //
  45 // The Metachunk object itself (the "chunk header") is separated from
  46 //  the memory region (the chunk payload) it describes. It also can have
  47 //  no payload (a "dead" chunk). In itself it lives in C-heap, managed
  48 //  as part of a pool of Metachunk headers (ChunkHeaderPool).
  49 //
  50 // -- Metachunk state --
  51 //
  52 // A Metachunk is "in-use" if it is part of a MetaspaceArena. That means
  53 //  its memory is used - or will be used shortly - to hold VM metadata
  54 //  on behalf of a class loader.
  55 //
  56 // A Metachunk is "free" if its payload is currently unused. In that
  57 //  case it is managed by a chunk freelist (the ChunkManager).
  58 // 
  59 // A Metachunk is "dead" if it does not have a corresponding payload.
  60 //  In that case it lives as part of a freelist-of-dead-chunk-headers
  61 //  in the ChunkHeaderPool.
  62 //
  63 // -- Level --
  64 //
  65 // Metachunks are managed as part of a buddy style allocation scheme.
  66 // Its sizes are always power-2, ranging from the smallest chunk size
  67 // (1Kb) to the largest (4Mb) (see chunklevel.hpp).
  68 // Its size is encoded as level, with level 0 being the largest chunk
  69 // size ("root chunk").
  70 //
  71 // -- Payload commit state --
  72 //
  73 // A Metachunk payload may be committed, partly committed or completely
  74 // uncommitted. Technically, a payload may be committed "checkered" -
  75 // i.e. committed and uncommitted parts may interleave - but the
  76 // important part is how much contiguous space is committed starting
  77 // at the base of the payload (since that's where we allocate). 
  78 // 
  79 // The Metachunk keeps track of how much space is committed starting
  80 //  at the base of the payload - which is a performace optimization - 
  81 //  while underlying layers (VirtualSpaceNode-&gt;commitmask) keep track
  82 //  of the "real" commit state, aka which granules are committed,
  83 //  independent on what chunks reside above those granules.
  84 
  85 
  86 //            +--------------+ &lt;- end    -----------+ ----------+
  87 //            |              |                      |           |
  88 //            |              |                      |           |
  89 //            |              |                      |           |
  90 //            |              |                      |           |
  91 //            |              |                      |           |
  92 //            | -----------  | &lt;- committed_top  -- +           |
  93 //            |              |                      |           |
  94 //            |              |                      | "free"    |
  95 //            |              |                      |           | size 
  96 //            |              |     "free_below_     |           |
  97 //            |              |        committed"    |           |
  98 //            |              |                      |           |
  99 //            |              |                      |           |
 100 //            | -----------  | &lt;- top     --------- + --------  |
 101 //            |              |                      |           |
 102 //            |              |     "used"           |           |
 103 //            |              |                      |           |
 104 //            +--------------+ &lt;- start   ----------+ ----------+
 105 
 106 // Note: this is a chunk **descriptor**. The real Payload area lives in metaspace,
 107 // this class lives somewhere else.
 108 class Metachunk {
 109 
 110   // start of chunk memory; NULL if dead.
 111   MetaWord* _base;
 112 
 113   // Used words.
 114   size_t _used_words;
 115 
 116   // Size of the region, starting from base, which is guaranteed to be committed. In words.
 117   //  The actual size of committed regions may actually be larger.
 118   //
 119   //  (This is a performance optimization. The underlying VirtualSpaceNode knows
 120   //   which granules are committed; but we want to avoid having to ask.)
 121   size_t _committed_words;
 122 
 123   chunklevel_t _level; // aka size.
 124 
 125   // state_free:    free, owned by a ChunkManager
 126   // state_in_use:  in-use, owned by a MetaspaceArena
 127   // dead:          just a hollow chunk header without associated memory, owned
 128   //                 by chunk header pool.
 129   enum state_t {
 130     state_free = 0,
 131     state_in_use = 1,
 132     state_dead = 2
 133   };
 134   state_t _state;
 135 
 136   // We need unfortunately a back link to the virtual space node
 137   // for splitting and merging nodes.
 138   VirtualSpaceNode* _vsnode;
 139 
 140 
 141   // A chunk header is kept in a list:
 142   // 1 in the list of used chunks inside a MetaspaceArena, if it is in use
 143   // 2 in the list of free chunks inside a ChunkManager, if it is free
 144   // 3 in the freelist of unused headers inside the ChunkHeaderPool,
 145   //   if it is unused (e.g. result of chunk merging) and has no associated
 146   //   memory area.
 147   Metachunk* _prev;
 148   Metachunk* _next;
 149 
 150   // Furthermore, we keep, per chunk, information about the neighboring chunks.
 151   // This is needed to split and merge chunks.
 152   //
 153   // Note: These members can be modified concurrently while a chunk is alive and in use.
 154   // This can happen if a neighboring chunk is added or removed.
 155   // This means only read or modify these members under expand lock protection.
 156   Metachunk* _prev_in_vs;
 157   Metachunk* _next_in_vs;
 158 
 159   // Commit uncommitted section of the chunk.
 160   // Fails if we hit a commit limit.
 161   bool commit_up_to(size_t new_committed_words);
 162 
 163   DEBUG_ONLY(static void assert_have_expand_lock();)
 164 
 165 public:
 166 
 167   Metachunk()
 168     : _base(NULL),
 169       _used_words(0),
 170       _committed_words(0),
 171       _level(chunklevel::ROOT_CHUNK_LEVEL),
 172       _state(state_free),
 173       _vsnode(NULL),
 174       _prev(NULL), _next(NULL),
 175       _prev_in_vs(NULL), _next_in_vs(NULL)
 176   {}
 177 
 178  void clear() {
 179    _base = NULL;
 180    _used_words = 0;
 181    _committed_words = 0;
 182    _level = chunklevel::ROOT_CHUNK_LEVEL;
 183    _state = state_free;
 184    _vsnode = NULL;
 185    _prev = NULL;
 186    _next = NULL;
 187    _prev_in_vs = NULL;
 188    _next_in_vs = NULL;
 189   }
 190 
 191 
 192   size_t word_size() const        { return chunklevel::word_size_for_level(_level); }
 193 
 194   MetaWord* base() const          { return _base; }
 195   MetaWord* top() const           { return base() + _used_words; }
 196   MetaWord* committed_top() const { return base() + _committed_words; }
 197   MetaWord* end() const           { return base() + word_size(); }
 198 
 199   // Chunk list wiring
 200   void set_prev(Metachunk* c)     { _prev = c; }
 201   Metachunk* prev() const         { return _prev; }
 202   void set_next(Metachunk* c)     { _next = c; }
 203   Metachunk* next() const         { return _next; }
 204 
 205   DEBUG_ONLY(bool in_list() const { return _prev != NULL || _next != NULL; })
 206 
 207   // Physical neighbors wiring
 208   void set_prev_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _prev_in_vs = c; }
 209   Metachunk* prev_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _prev_in_vs; }
 210   void set_next_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _next_in_vs = c; }
 211   Metachunk* next_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _next_in_vs; }
 212 
 213   bool is_free() const            { return _state == state_free; }
 214   bool is_in_use() const          { return _state == state_in_use; }
 215   bool is_dead() const            { return _state == state_dead; }
 216   void set_free()                 { _state = state_free; }
 217   void set_in_use()               { _state = state_in_use; }
 218   void set_dead()                 { _state = state_dead; }
 219 
 220   // Return a single char presentation of the state ('f', 'u', 'd')
 221   char get_state_char() const;
 222 
 223   void inc_level()                { _level ++; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }
 224   void dec_level()                { _level --; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }
 225   chunklevel_t level() const          { return _level; }
 226 
 227   // Convenience functions for extreme levels.
 228   bool is_root_chunk() const      { return chunklevel::ROOT_CHUNK_LEVEL == _level; }
 229   bool is_leaf_chunk() const      { return chunklevel::HIGHEST_CHUNK_LEVEL == _level; }
 230 
 231   VirtualSpaceNode* vsnode() const        { return _vsnode; }
 232 
 233   size_t used_words() const                   { return _used_words; }
 234   size_t free_words() const                   { return word_size() - used_words(); }
 235   size_t free_below_committed_words() const   { return committed_words() - used_words(); }
 236   void reset_used_words()                     { _used_words = 0; }
 237 
 238   size_t committed_words() const      { return _committed_words; }
 239   void set_committed_words(size_t v);
 240   bool is_fully_committed() const     { return committed_words() == word_size(); }
 241   bool is_fully_uncommitted() const   { return committed_words() == 0; }
 242 
 243   // Ensure that chunk is committed up to at least new_committed_words words.
 244   // Fails if we hit a commit limit.
 245   bool ensure_committed(size_t new_committed_words);
 246   bool ensure_committed_locked(size_t new_committed_words);
 247 
 248   bool ensure_fully_committed()           { return ensure_committed(word_size()); }
 249   bool ensure_fully_committed_locked()    { return ensure_committed_locked(word_size()); }
 250 
 251   // Ensure that the chunk is committed far enough to serve an additional allocation of word_size.
 252   bool ensure_committed_additional(size_t additional_word_size)   {
 253     return ensure_committed(used_words() + additional_word_size);
 254   }
 255 
 256   // Uncommit chunk area. The area must be a common multiple of the
 257   // commit granule size (in other words, we cannot uncommit chunks smaller than
 258   // a commit granule size).
 259   void uncommit();
 260   void uncommit_locked();
 261 
 262   // Allocation from a chunk
 263 
 264   // Allocate word_size words from this chunk (word_size must be aligned to
 265   //  allocation_alignment_words).
 266   //
 267   // Caller must make sure the chunk is both large enough and committed far enough
 268   // to hold the allocation. Will always work.
 269   //
 270   MetaWord* allocate(size_t request_word_size);
 271 
 272   // Initialize structure for reuse.
 273   void initialize(VirtualSpaceNode* node, MetaWord* base, chunklevel_t lvl) {
 274     _vsnode = node; _base = base; _level = lvl;
 275     _used_words = _committed_words = 0; _state = state_free;
 276     _next = _prev = _next_in_vs = _prev_in_vs = NULL;
 277   }
 278 
 279   // Returns true if this chunk is the leader in its buddy pair, false if not.
 280   // Do not call for root chunks.
 281   bool is_leader() const {
 282     assert(!is_root_chunk(), "Root chunks have no buddy."); // Bit harsh?
 283     return is_aligned(base(), chunklevel::word_size_for_level(level() - 1) * BytesPerWord);
 284   }
 285 
 286   //// Debug stuff ////
 287 #ifdef ASSERT
 288   void verify(bool slow) const;
 289   // Verifies linking with neighbors in virtual space. Needs expand lock protection.
 290   void verify_neighborhood() const;
 291   void zap_header(uint8_t c = 0x17);
 292   void fill_with_pattern(MetaWord pattern, size_t word_size);
 293   void check_pattern(MetaWord pattern, size_t word_size);
 294 
 295   // Returns true if given pointer points into the payload area of this chunk.
 296   bool is_valid_pointer(const MetaWord* p) const {
 297     return base() &lt;= p &amp;&amp; p &lt; top();
 298   }
 299 
 300   // Returns true if given pointer points into the commmitted payload area of this chunk.
 301   bool is_valid_committed_pointer(const MetaWord* p) const {
 302     return base() &lt;= p &amp;&amp; p &lt; committed_top();
 303   }
 304 
 305 #endif // ASSERT
 306 
 307   void print_on(outputStream* st) const;
 308 
 309 };
 310 
 311 // Little print helpers: since we often print out chunks, here some convenience macros
 312 #define METACHUNK_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT
 313 #define METACHUNK_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level()
 314 
 315 #define METACHUNK_FULL_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT " (" SIZE_FORMAT "), used: " SIZE_FORMAT ", committed: " SIZE_FORMAT ", committed-free: " SIZE_FORMAT
 316 #define METACHUNK_FULL_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level(), chunk-&gt;word_size(), chunk-&gt;used_words(), chunk-&gt;committed_words(), chunk-&gt;free_below_committed_words()
 317 
 318 } // namespace metaspace
 319 
 320 #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
</pre></body></html>
