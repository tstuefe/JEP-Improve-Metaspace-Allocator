<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metaspaceArena.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "logging/logStream.hpp"
  29 #include "memory/metaspace/allocationGuard.hpp"
  30 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  31 #include "memory/metaspace/freeBlocks.hpp"
  32 #include "memory/metaspace/chunkManager.hpp"
  33 #include "memory/metaspace/internStat.hpp"
  34 #include "memory/metaspace/metachunk.hpp"
  35 #include "memory/metaspace/metaspaceArena.hpp"
  36 #include "memory/metaspace/metaspaceCommon.hpp"
  37 #include "memory/metaspace/metaspaceStatistics.hpp"
  38 #include "memory/metaspace/virtualSpaceList.hpp"
  39 #include "runtime/atomic.hpp"
  40 #include "runtime/init.hpp"
  41 #include "services/memoryService.hpp"
  42 #include "utilities/align.hpp"
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
  45 
  46 namespace metaspace {
  47 
  48 #define LOGFMT         "Arena @" PTR_FORMAT " (%s)"
  49 #define LOGFMT_ARGS    p2i(this), this-&gt;_name
  50 
  51 // Given a net allocation word size, return the raw word size we actually allocate.
  52 // Note: externally visible for gtests.
  53 //static
  54 size_t get_raw_allocation_word_size(size_t net_word_size) {
  55 
  56   size_t byte_size = net_word_size * BytesPerWord;
  57 
  58   // Deallocated metablocks are kept in a binlist which limits their minimal
  59   //  size to at least the size of a binlist item (2 words).
  60   byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);
  61 
  62   // Metaspace allocations are aligned to word size.
  63   byte_size = align_up(byte_size, allocation_alignment_bytes);
  64 
  65   // If we guard allocations, we need additional space for a prefix.
  66 #ifdef ASSERT
  67   if (Settings::use_allocation_guard()) {
  68     byte_size += align_up(prefix_size(), allocation_alignment_bytes);
  69   }
  70 #endif
  71 
  72   size_t word_size = byte_size / BytesPerWord;
  73 
  74   assert(word_size * BytesPerWord == byte_size, "Sanity");
  75 
  76   return word_size;
  77 
  78 }
  79 
  80 // Returns the level of the next chunk to be added, acc to growth policy.
  81 chunklevel_t MetaspaceArena::next_chunk_level() const {
  82   const int growth_step = _chunks.count();
  83   return _growth_policy-&gt;get_level_at_step(growth_step);
  84 }
  85 
  86 // Given a chunk, add its remaining free committed space to the free block list.
  87 void MetaspaceArena::salvage_chunk(Metachunk* c) {
  88 
  89   if (Settings::handle_deallocations() == false) {
  90     return;
  91   }
  92 
  93   assert_lock_strong(lock());
  94 
  95   // If the chunk is completely empty, just return it to the chunk manager.
  96   if (c-&gt;used_words() == 0) {
  97     UL2(trace, "salvage: returning empty chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
  98     _chunk_manager-&gt;return_chunk(c);
  99     return;
 100   }
 101 
 102   size_t remaining_words = c-&gt;free_below_committed_words();
 103 
 104   if (remaining_words &gt; FreeBlocks::minimal_word_size) {
 105 
 106     UL2(trace, "salvaging chunk " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));
 107 
 108     MetaWord* ptr = c-&gt;allocate(remaining_words);
 109     assert(ptr != NULL, "Should have worked");
 110     _total_used_words_counter-&gt;increment_by(remaining_words);
 111 
 112     add_allocation_to_fbl(ptr, remaining_words);
 113 
 114     // After this operation: the chunk should have no free committed space left.
 115     assert(c-&gt;free_below_committed_words() == 0,
 116            "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",
 117            METACHUNK_FULL_FORMAT_ARGS(c));
 118 
 119   }
 120 
 121 }
 122 
 123 // Allocate a new chunk from the underlying chunk manager able to hold at least
 124 // requested word size.
 125 Metachunk* MetaspaceArena::allocate_new_chunk(size_t requested_word_size) {
 126 
 127   assert_lock_strong(lock());
 128 
 129   // Should this ever happen, we need to increase the maximum possible chunk size.
 130   guarantee(requested_word_size &lt;= chunklevel::MAX_CHUNK_WORD_SIZE,
 131             "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",
 132             requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);
 133 
 134   const int growth_step = _chunks.count();
 135   const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);
 136   const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());
 137 
 138   Metachunk* c = _chunk_manager-&gt;get_chunk(preferred_level, max_level, requested_word_size);
 139   if (c == NULL) {
 140     return NULL;
 141   }
 142 
 143   assert(c-&gt;is_in_use(), "Wrong chunk state.");
 144   assert(c-&gt;free_below_committed_words() &gt;= requested_word_size, "Chunk not committed");
 145 
 146   return c;
 147 
 148 }
 149 
 150 void MetaspaceArena::add_allocation_to_fbl(MetaWord* p, size_t word_size) {
 151   assert(Settings::handle_deallocations(), "Sanity");
 152   if (_fbl == NULL) {
 153     _fbl = new FreeBlocks(); // Create only on demand
 154   }
 155   _fbl-&gt;add_block(p, word_size);
 156 }
 157 
 158 MetaspaceArena::MetaspaceArena(ChunkManager* chunk_manager,
 159              const ArenaGrowthPolicy* growth_policy,
 160              Mutex* lock,
 161              SizeAtomicCounter* total_used_words_counter,
 162              const char* name,
 163              bool is_micro_loader)
 164 : _lock(lock),
 165   _chunk_manager(chunk_manager),
 166   _growth_policy(growth_policy),
 167   _chunks(),
 168   _fbl(NULL),
 169   _total_used_words_counter(total_used_words_counter),
 170   _name(name),
 171   _is_micro_loader(is_micro_loader)
 172 {
 173   UL(debug, ": born.");
 174 
 175   // Update statistics
 176   InternalStats::inc_num_arena_births();
 177   if (is_micro_loader) {
 178     DEBUG_ONLY(InternalStats::inc_num_micro_arena_births();)
 179   }
 180 }
 181 
 182 MetaspaceArena::~MetaspaceArena() {
 183 
 184   DEBUG_ONLY(verify(true);)
 185 
 186   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);
 187 
 188   MemRangeCounter return_counter;
 189 
 190   Metachunk* c = _chunks.first();
 191   Metachunk* c2 = NULL;
 192 
 193   while(c) {
 194     c2 = c-&gt;next();
 195     return_counter.add(c-&gt;used_words());
 196     DEBUG_ONLY(c-&gt;set_prev(NULL);)
 197     DEBUG_ONLY(c-&gt;set_next(NULL);)
 198     UL2(debug, "return chunk: " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 199     _chunk_manager-&gt;return_chunk(c);
 200     // c may be invalid after return_chunk(c) was called. Don't access anymore.
 201     c = c2;
 202   }
 203 
 204   UL2(info, "returned %d chunks, total capacity " SIZE_FORMAT " words.",
 205       return_counter.count(), return_counter.total_size());
 206 
 207   _total_used_words_counter-&gt;decrement_by(return_counter.total_size());
 208 
 209   DEBUG_ONLY(chunk_manager()-&gt;verify(true);)
 210 
 211   delete _fbl;
 212 
 213   UL(debug, ": dies.");
 214 
 215   // Update statistics
 216   InternalStats::inc_num_arena_deaths();
 217   if (_is_micro_loader) {
 218     DEBUG_ONLY(InternalStats::inc_num_micro_arena_deaths();)
 219   }
 220 
 221 }
 222 
 223 // Attempt to enlarge the current chunk to make it large enough to hold at least
 224 //  requested_word_size additional words.
 225 //
 226 // On success, true is returned, false otherwise.
 227 bool MetaspaceArena::attempt_enlarge_current_chunk(size_t requested_word_size) {
 228 
 229   assert_lock_strong(lock());
 230 
 231   Metachunk* c = current_chunk();
 232   assert(c-&gt;free_words() &lt; requested_word_size, "Sanity");
 233 
 234   // Not if chunk enlargment is switched off...
 235   if (Settings::enlarge_chunks_in_place() == false) {
 236     return false;
 237   }
 238 
 239   // ... we also disallow it for very large chunks...
 240   if (c-&gt;word_size() &gt; Settings::enlarge_chunks_in_place_max_word_size()) {
 241     return false;
 242   }
 243 
 244   // ... nor if we are already a root chunk ...
 245   if (c-&gt;is_root_chunk()) {
 246     return false;
 247   }
 248 
 249   // ... nor if the combined size of chunk content and new content would bring us above the size of a root chunk ...
 250   if ((c-&gt;used_words() + requested_word_size) &gt; metaspace::chunklevel::MAX_CHUNK_WORD_SIZE) {
 251     return false;
 252   }
 253 
 254   const chunklevel_t new_level =
 255       chunklevel::level_fitting_word_size(c-&gt;used_words() + requested_word_size);
 256   assert(new_level &lt; c-&gt;level(), "Sanity");
 257 
 258   // Atm we only enlarge by one level (so, doubling the chunk in size). So, if the requested enlargement
 259   // would require the chunk to more than double in size, we bail. But this covers about 99% of all cases,
 260   // so this is good enough.
 261   if (new_level &lt; c-&gt;level() - 1) {
 262     return false;
 263   }
 264 
 265   // This only works if chunk is the leader of its buddy pair (and also if buddy
 266   // is free and unsplit, but that we cannot check outside of metaspace lock).
 267   if (!c-&gt;is_leader()) {
 268     return false;
 269   }
 270 
 271   // If the size added to the chunk would be larger than allowed for the next growth step
 272   // dont enlarge.
 273   if (next_chunk_level() &gt; c-&gt;level()) {
 274     return false;
 275   }
 276 
 277   bool success = _chunk_manager-&gt;attempt_enlarge_chunk(c);
 278 
 279   assert(success == false || c-&gt;free_words() &gt;= requested_word_size, "Sanity");
 280 
 281   return success;
 282 
 283 }
 284 
 285 // Allocate memory from Metaspace.
 286 // 1) Attempt to allocate from the free block list.
 287 // 2) Attempt to allocate from the current chunk.
 288 // 3) Attempt to enlarge the current chunk in place if it is too small.
 289 // 4) Attempt to get a new chunk and allocate from that chunk.
 290 // At any point, if we hit a commit limit, we return NULL.
 291 MetaWord* MetaspaceArena::allocate(size_t requested_word_size) {
 292 
 293   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 294 
 295   UL2(trace, "requested " SIZE_FORMAT " words.", requested_word_size);
 296 
 297   MetaWord* p = NULL;
 298 
 299   const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);
 300 
 301   // 1) Attempt to allocate from the free blocks list
 302   if (Settings::handle_deallocations() &amp;&amp; _fbl != NULL &amp;&amp; !_fbl-&gt;is_empty()) {
 303     p = _fbl-&gt;get_block(raw_word_size);
 304     if (p != NULL) {
 305       DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)
 306       UL2(trace, "taken from fbl (now: %d, " SIZE_FORMAT ").",
 307           _fbl-&gt;count(), _fbl-&gt;total_size());
 308       // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -
 309       // that means that we do not modify any counters and therefore can skip the epilog.
 310       return p;
 311     }
 312   }
 313 
 314   bool current_chunk_too_small = false;
 315   bool commit_failure = false;
 316 
 317   if (current_chunk() != NULL) {
 318 
 319     // 2) Attempt to satisfy the allocation from the current chunk.
 320 
 321     // If the current chunk is too small to hold the requested size, attempt to enlarge it.
 322     // If that fails, retire the chunk.
 323     if (current_chunk()-&gt;free_words() &lt; raw_word_size) {
 324       if (!attempt_enlarge_current_chunk(raw_word_size)) {
 325         current_chunk_too_small = true;
 326       } else {
 327         DEBUG_ONLY(InternalStats::inc_num_chunks_enlarged();)
 328         UL(debug, "enlarged chunk.");
 329       }
 330     }
 331 
 332     // Commit the chunk far enough to hold the requested word size. If that fails, we
 333     // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the
 334     // chunk.
 335     if (!current_chunk_too_small) {
 336       if (!current_chunk()-&gt;ensure_committed_additional(raw_word_size)) {
 337         UL2(info, "commit failure (requested size: " SIZE_FORMAT ")", raw_word_size);
 338         commit_failure = true;
 339       }
 340     }
 341 
 342     // Allocate from the current chunk. This should work now.
 343     if (!current_chunk_too_small &amp;&amp; !commit_failure) {
 344       p = current_chunk()-&gt;allocate(raw_word_size);
 345       assert(p != NULL, "Allocation from chunk failed.");
 346     }
 347 
 348   }
 349 
 350   if (p == NULL) {
 351 
 352     // If we are here, we either had no current chunk to begin with or it was deemed insufficient.
 353     assert(current_chunk() == NULL ||
 354            current_chunk_too_small || commit_failure, "Sanity");
 355 
 356     Metachunk* new_chunk = allocate_new_chunk(raw_word_size);
 357 
 358     if (new_chunk != NULL) {
 359 
 360       UL2(debug, "allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",
 361           METACHUNK_FORMAT_ARGS(new_chunk), requested_word_size);
 362 
 363       assert(new_chunk-&gt;free_below_committed_words() &gt;= raw_word_size, "Sanity");
 364 
 365       // We have a new chunk. Before making it the current chunk, retire the old one.
 366       if (current_chunk() != NULL) {
 367         salvage_chunk(current_chunk());
 368         DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)
 369       }
 370 
 371       _chunks.add(new_chunk);
 372 
 373       // Now, allocate from that chunk. That should work.
 374       p = current_chunk()-&gt;allocate(raw_word_size);
 375       assert(p != NULL, "Allocation from chunk failed.");
 376 
 377     } else {
 378       UL2(info, "failed to allocate new chunk for requested word size " SIZE_FORMAT ".", requested_word_size);
 379     }
 380 
 381   }
 382 
 383 #ifdef ASSERT
 384   // When using allocation guards, establish a prefix.
 385   if (p != NULL &amp;&amp; Settings::use_allocation_guard()) {
 386     p = establish_prefix(p, raw_word_size);
 387   }
 388 #endif
 389 
 390   if (p == NULL) {
 391     InternalStats::inc_num_allocs_failed_limit();
 392   } else {
 393     DEBUG_ONLY(InternalStats::inc_num_allocs();)
 394     _total_used_words_counter-&gt;increment_by(raw_word_size);
 395   }
 396 
 397   SOMETIMES(verify_locked(true);)
 398 
 399   if (p == NULL) {
 400     UL(info, "allocation failed, returned NULL.");
 401   } else {
 402     UL2(trace, "returned " PTR_FORMAT ".", p2i(p));
 403   }
 404 
 405   return p;
 406 
 407 }
 408 
 409 // Prematurely returns a metaspace allocation to the _block_freelists
 410 // because it is not needed anymore (requires CLD lock to be active).
 411 void MetaspaceArena::deallocate_locked(MetaWord* p, size_t word_size) {
 412 
 413   if (Settings::handle_deallocations() == false) {
 414     return;
 415   }
 416 
 417   assert_lock_strong(lock());
 418 
 419   // At this point a current chunk must exist since we only deallocate if we did allocate before.
 420   assert(current_chunk() != NULL, "stray deallocation?");
 421 
 422   assert(is_valid_area(p, word_size),
 423          "Pointer range not part of this Arena and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",
 424          p2i(p), p2i(p + word_size));
 425 
 426   UL2(trace, "deallocating " PTR_FORMAT ", word size: " SIZE_FORMAT ".",
 427       p2i(p), word_size);
 428 
 429   size_t raw_word_size = get_raw_word_size_for_requested_word_size(word_size);
 430   add_allocation_to_fbl(p, raw_word_size);
 431 
 432   DEBUG_ONLY(verify_locked(false);)
 433 
 434 }
 435 
 436 // Prematurely returns a metaspace allocation to the _block_freelists because it is not
 437 // needed anymore.
 438 void MetaspaceArena::deallocate(MetaWord* p, size_t word_size) {
 439   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 440   deallocate_locked(p, word_size);
 441 }
 442 
 443 // Update statistics. This walks all in-use chunks.
 444 void MetaspaceArena::add_to_statistics(arena_stats_t* out) const {
 445 
 446   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 447 
 448   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 449     in_use_chunk_stats_t&amp; ucs = out-&gt;stats[c-&gt;level()];
 450     ucs.num ++;
 451     ucs.word_size += c-&gt;word_size();
 452     ucs.committed_words += c-&gt;committed_words();
 453     ucs.used_words += c-&gt;used_words();
 454     // Note: for free and waste, we only count what's committed.
 455     if (c == current_chunk()) {
 456       ucs.free_words += c-&gt;free_below_committed_words();
 457     } else {
 458       ucs.waste_words += c-&gt;free_below_committed_words();
 459     }
 460   }
 461 
 462   if (_fbl != NULL) {
 463     out-&gt;free_blocks_num += _fbl-&gt;count();
 464     out-&gt;free_blocks_word_size += _fbl-&gt;total_size();
 465   }
 466 
 467   SOMETIMES(out-&gt;verify();)
 468 
 469 }
 470 
 471 // Convenience method to get the most important usage statistics.
 472 // For deeper analysis use add_to_statistics().
 473 void MetaspaceArena::usage_numbers(size_t* p_used_words, size_t* p_committed_words, size_t* p_capacity_words) const {
 474   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 475   size_t used = 0, comm = 0, cap = 0;
 476   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 477     used += c-&gt;used_words();
 478     comm += c-&gt;committed_words();
 479     cap += c-&gt;word_size();
 480   }
 481   if (p_used_words != NULL) {
 482     *p_used_words = used;
 483   }
 484   if (p_committed_words != NULL) {
 485     *p_committed_words = comm;
 486   }
 487   if (p_capacity_words != NULL) {
 488     *p_capacity_words = cap;
 489   }
 490 }
 491 
 492 
 493 #ifdef ASSERT
 494 
 495 void MetaspaceArena::verify_locked(bool slow) const {
 496 
 497   assert_lock_strong(lock());
 498 
 499   assert(_growth_policy != NULL &amp;&amp; _chunk_manager != NULL, "Sanity");
 500 
 501   _chunks.verify();
 502 
 503   if (_fbl != NULL) {
 504     _fbl-&gt;verify();
 505   }
 506 
 507   // In slow mode, verify guard zones of all allocations
 508   if (slow &amp;&amp; Settings::use_allocation_guard()) {
 509     for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {
 510       const MetaWord* p = c-&gt;base();
 511       while (p &lt; c-&gt;top()) {
 512         const prefix_t* pp = (const prefix_t*)p;
 513         check_prefix(pp);
 514         p += pp-&gt;word_size;
 515       }
 516     }
 517   }
 518 
 519 }
 520 
 521 void MetaspaceArena::verify(bool slow) const {
 522 
 523   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
 524   verify_locked(slow);
 525 
 526 }
 527 
 528 // Returns true if the area indicated by pointer and size have actually been allocated
 529 // from this arena.
 530 bool MetaspaceArena::is_valid_area(MetaWord* p, size_t word_size) const {
 531   assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");
 532   bool found = false;
 533   if (!found) {
 534     for (const Metachunk* c = _chunks.first(); c != NULL &amp;&amp; !found; c = c-&gt;next()) {
 535       assert(c-&gt;is_valid_committed_pointer(p) ==
 536              c-&gt;is_valid_committed_pointer(p + word_size - 1), "range intersects");
 537       found = c-&gt;is_valid_committed_pointer(p);
 538     }
 539   }
 540   return found;
 541 }
 542 
 543 #endif // ASSERT
 544 
 545 void MetaspaceArena::print_on(outputStream* st) const {
 546   MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);
 547   print_on_locked(st);
 548 }
 549 
 550 void MetaspaceArena::print_on_locked(outputStream* st) const {
 551   assert_lock_strong(_lock);
 552   st-&gt;print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
 553                _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());
 554   _chunks.print_on(st);
 555   st-&gt;cr();
 556   st-&gt;print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,
 557                 _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));
 558 }
 559 
 560 
 561 
 562 } // namespace metaspace
 563 
</pre></body></html>
