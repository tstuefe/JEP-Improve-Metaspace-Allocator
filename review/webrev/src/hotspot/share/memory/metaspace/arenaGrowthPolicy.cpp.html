<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/arenaGrowthPolicy.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 #include "precompiled.hpp"
   2 
   3 #include "memory/metaspace/arenaGrowthPolicy.hpp"
   4 #include "memory/metaspace/chunkLevel.hpp"
   5 #include "utilities/globalDefinitions.hpp"
   6 
   7 namespace metaspace {
   8 
   9 // hard-coded chunk allocation sequences for various space types
  10 //  (Note: when modifying this, don't add jumps of more than double the
  11 //   last chunk size. There is a gtest testing this, see test_arenagrowthpolicy.cpp)
  12 
  13 static const chunklevel_t g_sequ_standard_non_class[] = {
  14     chunklevel::CHUNK_LEVEL_4K,
  15     chunklevel::CHUNK_LEVEL_4K,
  16     chunklevel::CHUNK_LEVEL_4K,
  17     chunklevel::CHUNK_LEVEL_8K,
  18     chunklevel::CHUNK_LEVEL_16K
  19     // .. repeat last
  20 };
  21 
  22 static const chunklevel_t g_sequ_standard_class[] = {
  23     chunklevel::CHUNK_LEVEL_2K,
  24     chunklevel::CHUNK_LEVEL_2K,
  25     chunklevel::CHUNK_LEVEL_4K,
  26     chunklevel::CHUNK_LEVEL_8K,
  27     chunklevel::CHUNK_LEVEL_16K
  28     // .. repeat last
  29 };
  30 
  31 static const chunklevel_t g_sequ_anon_non_class[] = {
  32    chunklevel::CHUNK_LEVEL_1K,
  33    // .. repeat last
  34 };
  35 
  36 static const chunklevel_t g_sequ_anon_class[] = {
  37     chunklevel::CHUNK_LEVEL_1K,
  38     // .. repeat last
  39 };
  40 
  41 static const chunklevel_t g_sequ_refl_non_class[] = {
  42     chunklevel::CHUNK_LEVEL_2K,
  43     chunklevel::CHUNK_LEVEL_1K
  44     // .. repeat last
  45 };
  46 
  47 static const chunklevel_t g_sequ_refl_class[] = {
  48     chunklevel::CHUNK_LEVEL_1K,
  49     // .. repeat last
  50 };
  51 
  52 // Boot class loader: give it large chunks: beyond commit granule size
  53 // (typically 64K) the costs for large chunks largely diminishes since
  54 // they are committed on the fly.
  55 static const chunklevel_t g_sequ_boot_non_class[] = {
  56     chunklevel::CHUNK_LEVEL_4M,
  57     chunklevel::CHUNK_LEVEL_1M
  58     // .. repeat last
  59 };
  60 
  61 static const chunklevel_t g_sequ_boot_class[] = {
  62     chunklevel::CHUNK_LEVEL_256K
  63     // .. repeat last
  64 };
  65 
  66 const ArenaGrowthPolicy* ArenaGrowthPolicy::policy_for_space_type(MetaspaceType space_type, bool is_class) {
  67 
  68 #define DEFINE_CLASS_FOR_ARRAY(what) \
  69   static ArenaGrowthPolicy chunk_alloc_sequence_##what (g_sequ_##what, sizeof(g_sequ_##what)/sizeof(chunklevel_t));
  70 
  71   DEFINE_CLASS_FOR_ARRAY(standard_non_class)
  72   DEFINE_CLASS_FOR_ARRAY(standard_class)
  73   DEFINE_CLASS_FOR_ARRAY(anon_non_class)
  74   DEFINE_CLASS_FOR_ARRAY(anon_class)
  75   DEFINE_CLASS_FOR_ARRAY(refl_non_class)
  76   DEFINE_CLASS_FOR_ARRAY(refl_class)
  77   DEFINE_CLASS_FOR_ARRAY(boot_non_class)
  78   DEFINE_CLASS_FOR_ARRAY(boot_class)
  79 
  80   if (is_class) {
  81     switch(space_type) {
  82     case StandardMetaspaceType:          return &amp;chunk_alloc_sequence_standard_class;
  83     case ReflectionMetaspaceType:        return &amp;chunk_alloc_sequence_refl_class;
  84     case ClassMirrorHolderMetaspaceType: return &amp;chunk_alloc_sequence_anon_class;
  85     case BootMetaspaceType:              return &amp;chunk_alloc_sequence_boot_class;
  86     default: ShouldNotReachHere();
  87     }
  88   } else {
  89     switch(space_type) {
  90     case StandardMetaspaceType:          return &amp;chunk_alloc_sequence_standard_non_class;
  91     case ReflectionMetaspaceType:        return &amp;chunk_alloc_sequence_refl_non_class;
  92     case ClassMirrorHolderMetaspaceType: return &amp;chunk_alloc_sequence_anon_non_class;
  93     case BootMetaspaceType:              return &amp;chunk_alloc_sequence_boot_non_class;
  94     default: ShouldNotReachHere();
  95     }
  96   }
  97 
  98   return NULL;
  99 
 100 }
 101 
 102 } // namespace
 103 
</pre></body></html>
