<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="new">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 
  27 #include "precompiled.hpp"
  28 #include "logging/log.hpp"
<a name="2" id="anc2"></a>
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<a name="3" id="anc3"></a><span class="changed">  31 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/freeChunkList.hpp"</span>
<span class="changed">  35 #include "memory/metaspace/metaspaceContext.hpp"</span>
  36 #include "memory/metaspace/virtualSpaceList.hpp"
  37 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="4" id="anc4"></a>

  38 #include "runtime/mutexLocker.hpp"
<a name="5" id="anc5"></a><span class="changed">  39 </span>
  40 
  41 namespace metaspace {
  42 
<a name="6" id="anc6"></a><span class="new">  43 #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"</span>
<span class="new">  44 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  45 
<a name="7" id="anc7"></a><span class="changed">  46 // Create a new, empty, expandable list.</span>
<span class="changed">  47 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">  48   : _name(name),</span>
<span class="changed">  49     _first_node(NULL),</span>
<span class="changed">  50     _can_expand(true),</span>
<span class="changed">  51     _can_purge(true),</span>
<span class="changed">  52     _commit_limiter(commit_limiter),</span>
<span class="changed">  53     _reserved_words_counter(),</span>
<span class="changed">  54     _committed_words_counter()</span>
<span class="changed">  55 {</span>
<span class="changed">  56 }</span>
<span class="changed">  57 </span>
<span class="changed">  58 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">  59 // It will be not expandable beyond that first node.</span>
<span class="changed">  60 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">  61 : _name(name),</span>
<span class="changed">  62   _first_node(NULL),</span>
<span class="changed">  63   _can_expand(false),</span>
<span class="changed">  64   _can_purge(false),</span>
<span class="changed">  65   _commit_limiter(commit_limiter),</span>
<span class="changed">  66   _reserved_words_counter(),</span>
<span class="changed">  67   _committed_words_counter()</span>
<span class="changed">  68 {</span>
<span class="changed">  69   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">  70   // for this list since we cannot expand.</span>
<span class="changed">  71   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(rs, _commit_limiter,</span>
<span class="changed">  72                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">  73   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">  74   _first_node = vsn;</span>
<span class="changed">  75   _first_node-&gt;set_next(NULL);</span>
<span class="changed">  76   _nodes_counter.increment();</span>
  77 }
  78 
<a name="8" id="anc8"></a><span class="changed">  79 VirtualSpaceList::~VirtualSpaceList() {</span>




  80   assert_lock_strong(MetaspaceExpand_lock);
<a name="9" id="anc9"></a><span class="changed">  81   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">  82   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">  83   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">  84   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">  85   while (vsn != NULL) {</span>
<span class="changed">  86     vsn2 = vsn-&gt;next();</span>
<span class="changed">  87     delete vsn;</span>
<span class="changed">  88     vsn = vsn2;</span>
<span class="changed">  89   }</span>
  90 }
  91 
<a name="10" id="anc10"></a><span class="changed">  92 // Create a new node and append it to the list. After</span>
<span class="changed">  93 // this function, _current_node shall point to a new empty node.</span>
<span class="changed">  94 // List must be expandable for this to work.</span>
<span class="changed">  95 void VirtualSpaceList::create_new_node() {</span>
<span class="changed">  96   assert(_can_expand, "List is not expandable");</span>








  97   assert_lock_strong(MetaspaceExpand_lock);
<a name="11" id="anc11"></a>
  98 
<a name="12" id="anc12"></a><span class="changed">  99   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(Settings::virtual_space_node_default_word_size(),</span>
<span class="changed"> 100                                                         _commit_limiter,</span>
<span class="changed"> 101                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed"> 102   assert(vsn != NULL, "node creation failed");</span>
<span class="changed"> 103   vsn-&gt;set_next(_first_node);</span>
<span class="changed"> 104   _first_node = vsn;</span>
<span class="changed"> 105   _nodes_counter.increment();</span>
 106 }
 107 
<a name="13" id="anc13"></a><span class="changed"> 108 // Allocate a root chunk from this list.</span>
<span class="changed"> 109 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 110 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 111 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 112 Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
 113   assert_lock_strong(MetaspaceExpand_lock);
<a name="14" id="anc14"></a>

 114 
<a name="15" id="anc15"></a><span class="changed"> 115   if (_first_node == NULL ||</span>
<span class="changed"> 116       _first_node-&gt;free_words() == 0) {</span>































 117 
<a name="16" id="anc16"></a><span class="changed"> 118     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="changed"> 119     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="changed"> 120     // we should never have left-over space.</span>
<span class="changed"> 121     assert(_first_node == NULL ||</span>
<span class="changed"> 122            _first_node-&gt;free_words() == 0, "Sanity");</span>
<span class="changed"> 123 </span>
<span class="changed"> 124     if (_can_expand) {</span>
<span class="changed"> 125       create_new_node();</span>
<span class="changed"> 126       UL2(debug, "added new node (now: %d).", num_nodes());</span>
 127     } else {
<a name="17" id="anc17"></a><span class="changed"> 128       UL(debug, "list cannot expand.");</span>
<span class="changed"> 129       return NULL; // We cannot expand this list.</span>























 130     }
 131   }
<a name="18" id="anc18"></a>


 132 
<a name="19" id="anc19"></a><span class="changed"> 133   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>

 134 
<a name="20" id="anc20"></a><span class="changed"> 135   assert(c != NULL, "This should have worked");</span>
 136 
<a name="21" id="anc21"></a><span class="changed"> 137   return c;</span>

 138 
<a name="22" id="anc22"></a>
 139 }
 140 
<a name="23" id="anc23"></a><span class="changed"> 141 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed"> 142 // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed"> 143 // Return number of purged nodes.</span>
<span class="changed"> 144 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>




























 145 
<a name="24" id="anc24"></a>





 146   assert_lock_strong(MetaspaceExpand_lock);
 147 
<a name="25" id="anc25"></a><span class="changed"> 148   if (_can_purge == false) {</span>
<span class="changed"> 149     return 0;</span>



 150   }
 151 
<a name="26" id="anc26"></a><span class="changed"> 152   UL(debug, "purging.");</span>



 153 
<a name="27" id="anc27"></a><span class="changed"> 154   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 155   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed"> 156   int num = 0, num_purged = 0;</span>
<span class="changed"> 157   while (vsn != NULL) {</span>
<span class="changed"> 158     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed"> 159     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed"> 160     if (purged) {</span>
<span class="changed"> 161       // Note: from now on do not dereference vsn!</span>
<span class="changed"> 162       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));</span>
<span class="changed"> 163       if (_first_node == vsn) {</span>
<span class="changed"> 164         _first_node = next_vsn;</span>
<span class="changed"> 165       }</span>
<span class="changed"> 166       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed"> 167       if (prev_vsn != NULL) {</span>
<span class="changed"> 168         prev_vsn-&gt;set_next(next_vsn);</span>



 169       }
<a name="28" id="anc28"></a><span class="changed"> 170       num_purged ++;</span>
<span class="changed"> 171       _nodes_counter.decrement();</span>






 172     } else {
<a name="29" id="anc29"></a><span class="changed"> 173       prev_vsn = vsn;</span>
 174     }
<a name="30" id="anc30"></a><span class="changed"> 175     vsn = next_vsn;</span>
<span class="changed"> 176     num ++;</span>











 177   }
<a name="31" id="anc31"></a>
 178 
<a name="32" id="anc32"></a><span class="changed"> 179   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());</span>



 180 
<a name="33" id="anc33"></a><span class="changed"> 181   return num_purged;</span>
 182 
<a name="34" id="anc34"></a>






 183 }
 184 
<a name="35" id="anc35"></a><span class="changed"> 185 // Print all nodes in this space list.</span>
<span class="changed"> 186 void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed"> 187   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>



 188 
<a name="36" id="anc36"></a><span class="changed"> 189   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed"> 190   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 191   int n = 0;</span>
<span class="changed"> 192   while (vsn != NULL) {</span>
<span class="changed"> 193     st-&gt;print("- node #%d: ", n);</span>
<span class="changed"> 194     vsn-&gt;print_on(st);</span>
<span class="changed"> 195     vsn = vsn-&gt;next();</span>
<span class="changed"> 196     n ++;</span>
 197   }
<a name="37" id="anc37"></a><span class="new"> 198   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="new"> 199                n, reserved_words(), committed_words());</span>
<span class="new"> 200 }</span>
 201 
<a name="38" id="anc38"></a><span class="changed"> 202 #ifdef ASSERT</span>
<span class="changed"> 203 void VirtualSpaceList::verify_locked(bool slow) const {</span>




 204 
<a name="39" id="anc39"></a><span class="changed"> 205   assert_lock_strong(MetaspaceExpand_lock);</span>
 206 
<a name="40" id="anc40"></a><span class="changed"> 207   assert(_name != NULL, "Sanity");</span>
























 208 
<a name="41" id="anc41"></a><span class="changed"> 209   int n = 0;</span>



 210 
<a name="42" id="anc42"></a><span class="changed"> 211   if (_first_node != NULL) {</span>


















 212 
<a name="43" id="anc43"></a><span class="new"> 213     size_t total_reserved_words = 0;</span>
<span class="new"> 214     size_t total_committed_words = 0;</span>
<span class="new"> 215     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="new"> 216     while (vsn != NULL) {</span>
<span class="new"> 217       n ++;</span>
<span class="new"> 218       vsn-&gt;verify_locked(slow);</span>
<span class="new"> 219       total_reserved_words += vsn-&gt;word_size();</span>
<span class="new"> 220       total_committed_words += vsn-&gt;committed_words();</span>
<span class="new"> 221       vsn = vsn-&gt;next();</span>
<span class="new"> 222     }</span>
<span class="new"> 223 </span>
<span class="new"> 224     _nodes_counter.check(n);</span>
<span class="new"> 225     _reserved_words_counter.check(total_reserved_words);</span>
<span class="new"> 226     _committed_words_counter.check(total_committed_words);</span>
 227 
<a name="44" id="anc44"></a><span class="changed"> 228   } else {</span>
 229 
<a name="45" id="anc45"></a><span class="changed"> 230     _reserved_words_counter.check(0);</span>
<span class="changed"> 231     _committed_words_counter.check(0);</span>
 232 
<a name="46" id="anc46"></a>

 233   }
<a name="47" id="anc47"></a><span class="new"> 234 }</span>
 235 
<a name="48" id="anc48"></a><span class="changed"> 236 void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed"> 237   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 238   verify_locked(slow);</span>
<span class="changed"> 239 }</span>
<span class="changed"> 240 #endif</span>

 241 
<a name="49" id="anc49"></a><span class="changed"> 242 // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed"> 243 bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed"> 244   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 245   while (vsn != NULL) {</span>
<span class="changed"> 246     if (vsn-&gt;contains(p)) {</span>
<span class="changed"> 247       return true;</span>
 248     }
<a name="50" id="anc50"></a><span class="changed"> 249     vsn = vsn-&gt;next();</span>




 250   }
<a name="51" id="anc51"></a><span class="changed"> 251   return false;</span>

 252 }
 253 
<a name="52" id="anc52"></a><span class="changed"> 254 // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed"> 255 // can be allocated.</span>
<span class="changed"> 256 bool VirtualSpaceList::is_full() const {</span>
<span class="changed"> 257   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed"> 258     return true;</span>



 259   }
<a name="53" id="anc53"></a><span class="new"> 260   return false;</span>
 261 }
 262 
<a name="54" id="anc54"></a><span class="changed"> 263 // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed"> 264 //  and non-class chunkmanager, respectively.</span>
<span class="changed"> 265 VirtualSpaceList* VirtualSpaceList::vslist_class() {</span>
<span class="changed"> 266   return MetaspaceContext::contect_class() == NULL ? NULL : MetaspaceContext::contect_class()-&gt;vslist();</span>






 267 }
 268 
<a name="55" id="anc55"></a><span class="changed"> 269 VirtualSpaceList* VirtualSpaceList::vslist_nonclass() {</span>
<span class="changed"> 270   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;vslist();</span>


 271 }
 272 
 273 
<a name="56" id="anc56"></a>



























 274 
 275 } // namespace metaspace
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="57" type="hidden" /></form></body></html>
