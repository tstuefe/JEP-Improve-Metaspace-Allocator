<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metaspaceStatistics.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   3  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 
  28 #include "memory/metaspace/chunkLevel.hpp"
  29 #include "memory/metaspace/metaspaceCommon.hpp"
  30 #include "memory/metaspace/metaspaceStatistics.hpp"
  31 
  32 #include "utilities/debug.hpp"
  33 #include "utilities/globalDefinitions.hpp"
  34 #include "utilities/ostream.hpp"
  35 
  36 namespace metaspace {
  37 
  38 
  39 // Returns total word size of all chunks in this manager.
  40 void cm_stats_t::add(const cm_stats_t&amp; other) {
  41   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
  42     num_chunks[l] += other.num_chunks[l];
  43     committed_word_size[l] += other.committed_word_size[l];
  44   }
  45 }
  46 
  47 // Returns total word size of all chunks in this manager.
  48 size_t cm_stats_t::total_word_size() const {
  49   size_t s = 0;
  50   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
  51     s += num_chunks[l] * chunklevel::word_size_for_level(l);
  52   }
  53   return s;
  54 }
  55 
  56 // Returns total committed word size of all chunks in this manager.
  57 size_t cm_stats_t::total_committed_word_size() const {
  58   size_t s = 0;
  59   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
  60     s += committed_word_size[l];
  61   }
  62   return s;
  63 }
  64 
  65 
  66 void cm_stats_t::print_on(outputStream* st, size_t scale) const {
  67   // Note: used as part of MetaspaceReport so formatting matters.
  68   size_t total_size = 0;
  69   size_t total_committed_size = 0;
  70   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
  71     st-&gt;cr();
  72     chunklevel::print_chunk_size(st, l);
  73     st-&gt;print(": ");
  74     if (num_chunks[l] &gt; 0) {
  75       const size_t word_size = num_chunks[l] * chunklevel::word_size_for_level(l);
  76 
  77       st-&gt;print("%4d, capacity=", num_chunks[l]);
  78       print_scaled_words(st, word_size, scale);
  79 
  80       st-&gt;print(", committed=");
  81       print_scaled_words_and_percentage(st, committed_word_size[l], word_size, scale);
  82 
  83       total_size += word_size;
  84       total_committed_size += committed_word_size[l];
  85     } else {
  86       st-&gt;print("(none)");
  87     }
  88   }
  89   st-&gt;cr();
  90   st-&gt;print("Total word size: ");
  91   print_scaled_words(st, total_size, scale);
  92   st-&gt;print(", committed: ");
  93   print_scaled_words_and_percentage(st, total_committed_size, total_size, scale);
  94   st-&gt;cr();
  95 }
  96 
  97 #ifdef ASSERT
  98 void cm_stats_t::verify() const {
  99   assert(total_committed_word_size() &lt;= total_word_size(),
 100          "Sanity");
 101 }
 102 #endif
 103 
 104 
 105 void in_use_chunk_stats_t::print_on(outputStream* st, size_t scale) const {
 106   int col = st-&gt;position();
 107   st-&gt;print("%4d chunk%s, ", num, num != 1 ? "s" : "");
 108   if (num &gt; 0) {
 109     col += 14; st-&gt;fill_to(col);
 110 
 111     print_scaled_words(st, word_size, scale, 5);
 112     st-&gt;print(" capacity,");
 113 
 114     col += 20; st-&gt;fill_to(col);
 115     print_scaled_words_and_percentage(st, committed_words, word_size, scale, 5);
 116     st-&gt;print(" committed, ");
 117 
 118     col += 18; st-&gt;fill_to(col);
 119     print_scaled_words_and_percentage(st, used_words, word_size, scale, 5);
 120     st-&gt;print(" used, ");
 121 
 122     col += 20; st-&gt;fill_to(col);
 123     print_scaled_words_and_percentage(st, free_words, word_size, scale, 5);
 124     st-&gt;print(" free, ");
 125 
 126     col += 20; st-&gt;fill_to(col);
 127     print_scaled_words_and_percentage(st, waste_words, word_size, scale, 5);
 128     st-&gt;print(" waste ");
 129 
 130   }
 131 }
 132 
 133 #ifdef ASSERT
 134 void in_use_chunk_stats_t::verify() const {
 135   assert(word_size &gt;= committed_words &amp;&amp;
 136       committed_words == used_words + free_words + waste_words,
 137          "Sanity: cap " SIZE_FORMAT ", committed " SIZE_FORMAT ", used " SIZE_FORMAT ", free " SIZE_FORMAT ", waste " SIZE_FORMAT ".",
 138          word_size, committed_words, used_words, free_words, waste_words);
 139 }
 140 #endif
 141 
 142 void arena_stats_t::add(const arena_stats_t&amp; other) {
 143   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 144     stats[l].add(other.stats[l]);
 145   }
 146   free_blocks_num += other.free_blocks_num;
 147   free_blocks_word_size += other.free_blocks_word_size;
 148 }
 149 
 150 
 151 // Returns total chunk statistics over all chunk types.
 152 in_use_chunk_stats_t arena_stats_t::totals() const {
 153   in_use_chunk_stats_t out;
 154   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 155     out.add(stats[l]);
 156   }
 157   return out;
 158 }
 159 
 160 void arena_stats_t::print_on(outputStream* st, size_t scale,  bool detailed) const {
 161   streamIndentor sti(st);
 162   if (detailed) {
 163     st-&gt;cr_indent();
 164     st-&gt;print("Usage by chunk level:");
 165     {
 166       streamIndentor sti2(st);
 167       for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 168         st-&gt;cr_indent();
 169         chunklevel::print_chunk_size(st, l);
 170         st-&gt;print(" chunks: ");
 171         if (stats[l].num == 0) {
 172           st-&gt;print(" (none)");
 173         } else {
 174           stats[l].print_on(st, scale);
 175         }
 176       }
 177 
 178       st-&gt;cr_indent();
 179       st-&gt;print("%15s: ", "-total-");
 180       totals().print_on(st, scale);
 181     }
 182     if (free_blocks_num &gt; 0) {
 183       st-&gt;cr_indent();
 184       st-&gt;print("deallocated: " UINTX_FORMAT " blocks with ", free_blocks_num);
 185       print_scaled_words(st, free_blocks_word_size, scale);
 186     }
 187   } else {
 188     totals().print_on(st, scale);
 189     st-&gt;print(", ");
 190     st-&gt;print("deallocated: " UINTX_FORMAT " blocks with ", free_blocks_num);
 191     print_scaled_words(st, free_blocks_word_size, scale);
 192   }
 193 }
 194 
 195 #ifdef ASSERT
 196 
 197 void arena_stats_t::verify() const {
 198   size_t total_used = 0;
 199   for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 200     stats[l].verify();
 201     total_used += stats[l].used_words;
 202   }
 203   // Deallocated allocations still count as used
 204   assert(total_used &gt;= free_blocks_word_size,
 205          "Sanity");
 206 }
 207 #endif
 208 
 209 
 210 // Returns total arena statistics for both class and non-class metaspace
 211 arena_stats_t clms_stats_t::totals() const {
 212   arena_stats_t out;
 213   out.add(arena_stats_nonclass);
 214   out.add(arena_stats_class);
 215   return out;
 216 }
 217 
 218 void clms_stats_t::print_on(outputStream* st, size_t scale, bool detailed) const {
 219   streamIndentor sti(st);
 220   st-&gt;cr_indent();
 221   if (Metaspace::using_class_space()) {
 222     st-&gt;print("Non-Class: ");
 223   }
 224   arena_stats_nonclass.print_on(st, scale, detailed);
 225   if (detailed) {
 226     st-&gt;cr();
 227   }
 228   if (Metaspace::using_class_space()) {
 229     st-&gt;cr_indent();
 230     st-&gt;print("    Class: ");
 231     arena_stats_class.print_on(st, scale, detailed);
 232     if (detailed) {
 233       st-&gt;cr();
 234     }
 235     st-&gt;cr_indent();
 236     st-&gt;print("     Both: ");
 237     totals().print_on(st, scale, detailed);
 238     if (detailed) {
 239       st-&gt;cr();
 240     }
 241   }
 242   st-&gt;cr();
 243 }
 244 
 245 
 246 #ifdef ASSERT
 247 void clms_stats_t::verify() const {
 248   arena_stats_nonclass.verify();
 249   arena_stats_class.verify();
 250 }
 251 #endif
 252 
 253 } // end namespace metaspace
 254 
 255 
 256 
</pre></body></html>
