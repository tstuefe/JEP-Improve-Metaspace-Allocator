<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/metaspaceStatistics.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
   3  * Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_METASPACESTATISTICS_HPP
  27 #define SHARE_MEMORY_METASPACE_METASPACESTATISTICS_HPP
  28 
  29 #include "memory/metaspace.hpp"             // for MetadataType enum
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "utilities/globalDefinitions.hpp"
  32 
  33 class outputStream;
  34 
  35 namespace metaspace {
  36 
  37 
  38 // Contains statistics for one or multiple ChunkManager.
  39 struct cm_stats_t {
  40 
  41   // How many chunks per level are checked in.
  42   int num_chunks[chunklevel::NUM_CHUNK_LEVELS];
  43 
  44   // Size, in words, of the sum of all committed areas in this chunk manager, per level.
  45   size_t committed_word_size[chunklevel::NUM_CHUNK_LEVELS];
  46 
  47   cm_stats_t() : num_chunks(), committed_word_size() {}
  48 
  49   void add(const cm_stats_t&amp; other);
  50 
  51   // Returns total word size of all chunks in this manager.
  52   size_t total_word_size() const;
  53 
  54   // Returns total committed word size of all chunks in this manager.
  55   size_t total_committed_word_size() const;
  56 
  57   void print_on(outputStream* st, size_t scale) const;
  58 
  59   DEBUG_ONLY(void verify() const;)
  60 
  61 };
  62 
  63 // Contains statistics for one or multiple chunks in use.
  64 struct in_use_chunk_stats_t {
  65 
  66   // Number of chunks
  67   int num;
  68 
  69   // Note:
  70   // capacity = committed + uncommitted
  71   //            committed = used + free + waste
  72 
  73   // Capacity (total sum of all chunk sizes) in words.
  74   // May contain committed and uncommitted space.
  75   size_t word_size;
  76 
  77   // Total committed area, in words.
  78   size_t committed_words;
  79 
  80   // Total used area, in words.
  81   size_t used_words;
  82 
  83   // Total free committed area, in words.
  84   size_t free_words;
  85 
  86   // Total waste committed area, in words.
  87   size_t waste_words;
  88 
  89   in_use_chunk_stats_t()
  90     : num(0), word_size(0), committed_words(0),
  91       used_words(0), free_words(0), waste_words(0)
  92   {}
  93 
  94   void add(const in_use_chunk_stats_t&amp; other) {
  95     num += other.num;
  96     word_size += other.word_size;
  97     committed_words += other.committed_words;
  98     used_words += other.used_words;
  99     free_words += other.free_words;
 100     waste_words += other.waste_words;
 101 
 102   }
 103 
 104   void print_on(outputStream* st, size_t scale) const;
 105 
 106   DEBUG_ONLY(void verify() const;)
 107 
 108 };
 109 
 110 // Class containing statistics for one or more MetaspaceArena objects.
 111 struct  arena_stats_t {
 112 
 113   // chunk statistics by chunk level
 114   in_use_chunk_stats_t stats[chunklevel::NUM_CHUNK_LEVELS];
 115   uintx free_blocks_num;
 116   size_t free_blocks_word_size;
 117 
 118   arena_stats_t()
 119     : stats(),
 120       free_blocks_num(0),
 121       free_blocks_word_size(0)
 122   {}
 123 
 124   void add(const arena_stats_t&amp; other);
 125 
 126   void print_on(outputStream* st, size_t scale = K,  bool detailed = true) const;
 127 
 128   in_use_chunk_stats_t totals() const;
 129 
 130   DEBUG_ONLY(void verify() const;)
 131 
 132 };
 133 
 134 // Statistics for one or multiple ClassLoaderMetaspace objects
 135 struct clms_stats_t {
 136 
 137   arena_stats_t arena_stats_nonclass;
 138   arena_stats_t arena_stats_class;
 139 
 140   clms_stats_t() : arena_stats_nonclass(), arena_stats_class() {}
 141 
 142   void add(const clms_stats_t&amp; other) {
 143     arena_stats_nonclass.add(other.arena_stats_nonclass);
 144     arena_stats_class.add(other.arena_stats_class);
 145   }
 146 
 147   void print_on(outputStream* st, size_t scale, bool detailed) const;
 148 
 149   // Returns total statistics for both class and non-class metaspace
 150   arena_stats_t totals() const;
 151 
 152 
 153   DEBUG_ONLY(void verify() const;)
 154 
 155 };
 156 
 157 } // namespace metaspace
 158 
 159 #endif // SHARE_MEMORY_METASPACE_METASPACESTATISTICS_HPP
 160 
</pre></body></html>
