<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/classfile </title>
</head><body id="SUNWwebrev">
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderData.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  42 //
  43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
  44 // that represent the loader's "linking domain" in the JVM.
  45 //
  46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
  47 // the singleton class the_null_class_loader_data().
  48 
  49 #include "precompiled.hpp"
  50 #include "classfile/classLoaderData.inline.hpp"
  51 #include "classfile/classLoaderDataGraph.inline.hpp"
  52 #include "classfile/dictionary.hpp"
  53 #include "classfile/javaClasses.hpp"
  54 #include "classfile/moduleEntry.hpp"
  55 #include "classfile/packageEntry.hpp"
  56 #include "classfile/symbolTable.hpp"
  57 #include "classfile/systemDictionary.hpp"
  58 #include "logging/log.hpp"
  59 #include "logging/logStream.hpp"
  60 #include "memory/allocation.inline.hpp"
  61 #include "memory/metadataFactory.hpp"


  62 #include "memory/resourceArea.hpp"
  63 #include "memory/universe.hpp"
  64 #include "oops/access.inline.hpp"
  65 #include "oops/oop.inline.hpp"
  66 #include "oops/oopHandle.inline.hpp"
  67 #include "oops/weakHandle.inline.hpp"
  68 #include "runtime/atomic.hpp"
  69 #include "runtime/handles.inline.hpp"
  70 #include "runtime/mutex.hpp"
  71 #include "runtime/safepoint.hpp"
  72 #include "utilities/growableArray.hpp"
  73 #include "utilities/macros.hpp"
  74 #include "utilities/ostream.hpp"
  75 


  76 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
  77 
  78 void ClassLoaderData::init_null_class_loader_data() {
  79   assert(_the_null_class_loader_data == NULL, "cannot initialize twice");
  80   assert(ClassLoaderDataGraph::_head == NULL, "cannot initialize twice");
  81 
  82   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
  83   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
  84   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), "Must be");
  85 
  86   LogTarget(Trace, class, loader, data) lt;
  87   if (lt.is_enabled()) {
  88     ResourceMark rm;
  89     LogStream ls(lt);
  90     ls.print("create ");
  91     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
  92     ls.cr();
  93   }
  94 }
  95 

</pre><hr></hr><pre>
 742 // Returns true if this class loader data is a class loader data
 743 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
 744 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
 745 bool ClassLoaderData::is_permanent_class_loader_data() const {
 746   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();
 747 }
 748 
 749 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
 750   // If the metaspace has not been allocated, create a new one.  Might want
 751   // to create smaller arena for Reflection class loaders also.
 752   // The reason for the delayed allocation is because some class loaders are
 753   // simply for delegating with no metadata of their own.
 754   // Lock-free access requires load_acquire.
 755   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
 756   if (metaspace == NULL) {
 757     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
 758     // Check if _metaspace got allocated while we were waiting for this lock.
 759     if ((metaspace = _metaspace) == NULL) {
 760       if (this == the_null_class_loader_data()) {
 761         assert (class_loader() == NULL, "Must be");
<span class="changed"> 762         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);</span>
 763       } else if (has_class_mirror_holder()) {
<span class="changed"> 764         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);</span>
 765       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
<span class="changed"> 766         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);</span>
 767       } else {
<span class="changed"> 768         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);</span>
 769       }
 770       // Ensure _metaspace is stable, since it is examined without a lock
 771       Atomic::release_store(&amp;_metaspace, metaspace);
 772     }
 773   }
 774   return metaspace;
 775 }
 776 
 777 OopHandle ClassLoaderData::add_handle(Handle h) {
 778   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
 779   record_modified_oops();
 780   return _handles.add(h());
 781 }
 782 
 783 void ClassLoaderData::remove_handle(OopHandle h) {
 784   assert(!is_unloading(), "Do not remove a handle for a CLD that is unloading");
 785   oop* ptr = h.ptr_raw();
 786   if (ptr != NULL) {
 787     assert(_handles.owner_of(ptr), "Got unexpected handle " PTR_FORMAT, p2i(ptr));
 788     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));

</pre><hr></hr><pre>
 933 
 934   if (_jmethod_ids != NULL) {
 935     Method::print_jmethod_ids(this, out);
 936   }
 937   out-&gt;print(" handles count %d", _handles.count());
 938   out-&gt;print(" dependencies %d", _dependency_count);
 939   out-&gt;print_cr("}");
 940 }
 941 #endif // PRODUCT
 942 
 943 void ClassLoaderData::print() const { print_on(tty); }
 944 
 945 void ClassLoaderData::verify() {
 946   assert_locked_or_safepoint(_metaspace_lock);
 947   oop cl = class_loader();
 948 
 949   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
 950   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 951 
 952   // Verify the integrity of the allocated space.

 953   if (metaspace_or_null() != NULL) {
 954     metaspace_or_null()-&gt;verify();
 955   }

 956 
 957   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 958     guarantee(k-&gt;class_loader_data() == this, "Must be the same");
 959     k-&gt;verify();
 960     assert(k != k-&gt;next_link(), "no loops!");
 961   }
 962 }
 963 
 964 bool ClassLoaderData::contains_klass(Klass* klass) {
 965   // Lock-free access requires load_acquire
 966   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 967     if (k == klass) return true;
 968   }
 969   return false;
 970 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  42 //
  43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
  44 // that represent the loader's "linking domain" in the JVM.
  45 //
  46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
  47 // the singleton class the_null_class_loader_data().
  48 
  49 #include "precompiled.hpp"
  50 #include "classfile/classLoaderData.inline.hpp"
  51 #include "classfile/classLoaderDataGraph.inline.hpp"
  52 #include "classfile/dictionary.hpp"
  53 #include "classfile/javaClasses.hpp"
  54 #include "classfile/moduleEntry.hpp"
  55 #include "classfile/packageEntry.hpp"
  56 #include "classfile/symbolTable.hpp"
  57 #include "classfile/systemDictionary.hpp"
  58 #include "logging/log.hpp"
  59 #include "logging/logStream.hpp"
  60 #include "memory/allocation.inline.hpp"
  61 #include "memory/metadataFactory.hpp"
<span class="new">  62 #include "memory/metaspace/classLoaderMetaspace.hpp"</span>
<span class="new">  63 #include "memory/metaspace/metaspaceEnums.hpp"</span>
  64 #include "memory/resourceArea.hpp"
  65 #include "memory/universe.hpp"
  66 #include "oops/access.inline.hpp"
  67 #include "oops/oop.inline.hpp"
  68 #include "oops/oopHandle.inline.hpp"
  69 #include "oops/weakHandle.inline.hpp"
  70 #include "runtime/atomic.hpp"
  71 #include "runtime/handles.inline.hpp"
  72 #include "runtime/mutex.hpp"
  73 #include "runtime/safepoint.hpp"
  74 #include "utilities/growableArray.hpp"
  75 #include "utilities/macros.hpp"
  76 #include "utilities/ostream.hpp"
  77 
<span class="new">  78 using metaspace::ClassLoaderMetaspace;</span>
<span class="new">  79 </span>
  80 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
  81 
  82 void ClassLoaderData::init_null_class_loader_data() {
  83   assert(_the_null_class_loader_data == NULL, "cannot initialize twice");
  84   assert(ClassLoaderDataGraph::_head == NULL, "cannot initialize twice");
  85 
  86   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
  87   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
  88   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), "Must be");
  89 
  90   LogTarget(Trace, class, loader, data) lt;
  91   if (lt.is_enabled()) {
  92     ResourceMark rm;
  93     LogStream ls(lt);
  94     ls.print("create ");
  95     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
  96     ls.cr();
  97   }
  98 }
  99 

</pre><hr></hr><pre>
 746 // Returns true if this class loader data is a class loader data
 747 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
 748 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
 749 bool ClassLoaderData::is_permanent_class_loader_data() const {
 750   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();
 751 }
 752 
 753 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
 754   // If the metaspace has not been allocated, create a new one.  Might want
 755   // to create smaller arena for Reflection class loaders also.
 756   // The reason for the delayed allocation is because some class loaders are
 757   // simply for delegating with no metadata of their own.
 758   // Lock-free access requires load_acquire.
 759   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
 760   if (metaspace == NULL) {
 761     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
 762     // Check if _metaspace got allocated while we were waiting for this lock.
 763     if ((metaspace = _metaspace) == NULL) {
 764       if (this == the_null_class_loader_data()) {
 765         assert (class_loader() == NULL, "Must be");
<span class="changed"> 766         metaspace = new ClassLoaderMetaspace(_metaspace_lock, metaspace::BootMetaspaceType);</span>
 767       } else if (has_class_mirror_holder()) {
<span class="changed"> 768         metaspace = new ClassLoaderMetaspace(_metaspace_lock, metaspace::ClassMirrorHolderMetaspaceType);</span>
 769       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
<span class="changed"> 770         metaspace = new ClassLoaderMetaspace(_metaspace_lock, metaspace::ReflectionMetaspaceType);</span>
 771       } else {
<span class="changed"> 772         metaspace = new ClassLoaderMetaspace(_metaspace_lock, metaspace::StandardMetaspaceType);</span>
 773       }
 774       // Ensure _metaspace is stable, since it is examined without a lock
 775       Atomic::release_store(&amp;_metaspace, metaspace);
 776     }
 777   }
 778   return metaspace;
 779 }
 780 
 781 OopHandle ClassLoaderData::add_handle(Handle h) {
 782   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
 783   record_modified_oops();
 784   return _handles.add(h());
 785 }
 786 
 787 void ClassLoaderData::remove_handle(OopHandle h) {
 788   assert(!is_unloading(), "Do not remove a handle for a CLD that is unloading");
 789   oop* ptr = h.ptr_raw();
 790   if (ptr != NULL) {
 791     assert(_handles.owner_of(ptr), "Got unexpected handle " PTR_FORMAT, p2i(ptr));
 792     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));

</pre><hr></hr><pre>
 937 
 938   if (_jmethod_ids != NULL) {
 939     Method::print_jmethod_ids(this, out);
 940   }
 941   out-&gt;print(" handles count %d", _handles.count());
 942   out-&gt;print(" dependencies %d", _dependency_count);
 943   out-&gt;print_cr("}");
 944 }
 945 #endif // PRODUCT
 946 
 947 void ClassLoaderData::print() const { print_on(tty); }
 948 
 949 void ClassLoaderData::verify() {
 950   assert_locked_or_safepoint(_metaspace_lock);
 951   oop cl = class_loader();
 952 
 953   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
 954   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 955 
 956   // Verify the integrity of the allocated space.
<span class="new"> 957 #ifdef ASSERT</span>
 958   if (metaspace_or_null() != NULL) {
 959     metaspace_or_null()-&gt;verify();
 960   }
<span class="new"> 961 #endif</span>
 962 
 963   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 964     guarantee(k-&gt;class_loader_data() == this, "Must be the same");
 965     k-&gt;verify();
 966     assert(k != k-&gt;next_link(), "no loops!");
 967   }
 968 }
 969 
 970 bool ClassLoaderData::contains_klass(Klass* klass) {
 971   // Lock-free access requires load_acquire
 972   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 973     if (k == klass) return true;
 974   }
 975   return false;
 976 }
</pre></td>
</tr></table>
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderData.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
