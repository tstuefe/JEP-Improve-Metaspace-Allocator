<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60448">60448</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include "precompiled.hpp"
  25 #include "gc/shared/gcHeapSummary.hpp"
  26 #include "gc/shared/suspendibleThreadSet.hpp"
  27 #include "gc/z/zCollectedHeap.hpp"
  28 #include "gc/z/zDirector.hpp"
  29 #include "gc/z/zDriver.hpp"
  30 #include "gc/z/zGlobals.hpp"
  31 #include "gc/z/zHeap.inline.hpp"
  32 #include "gc/z/zNMethod.hpp"
  33 #include "gc/z/zObjArrayAllocator.hpp"
  34 #include "gc/z/zOop.inline.hpp"
  35 #include "gc/z/zServiceability.hpp"
  36 #include "gc/z/zStat.hpp"
  37 #include "gc/z/zUtils.inline.hpp"
<a name="1" id="anc1"></a><span class="new">  38 #include "memory/metaspace/classLoaderMetaspace.hpp"</span>
  39 #include "memory/iterator.hpp"
  40 #include "memory/universe.hpp"
  41 #include "runtime/mutexLocker.hpp"
  42 #include "utilities/align.hpp"
  43 
  44 ZCollectedHeap* ZCollectedHeap::heap() {
  45   return named_heap&lt;ZCollectedHeap&gt;(CollectedHeap::Z);
  46 }
  47 
  48 ZCollectedHeap::ZCollectedHeap() :
  49     _soft_ref_policy(),
  50     _barrier_set(),
  51     _initialize(&amp;_barrier_set),
  52     _heap(),
  53     _director(new ZDirector()),
  54     _driver(new ZDriver()),
  55     _stat(new ZStat()),
  56     _runtime_workers() {}
  57 
  58 CollectedHeap::Name ZCollectedHeap::kind() const {
  59   return CollectedHeap::Z;
  60 }
  61 
  62 const char* ZCollectedHeap::name() const {
  63   return ZName;
  64 }
  65 
  66 jint ZCollectedHeap::initialize() {
  67   if (!_heap.is_initialized()) {
  68     return JNI_ENOMEM;
  69   }
  70 
  71   Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);
  72 
  73   return JNI_OK;
  74 }
  75 
  76 void ZCollectedHeap::initialize_serviceability() {
  77   _heap.serviceability_initialize();
  78 }
  79 
  80 class ZStopConcurrentGCThreadClosure : public ThreadClosure {
  81 public:
  82   virtual void do_thread(Thread* thread) {
  83     if (thread-&gt;is_ConcurrentGC_thread() &amp;&amp;
  84         !thread-&gt;is_GC_task_thread()) {
  85       static_cast&lt;ConcurrentGCThread*&gt;(thread)-&gt;stop();
  86     }
  87   }
  88 };
  89 
  90 void ZCollectedHeap::stop() {
  91   ZStopConcurrentGCThreadClosure cl;
  92   gc_threads_do(&amp;cl);
  93 }
  94 
  95 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
  96   return &amp;_soft_ref_policy;
  97 }
  98 
  99 size_t ZCollectedHeap::max_capacity() const {
 100   return _heap.max_capacity();
 101 }
 102 
 103 size_t ZCollectedHeap::capacity() const {
 104   return _heap.capacity();
 105 }
 106 
 107 size_t ZCollectedHeap::used() const {
 108   return _heap.used();
 109 }
 110 
 111 size_t ZCollectedHeap::unused() const {
 112   return _heap.unused();
 113 }
 114 
 115 bool ZCollectedHeap::is_maximal_no_gc() const {
 116   // Not supported
 117   ShouldNotReachHere();
 118   return false;
 119 }
 120 
 121 bool ZCollectedHeap::is_in(const void* p) const {
 122   return _heap.is_in((uintptr_t)p);
 123 }
 124 
 125 uint32_t ZCollectedHeap::hash_oop(oop obj) const {
 126   return _heap.hash_oop(ZOop::to_address(obj));
 127 }
 128 
 129 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
 130   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
 131   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
 132 
 133   if (addr != 0) {
 134     *actual_size = requested_size;
 135   }
 136 
 137   return (HeapWord*)addr;
 138 }
 139 
 140 oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {
 141   if (!do_zero) {
 142     return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);
 143   }
 144 
 145   ZObjArrayAllocator allocator(klass, size, length, THREAD);
 146   return allocator.allocate();
 147 }
 148 
 149 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
 150   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
 151   return (HeapWord*)_heap.alloc_object(size_in_bytes);
 152 }
 153 
 154 MetaWord* ZCollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 155                                                              size_t size,
 156                                                              Metaspace::MetadataType mdtype) {
 157   MetaWord* result;
 158 
 159   // Start asynchronous GC
 160   collect(GCCause::_metadata_GC_threshold);
 161 
 162   // Expand and retry allocation
 163   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 164   if (result != NULL) {
 165     return result;
 166   }
 167 
 168   // Start synchronous GC
 169   collect(GCCause::_metadata_GC_clear_soft_refs);
 170 
 171   // Retry allocation
 172   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 173   if (result != NULL) {
 174     return result;
 175   }
 176 
 177   // Expand and retry allocation
 178   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 179   if (result != NULL) {
 180     return result;
 181   }
 182 
 183   // Out of memory
 184   return NULL;
 185 }
 186 
 187 void ZCollectedHeap::collect(GCCause::Cause cause) {
 188   _driver-&gt;collect(cause);
 189 }
 190 
 191 void ZCollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
 192   // These collection requests are ignored since ZGC can't run a synchronous
 193   // GC cycle from within the VM thread. This is considered benign, since the
 194   // only GC causes coming in here should be heap dumper and heap inspector.
 195   // However, neither the heap dumper nor the heap inspector really need a GC
 196   // to happen, but the result of their heap iterations might in that case be
 197   // less accurate since they might include objects that would otherwise have
 198   // been collected by a GC.
 199   assert(Thread::current()-&gt;is_VM_thread(), "Should be the VM thread");
 200   guarantee(cause == GCCause::_heap_dump ||
 201             cause == GCCause::_heap_inspection, "Invalid cause");
 202 }
 203 
 204 void ZCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
 205   // Not supported
 206   ShouldNotReachHere();
 207 }
 208 
 209 bool ZCollectedHeap::supports_tlab_allocation() const {
 210   return true;
 211 }
 212 
 213 size_t ZCollectedHeap::tlab_capacity(Thread* ignored) const {
 214   return _heap.tlab_capacity();
 215 }
 216 
 217 size_t ZCollectedHeap::tlab_used(Thread* ignored) const {
 218   return _heap.tlab_used();
 219 }
 220 
 221 size_t ZCollectedHeap::max_tlab_size() const {
 222   return _heap.max_tlab_size();
 223 }
 224 
 225 size_t ZCollectedHeap::unsafe_max_tlab_alloc(Thread* ignored) const {
 226   return _heap.unsafe_max_tlab_alloc();
 227 }
 228 
 229 bool ZCollectedHeap::can_elide_tlab_store_barriers() const {
 230   return false;
 231 }
 232 
 233 bool ZCollectedHeap::can_elide_initializing_store_barrier(oop new_obj) {
 234   // Not supported
 235   ShouldNotReachHere();
 236   return true;
 237 }
 238 
 239 bool ZCollectedHeap::card_mark_must_follow_store() const {
 240   // Not supported
 241   ShouldNotReachHere();
 242   return false;
 243 }
 244 
 245 GrowableArray&lt;GCMemoryManager*&gt; ZCollectedHeap::memory_managers() {
 246   return GrowableArray&lt;GCMemoryManager*&gt;(1, 1, _heap.serviceability_memory_manager());
 247 }
 248 
 249 GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
 250   return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
 251 }
 252 
 253 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
 254   _heap.object_iterate(cl, true /* visit_weaks */);
 255 }
 256 
 257 void ZCollectedHeap::keep_alive(oop obj) {
 258   _heap.keep_alive(obj);
 259 }
 260 
 261 void ZCollectedHeap::register_nmethod(nmethod* nm) {
 262   ZNMethod::register_nmethod(nm);
 263 }
 264 
 265 void ZCollectedHeap::unregister_nmethod(nmethod* nm) {
 266   ZNMethod::unregister_nmethod(nm);
 267 }
 268 
 269 void ZCollectedHeap::flush_nmethod(nmethod* nm) {
 270   ZNMethod::flush_nmethod(nm);
 271 }
 272 
 273 void ZCollectedHeap::verify_nmethod(nmethod* nm) {
 274   // Does nothing
 275 }
 276 
 277 WorkGang* ZCollectedHeap::get_safepoint_workers() {
 278   return _runtime_workers.workers();
 279 }
 280 
 281 jlong ZCollectedHeap::millis_since_last_gc() {
 282   return ZStatCycle::time_since_last() / MILLIUNITS;
 283 }
 284 
 285 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
 286   tc-&gt;do_thread(_director);
 287   tc-&gt;do_thread(_driver);
 288   tc-&gt;do_thread(_stat);
 289   _heap.threads_do(tc);
 290   _runtime_workers.threads_do(tc);
 291 }
 292 
 293 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
 294   return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());
 295 }
 296 
 297 void ZCollectedHeap::safepoint_synchronize_begin() {
 298   SuspendibleThreadSet::synchronize();
 299 }
 300 
 301 void ZCollectedHeap::safepoint_synchronize_end() {
 302   SuspendibleThreadSet::desynchronize();
 303 }
 304 
 305 void ZCollectedHeap::prepare_for_verify() {
 306   // Does nothing
 307 }
 308 
 309 void ZCollectedHeap::print_on(outputStream* st) const {
 310   _heap.print_on(st);
 311 }
 312 
 313 void ZCollectedHeap::print_on_error(outputStream* st) const {
 314   st-&gt;print_cr("ZGC Globals:");
 315   st-&gt;print_cr(" GlobalPhase:       %u (%s)", ZGlobalPhase, ZGlobalPhaseToString());
 316   st-&gt;print_cr(" GlobalSeqNum:      %u", ZGlobalSeqNum);
 317   st-&gt;print_cr(" Offset Max:        " SIZE_FORMAT "%s (" PTR_FORMAT ")",
 318                byte_size_in_exact_unit(ZAddressOffsetMax),
 319                exact_unit_for_byte_size(ZAddressOffsetMax),
 320                ZAddressOffsetMax);
 321   st-&gt;print_cr(" Page Size Small:   " SIZE_FORMAT "M", ZPageSizeSmall / M);
 322   st-&gt;print_cr(" Page Size Medium:  " SIZE_FORMAT "M", ZPageSizeMedium / M);
 323   st-&gt;cr();
 324   st-&gt;print_cr("ZGC Metadata Bits:");
 325   st-&gt;print_cr(" Good:              " PTR_FORMAT, ZAddressGoodMask);
 326   st-&gt;print_cr(" Bad:               " PTR_FORMAT, ZAddressBadMask);
 327   st-&gt;print_cr(" WeakBad:           " PTR_FORMAT, ZAddressWeakBadMask);
 328   st-&gt;print_cr(" Marked:            " PTR_FORMAT, ZAddressMetadataMarked);
 329   st-&gt;print_cr(" Remapped:          " PTR_FORMAT, ZAddressMetadataRemapped);
 330   st-&gt;cr();
 331   CollectedHeap::print_on_error(st);
 332 }
 333 
 334 void ZCollectedHeap::print_extended_on(outputStream* st) const {
 335   _heap.print_extended_on(st);
 336 }
 337 
 338 void ZCollectedHeap::print_tracing_info() const {
 339   // Does nothing
 340 }
 341 
 342 bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {
 343   return _heap.print_location(st, (uintptr_t)addr);
 344 }
 345 
 346 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
 347   _heap.verify();
 348 }
 349 
 350 bool ZCollectedHeap::is_oop(oop object) const {
 351   return _heap.is_oop(ZOop::to_address(object));
 352 }
 353 
 354 bool ZCollectedHeap::supports_concurrent_gc_breakpoints() const {
 355   return true;
 356 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
