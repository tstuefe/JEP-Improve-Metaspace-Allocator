<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/prims/whitebox.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 
  27 #include &lt;new&gt;
  28 
  29 #include "classfile/classLoaderDataGraph.hpp"
  30 #include "classfile/javaClasses.inline.hpp"
  31 #include "classfile/modules.hpp"
  32 #include "classfile/protectionDomainCache.hpp"
  33 #include "classfile/stringTable.hpp"
  34 #include "classfile/symbolTable.hpp"
  35 #include "code/codeCache.hpp"
  36 #include "compiler/compilationPolicy.hpp"
  37 #include "compiler/methodMatcher.hpp"
  38 #include "compiler/directivesParser.hpp"
  39 #include "gc/shared/concurrentGCBreakpoints.hpp"
  40 #include "gc/shared/gcConfig.hpp"
  41 #include "gc/shared/genArguments.hpp"
  42 #include "gc/shared/genCollectedHeap.hpp"
  43 #include "jvmtifiles/jvmtiEnv.hpp"
  44 #include "logging/log.hpp"
  45 #include "memory/filemap.hpp"
  46 #include "memory/heapShared.inline.hpp"
  47 #include "memory/metaspaceShared.hpp"
  48 #include "memory/metadataFactory.hpp"
  49 #include "memory/metaspace/metaspace_test.hpp"
  50 #include "memory/iterator.hpp"
  51 #include "memory/resourceArea.hpp"
  52 #include "memory/universe.hpp"
  53 #include "memory/oopFactory.hpp"
  54 #include "oops/array.hpp"
  55 #include "oops/compressedOops.hpp"
  56 #include "oops/constantPool.inline.hpp"
  57 #include "oops/method.inline.hpp"
  58 #include "oops/objArrayKlass.hpp"
  59 #include "oops/objArrayOop.inline.hpp"
  60 #include "oops/oop.inline.hpp"
  61 #include "oops/typeArrayOop.inline.hpp"
  62 #include "prims/resolvedMethodTable.hpp"
  63 #include "prims/wbtestmethods/parserTests.hpp"
  64 #include "prims/whitebox.inline.hpp"
  65 #include "runtime/arguments.hpp"
  66 #include "runtime/atomic.hpp"
  67 #include "runtime/deoptimization.hpp"
  68 #include "runtime/fieldDescriptor.inline.hpp"
  69 #include "runtime/flags/jvmFlag.hpp"
  70 #include "runtime/frame.inline.hpp"
  71 #include "runtime/handles.inline.hpp"
  72 #include "runtime/handshake.hpp"
  73 #include "runtime/interfaceSupport.inline.hpp"
  74 #include "runtime/javaCalls.hpp"
  75 #include "runtime/jniHandles.inline.hpp"
  76 #include "runtime/os.hpp"
  77 #include "runtime/sweeper.hpp"
  78 #include "runtime/synchronizer.hpp"
  79 #include "runtime/thread.hpp"
  80 #include "runtime/threadSMR.hpp"
  81 #include "runtime/vm_version.hpp"
  82 #include "services/memoryService.hpp"
  83 #include "utilities/align.hpp"
  84 #include "utilities/debug.hpp"
  85 #include "utilities/elfFile.hpp"
  86 #include "utilities/exceptions.hpp"
  87 #include "utilities/macros.hpp"
  88 #include "utilities/ostream.hpp"
  89 #if INCLUDE_CDS
  90 #include "prims/cdsoffsets.hpp"
  91 #endif // INCLUDE_CDS
  92 #if INCLUDE_G1GC
  93 #include "gc/g1/g1Arguments.hpp"
  94 #include "gc/g1/g1CollectedHeap.inline.hpp"
  95 #include "gc/g1/g1ConcurrentMark.hpp"
  96 #include "gc/g1/g1ConcurrentMarkThread.hpp"
  97 #include "gc/g1/heapRegionRemSet.hpp"
  98 #include "gc/g1/heterogeneousHeapRegionManager.hpp"
  99 #endif // INCLUDE_G1GC
 100 #if INCLUDE_PARALLELGC
 101 #include "gc/parallel/parallelScavengeHeap.inline.hpp"
 102 #endif // INCLUDE_PARALLELGC
 103 #if INCLUDE_NMT
 104 #include "services/mallocSiteTable.hpp"
 105 #include "services/memTracker.hpp"
 106 #include "utilities/nativeCallStack.hpp"
 107 #endif // INCLUDE_NMT
 108 #if INCLUDE_AOT
 109 #include "aot/aotLoader.hpp"
 110 #endif // INCLUDE_AOT
 111 
 112 #ifdef LINUX
 113 #include "osContainer_linux.hpp"
 114 #include "cgroupSubsystem_linux.hpp"
 115 #endif
 116 
 117 #define SIZE_T_MAX_VALUE ((size_t) -1)
 118 
 119 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 120   do {                                                                 \
 121     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 122     THREAD-&gt;clear_pending_jni_exception_check();                       \
 123     if (HAS_PENDING_EXCEPTION) {                                       \
 124       return(value);                                                   \
 125     }                                                                  \
 126   } while (0)
 127 
 128 #define CHECK_JNI_EXCEPTION(env)                                       \
 129   do {                                                                 \
 130     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 131     THREAD-&gt;clear_pending_jni_exception_check();                       \
 132     if (HAS_PENDING_EXCEPTION) {                                       \
 133       return;                                                          \
 134     }                                                                  \
 135   } while (0)
 136 
 137 bool WhiteBox::_used = false;
 138 volatile bool WhiteBox::compilation_locked = false;
 139 
 140 class VM_WhiteBoxOperation : public VM_Operation {
 141  public:
 142   VM_WhiteBoxOperation()                         { }
 143   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 144   bool allow_nested_vm_operations() const        { return true; }
 145 };
 146 
 147 
 148 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 149   return (jlong)(void*)JNIHandles::resolve(obj);
 150 WB_END
 151 
 152 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 153   return heapOopSize;
 154 WB_END
 155 
 156 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 157   return os::vm_page_size();
 158 WB_END
 159 
 160 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 161   return os::vm_allocation_granularity();
 162 WB_END
 163 
 164 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 165   return os::large_page_size();
 166 WB_END
 167 
 168 class WBIsKlassAliveClosure : public LockedClassesDo {
 169     Symbol* _name;
 170     int _count;
 171 public:
 172     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 173 
 174     void do_klass(Klass* k) {
 175       Symbol* ksym = k-&gt;name();
 176       if (ksym-&gt;fast_compare(_name) == 0) {
 177         _count++;
 178       }
 179     }
 180 
 181     int count() const {
 182         return _count;
 183     }
 184 };
 185 
 186 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 187   oop h_name = JNIHandles::resolve(name);
 188   if (h_name == NULL) return false;
 189   Symbol* sym = java_lang_String::as_symbol(h_name);
 190   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 191 
 192   WBIsKlassAliveClosure closure(sym);
 193   ClassLoaderDataGraph::classes_do(&amp;closure);
 194 
 195   // Return the count of alive classes with this name.
 196   return closure.count();
 197 WB_END
 198 
 199 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 200   oop h_name = JNIHandles::resolve(name);
 201   if (h_name == NULL) return false;
 202   Symbol* sym = java_lang_String::as_symbol(h_name);
 203   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 204   return (jint)sym-&gt;refcount();
 205 WB_END
 206 
 207 
 208 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 209 #if INCLUDE_JVMTI
 210   ResourceMark rm;
 211   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 212   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 213   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 214   assert(err == JVMTI_ERROR_NONE, "must not fail");
 215 #endif
 216 }
 217 WB_END
 218 
 219 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 220 #if INCLUDE_JVMTI
 221   ResourceMark rm;
 222   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 223   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 224   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 225   assert(err == JVMTI_ERROR_NONE, "must not fail");
 226 #endif
 227 }
 228 WB_END
 229 
 230 
 231 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 232   return (jlong)Arguments::max_heap_for_compressed_oops();
 233 }
 234 WB_END
 235 
 236 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 237   tty-&gt;print_cr("Minimum heap " SIZE_FORMAT " Initial heap " SIZE_FORMAT " "
 238                 "Maximum heap " SIZE_FORMAT " Space alignment " SIZE_FORMAT " Heap alignment " SIZE_FORMAT,
 239                 MinHeapSize,
 240                 InitialHeapSize,
 241                 MaxHeapSize,
 242                 SpaceAlignment,
 243                 HeapAlignment);
 244 }
 245 WB_END
 246 
 247 #ifndef PRODUCT
 248 // Forward declaration
 249 void TestReservedSpace_test();
 250 void TestReserveMemorySpecial_test();
 251 void TestVirtualSpace_test();
 252 #endif
 253 
 254 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 255 #ifndef PRODUCT
 256   TestReservedSpace_test();
 257   TestReserveMemorySpecial_test();
 258   TestVirtualSpace_test();
 259 #endif
 260 WB_END
 261 
 262 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 263   size_t granularity = os::vm_allocation_granularity();
 264   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 265   VirtualSpace vs;
 266   vs.initialize(rhs, 50 * granularity);
 267 
 268   // Check if constraints are complied
 269   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 270          CompressedOops::base() != NULL &amp;&amp;
 271          CompressedOops::use_implicit_null_checks() )) {
 272     tty-&gt;print_cr("WB_ReadFromNoaccessArea method is useless:\n "
 273                   "\tUseCompressedOops is %d\n"
 274                   "\trhs.base() is " PTR_FORMAT "\n"
 275                   "\tCompressedOops::base() is " PTR_FORMAT "\n"
 276                   "\tCompressedOops::use_implicit_null_checks() is %d",
 277                   UseCompressedOops,
 278                   p2i(rhs.base()),
 279                   p2i(CompressedOops::base()),
 280                   CompressedOops::use_implicit_null_checks());
 281     return;
 282   }
 283   tty-&gt;print_cr("Reading from no access area... ");
 284   tty-&gt;print_cr("*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c",
 285                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 286 WB_END
 287 
 288 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 289                                            size_t magnitude, size_t iterations) {
 290   size_t granularity = os::vm_allocation_granularity();
 291   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 292   VirtualSpace vs;
 293   if (!vs.initialize(rhs, 0)) {
 294     tty-&gt;print_cr("Failed to initialize VirtualSpace. Can't proceed.");
 295     return 3;
 296   }
 297 
 298   int seed = os::random();
 299   tty-&gt;print_cr("Random seed is %d", seed);
 300   os::init_random(seed);
 301 
 302   for (size_t i = 0; i &lt; iterations; i++) {
 303 
 304     // Whether we will shrink or grow
 305     bool shrink = os::random() % 2L == 0;
 306 
 307     // Get random delta to resize virtual space
 308     size_t delta = (size_t)os::random() % magnitude;
 309 
 310     // If we are about to shrink virtual space below zero, then expand instead
 311     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 312       shrink = false;
 313     }
 314 
 315     // Resizing by delta
 316     if (shrink) {
 317       vs.shrink_by(delta);
 318     } else {
 319       // If expanding fails expand_by will silently return false
 320       vs.expand_by(delta, true);
 321     }
 322   }
 323   return 0;
 324 }
 325 
 326 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 327         jlong reserved_space_size, jlong magnitude, jlong iterations))
 328   tty-&gt;print_cr("reservedSpaceSize=" JLONG_FORMAT ", magnitude=" JLONG_FORMAT ", "
 329                 "iterations=" JLONG_FORMAT "\n", reserved_space_size, magnitude,
 330                 iterations);
 331   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 332     tty-&gt;print_cr("One of variables printed above is negative. Can't proceed.\n");
 333     return 1;
 334   }
 335 
 336   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 337   // always 8 byte. That's why we should avoid overflow in case of 32bit platform.
 338   if (sizeof(size_t) &lt; sizeof(jlong)) {
 339     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 340     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 341         || iterations &gt; size_t_max_value) {
 342       tty-&gt;print_cr("One of variables printed above overflows size_t. Can't proceed.\n");
 343       return 2;
 344     }
 345   }
 346 
 347   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 348                                         (size_t) magnitude, (size_t) iterations);
 349 WB_END
 350 
 351 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 352   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 353 WB_END
 354 
 355 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 356   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 357 WB_END
 358 
 359 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 360   return GCConfig::is_gc_selected_ergonomically();
 361 WB_END
 362 
 363 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 364   oop p = JNIHandles::resolve(obj);
 365 #if INCLUDE_G1GC
 366   if (UseG1GC) {
 367     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 368     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 369     if (hr == NULL) {
 370       return false;
 371     }
 372     return !(hr-&gt;is_young());
 373   }
 374 #endif
 375 #if INCLUDE_PARALLELGC
 376   if (UseParallelGC) {
 377     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 378     return !psh-&gt;is_in_young(p);
 379   }
 380 #endif
 381 #if INCLUDE_ZGC
 382   if (UseZGC) {
 383     return Universe::heap()-&gt;is_in(p);
 384   }
 385 #endif
 386   GenCollectedHeap* gch = GenCollectedHeap::heap();
 387   return !gch-&gt;is_in_young(p);
 388 WB_END
 389 
 390 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 391   oop p = JNIHandles::resolve(obj);
 392   return p-&gt;size() * HeapWordSize;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 396   return (jlong)SpaceAlignment;
 397 WB_END
 398 
 399 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 400   return (jlong)HeapAlignment;
 401 WB_END
 402 
 403 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 404   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 405 WB_END
 406 
 407 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 408   ConcurrentGCBreakpoints::acquire_control();
 409 WB_END
 410 
 411 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 412   ConcurrentGCBreakpoints::release_control();
 413 WB_END
 414 
 415 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 416   ConcurrentGCBreakpoints::run_to_idle();
 417 WB_END
 418 
 419 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 420   Handle h_name(THREAD, JNIHandles::resolve(at));
 421   ResourceMark rm;
 422   const char* c_name = java_lang_String::as_utf8_string(h_name());
 423   return ConcurrentGCBreakpoints::run_to(c_name);
 424 WB_END
 425 
 426 #if INCLUDE_G1GC
 427 
 428 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 429   if (UseG1GC) {
 430     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 431     oop result = JNIHandles::resolve(obj);
 432     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 433     return hr-&gt;is_humongous();
 434   }
 435   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1IsHumongous: G1 GC is not enabled");
 436 WB_END
 437 
 438 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 439   if (UseG1GC) {
 440     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 441     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 442     return hr-&gt;is_humongous();
 443   }
 444   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToHumongousRegion: G1 GC is not enabled");
 445 WB_END
 446 
 447 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 448   if (UseG1GC) {
 449     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 450     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 451     return hr-&gt;is_free();
 452   }
 453   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToFreeRegion: G1 GC is not enabled");
 454 WB_END
 455 
 456 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 457   if (UseG1GC) {
 458     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 459     size_t nr = g1h-&gt;max_regions();
 460     return (jlong)nr;
 461   }
 462   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumMaxRegions: G1 GC is not enabled");
 463 WB_END
 464 
 465 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 466   if (UseG1GC) {
 467     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 468     size_t nr = g1h-&gt;num_free_regions();
 469     return (jlong)nr;
 470   }
 471   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumFreeRegions: G1 GC is not enabled");
 472 WB_END
 473 
 474 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 475   if (UseG1GC) {
 476     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 477     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 478   }
 479   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1InConcurrentMark: G1 GC is not enabled");
 480 WB_END
 481 
 482 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 483   if (UseG1GC) {
 484     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 485     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 486       g1h-&gt;collect(GCCause::_wb_conc_mark);
 487       return true;
 488     }
 489     return false;
 490   }
 491   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1StartMarkCycle: G1 GC is not enabled");
 492 WB_END
 493 
 494 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 495   if (UseG1GC) {
 496     return (jint)HeapRegion::GrainBytes;
 497   }
 498   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1RegionSize: G1 GC is not enabled");
 499 WB_END
 500 
 501 #endif // INCLUDE_G1GC
 502 
 503 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 504 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 505 #if INCLUDE_G1GC
 506   if (UseG1GC) {
 507     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 508     if (g1h-&gt;is_heterogeneous_heap()) {
 509       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 510       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 511     } else {
 512       return (jlong)g1h-&gt;base();
 513     }
 514   }
 515 #endif // INCLUDE_G1GC
 516 #if INCLUDE_PARALLELGC
 517   if (UseParallelGC) {
 518     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 519     if (AllocateOldGenAt != NULL) {
 520       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 521       return (jlong)reserved.start();
 522     } else {
 523       return (jlong)ps_heap-&gt;base();
 524     }
 525   }
 526 #endif // INCLUDE_PARALLELGC
 527   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedStart: enabled only for G1 and Parallel GC");
 528 WB_END
 529 
 530 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 531 #if INCLUDE_G1GC
 532   if (UseG1GC) {
 533     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 534     if (g1h-&gt;is_heterogeneous_heap()) {
 535       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 536       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 537     } else {
 538       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 539     }
 540   }
 541 #endif // INCLUDE_G1GC
 542 #if INCLUDE_PARALLELGC
 543   if (UseParallelGC) {
 544     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 545     if (AllocateOldGenAt != NULL) {
 546       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 547       return (jlong)reserved.end();
 548     } else {
 549       return (jlong)ps_heap-&gt;reserved_region().end();
 550     }
 551   }
 552 #endif // INCLUDE_PARALLELGC
 553   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedEnd: enabled only for G1 and Parallel GC");
 554 WB_END
 555 
 556 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 557 #if INCLUDE_G1GC
 558   if (UseG1GC) {
 559     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 560     if (g1h-&gt;is_heterogeneous_heap()) {
 561       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 562       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 563     } else {
 564       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 565     }
 566   }
 567 #endif // INCLUDE_G1GC
 568 #if INCLUDE_PARALLELGC
 569   if (UseParallelGC) {
 570     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 571     if (AllocateOldGenAt != NULL) {
 572       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 573       return (jlong)reserved.start();
 574     } else {
 575       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 576     }
 577   }
 578 #endif // INCLUDE_PARALLELGC
 579   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: enabled only for G1 and Parallel GC");
 580 WB_END
 581 
 582 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 583 #if INCLUDE_G1GC
 584   if (UseG1GC) {
 585     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 586     if (g1h-&gt;is_heterogeneous_heap()) {
 587       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 588       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 589     } else {
 590       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 591     }
 592   }
 593 #endif // INCLUDE_G1GC
 594 #if INCLUDE_PARALLELGC
 595   if (UseParallelGC) {
 596     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 597     if (AllocateOldGenAt != NULL) {
 598       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 599       return (jlong)reserved.end();
 600       } else {
 601       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 602     }
 603   }
 604 #endif // INCLUDE_PARALLELGC
 605   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC");
 606 WB_END
 607 
 608 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 609 
 610 #if INCLUDE_PARALLELGC
 611 
 612 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 613   if (UseParallelGC) {
 614     return GenAlignment;
 615   }
 616   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSVirtualSpaceAlignment: Parallel GC is not enabled");
 617 WB_END
 618 
 619 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 620   if (UseParallelGC) {
 621     return GenAlignment;
 622   }
 623   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSHeapGenerationAlignment: Parallel GC is not enabled");
 624 WB_END
 625 
 626 #endif // INCLUDE_PARALLELGC
 627 
 628 #if INCLUDE_G1GC
 629 
 630 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 631   if (UseG1GC) {
 632     ResourceMark rm(THREAD);
 633     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 634     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 635     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 636     return JNIHandles::make_local(THREAD, h());
 637   }
 638   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled");
 639 WB_END
 640 
 641 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 642   if (UseG1GC) {
 643     G1NUMA* numa = G1NUMA::numa();
 644     return (jint)numa-&gt;num_active_nodes();
 645   }
 646   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1ActiveMemoryNodeCount: G1 GC is not enabled");
 647 WB_END
 648 
 649 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 650   if (UseG1GC) {
 651     G1NUMA* numa = G1NUMA::numa();
 652     int num_node_ids = (int)numa-&gt;num_active_nodes();
 653     const int* node_ids = numa-&gt;node_ids();
 654 
 655     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 656     for (int i = 0; i &lt; num_node_ids; i++) {
 657       result-&gt;int_at_put(i, (jint)node_ids[i]);
 658     }
 659     return (jintArray) JNIHandles::make_local(THREAD, result);
 660   }
 661   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1MemoryNodeIds: G1 GC is not enabled");
 662 WB_END
 663 
 664 class OldRegionsLivenessClosure: public HeapRegionClosure {
 665 
 666  private:
 667   const int _liveness;
 668   size_t _total_count;
 669   size_t _total_memory;
 670   size_t _total_memory_to_free;
 671 
 672  public:
 673   OldRegionsLivenessClosure(int liveness) :
 674     _liveness(liveness),
 675     _total_count(0),
 676     _total_memory(0),
 677     _total_memory_to_free(0) { }
 678 
 679     size_t total_count() { return _total_count; }
 680     size_t total_memory() { return _total_memory; }
 681     size_t total_memory_to_free() { return _total_memory_to_free; }
 682 
 683   bool do_heap_region(HeapRegion* r) {
 684     if (r-&gt;is_old()) {
 685       size_t prev_live = r-&gt;marked_bytes();
 686       size_t live = r-&gt;live_bytes();
 687       size_t size = r-&gt;used();
 688       size_t reg_size = HeapRegion::GrainBytes;
 689       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 690         _total_memory += size;
 691         ++_total_count;
 692         if (size == reg_size) {
 693         // we don't include non-full regions since they are unlikely included in mixed gc
 694         // for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed
 695           _total_memory_to_free += size - prev_live;
 696         }
 697       }
 698     }
 699     return false;
 700   }
 701 };
 702 
 703 
 704 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 705   if (!UseG1GC) {
 706     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1GetMixedGCInfo: G1 GC is not enabled");
 707   }
 708   if (liveness &lt; 0) {
 709     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "liveness value should be non-negative");
 710   }
 711 
 712   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 713   OldRegionsLivenessClosure rli(liveness);
 714   g1h-&gt;heap_region_iterate(&amp;rli);
 715 
 716   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 717   result-&gt;long_at_put(0, rli.total_count());
 718   result-&gt;long_at_put(1, rli.total_memory());
 719   result-&gt;long_at_put(2, rli.total_memory_to_free());
 720   return (jlongArray) JNIHandles::make_local(THREAD, result);
 721 WB_END
 722 
 723 #endif // INCLUDE_G1GC
 724 
 725 #if INCLUDE_NMT
 726 // Alloc memory using the test memory type so that we can use that to see if
 727 // NMT picks it up correctly
 728 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 729   jlong addr = 0;
 730   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 731   return addr;
 732 WB_END
 733 
 734 // Alloc memory with pseudo call stack. The test can create psudo malloc
 735 // allocation site to stress the malloc tracking.
 736 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 737   address pc = (address)(size_t)pseudo_stack;
 738   NativeCallStack stack(&amp;pc, 1);
 739   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 740 WB_END
 741 
 742 // Alloc memory with pseudo call stack and specific memory type.
 743 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 744   address pc = (address)(size_t)pseudo_stack;
 745   NativeCallStack stack(&amp;pc, 1);
 746   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 747 WB_END
 748 
 749 // Free the memory allocated by NMTAllocTest
 750 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 751   os::free((void*)(uintptr_t)mem);
 752 WB_END
 753 
 754 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 755   jlong addr = 0;
 756 
 757   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 758   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 759 
 760   return addr;
 761 WB_END
 762 
 763 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 764   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 765   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 766 
 767   return addr;
 768 WB_END
 769 
 770 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 771   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 772   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 773 WB_END
 774 
 775 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 776   os::uncommit_memory((char *)(uintptr_t)addr, size);
 777 WB_END
 778 
 779 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 780   os::release_memory((char *)(uintptr_t)addr, size);
 781 WB_END
 782 
 783 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 784   // Test that we can downgrade NMT levels but not upgrade them.
 785   if (MemTracker::tracking_level() == NMT_off) {
 786     MemTracker::transition_to(NMT_off);
 787     return MemTracker::tracking_level() == NMT_off;
 788   } else {
 789     assert(MemTracker::tracking_level() == NMT_detail, "Should start out as detail tracking");
 790     MemTracker::transition_to(NMT_summary);
 791     assert(MemTracker::tracking_level() == NMT_summary, "Should be summary now");
 792 
 793     // Can't go to detail once NMT is set to summary.
 794     MemTracker::transition_to(NMT_detail);
 795     assert(MemTracker::tracking_level() == NMT_summary, "Should still be summary now");
 796 
 797     // Shutdown sets tracking level to minimal.
 798     MemTracker::shutdown();
 799     assert(MemTracker::tracking_level() == NMT_minimal, "Should be minimal now");
 800 
 801     // Once the tracking level is minimal, we cannot increase to summary.
 802     // The code ignores this request instead of asserting because if the malloc site
 803     // table overflows in another thread, it tries to change the code to summary.
 804     MemTracker::transition_to(NMT_summary);
 805     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 806 
 807     // Really can never go up to detail, verify that the code would never do this.
 808     MemTracker::transition_to(NMT_detail);
 809     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 810     return MemTracker::tracking_level() == NMT_minimal;
 811   }
 812 WB_END
 813 
 814 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 815   int hash_size = MallocSiteTable::hash_buckets();
 816   assert(hash_size &gt; 0, "NMT hash_size should be &gt; 0");
 817   return (jint)hash_size;
 818 WB_END
 819 
 820 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 821   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 822   return (jlong)arena;
 823 WB_END
 824 
 825 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 826   Arena* a = (Arena*)arena;
 827   delete a;
 828 WB_END
 829 
 830 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 831   Arena* a = (Arena*)arena;
 832   a-&gt;Amalloc(size_t(size));
 833 WB_END
 834 #endif // INCLUDE_NMT
 835 
 836 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 837   assert(method != NULL, "method should not be null");
 838   ThreadToNativeFromVM ttn(thread);
 839   return env-&gt;FromReflectedMethod(method);
 840 }
 841 
 842 static CompLevel highestCompLevel() {
 843   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 844 }
 845 
 846 // Deoptimizes all compiled frames and makes nmethods not entrant if it's requested
 847 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 848  private:
 849   int _result;
 850   const bool _make_not_entrant;
 851  public:
 852   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 853         _result(0), _make_not_entrant(make_not_entrant) { }
 854   int  result() const { return _result; }
 855 
 856   void doit() {
 857     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 858       if (t-&gt;has_last_Java_frame()) {
 859         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 860           frame* f = fst.current();
 861           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 862             Deoptimization::deoptimize(t, *f);
 863             if (_make_not_entrant) {
 864                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 865                 assert(cm != NULL, "sanity check");
 866                 cm-&gt;make_not_entrant();
 867             }
 868             ++_result;
 869           }
 870         }
 871       }
 872     }
 873   }
 874 };
 875 
 876 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 877   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 878   VMThread::execute(&amp;op);
 879   return op.result();
 880 WB_END
 881 
 882 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 883   CodeCache::mark_all_nmethods_for_deoptimization();
 884   Deoptimization::deoptimize_all_marked();
 885 WB_END
 886 
 887 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 888   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 889   int result = 0;
 890   CHECK_JNI_EXCEPTION_(env, result);
 891   MutexLocker mu(Compile_lock);
 892   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 893   if (is_osr) {
 894     result += mh-&gt;mark_osr_nmethods();
 895   } else if (mh-&gt;code() != NULL) {
 896     mh-&gt;code()-&gt;mark_for_deoptimization();
 897     ++result;
 898   }
 899   result += CodeCache::mark_for_deoptimization(mh());
 900   if (result &gt; 0) {
 901     Deoptimization::deoptimize_all_marked();
 902   }
 903   return result;
 904 WB_END
 905 
 906 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 907   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 908   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 909   MutexLocker mu(Compile_lock);
 910   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 911   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 912   if (code == NULL) {
 913     return JNI_FALSE;
 914   }
 915   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 916 WB_END
 917 
 918 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 919   if (method == NULL || comp_level &gt; highestCompLevel()) {
 920     return false;
 921   }
 922   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 923   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 924   MutexLocker mu(Compile_lock);
 925   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 926   if (is_osr) {
 927     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 928   } else {
 929     return CompilationPolicy::can_be_compiled(mh, comp_level);
 930   }
 931 WB_END
 932 
 933 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 934   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 935   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 936   MutexLocker mu(Compile_lock);
 937   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 938   return mh-&gt;queued_for_compilation();
 939 WB_END
 940 
 941 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 942   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 943     return false; // Intrinsic is not available on a non-existent compilation level.
 944   }
 945   jmethodID method_id, compilation_context_id;
 946   method_id = reflected_method_to_jmid(thread, env, method);
 947   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 948   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 949 
 950   DirectiveSet* directive;
 951   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 952   assert(comp != NULL, "compiler not available");
 953   if (compilation_context != NULL) {
 954     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 955     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 956     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 957     directive = DirectivesStack::getMatchingDirective(cch, comp);
 958   } else {
 959     // Calling with NULL matches default directive
 960     directive = DirectivesStack::getDefaultDirective(comp);
 961   }
 962   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 963   DirectivesStack::release(directive);
 964   return result;
 965 WB_END
 966 
 967 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 968   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 969   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 970   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 971   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 972   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 973 WB_END
 974 
 975 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 976   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 977   CHECK_JNI_EXCEPTION(env);
 978   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 979   if (is_osr) {
 980     mh-&gt;set_not_osr_compilable("WhiteBox", comp_level);
 981   } else {
 982     mh-&gt;set_not_compilable("WhiteBox", comp_level);
 983   }
 984 WB_END
 985 
 986 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 987   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 988   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 989   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 990   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 991   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 992 WB_END
 993 
 994 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 995   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 996   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 997   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 998   bool result = mh-&gt;dont_inline();
 999   mh-&gt;set_dont_inline(value == JNI_TRUE);
1000   return result;
1001 WB_END
1002 
1003 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1004   if (comp_level == CompLevel_any) {
1005     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1006         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1007   } else {
1008     return CompileBroker::queue_size(comp_level);
1009   }
1010 WB_END
1011 
1012 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1013   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1014   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1015   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1016   bool result = mh-&gt;force_inline();
1017   mh-&gt;set_force_inline(value == JNI_TRUE);
1018   return result;
1019 WB_END
1020 
1021 #ifdef LINUX
1022 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1023                                const char* proc_self_cgroup,
1024                                const char* proc_self_mountinfo,
1025                                u1* cg_flags) {
1026   CgroupInfo cg_infos[4];
1027   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1028                                                     proc_self_cgroup,
1029                                                     proc_self_mountinfo, cg_flags);
1030 }
1031 #endif
1032 
1033 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1034   // Screen for unavailable/bad comp level or null method
1035   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1036   if (method == NULL) {
1037     tty-&gt;print_cr("WB error: request to compile NULL method");
1038     return false;
1039   }
1040   if (comp_level &gt; highestCompLevel()) {
1041     tty-&gt;print_cr("WB error: invalid compilation level %d", comp_level);
1042     return false;
1043   }
1044   if (comp == NULL) {
1045     tty-&gt;print_cr("WB error: no compiler for requested compilation level %d", comp_level);
1046     return false;
1047   }
1048 
1049   // Check if compilation is blocking
1050   methodHandle mh(THREAD, method);
1051   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1052   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1053   DirectivesStack::release(directive);
1054 
1055   // Compile method and check result
1056   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1057   MutexLocker mu(THREAD, Compile_lock);
1058   bool is_queued = mh-&gt;queued_for_compilation();
1059   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1060     return true;
1061   }
1062   tty-&gt;print("WB error: failed to %s compile at level %d method ", is_blocking ? "blocking" : "", comp_level);
1063   mh-&gt;print_short_name(tty);
1064   tty-&gt;cr();
1065   if (is_blocking &amp;&amp; is_queued) {
1066     tty-&gt;print_cr("WB error: blocking compilation is still in queue!");
1067   }
1068   return false;
1069 }
1070 
1071 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1072   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1073   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1074   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1075 WB_END
1076 
1077 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1078   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1079   Method* clinit = ik-&gt;class_initializer();
1080   if (clinit == NULL) {
1081     return false;
1082   }
1083   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1084 WB_END
1085 
1086 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1087   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1088   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1089 
1090   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1091   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1092   bool result = directive-&gt;PrintAssemblyOption;
1093   DirectivesStack::release(directive);
1094 
1095   return result;
1096 WB_END
1097 
1098 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1099   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1100   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1101 
1102   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1103 
1104   ResourceMark rm(THREAD);
1105   const char* error_msg = NULL;
1106   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1107   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1108 
1109   if (m == NULL) {
1110     assert(error_msg != NULL, "Always have an error message");
1111     tty-&gt;print_cr("Got error: %s", error_msg);
1112     return -1; // Pattern failed
1113   }
1114 
1115   // Pattern works - now check if it matches
1116   int result;
1117   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1118     result = 2; // Force inline match
1119   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1120     result = 1; // Dont inline match
1121   } else {
1122     result = 0; // No match
1123   }
1124   delete m;
1125   return result;
1126 WB_END
1127 
1128 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1129   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1130   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1131 
1132   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1133 
1134   ResourceMark rm;
1135   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1136 
1137   const char* error_msg = NULL;
1138 
1139   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1140   if (m == NULL) {
1141     assert(error_msg != NULL, "Must have error_msg");
1142     tty-&gt;print_cr("Got error: %s", error_msg);
1143     return -1;
1144   }
1145 
1146   // Pattern works - now check if it matches
1147   int result = m-&gt;matches(mh);
1148   delete m;
1149   assert(result == 0 || result == 1, "Result out of range");
1150   return result;
1151 WB_END
1152 
1153 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1154   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1155   CHECK_JNI_EXCEPTION(env);
1156   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1157 
1158   MethodData* mdo = mh-&gt;method_data();
1159   if (mdo == NULL) {
1160     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1161     mdo = mh-&gt;method_data();
1162   }
1163   mdo-&gt;init();
1164   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1165   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1166   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1167   icnt-&gt;set(Tier4MinInvocationThreshold);
1168   bcnt-&gt;set(Tier4CompileThreshold);
1169 WB_END
1170 
1171 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1172   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1173   CHECK_JNI_EXCEPTION(env);
1174   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1175   MutexLocker mu(THREAD, Compile_lock);
1176   MethodData* mdo = mh-&gt;method_data();
1177   MethodCounters* mcs = mh-&gt;method_counters();
1178 
1179   if (mdo != NULL) {
1180     mdo-&gt;init();
1181     ResourceMark rm(THREAD);
1182     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1183     for (int i = 0; i &lt; arg_count; i++) {
1184       mdo-&gt;set_arg_modified(i, 0);
1185     }
1186     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1187     mdo-&gt;clean_method_data(/*always_clean*/true);
1188   }
1189 
1190   mh-&gt;clear_not_c1_compilable();
1191   mh-&gt;clear_not_c2_compilable();
1192   mh-&gt;clear_not_c2_osr_compilable();
1193   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1194   if (mcs != NULL) {
1195     mcs-&gt;backedge_counter()-&gt;init();
1196     mcs-&gt;invocation_counter()-&gt;init();
1197     mcs-&gt;set_interpreter_invocation_count(0);
1198     mcs-&gt;set_interpreter_throwout_count(0);
1199 
1200 #ifdef TIERED
1201     mcs-&gt;set_rate(0.0F);
1202     mh-&gt;set_prev_event_count(0);
1203     mh-&gt;set_prev_time(0);
1204 #endif
1205   }
1206 WB_END
1207 
1208 template &lt;typename T&gt;
1209 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1210   if (name == NULL) {
1211     return false;
1212   }
1213   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1214   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1215   CHECK_JNI_EXCEPTION_(env, false);
1216   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1217   JVMFlag::Error result = (*TAt)(flag, value);
1218   env-&gt;ReleaseStringUTFChars(name, flag_name);
1219   return (result == JVMFlag::SUCCESS);
1220 }
1221 
1222 template &lt;typename T&gt;
1223 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1224   if (name == NULL) {
1225     return false;
1226   }
1227   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1228   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1229   CHECK_JNI_EXCEPTION_(env, false);
1230   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1231   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1232   env-&gt;ReleaseStringUTFChars(name, flag_name);
1233   return (result == JVMFlag::SUCCESS);
1234 }
1235 
1236 template &lt;typename T&gt;
1237 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1238   ResourceMark rm(thread);
1239   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1240   CHECK_JNI_EXCEPTION_(env, NULL);
1241   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1242         vmSymbols::valueOf_name()-&gt;as_C_string(),
1243         sig-&gt;as_C_string());
1244   CHECK_JNI_EXCEPTION_(env, NULL);
1245   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1246   CHECK_JNI_EXCEPTION_(env, NULL);
1247   return result;
1248 }
1249 
1250 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1251   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1252 }
1253 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1254   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1255 }
1256 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1257   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1258 }
1259 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1260   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1261 }*/
1262 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1263   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1264 }
1265 
1266 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1267   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1268   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1269   CHECK_JNI_EXCEPTION_(env, NULL);
1270   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1271   env-&gt;ReleaseStringUTFChars(name, flag_name);
1272   return result;
1273 }
1274 
1275 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1276   const JVMFlag* flag = getVMFlag(thread, env, name);
1277   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1278 WB_END
1279 
1280 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1281   const JVMFlag* flag = getVMFlag(thread, env, name);
1282   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1283 WB_END
1284 
1285 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1286   bool result;
1287   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1288     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1289     return booleanBox(thread, env, result);
1290   }
1291   return NULL;
1292 WB_END
1293 
1294 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1295   int result;
1296   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1297     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1298     return longBox(thread, env, result);
1299   }
1300   return NULL;
1301 WB_END
1302 
1303 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1304   uint result;
1305   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1306     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1307     return longBox(thread, env, result);
1308   }
1309   return NULL;
1310 WB_END
1311 
1312 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1313   intx result;
1314   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1315     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1316     return longBox(thread, env, result);
1317   }
1318   return NULL;
1319 WB_END
1320 
1321 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1322   uintx result;
1323   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1324     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1325     return longBox(thread, env, result);
1326   }
1327   return NULL;
1328 WB_END
1329 
1330 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1331   uint64_t result;
1332   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1333     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1334     return longBox(thread, env, result);
1335   }
1336   return NULL;
1337 WB_END
1338 
1339 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1340   size_t result;
1341   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1342     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1343     return longBox(thread, env, result);
1344   }
1345   return NULL;
1346 WB_END
1347 
1348 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1349   double result;
1350   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1351     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1352     return doubleBox(thread, env, result);
1353   }
1354   return NULL;
1355 WB_END
1356 
1357 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1358   ccstr ccstrResult;
1359   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1360     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1361     jstring result = env-&gt;NewStringUTF(ccstrResult);
1362     CHECK_JNI_EXCEPTION_(env, NULL);
1363     return result;
1364   }
1365   return NULL;
1366 WB_END
1367 
1368 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1369   bool result = value == JNI_TRUE ? true : false;
1370   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1374   int result = value;
1375   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1376 WB_END
1377 
1378 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1379   uint result = value;
1380   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1381 WB_END
1382 
1383 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1384   intx result = value;
1385   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1386 WB_END
1387 
1388 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1389   uintx result = value;
1390   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1391 WB_END
1392 
1393 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1394   uint64_t result = value;
1395   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1396 WB_END
1397 
1398 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1399   size_t result = value;
1400   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1401 WB_END
1402 
1403 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1404   double result = value;
1405   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1406 WB_END
1407 
1408 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1409   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1410   const char* ccstrValue;
1411   if (value == NULL) {
1412     ccstrValue = NULL;
1413   }
1414   else {
1415     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1416     CHECK_JNI_EXCEPTION(env);
1417   }
1418   ccstr ccstrResult = ccstrValue;
1419   bool needFree;
1420   {
1421     ThreadInVMfromNative ttvfn(thread); // back to VM
1422     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1423   }
1424   if (value != NULL) {
1425     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1426   }
1427   if (needFree) {
1428     FREE_C_HEAP_ARRAY(char, ccstrResult);
1429   }
1430 WB_END
1431 
1432 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1433   WhiteBox::compilation_locked = true;
1434 WB_END
1435 
1436 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1437   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1438   WhiteBox::compilation_locked = false;
1439   mo.notify_all();
1440 WB_END
1441 
1442 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1443   // Force a code cache sweep and block until it finished
1444   NMethodSweeper::force_sweep();
1445 WB_END
1446 
1447 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1448   ResourceMark rm(THREAD);
1449   int len;
1450   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1451   return (StringTable::lookup(name, len) != NULL);
1452 WB_END
1453 
1454 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1455   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1456   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1457 #if INCLUDE_G1GC
1458   if (UseG1GC) {
1459     // Needs to be cleared explicitly for G1
1460     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1461   }
1462 #endif // INCLUDE_G1GC
1463 WB_END
1464 
1465 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1466   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1467 WB_END
1468 
1469 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1470   // static+volatile in order to force the read to happen
1471   // (not be eliminated by the compiler)
1472   static char c;
1473   static volatile char* p;
1474 
1475   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1476   if (p == NULL) {
1477     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to reserve memory");
1478   }
1479 
1480   c = *p;
1481 WB_END
1482 
1483 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1484   const char* features = VM_Version::features_string();
1485   ThreadToNativeFromVM ttn(thread);
1486   jstring features_string = env-&gt;NewStringUTF(features);
1487 
1488   CHECK_JNI_EXCEPTION_(env, NULL);
1489 
1490   return features_string;
1491 WB_END
1492 
1493 int WhiteBox::get_blob_type(const CodeBlob* code) {
1494   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1495   if (code-&gt;is_aot()) {
1496     return -1;
1497   }
1498   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1499 }
1500 
1501 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1502   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1503   return CodeCache::get_code_heap(blob_type);
1504 }
1505 
1506 struct CodeBlobStub {
1507   CodeBlobStub(const CodeBlob* blob) :
1508       name(os::strdup(blob-&gt;name())),
1509       size(blob-&gt;size()),
1510       blob_type(WhiteBox::get_blob_type(blob)),
1511       address((jlong) blob) { }
1512   ~CodeBlobStub() { os::free((void*) name); }
1513   const char* const name;
1514   const jint        size;
1515   const jint        blob_type;
1516   const jlong       address;
1517 };
1518 
1519 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1520   ResourceMark rm;
1521   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1522   CHECK_JNI_EXCEPTION_(env, NULL);
1523   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1524 
1525   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1526   CHECK_JNI_EXCEPTION_(env, NULL);
1527   env-&gt;SetObjectArrayElement(result, 0, name);
1528 
1529   jobject obj = integerBox(thread, env, cb-&gt;size);
1530   CHECK_JNI_EXCEPTION_(env, NULL);
1531   env-&gt;SetObjectArrayElement(result, 1, obj);
1532 
1533   obj = integerBox(thread, env, cb-&gt;blob_type);
1534   CHECK_JNI_EXCEPTION_(env, NULL);
1535   env-&gt;SetObjectArrayElement(result, 2, obj);
1536 
1537   obj = longBox(thread, env, cb-&gt;address);
1538   CHECK_JNI_EXCEPTION_(env, NULL);
1539   env-&gt;SetObjectArrayElement(result, 3, obj);
1540 
1541   return result;
1542 }
1543 
1544 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1545   ResourceMark rm(THREAD);
1546   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1547   CHECK_JNI_EXCEPTION_(env, NULL);
1548   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1549   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1550   jobjectArray result = NULL;
1551   if (code == NULL) {
1552     return result;
1553   }
1554   int comp_level = code-&gt;comp_level();
1555   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1556 
1557   ThreadToNativeFromVM ttn(thread);
1558   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1559   CHECK_JNI_EXCEPTION_(env, NULL);
1560   result = env-&gt;NewObjectArray(5, clazz, NULL);
1561   if (result == NULL) {
1562     return result;
1563   }
1564 
1565   CodeBlobStub stub(code);
1566   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1567   CHECK_JNI_EXCEPTION_(env, NULL);
1568   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1569 
1570   jobject level = integerBox(thread, env, comp_level);
1571   CHECK_JNI_EXCEPTION_(env, NULL);
1572   env-&gt;SetObjectArrayElement(result, 1, level);
1573 
1574   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1575   CHECK_JNI_EXCEPTION_(env, NULL);
1576   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1577   env-&gt;SetObjectArrayElement(result, 2, insts);
1578 
1579   jobject id = integerBox(thread, env, code-&gt;compile_id());
1580   CHECK_JNI_EXCEPTION_(env, NULL);
1581   env-&gt;SetObjectArrayElement(result, 3, id);
1582 
1583   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1584   CHECK_JNI_EXCEPTION_(env, NULL);
1585   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1586 
1587   return result;
1588 WB_END
1589 
1590 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1591   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1592   BufferBlob* blob;
1593   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1594   if (full_size &lt; size) {
1595     full_size += align_up(size - full_size, oopSize);
1596   }
1597   {
1598     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1599     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1600     if (blob != NULL) {
1601       ::new (blob) BufferBlob("WB::DummyBlob", full_size);
1602     }
1603   }
1604   // Track memory usage statistic after releasing CodeCache_lock
1605   MemoryService::track_code_cache_memory_usage();
1606   return blob;
1607 }
1608 
1609 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1610   if (size &lt; 0) {
1611     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1612       err_msg("WB_AllocateCodeBlob: size is negative: " INT32_FORMAT, size));
1613   }
1614   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1615 WB_END
1616 
1617 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1618   if (addr == 0) {
1619     return;
1620   }
1621   BufferBlob::free((BufferBlob*) addr);
1622 WB_END
1623 
1624 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1625   ResourceMark rm;
1626   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1627   {
1628     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1629     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1630     if (heap == NULL) {
1631       return NULL;
1632     }
1633     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1634          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1635       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1636       new (stub) CodeBlobStub(cb);
1637       blobs.append(stub);
1638     }
1639   }
1640   ThreadToNativeFromVM ttn(thread);
1641   jobjectArray result = NULL;
1642   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1643   CHECK_JNI_EXCEPTION_(env, NULL);
1644   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1645   CHECK_JNI_EXCEPTION_(env, NULL);
1646   if (result == NULL) {
1647     return result;
1648   }
1649   int i = 0;
1650   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1651        it != blobs.end(); ++it) {
1652     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1653     CHECK_JNI_EXCEPTION_(env, NULL);
1654     env-&gt;SetObjectArrayElement(result, i, obj);
1655     CHECK_JNI_EXCEPTION_(env, NULL);
1656     ++i;
1657   }
1658   return result;
1659 WB_END
1660 
1661 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1662   return CompileBroker::get_compilation_activity_mode();
1663 WB_END
1664 
1665 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1666   if (addr == 0) {
1667     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1668       "WB_GetCodeBlob: addr is null");
1669   }
1670   ThreadToNativeFromVM ttn(thread);
1671   CodeBlobStub stub((CodeBlob*) addr);
1672   return codeBlob2objectArray(thread, env, &amp;stub);
1673 WB_END
1674 
1675 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1676   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1677   CHECK_JNI_EXCEPTION_(env, 0);
1678   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1679   return (jlong) mh-&gt;method_data();
1680 WB_END
1681 
1682 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1683   return (jlong) thread-&gt;stack_size();
1684 WB_END
1685 
1686 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1687   return (jlong) thread-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1688 WB_END
1689 
1690 
1691 int WhiteBox::array_bytes_to_length(size_t bytes) {
1692   return Array&lt;u1&gt;::bytes_to_length(bytes);
1693 }
1694 
1695 ///////////////
1696 // MetaspaceTestContext and MetaspaceTestArena
1697 WB_ENTRY(jlong, WB_CreateMetaspaceTestContext(JNIEnv* env, jobject wb, jlong commit_limit, jlong reserve_limit))
1698   metaspace::MetaspaceTestContext* context =
1699       new metaspace::MetaspaceTestContext("whitebox-metaspace-context", (size_t) commit_limit, (size_t) reserve_limit);
1700   return (jlong)p2i(context);
1701 WB_END
1702 
1703 WB_ENTRY(void, WB_DestroyMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))
1704   delete (metaspace::MetaspaceTestContext*) context;
1705 WB_END
1706 
1707 WB_ENTRY(void, WB_PurgeMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))
1708   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;
1709   context0-&gt;purge_area();
1710 WB_END
1711 
1712 WB_ENTRY(void, WB_PrintMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))
1713   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;
1714   context0-&gt;print_on(tty);
1715 WB_END
1716 
1717 WB_ENTRY(jlong, WB_GetTotalCommittedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))
1718   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;
1719   return context0-&gt;committed_words();
1720 WB_END
1721 
1722 WB_ENTRY(jlong, WB_GetTotalUsedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))
1723   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;
1724   return context0-&gt;used_words();
1725 WB_END
1726 
1727 WB_ENTRY(jlong, WB_CreateArenaInTestContext(JNIEnv* env, jobject wb, jlong context, jboolean is_micro))
1728   const metaspace::MetaspaceType type = is_micro ? metaspace::ReflectionMetaspaceType : metaspace::StandardMetaspaceType;
1729   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;
1730   return (jlong)p2i(context0-&gt;create_arena(type));
1731 WB_END
1732 
1733 WB_ENTRY(void, WB_DestroyMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena))
1734   delete (metaspace::MetaspaceTestArena*) arena;
1735 WB_END
1736 
1737 WB_ENTRY(jlong, WB_AllocateFromMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong word_size))
1738   metaspace::MetaspaceTestArena* arena0 = (metaspace::MetaspaceTestArena*) arena;
1739   MetaWord* p = arena0-&gt;allocate((size_t) word_size);
1740   return (jlong)p2i(p);
1741 WB_END
1742 
1743 WB_ENTRY(void, WB_DeallocateToMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong p, jlong word_size))
1744   metaspace::MetaspaceTestArena* arena0 = (metaspace::MetaspaceTestArena*) arena;
1745   arena0-&gt;deallocate((MetaWord*)p, (size_t) word_size);
1746 WB_END
1747 
1748 WB_ENTRY(jlong, WB_GetMaxMetaspaceAllocationSize(JNIEnv* env, jobject wb))
1749   return (jlong) Metaspace::max_allocation_word_size() * BytesPerWord;
1750 WB_END
1751 
1752 //////////////
1753 
1754 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1755   if (size &lt; 0) {
1756     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1757         err_msg("WB_AllocateMetaspace: size is negative: " JLONG_FORMAT, size));
1758   }
1759 
1760   oop class_loader_oop = JNIHandles::resolve(class_loader);
1761   ClassLoaderData* cld = class_loader_oop != NULL
1762       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1763       : ClassLoaderData::the_null_class_loader_data();
1764 
1765   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1766 
1767   return (jlong)(uintptr_t)metadata;
1768 WB_END
1769 
1770 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1771                                 jstring version, jstring location, jobjectArray packages))
1772   Modules::define_module(module, is_open, version, location, packages, CHECK);
1773 WB_END
1774 
1775 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1776   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1777 WB_END
1778 
1779 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1780   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1781 WB_END
1782 
1783 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1784   Modules::add_module_exports(module, package, NULL, CHECK);
1785 WB_END
1786 
1787 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1788   Modules::add_reads_module(from_module, source_module, CHECK);
1789 WB_END
1790 
1791 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1792   if (inc &lt; 0) {
1793     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1794         err_msg("WB_IncMetaspaceCapacityUntilGC: inc is negative: " JLONG_FORMAT, inc));
1795   }
1796 
1797   jlong max_size_t = (jlong) ((size_t) -1);
1798   if (inc &gt; max_size_t) {
1799     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1800         err_msg("WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: " JLONG_FORMAT, inc));
1801   }
1802 
1803   size_t new_cap_until_GC = 0;
1804   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1805   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1806   if (!success) {
1807     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1808                 "WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC "
1809                 "due to contention with another thread");
1810   }
1811   return (jlong) new_cap_until_GC;
1812 WB_END
1813 
1814 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1815   return (jlong) MetaspaceGC::capacity_until_GC();
1816 WB_END
1817 
1818 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1819   return (jlong)Metaspace::reserve_alignment();
1820 WB_END
1821 
1822 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1823   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1824                                            Mutex::_safepoint_check_always :
1825                                            Mutex::_safepoint_check_never;
1826   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1827                                            Mutex::_no_safepoint_check_flag :
1828                                            Mutex::_safepoint_check_flag;
1829   MutexLocker ml(new Mutex(Mutex::leaf, "SFPT_Test_lock", true, sfpt_check_required),
1830                  sfpt_check_attempted);
1831 WB_END
1832 
1833 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1834   // Create a special lock violating condition in value
1835   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1836                                            Mutex::_safepoint_check_always :
1837                                            Mutex::_safepoint_check_never;
1838   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1839                                            Monitor::_safepoint_check_flag :
1840                                            Monitor::_no_safepoint_check_flag;
1841 
1842   MutexLocker ml(new Mutex(Mutex::special, "SpecialTest_lock", allowVMBlock, sfpt_check_required), safepoint_check);
1843   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1844   ThreadBlockInVM tbivm(thread);
1845 WB_END
1846 
1847 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1848   oop obj_oop = JNIHandles::resolve(obj);
1849   return (jboolean) obj_oop-&gt;mark().has_monitor();
1850 WB_END
1851 
1852 WB_ENTRY(jboolean, WB_DeflateIdleMonitors(JNIEnv* env, jobject wb))
1853   log_info(monitorinflation)("WhiteBox initiated DeflateIdleMonitors");
1854   return ObjectSynchronizer::request_deflate_idle_monitors();
1855 WB_END
1856 
1857 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1858   VM_ForceSafepoint force_safepoint_op;
1859   VMThread::execute(&amp;force_safepoint_op);
1860 WB_END
1861 
1862 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1863   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1864   return (jlong) ik-&gt;constants();
1865 WB_END
1866 
1867 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1868   return ConstantPool::CPCACHE_INDEX_TAG;
1869 WB_END
1870 
1871 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1872   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1873   ConstantPool* cp = ik-&gt;constants();
1874   if (cp-&gt;cache() == NULL) {
1875       return -1;
1876   }
1877   return cp-&gt;cache()-&gt;length();
1878 WB_END
1879 
1880 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1881   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1882   ConstantPool* cp = ik-&gt;constants();
1883   if (cp-&gt;cache() == NULL) {
1884     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), "Constant pool does not have a cache");
1885   }
1886   jint cpci = index;
1887   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1888   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1889     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Constant pool cache index is out of range");
1890   }
1891   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1892   return cpi;
1893 WB_END
1894 
1895 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1896   return ConstantPool::encode_invokedynamic_index(index);
1897 WB_END
1898 
1899 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1900   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1901   VMThread::execute(&amp;clear_ics);
1902 WB_END
1903 
1904 template &lt;typename T&gt;
1905 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1906   assert(value != NULL, "sanity");
1907   if (method == NULL || name == NULL) {
1908     return false;
1909   }
1910   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1911   CHECK_JNI_EXCEPTION_(env, false);
1912   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1913   // can't be in VM when we call JNI
1914   ThreadToNativeFromVM ttnfv(thread);
1915   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1916   CHECK_JNI_EXCEPTION_(env, false);
1917   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1918   env-&gt;ReleaseStringUTFChars(name, flag_name);
1919   return result;
1920 }
1921 
1922 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1923   bool result;
1924   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1925     // can't be in VM when we call JNI
1926     ThreadToNativeFromVM ttnfv(thread);
1927     return booleanBox(thread, env, result);
1928   }
1929   return NULL;
1930 WB_END
1931 
1932 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1933   intx result;
1934   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1935     // can't be in VM when we call JNI
1936     ThreadToNativeFromVM ttnfv(thread);
1937     return longBox(thread, env, result);
1938   }
1939   return NULL;
1940 WB_END
1941 
1942 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1943   uintx result;
1944   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1945     // can't be in VM when we call JNI
1946     ThreadToNativeFromVM ttnfv(thread);
1947     return longBox(thread, env, result);
1948   }
1949   return NULL;
1950 WB_END
1951 
1952 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1953   double result;
1954   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1955     // can't be in VM when we call JNI
1956     ThreadToNativeFromVM ttnfv(thread);
1957     return doubleBox(thread, env, result);
1958   }
1959   return NULL;
1960 WB_END
1961 
1962 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1963   ccstr ccstrResult;
1964   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1965     // can't be in VM when we call JNI
1966     ThreadToNativeFromVM ttnfv(thread);
1967     jstring result = env-&gt;NewStringUTF(ccstrResult);
1968     CHECK_JNI_EXCEPTION_(env, NULL);
1969     return result;
1970   }
1971   return NULL;
1972 WB_END
1973 
1974 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1975   const char* p = Arguments::get_default_shared_archive_path();
1976   ThreadToNativeFromVM ttn(thread);
1977   jstring path_string = env-&gt;NewStringUTF(p);
1978 
1979   CHECK_JNI_EXCEPTION_(env, NULL);
1980 
1981   return path_string;
1982 WB_END
1983 
1984 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1985   return UseSharedSpaces;
1986 WB_END
1987 
1988 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
1989   return FileMapInfo::memory_mapping_failed();
1990 WB_END
1991 
1992 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1993   oop obj_oop = JNIHandles::resolve(obj);
1994   return HeapShared::is_archived_object(obj_oop);
1995 WB_END
1996 
1997 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1998   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1999 WB_END
2000 
2001 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
2002   return !HeapShared::closed_archive_heap_region_mapped();
2003 WB_END
2004 
2005 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
2006   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2007   if (k-&gt;is_instance_klass()) {
2008     InstanceKlass *ik = InstanceKlass::cast(k);
2009     ConstantPool *cp = ik-&gt;constants();
2010     objArrayOop refs =  cp-&gt;resolved_references();
2011     return (jobject)JNIHandles::make_local(THREAD, refs);
2012   } else {
2013     return NULL;
2014   }
2015 WB_END
2016 
2017 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2018   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2019   if (!k-&gt;is_instance_klass()) {
2020     return;
2021   }
2022   InstanceKlass *ik = InstanceKlass::cast(k);
2023   ik-&gt;link_class(THREAD); // may throw verification error
2024 WB_END
2025 
2026 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2027   return HeapShared::open_archive_heap_region_mapped();
2028 WB_END
2029 
2030 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2031 #if INCLUDE_CDS
2032   return true;
2033 #else
2034   return false;
2035 #endif // INCLUDE_CDS
2036 WB_END
2037 
2038 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2039 #if COMPILER2_OR_JVMCI
2040   return true;
2041 #else
2042   return false;
2043 #endif
2044 WB_END
2045 
2046 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2047   return HeapShared::is_heap_object_archiving_allowed();
2048 WB_END
2049 
2050 
2051 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2052 #if INCLUDE_JFR
2053   return true;
2054 #else
2055   return false;
2056 #endif // INCLUDE_JFR
2057 WB_END
2058 
2059 #if INCLUDE_CDS
2060 
2061 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2062   ResourceMark rm;
2063   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2064   int result = CDSOffsets::find_offset(c_name);
2065   return (jint)result;
2066 WB_END
2067 
2068 #endif // INCLUDE_CDS
2069 
2070 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2071   class TraceSelfClosure : public HandshakeClosure {
2072     jint _num_threads_completed;
2073 
2074     void do_thread(Thread* th) {
2075       assert(th-&gt;is_Java_thread(), "sanity");
2076       JavaThread* jt = (JavaThread*)th;
2077       ResourceMark rm;
2078 
2079       jt-&gt;print_on(tty);
2080       jt-&gt;print_stack_on(tty);
2081       tty-&gt;cr();
2082       Atomic::inc(&amp;_num_threads_completed);
2083     }
2084 
2085   public:
2086     TraceSelfClosure(Thread* thread) : HandshakeClosure("WB_TraceSelf"), _num_threads_completed(0) {}
2087 
2088     jint num_threads_completed() const { return _num_threads_completed; }
2089   };
2090   TraceSelfClosure tsc(Thread::current());
2091 
2092   if (all_threads) {
2093     Handshake::execute(&amp;tsc);
2094   } else {
2095     oop thread_oop = JNIHandles::resolve(thread_handle);
2096     if (thread_oop != NULL) {
2097       JavaThread* target = java_lang_Thread::thread(thread_oop);
2098       Handshake::execute(&amp;tsc, target);
2099     }
2100   }
2101   return tsc.num_threads_completed();
2102 WB_END
2103 
2104 //Some convenience methods to deal with objects from java
2105 int WhiteBox::offset_for_field(const char* field_name, oop object,
2106     Symbol* signature_symbol) {
2107   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, "Field name not valid");
2108   Thread* THREAD = Thread::current();
2109 
2110   //Get the class of our object
2111   Klass* arg_klass = object-&gt;klass();
2112   //Turn it into an instance-klass
2113   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2114 
2115   //Create symbols to look for in the class
2116   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2117 
2118   //To be filled in with an offset of the field we're looking for
2119   fieldDescriptor fd;
2120 
2121   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2122   if (res == NULL) {
2123     tty-&gt;print_cr("Invalid layout of %s at %s", ik-&gt;external_name(),
2124         name_symbol-&gt;as_C_string());
2125     vm_exit_during_initialization("Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class");
2126   }
2127 
2128   //fetch the field at the offset we've found
2129   int dest_offset = fd.offset();
2130 
2131   return dest_offset;
2132 }
2133 
2134 
2135 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2136   int offset = offset_for_field(field_name, object,
2137       vmSymbols::string_signature());
2138   oop string = object-&gt;obj_field(offset);
2139   if (string == NULL) {
2140     return NULL;
2141   }
2142   const char* ret = java_lang_String::as_utf8_string(string);
2143   return ret;
2144 }
2145 
2146 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2147   int offset =
2148       offset_for_field(field_name, object, vmSymbols::bool_signature());
2149   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2150   return ret;
2151 }
2152 
2153 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2154   ResourceMark rm;
2155   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
2156 
2157   //  one by one registration natives for exception catching
2158   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2159   CHECK_JNI_EXCEPTION(env);
2160   for (int i = 0, n = method_count; i &lt; n; ++i) {
2161     // Skip dummy entries
2162     if (method_array[i].fnPtr == NULL) continue;
2163     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2164       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2165       if (throwable_obj != NULL) {
2166         env-&gt;ExceptionClear();
2167         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2168           // NoSuchMethodError is thrown when a method can't be found or a method is not native.
2169           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2170           tty-&gt;print_cr("Warning: 'NoSuchMethodError' on register of sun.hotspot.WhiteBox::%s%s",
2171               method_array[i].name, method_array[i].signature);
2172         }
2173       } else {
2174         // Registration failed unexpectedly.
2175         tty-&gt;print_cr("Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered",
2176             method_array[i].name, method_array[i].signature);
2177         env-&gt;UnregisterNatives(wbclass);
2178         break;
2179       }
2180     }
2181   }
2182 }
2183 
2184 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2185   // can't be in VM when we call JNI
2186   ThreadToNativeFromVM ttnfv(thread);
2187   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2188   CHECK_JNI_EXCEPTION_(env, 0);
2189   int ret;
2190   {
2191     ThreadInVMfromNative ttvfn(thread); // back to VM
2192     ret = DirectivesParser::parse_string(dir, tty);
2193   }
2194   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2195   // -1 for error parsing directive. Return 0 as number of directives added.
2196   if (ret == -1) {
2197     ret = 0;
2198   }
2199   return (jint) ret;
2200 WB_END
2201 
2202 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2203   DirectivesStack::pop(count);
2204 WB_END
2205 
2206 // Checks that the library libfile has the noexecstack bit set.
2207 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2208   jboolean ret = false;
2209 #ifdef LINUX
2210   // Can't be in VM when we call JNI.
2211   ThreadToNativeFromVM ttnfv(thread);
2212   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2213   CHECK_JNI_EXCEPTION_(env, 0);
2214   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2215   env-&gt;ReleaseStringUTFChars(libfile, lf);
2216 #endif
2217   return ret;
2218 WB_END
2219 
2220 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2221   LINUX_ONLY(return OSContainer::is_containerized();)
2222   return false;
2223 WB_END
2224 
2225 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2226                                     jobject o,
2227                                     jstring proc_cgroups,
2228                                     jstring proc_self_cgroup,
2229                                     jstring proc_self_mountinfo))
2230   jint ret = 0;
2231 #ifdef LINUX
2232   ThreadToNativeFromVM ttnfv(thread);
2233   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2234   CHECK_JNI_EXCEPTION_(env, 0);
2235   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2236   CHECK_JNI_EXCEPTION_(env, 0);
2237   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2238   CHECK_JNI_EXCEPTION_(env, 0);
2239   u1 cg_type_flags = 0;
2240   // This sets cg_type_flags
2241   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2242   ret = (jint)cg_type_flags;
2243   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2244   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2245   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2246 #endif
2247   return ret;
2248 WB_END
2249 
2250 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2251   os::print_os_info(tty);
2252 WB_END
2253 
2254 // Elf decoder
2255 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2256 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2257   ElfFile::_do_not_cache_elf_section = true;
2258 #endif
2259 WB_END
2260 
2261 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2262   return (jlong) ResolvedMethodTable::items_count();
2263 WB_END
2264 
2265 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2266   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2267 WB_END
2268 
2269 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2270   jint result = 0;
2271 #if INCLUDE_AOT
2272   result = (jint) AOTLoader::heaps_count();
2273 #endif
2274   return result;
2275 WB_END
2276 
2277 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2278   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2279   // Return size in bytes.
2280   return k-&gt;size() * wordSize;
2281 WB_END
2282 
2283 // See test/hotspot/jtreg/runtime/Thread/ThreadObjAccessAtExit.java.
2284 // It explains how the thread's priority field is used for test state coordination.
2285 //
2286 WB_ENTRY(void, WB_CheckThreadObjOfTerminatingThread(JNIEnv* env, jobject wb, jobject target_handle))
2287   oop target_oop = JNIHandles::resolve_non_null(target_handle);
2288   jlong tid = java_lang_Thread::thread_id(target_oop);
2289   JavaThread* target = java_lang_Thread::thread(target_oop);
2290 
2291   // Grab a ThreadsListHandle to protect the target thread whilst terminating
2292   ThreadsListHandle tlh;
2293 
2294   // Look up the target thread by tid to ensure it is present
2295   JavaThread* t = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
2296   if (t == NULL) {
2297     THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread not found in ThreadsList!");
2298   }
2299 
2300   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is protected");
2301   // Allow target to terminate by boosting priority
2302   java_lang_Thread::set_priority(t-&gt;threadObj(), ThreadPriority(NormPriority + 1));
2303 
2304   // Now wait for the target to terminate
2305   while (!target-&gt;is_terminated()) {
2306     ThreadBlockInVM tbivm(thread);  // just in case target is involved in a safepoint
2307     os::naked_short_sleep(0);
2308   }
2309 
2310   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is terminated");
2311 
2312   // Now release the GC inducing thread - we have to re-resolve the external oop that
2313   // was passed in as GC may have occurred and we don't know if we can trust t-&gt;threadObj() now.
2314   oop original = JNIHandles::resolve_non_null(target_handle);
2315   java_lang_Thread::set_priority(original, ThreadPriority(NormPriority + 2));
2316 
2317   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: GC has been initiated - checking threadObj:");
2318 
2319   // The Java code should be creating garbage and triggering GC, which would potentially move
2320   // the threadObj oop. If the exiting thread is properly protected then its threadObj should
2321   // remain valid and equal to our initial target_handle. Loop a few times to give GC a chance to
2322   // kick in.
2323   for (int i = 0; i &lt; 5; i++) {
2324     oop original = JNIHandles::resolve_non_null(target_handle);
2325     oop current = t-&gt;threadObj();
2326     if (original != current) {
2327       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: failed comparison on iteration %d", i);
2328       THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread oop has changed!");
2329     } else {
2330       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: successful comparison on iteration %d", i);
2331       ThreadBlockInVM tbivm(thread);
2332       os::naked_short_sleep(50);
2333     }
2334   }
2335 WB_END
2336 
2337 #define CC (char*)
2338 
2339 static JNINativeMethod methods[] = {
2340   {CC"getObjectAddress0",                CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectAddress  },
2341   {CC"getObjectSize0",                   CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectSize     },
2342   {CC"isObjectInOldGen0",                CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_isObjectInOldGen  },
2343   {CC"getHeapOopSize",                   CC"()I",                   (void*)&amp;WB_GetHeapOopSize    },
2344   {CC"getVMPageSize",                    CC"()I",                   (void*)&amp;WB_GetVMPageSize     },
2345   {CC"getVMAllocationGranularity",       CC"()J",                   (void*)&amp;WB_GetVMAllocationGranularity },
2346   {CC"getVMLargePageSize",               CC"()J",                   (void*)&amp;WB_GetVMLargePageSize},
2347   {CC"getHeapSpaceAlignment",            CC"()J",                   (void*)&amp;WB_GetHeapSpaceAlignment},
2348   {CC"getHeapAlignment",                 CC"()J",                   (void*)&amp;WB_GetHeapAlignment},
2349   {CC"countAliveClasses0",               CC"(Ljava/lang/String;)I", (void*)&amp;WB_CountAliveClasses },
2350   {CC"getSymbolRefcount",                CC"(Ljava/lang/String;)I", (void*)&amp;WB_GetSymbolRefcount },
2351   {CC"parseCommandLine0",
2352       CC"(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;",
2353       (void*) &amp;WB_ParseCommandLine
2354   },
2355   {CC"addToBootstrapClassLoaderSearch0", CC"(Ljava/lang/String;)V",
2356                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2357   {CC"addToSystemClassLoaderSearch0",    CC"(Ljava/lang/String;)V",
2358                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2359   {CC"getCompressedOopsMaxHeapSize", CC"()J",
2360       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2361   {CC"printHeapSizes",     CC"()V",                   (void*)&amp;WB_PrintHeapSizes    },
2362   {CC"runMemoryUnitTests", CC"()V",                   (void*)&amp;WB_RunMemoryUnitTests},
2363   {CC"readFromNoaccessArea",CC"()V",                  (void*)&amp;WB_ReadFromNoaccessArea},
2364   {CC"stressVirtualSpaceResize",CC"(JJJ)I",           (void*)&amp;WB_StressVirtualSpaceResize},
2365 #if INCLUDE_CDS
2366   {CC"getOffsetForName0", CC"(Ljava/lang/String;)I",  (void*)&amp;WB_GetOffsetForName},
2367 #endif
2368 #if INCLUDE_G1GC
2369   {CC"g1InConcurrentMark", CC"()Z",                   (void*)&amp;WB_G1InConcurrentMark},
2370   {CC"g1IsHumongous0",      CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_G1IsHumongous     },
2371   {CC"g1BelongsToHumongousRegion0", CC"(J)Z",         (void*)&amp;WB_G1BelongsToHumongousRegion},
2372   {CC"g1BelongsToFreeRegion0", CC"(J)Z",              (void*)&amp;WB_G1BelongsToFreeRegion},
2373   {CC"g1NumMaxRegions",    CC"()J",                   (void*)&amp;WB_G1NumMaxRegions  },
2374   {CC"g1NumFreeRegions",   CC"()J",                   (void*)&amp;WB_G1NumFreeRegions  },
2375   {CC"g1RegionSize",       CC"()I",                   (void*)&amp;WB_G1RegionSize      },
2376   {CC"g1StartConcMarkCycle",       CC"()Z",           (void*)&amp;WB_G1StartMarkCycle  },
2377   {CC"g1AuxiliaryMemoryUsage", CC"()Ljava/lang/management/MemoryUsage;",
2378                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2379   {CC"g1ActiveMemoryNodeCount", CC"()I",              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2380   {CC"g1MemoryNodeIds",    CC"()[I",                  (void*)&amp;WB_G1MemoryNodeIds },
2381   {CC"g1GetMixedGCInfo",   CC"(I)[J",                 (void*)&amp;WB_G1GetMixedGCInfo },
2382 #endif // INCLUDE_G1GC
2383 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2384   {CC"dramReservedStart",   CC"()J",                  (void*)&amp;WB_DramReservedStart },
2385   {CC"dramReservedEnd",     CC"()J",                  (void*)&amp;WB_DramReservedEnd },
2386   {CC"nvdimmReservedStart", CC"()J",                  (void*)&amp;WB_NvdimmReservedStart },
2387   {CC"nvdimmReservedEnd",   CC"()J",                  (void*)&amp;WB_NvdimmReservedEnd },
2388 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2389 #if INCLUDE_PARALLELGC
2390   {CC"psVirtualSpaceAlignment",CC"()J",               (void*)&amp;WB_PSVirtualSpaceAlignment},
2391   {CC"psHeapGenerationAlignment",CC"()J",             (void*)&amp;WB_PSHeapGenerationAlignment},
2392 #endif
2393 #if INCLUDE_NMT
2394   {CC"NMTMalloc",           CC"(J)J",                 (void*)&amp;WB_NMTMalloc          },
2395   {CC"NMTMallocWithPseudoStack", CC"(JI)J",           (void*)&amp;WB_NMTMallocWithPseudoStack},
2396   {CC"NMTMallocWithPseudoStackAndType", CC"(JII)J",   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2397   {CC"NMTFree",             CC"(J)V",                 (void*)&amp;WB_NMTFree            },
2398   {CC"NMTReserveMemory",    CC"(J)J",                 (void*)&amp;WB_NMTReserveMemory   },
2399   {CC"NMTAttemptReserveMemoryAt",    CC"(JJ)J",       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2400   {CC"NMTCommitMemory",     CC"(JJ)V",                (void*)&amp;WB_NMTCommitMemory    },
2401   {CC"NMTUncommitMemory",   CC"(JJ)V",                (void*)&amp;WB_NMTUncommitMemory  },
2402   {CC"NMTReleaseMemory",    CC"(JJ)V",                (void*)&amp;WB_NMTReleaseMemory   },
2403   {CC"NMTChangeTrackingLevel", CC"()Z",               (void*)&amp;WB_NMTChangeTrackingLevel},
2404   {CC"NMTGetHashSize",      CC"()I",                  (void*)&amp;WB_NMTGetHashSize     },
2405   {CC"NMTNewArena",         CC"(J)J",                 (void*)&amp;WB_NMTNewArena        },
2406   {CC"NMTFreeArena",        CC"(J)V",                 (void*)&amp;WB_NMTFreeArena       },
2407   {CC"NMTArenaMalloc",      CC"(JJ)V",                (void*)&amp;WB_NMTArenaMalloc     },
2408 #endif // INCLUDE_NMT
2409   {CC"deoptimizeFrames",   CC"(Z)I",                  (void*)&amp;WB_DeoptimizeFrames  },
2410   {CC"deoptimizeAll",      CC"()V",                   (void*)&amp;WB_DeoptimizeAll     },
2411   {CC"deoptimizeMethod0",   CC"(Ljava/lang/reflect/Executable;Z)I",
2412                                                       (void*)&amp;WB_DeoptimizeMethod  },
2413   {CC"isMethodCompiled0",   CC"(Ljava/lang/reflect/Executable;Z)Z",
2414                                                       (void*)&amp;WB_IsMethodCompiled  },
2415   {CC"isMethodCompilable0", CC"(Ljava/lang/reflect/Executable;IZ)Z",
2416                                                       (void*)&amp;WB_IsMethodCompilable},
2417   {CC"isMethodQueuedForCompilation0",
2418       CC"(Ljava/lang/reflect/Executable;)Z",          (void*)&amp;WB_IsMethodQueuedForCompilation},
2419   {CC"isIntrinsicAvailable0",
2420       CC"(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z",
2421                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2422   {CC"makeMethodNotCompilable0",
2423       CC"(Ljava/lang/reflect/Executable;IZ)V",        (void*)&amp;WB_MakeMethodNotCompilable},
2424   {CC"testSetDontInlineMethod0",
2425       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetDontInlineMethod},
2426   {CC"getMethodCompilationLevel0",
2427       CC"(Ljava/lang/reflect/Executable;Z)I",         (void*)&amp;WB_GetMethodCompilationLevel},
2428   {CC"getMethodEntryBci0",
2429       CC"(Ljava/lang/reflect/Executable;)I",          (void*)&amp;WB_GetMethodEntryBci},
2430   {CC"getCompileQueueSize",
2431       CC"(I)I",                                       (void*)&amp;WB_GetCompileQueueSize},
2432   {CC"testSetForceInlineMethod0",
2433       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetForceInlineMethod},
2434   {CC"enqueueMethodForCompilation0",
2435       CC"(Ljava/lang/reflect/Executable;II)Z",        (void*)&amp;WB_EnqueueMethodForCompilation},
2436   {CC"enqueueInitializerForCompilation0",
2437       CC"(Ljava/lang/Class;I)Z",                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2438   {CC"markMethodProfiled",
2439       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_MarkMethodProfiled},
2440   {CC"clearMethodState0",
2441       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_ClearMethodState},
2442   {CC"lockCompilation",    CC"()V",                   (void*)&amp;WB_LockCompilation},
2443   {CC"unlockCompilation",  CC"()V",                   (void*)&amp;WB_UnlockCompilation},
2444   {CC"matchesMethod",
2445       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2446                                                       (void*)&amp;WB_MatchesMethod},
2447   {CC"matchesInline",
2448       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2449                                                       (void*)&amp;WB_MatchesInline},
2450   {CC"shouldPrintAssembly",
2451         CC"(Ljava/lang/reflect/Executable;I)Z",
2452                                                         (void*)&amp;WB_ShouldPrintAssembly},
2453 
2454   {CC"isConstantVMFlag",   CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsConstantVMFlag},
2455   {CC"isLockedVMFlag",     CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsLockedVMFlag},
2456   {CC"setBooleanVMFlag",   CC"(Ljava/lang/String;Z)V",(void*)&amp;WB_SetBooleanVMFlag},
2457   {CC"setIntVMFlag",       CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntVMFlag},
2458   {CC"setUintVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintVMFlag},
2459   {CC"setIntxVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntxVMFlag},
2460   {CC"setUintxVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintxVMFlag},
2461   {CC"setUint64VMFlag",    CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUint64VMFlag},
2462   {CC"setSizeTVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetSizeTVMFlag},
2463   {CC"setDoubleVMFlag",    CC"(Ljava/lang/String;D)V",(void*)&amp;WB_SetDoubleVMFlag},
2464   {CC"setStringVMFlag",    CC"(Ljava/lang/String;Ljava/lang/String;)V",
2465                                                       (void*)&amp;WB_SetStringVMFlag},
2466   {CC"getBooleanVMFlag",   CC"(Ljava/lang/String;)Ljava/lang/Boolean;",
2467                                                       (void*)&amp;WB_GetBooleanVMFlag},
2468   {CC"getIntVMFlag",       CC"(Ljava/lang/String;)Ljava/lang/Long;",
2469                                                       (void*)&amp;WB_GetIntVMFlag},
2470   {CC"getUintVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2471                                                       (void*)&amp;WB_GetUintVMFlag},
2472   {CC"getIntxVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2473                                                       (void*)&amp;WB_GetIntxVMFlag},
2474   {CC"getUintxVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2475                                                       (void*)&amp;WB_GetUintxVMFlag},
2476   {CC"getUint64VMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Long;",
2477                                                       (void*)&amp;WB_GetUint64VMFlag},
2478   {CC"getSizeTVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2479                                                       (void*)&amp;WB_GetSizeTVMFlag},
2480   {CC"getDoubleVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Double;",
2481                                                       (void*)&amp;WB_GetDoubleVMFlag},
2482   {CC"getStringVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/String;",
2483                                                       (void*)&amp;WB_GetStringVMFlag},
2484   {CC"isInStringTable",    CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsInStringTable  },
2485   {CC"fullGC",   CC"()V",                             (void*)&amp;WB_FullGC },
2486   {CC"youngGC",  CC"()V",                             (void*)&amp;WB_YoungGC },
2487   {CC"readReservedMemory", CC"()V",                   (void*)&amp;WB_ReadReservedMemory },
2488   {CC"allocateMetaspace",
2489      CC"(Ljava/lang/ClassLoader;J)J",                 (void*)&amp;WB_AllocateMetaspace },
2490   {CC"incMetaspaceCapacityUntilGC", CC"(J)J",         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2491   {CC"metaspaceCapacityUntilGC", CC"()J",             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2492   {CC"metaspaceReserveAlignment", CC"()J",            (void*)&amp;WB_MetaspaceReserveAlignment },
2493   {CC"getCPUFeatures",     CC"()Ljava/lang/String;",  (void*)&amp;WB_GetCPUFeatures     },
2494   {CC"getNMethod0",         CC"(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;",
2495                                                       (void*)&amp;WB_GetNMethod         },
2496   {CC"forceNMethodSweep",  CC"()V",                   (void*)&amp;WB_ForceNMethodSweep  },
2497   {CC"allocateCodeBlob",   CC"(II)J",                 (void*)&amp;WB_AllocateCodeBlob   },
2498   {CC"freeCodeBlob",       CC"(J)V",                  (void*)&amp;WB_FreeCodeBlob       },
2499   {CC"getCodeHeapEntries", CC"(I)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeHeapEntries },
2500   {CC"getCompilationActivityMode",
2501                            CC"()I",                   (void*)&amp;WB_GetCompilationActivityMode},
2502   {CC"getMethodData0",     CC"(Ljava/lang/reflect/Executable;)J",
2503                                                       (void*)&amp;WB_GetMethodData      },
2504   {CC"getCodeBlob",        CC"(J)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeBlob        },
2505   {CC"getThreadStackSize", CC"()J",                   (void*)&amp;WB_GetThreadStackSize },
2506   {CC"getThreadRemainingStackSize", CC"()J",          (void*)&amp;WB_GetThreadRemainingStackSize },
2507   {CC"DefineModule",       CC"(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V",
2508                                                       (void*)&amp;WB_DefineModule },
2509   {CC"AddModuleExports",   CC"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V",
2510                                                       (void*)&amp;WB_AddModuleExports },
2511   {CC"AddReadsModule",     CC"(Ljava/lang/Object;Ljava/lang/Object;)V",
2512                                                       (void*)&amp;WB_AddReadsModule },
2513   {CC"AddModuleExportsToAllUnnamed", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2514                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2515   {CC"AddModuleExportsToAll", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2516                                                       (void*)&amp;WB_AddModuleExportsToAll },
2517   {CC"assertMatchingSafepointCalls", CC"(ZZ)V",       (void*)&amp;WB_AssertMatchingSafepointCalls },
2518   {CC"assertSpecialLock",  CC"(ZZ)V",                 (void*)&amp;WB_AssertSpecialLock },
2519   {CC"deflateIdleMonitors", CC"()Z",                  (void*)&amp;WB_DeflateIdleMonitors },
2520   {CC"isMonitorInflated0", CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsMonitorInflated  },
2521   {CC"forceSafepoint",     CC"()V",                   (void*)&amp;WB_ForceSafepoint     },
2522   {CC"getConstantPool0",   CC"(Ljava/lang/Class;)J",  (void*)&amp;WB_GetConstantPool    },
2523   {CC"getConstantPoolCacheIndexTag0", CC"()I",  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2524   {CC"getConstantPoolCacheLength0", CC"(Ljava/lang/Class;)I",  (void*)&amp;WB_GetConstantPoolCacheLength},
2525   {CC"remapInstructionOperandFromCPCache0",
2526       CC"(Ljava/lang/Class;I)I",                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2527   {CC"encodeConstantPoolIndyIndex0",
2528       CC"(I)I",                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2529   {CC"getMethodBooleanOption",
2530       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;",
2531                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2532   {CC"getMethodIntxOption",
2533       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2534                                                       (void*)&amp;WB_GetMethodIntxOption},
2535   {CC"getMethodUintxOption",
2536       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2537                                                       (void*)&amp;WB_GetMethodUintxOption},
2538   {CC"getMethodDoubleOption",
2539       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;",
2540                                                       (void*)&amp;WB_GetMethodDoubleOption},
2541   {CC"getMethodStringOption",
2542       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;",
2543                                                       (void*)&amp;WB_GetMethodStringOption},
2544   {CC"getDefaultArchivePath",             CC"()Ljava/lang/String;",
2545                                                       (void*)&amp;WB_GetDefaultArchivePath},
2546   {CC"isSharingEnabled",   CC"()Z",                   (void*)&amp;WB_IsSharingEnabled},
2547   {CC"isShared",           CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsShared },
2548   {CC"isSharedClass",      CC"(Ljava/lang/Class;)Z",  (void*)&amp;WB_IsSharedClass },
2549   {CC"areSharedStringsIgnored",           CC"()Z",    (void*)&amp;WB_AreSharedStringsIgnored },
2550   {CC"getResolvedReferences", CC"(Ljava/lang/Class;)Ljava/lang/Object;", (void*)&amp;WB_GetResolvedReferences},
2551   {CC"linkClass",          CC"(Ljava/lang/Class;)V",  (void*)&amp;WB_LinkClass},
2552   {CC"areOpenArchiveHeapObjectsMapped",   CC"()Z",    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2553   {CC"isCDSIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2554   {CC"isJFRIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2555   {CC"isC2OrJVMCIIncludedInVmBuild",      CC"()Z",    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2556   {CC"isJavaHeapArchiveSupported",        CC"()Z",    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2557   {CC"cdsMemoryMappingFailed",            CC"()Z",    (void*)&amp;WB_CDSMemoryMappingFailed },
2558 
2559   {CC"clearInlineCaches0",  CC"(Z)V",                 (void*)&amp;WB_ClearInlineCaches },
2560   {CC"handshakeWalkStack", CC"(Ljava/lang/Thread;Z)I", (void*)&amp;WB_HandshakeWalkStack },
2561   {CC"checkThreadObjOfTerminatingThread", CC"(Ljava/lang/Thread;)V", (void*)&amp;WB_CheckThreadObjOfTerminatingThread },
2562   {CC"addCompilerDirective",    CC"(Ljava/lang/String;)I",
2563                                                       (void*)&amp;WB_AddCompilerDirective },
2564   {CC"removeCompilerDirective",   CC"(I)V",           (void*)&amp;WB_RemoveCompilerDirective },
2565   {CC"isGCSupported",             CC"(I)Z",           (void*)&amp;WB_IsGCSupported},
2566   {CC"isGCSelected",              CC"(I)Z",           (void*)&amp;WB_IsGCSelected},
2567   {CC"isGCSelectedErgonomically", CC"()Z",            (void*)&amp;WB_IsGCSelectedErgonomically},
2568   {CC"supportsConcurrentGCBreakpoints", CC"()Z",      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2569   {CC"concurrentGCAcquireControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCAcquireControl},
2570   {CC"concurrentGCReleaseControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCReleaseControl},
2571   {CC"concurrentGCRunToIdle0",    CC"()V",            (void*)&amp;WB_ConcurrentGCRunToIdle},
2572   {CC"concurrentGCRunTo0",        CC"(Ljava/lang/String;)Z",
2573                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2574   {CC"checkLibSpecifiesNoexecstack", CC"(Ljava/lang/String;)Z",
2575                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2576   {CC"isContainerized",           CC"()Z",            (void*)&amp;WB_IsContainerized },
2577   {CC"validateCgroup",
2578       CC"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
2579                                                       (void*)&amp;WB_ValidateCgroup },
2580   {CC"printOsInfo",               CC"()V",            (void*)&amp;WB_PrintOsInfo },
2581   {CC"disableElfSectionCache",    CC"()V",            (void*)&amp;WB_DisableElfSectionCache },
2582   {CC"resolvedMethodItemsCount",  CC"()J",            (void*)&amp;WB_ResolvedMethodItemsCount },
2583   {CC"protectionDomainRemovedCount",   CC"()I",       (void*)&amp;WB_ProtectionDomainRemovedCount },
2584   {CC"aotLibrariesCount", CC"()I",                    (void*)&amp;WB_AotLibrariesCount },
2585   {CC"getKlassMetadataSize", CC"(Ljava/lang/Class;)I",(void*)&amp;WB_GetKlassMetadataSize},
2586 
2587   {CC"createMetaspaceTestContext", CC"(JJ)J",         (void*)&amp;WB_CreateMetaspaceTestContext},
2588   {CC"destroyMetaspaceTestContext", CC"(J)V",         (void*)&amp;WB_DestroyMetaspaceTestContext},
2589   {CC"purgeMetaspaceTestContext", CC"(J)V",           (void*)&amp;WB_PurgeMetaspaceTestContext},
2590   {CC"printMetaspaceTestContext", CC"(J)V",           (void*)&amp;WB_PrintMetaspaceTestContext},
2591   {CC"getTotalCommittedWordsInMetaspaceTestContext", CC"(J)J",(void*)&amp;WB_GetTotalCommittedWordsInMetaspaceTestContext},
2592   {CC"getTotalUsedWordsInMetaspaceTestContext", CC"(J)J", (void*)&amp;WB_GetTotalUsedWordsInMetaspaceTestContext},
2593   {CC"createArenaInTestContext", CC"(JZ)J",           (void*)&amp;WB_CreateArenaInTestContext},
2594   {CC"destroyMetaspaceTestArena", CC"(J)V",           (void*)&amp;WB_DestroyMetaspaceTestArena},
2595   {CC"allocateFromMetaspaceTestArena", CC"(JJ)J",     (void*)&amp;WB_AllocateFromMetaspaceTestArena},
2596   {CC"deallocateToMetaspaceTestArena", CC"(JJJ)V",    (void*)&amp;WB_DeallocateToMetaspaceTestArena},
2597   {CC"maxMetaspaceAllocationSize", CC"()J",           (void*)&amp;WB_GetMaxMetaspaceAllocationSize},
2598 
2599 };
2600 
2601 
2602 #undef CC
2603 
2604 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2605   {
2606     if (WhiteBoxAPI) {
2607       // Make sure that wbclass is loaded by the null classloader
2608       InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));
2609       Handle loader(THREAD, ik-&gt;class_loader());
2610       if (loader.is_null()) {
2611         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2612         WhiteBox::set_used();
2613       }
2614     }
2615   }
2616 JVM_END
</pre></body></html>
