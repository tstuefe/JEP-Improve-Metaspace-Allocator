<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_metaspacearena.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2020 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 
  28 #include "memory/metaspace/msArena.hpp"
  29 #include "memory/metaspace/msArenaGrowthPolicy.hpp"
  30 #include "memory/metaspace/msCommitLimiter.hpp"
  31 #include "memory/metaspace/msCounter.hpp"
  32 #include "memory/metaspace/msInternalStats.hpp"
  33 #include "memory/metaspace/msSettings.hpp"
  34 #include "memory/metaspace/msStatistics.hpp"
  35 #include "runtime/mutex.hpp"
  36 #include "runtime/mutexLocker.hpp"
  37 #include "utilities/debug.hpp"
  38 #include "utilities/globalDefinitions.hpp"
  39 
  40 //#define LOG_PLEASE
  41 #include "metaspaceGtestCommon.hpp"
  42 #include "metaspaceGtestContexts.hpp"
  43 #include "metaspaceGtestRangeHelpers.hpp"
  44 
  45 using metaspace::ArenaGrowthPolicy;
  46 using metaspace::CommitLimiter;
  47 using metaspace::InternalStats;
  48 using metaspace::MemRangeCounter;
  49 using metaspace::MetaspaceArena;
  50 using metaspace::SizeAtomicCounter;
  51 using metaspace::Settings;
  52 using metaspace::ArenaStats;
  53 
  54 class MetaspaceArenaTestHelper {
  55 
  56   MetaspaceGtestContext&amp; _context;
  57 
  58   Mutex* _lock;
  59   const ArenaGrowthPolicy* _growth_policy;
  60   SizeAtomicCounter _used_words_counter;
  61   MetaspaceArena* _arena;
  62 
  63   void initialize(const ArenaGrowthPolicy* growth_policy, const char* name = "gtest-MetaspaceArena") {
  64     _growth_policy = growth_policy;
  65     _lock = new Mutex(Monitor::native, "gtest-MetaspaceArenaTest-lock", false, Monitor::_safepoint_check_never);
  66     // Lock during space creation, since this is what happens in the VM too
  67     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
  68     {
  69       MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
  70       _arena = new MetaspaceArena(&amp;_context.cm(), _growth_policy, _lock, &amp;_used_words_counter, name);
  71     }
  72     DEBUG_ONLY(_arena-&gt;verify());
  73 
  74   }
  75 
  76 public:
  77 
  78   // Create a helper; growth policy for arena is determined by the given spacetype|class tupel
  79   MetaspaceArenaTestHelper(MetaspaceGtestContext&amp; helper,
  80                             Metaspace::MetaspaceType space_type, bool is_class,
  81                             const char* name = "gtest-MetaspaceArena")
  82     :_context(helper)
  83   {
  84     initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), name);
  85   }
  86 
  87   // Create a helper; growth policy is directly specified
  88   MetaspaceArenaTestHelper(MetaspaceGtestContext&amp; helper, const ArenaGrowthPolicy* growth_policy,
  89                             const char* name = "gtest-MetaspaceArena")
  90     :_context(helper)
  91   {
  92     initialize(growth_policy, name);
  93   }
  94 
  95   ~MetaspaceArenaTestHelper() {
  96     delete_arena_with_tests();
  97     delete _lock;
  98   }
  99 
 100   const CommitLimiter&amp; limiter() const { return _context.commit_limiter(); }
 101   MetaspaceArena* arena() const { return _arena; }
 102   SizeAtomicCounter&amp; used_words_counter() { return _used_words_counter; }
 103 
 104   // Note: all test functions return void due to gtests limitation that we cannot use ASSERT
 105   // in non-void returning tests.
 106 
 107   void delete_arena_with_tests() {
 108     if (_arena != NULL) {
 109       size_t used_words_before = _used_words_counter.get();
 110       size_t committed_words_before = limiter().committed_words();
 111       DEBUG_ONLY(_arena-&gt;verify());
 112       delete _arena;
 113       _arena = NULL;
 114       size_t used_words_after = _used_words_counter.get();
 115       size_t committed_words_after = limiter().committed_words();
 116       ASSERT_0(used_words_after);
 117       if (Settings::uncommit_free_chunks()) {
 118         ASSERT_LE(committed_words_after, committed_words_before);
 119       } else {
 120         ASSERT_EQ(committed_words_after, committed_words_before);
 121       }
 122     }
 123   }
 124 
 125   void usage_numbers_with_test(size_t* p_used, size_t* p_committed, size_t* p_capacity) const {
 126     _arena-&gt;usage_numbers(p_used, p_committed, p_capacity);
 127     if (p_used != NULL) {
 128       if (p_committed != NULL) {
 129         ASSERT_GE(*p_committed, *p_used);
 130       }
 131       // Since we own the used words counter, it should reflect our usage number 1:1
 132       ASSERT_EQ(_used_words_counter.get(), *p_used);
 133     }
 134     if (p_committed != NULL &amp;&amp; p_capacity != NULL) {
 135       ASSERT_GE(*p_capacity, *p_committed);
 136     }
 137   }
 138 
 139   // Allocate; caller expects success; return pointer in *p_return_value
 140   void allocate_from_arena_with_tests_expect_success(MetaWord** p_return_value, size_t word_size) {
 141     allocate_from_arena_with_tests(p_return_value, word_size);
 142     ASSERT_NOT_NULL(*p_return_value);
 143   }
 144 
 145   // Allocate; caller expects success but is not interested in return value
 146   void allocate_from_arena_with_tests_expect_success(size_t word_size) {
 147     MetaWord* dummy = NULL;
 148     allocate_from_arena_with_tests_expect_success(&amp;dummy, word_size);
 149   }
 150 
 151   // Allocate; caller expects failure
 152   void allocate_from_arena_with_tests_expect_failure(size_t word_size) {
 153     MetaWord* dummy = NULL;
 154     allocate_from_arena_with_tests(&amp;dummy, word_size);
 155     ASSERT_NULL(dummy);
 156   }
 157 
 158   // Allocate; it may or may not work; return value in *p_return_value
 159   void allocate_from_arena_with_tests(MetaWord** p_return_value, size_t word_size) {
 160 
 161     // Note: usage_numbers walks all chunks in use and counts.
 162     size_t used = 0, committed = 0, capacity = 0;
 163     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 164 
 165     size_t possible_expansion = limiter().possible_expansion_words();
 166 
 167     MetaWord* p = _arena-&gt;allocate(word_size);
 168 
 169     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify();))
 170 
 171     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 172     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 173 
 174     if (p == NULL) {
 175       // Allocation failed.
 176       if (Settings::new_chunks_are_fully_committed()) {
 177         ASSERT_LT(possible_expansion, MAX_CHUNK_WORD_SIZE);
 178       } else {
 179         ASSERT_LT(possible_expansion, word_size);
 180       }
 181 
 182       ASSERT_EQ(used, used2);
 183       ASSERT_EQ(committed, committed2);
 184       ASSERT_EQ(capacity, capacity2);
 185     } else {
 186       // Allocation succeeded. Should be correctly aligned.
 187       ASSERT_TRUE(is_aligned(p, sizeof(MetaWord)));
 188       // used: may go up or may not (since our request may have been satisfied from the freeblocklist
 189       //   whose content already counts as used).
 190       // committed: may go up, may not
 191       // capacity: ditto
 192       ASSERT_GE(used2, used);
 193       ASSERT_GE(committed2, committed);
 194       ASSERT_GE(capacity2, capacity);
 195     }
 196 
 197     *p_return_value = p;
 198   }
 199 
 200   // Allocate; it may or may not work; but caller does not care for the result value
 201   void allocate_from_arena_with_tests(size_t word_size) {
 202     MetaWord* dummy = NULL;
 203     allocate_from_arena_with_tests(&amp;dummy, word_size);
 204   }
 205 
 206   void deallocate_with_tests(MetaWord* p, size_t word_size) {
 207     size_t used = 0, committed = 0, capacity = 0;
 208     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 209 
 210     _arena-&gt;deallocate(p, word_size);
 211 
 212     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify();))
 213 
 214     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 215     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 216 
 217     // Nothing should have changed. Deallocated blocks are added to the free block list
 218     // which still counts as used.
 219     ASSERT_EQ(used2, used);
 220     ASSERT_EQ(committed2, committed);
 221     ASSERT_EQ(capacity2, capacity);
 222   }
 223 
 224   ArenaStats get_arena_statistics() const {
 225     ArenaStats stats;
 226     _arena-&gt;add_to_statistics(&amp;stats);
 227     return stats;
 228   }
 229 
 230   // Convenience method to return number of chunks in arena (including current chunk)
 231   int get_number_of_chunks() const {
 232     return get_arena_statistics().totals()._num;
 233   }
 234 
 235 };
 236 
 237 static void test_basics(size_t commit_limit, bool is_micro) {
 238   MetaspaceGtestContext context(commit_limit);
 239   MetaspaceArenaTestHelper helper(context, is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType, false);
 240 
 241   helper.allocate_from_arena_with_tests(1);
 242   helper.allocate_from_arena_with_tests(128);
 243   helper.allocate_from_arena_with_tests(128 * K);
 244   helper.allocate_from_arena_with_tests(1);
 245   helper.allocate_from_arena_with_tests(128);
 246   helper.allocate_from_arena_with_tests(128 * K);
 247 }
 248 
 249 TEST_VM(metaspace, MetaspaceArena_basics_micro_nolimit) {
 250   test_basics(max_uintx, true);
 251 }
 252 
 253 TEST_VM(metaspace, MetaspaceArena_basics_micro_limit) {
 254   test_basics(256 * K, true);
 255 }
 256 
 257 TEST_VM(metaspace, MetaspaceArena_basics_standard_nolimit) {
 258   test_basics(max_uintx, false);
 259 }
 260 
 261 TEST_VM(metaspace, MetaspaceArena_basics_standard_limit) {
 262   test_basics(256 * K, false);
 263 }
 264 
 265 // Test chunk enlargement:
 266 //  A single MetaspaceArena, left undisturbed with place to grow. Slowly fill arena up.
 267 //  We should see at least some occurrences of chunk-in-place enlargement.
 268 static void test_chunk_enlargment_simple(Metaspace::MetaspaceType spacetype, bool is_class) {
 269 
 270   MetaspaceGtestContext context;
 271   MetaspaceArenaTestHelper helper(context, (Metaspace::MetaspaceType)spacetype, is_class);
 272 
 273   uint64_t n1 = metaspace::InternalStats::num_chunks_enlarged();
 274 
 275   size_t allocated = 0;
 276   while (allocated &lt;= MAX_CHUNK_WORD_SIZE &amp;&amp;
 277          metaspace::InternalStats::num_chunks_enlarged() == n1) {
 278     size_t s = IntRange(32, 128).random_value();
 279     helper.allocate_from_arena_with_tests_expect_success(s);
 280     allocated += s;
 281   }
 282 
 283   EXPECT_GT(metaspace::InternalStats::num_chunks_enlarged(), n1);
 284 
 285 }
 286 
 287 // Do this test for some of the standard types; don't do it for the boot loader type
 288 //  since that one starts out with max chunk size so we would not see any enlargement.
 289 
 290 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_standard_c) {
 291   test_chunk_enlargment_simple(Metaspace::StandardMetaspaceType, true);
 292 }
 293 
 294 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_standard_nc) {
 295   test_chunk_enlargment_simple(Metaspace::StandardMetaspaceType, false);
 296 }
 297 
 298 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_micro_c) {
 299   test_chunk_enlargment_simple(Metaspace::ReflectionMetaspaceType, true);
 300 }
 301 
 302 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_micro_nc) {
 303   test_chunk_enlargment_simple(Metaspace::ReflectionMetaspaceType, false);
 304 }
 305 
 306 // Test chunk enlargement:
 307 // A single MetaspaceArena, left undisturbed with place to grow. Slowly fill arena up.
 308 //  We should see occurrences of chunk-in-place enlargement.
 309 //  Here, we give it an ideal policy which should enable the initial chunk to grow unmolested
 310 //  until finish.
 311 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_2) {
 312 
 313   if (Settings::use_allocation_guard()) {
 314     return;
 315   }
 316 
 317   // Note: internally, chunk in-place enlargement is disallowed if growing the chunk
 318   //  would cause the arena to claim more memory than its growth policy allows. This
 319   //  is done to prevent the arena to grow too fast.
 320   //
 321   // In order to test in-place growth here without that restriction I give it an
 322   //  artificial growth policy which starts out with a tiny chunk size, then balloons
 323   //  right up to max chunk size. This will cause the initial chunk to be tiny, and
 324   //  then the arena is able to grow it without violating growth policy.
 325   chunklevel_t growth[] = { HIGHEST_CHUNK_LEVEL, ROOT_CHUNK_LEVEL };
 326   ArenaGrowthPolicy growth_policy(growth, 2);
 327 
 328   MetaspaceGtestContext context;
 329   MetaspaceArenaTestHelper helper(context, &amp;growth_policy);
 330 
 331   uint64_t n1 = metaspace::InternalStats::num_chunks_enlarged();
 332 
 333   size_t allocated = 0;
 334   while (allocated &lt;= MAX_CHUNK_WORD_SIZE) {
 335     size_t s = IntRange(32, 128).random_value();
 336     helper.allocate_from_arena_with_tests_expect_success(s);
 337     allocated += s;
 338     if (allocated &lt;= MAX_CHUNK_WORD_SIZE) {
 339       // Chunk should have been enlarged in place
 340       ASSERT_EQ(1, helper.get_number_of_chunks());
 341     } else {
 342       // Next chunk should have started
 343       ASSERT_EQ(2, helper.get_number_of_chunks());
 344     }
 345   }
 346 
 347   int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;
 348   LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);
 349 
 350   ASSERT_GT0(times_chunk_were_enlarged);
 351 
 352 }
 353 
 354 // Regression test: Given a single MetaspaceArena, left undisturbed with place to grow,
 355 //  test that in place enlargement correctly fails if growing the chunk would bring us
 356 //  beyond the max. size of a chunk.
 357 TEST_VM(metaspace, MetaspaceArena_test_failing_to_enlarge_in_place_max_chunk_size) {
 358 
 359   if (Settings::use_allocation_guard()) {
 360     return;
 361   }
 362 
 363   MetaspaceGtestContext context;
 364 
 365   for (size_t first_allocation_size = 1; first_allocation_size &lt;= MAX_CHUNK_WORD_SIZE / 2; first_allocation_size *= 2) {
 366 
 367     MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);
 368 
 369     // we allocate first a small amount, then the full amount possible.
 370     // The sum of first and second allocation should bring us above root chunk size.
 371     // This should work, we should not see any problems, but no chunk enlargement should
 372     // happen.
 373     int n1 = metaspace::InternalStats::num_chunks_enlarged();
 374 
 375     helper.allocate_from_arena_with_tests_expect_success(first_allocation_size);
 376     EXPECT_EQ(helper.get_number_of_chunks(), 1);
 377 
 378     helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE - first_allocation_size + 1);
 379     EXPECT_EQ(helper.get_number_of_chunks(), 2);
 380 
 381     int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;
 382     LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);
 383 
 384     EXPECT_0(times_chunk_were_enlarged);
 385 
 386   }
 387 }
 388 
 389 // Regression test: Given a single MetaspaceArena, left undisturbed with place to grow,
 390 //  test that in place enlargement correctly fails if growing the chunk would cause more
 391 //  than doubling its size
 392 TEST_VM(metaspace, MetaspaceArena_test_failing_to_enlarge_in_place_doubling_chunk_size) {
 393 
 394   if (Settings::use_allocation_guard()) {
 395     return;
 396   }
 397 
 398   MetaspaceGtestContext context;
 399   MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);
 400 
 401   int n1 = metaspace::InternalStats::num_chunks_enlarged();
 402 
 403   helper.allocate_from_arena_with_tests_expect_success(1000);
 404   EXPECT_EQ(helper.get_number_of_chunks(), 1);
 405 
 406   helper.allocate_from_arena_with_tests_expect_success(4000);
 407   EXPECT_EQ(helper.get_number_of_chunks(), 2);
 408 
 409   int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;
 410   LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);
 411 
 412   EXPECT_0(times_chunk_were_enlarged);
 413 
 414 }
 415 
 416 // Test the MetaspaceArenas' free block list:
 417 // Allocate, deallocate, then allocate the same block again. The second allocate should
 418 // reuse the deallocated block.
 419 TEST_VM(metaspace, MetaspaceArena_deallocate) {
 420   if (Settings::use_allocation_guard()) {
 421     return;
 422   }
 423   for (size_t s = 2; s &lt;= MAX_CHUNK_WORD_SIZE; s *= 2) {
 424     MetaspaceGtestContext context;
 425     MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);
 426 
 427     MetaWord* p1 = NULL;
 428     helper.allocate_from_arena_with_tests_expect_success(&amp;p1, s);
 429 
 430     size_t used1 = 0, capacity1 = 0;
 431     helper.usage_numbers_with_test(&amp;used1, NULL, &amp;capacity1);
 432     ASSERT_EQ(used1, s);
 433 
 434     helper.deallocate_with_tests(p1, s);
 435 
 436     size_t used2 = 0, capacity2 = 0;
 437     helper.usage_numbers_with_test(&amp;used2, NULL, &amp;capacity2);
 438     ASSERT_EQ(used1, used2);
 439     ASSERT_EQ(capacity2, capacity2);
 440 
 441     MetaWord* p2 = NULL;
 442     helper.allocate_from_arena_with_tests_expect_success(&amp;p2, s);
 443 
 444     size_t used3 = 0, capacity3 = 0;
 445     helper.usage_numbers_with_test(&amp;used3, NULL, &amp;capacity3);
 446     ASSERT_EQ(used3, used2);
 447     ASSERT_EQ(capacity3, capacity2);
 448 
 449     // Actually, we should get the very same allocation back
 450     ASSERT_EQ(p1, p2);
 451   }
 452 }
 453 
 454 static void test_recover_from_commit_limit_hit() {
 455 
 456   if (Settings::new_chunks_are_fully_committed()) {
 457     return; // This would throw off the commit counting in this test.
 458   }
 459 
 460   // Test:
 461   // - Multiple MetaspaceArena allocate (operating under the same commit limiter).
 462   // - One, while attempting to commit parts of its current chunk on demand,
 463   //   triggers the limit and cannot commit its chunk further.
 464   // - We release the other MetaspaceArena - its content is put back to the
 465   //   freelists.
 466   // - We re-attempt allocation from the first manager. It should now succeed.
 467   //
 468   // This means if the first MetaspaceArena may have to let go of its current chunk and
 469   // retire it and take a fresh chunk from the freelist.
 470 
 471   const size_t commit_limit = Settings::commit_granule_words() * 10;
 472   MetaspaceGtestContext context(commit_limit);
 473 
 474   // The first MetaspaceArena mimicks a micro loader. This will fill the free
 475   //  chunk list with very small chunks. We allocate from them in an interleaved
 476   //  way to cause fragmentation.
 477   MetaspaceArenaTestHelper helper1(context, Metaspace::ReflectionMetaspaceType, false);
 478   MetaspaceArenaTestHelper helper2(context, Metaspace::ReflectionMetaspaceType, false);
 479 
 480   // This MetaspaceArena should hit the limit. We use BootMetaspaceType here since
 481   // it gets a large initial chunk which is committed
 482   // on demand and we are likely to hit a commit limit while trying to expand it.
 483   MetaspaceArenaTestHelper helper3(context, Metaspace::BootMetaspaceType, false);
 484 
 485   // Allocate space until we have below two but above one granule left
 486   size_t allocated_from_1_and_2 = 0;
 487   while (context.commit_limiter().possible_expansion_words() &gt;= Settings::commit_granule_words() * 2 &amp;&amp;
 488       allocated_from_1_and_2 &lt; commit_limit) {
 489     helper1.allocate_from_arena_with_tests_expect_success(1);
 490     helper2.allocate_from_arena_with_tests_expect_success(1);
 491     allocated_from_1_and_2 += 2;
 492   }
 493 
 494   // Now, allocating from helper3, creep up on the limit
 495   size_t allocated_from_3 = 0;
 496   MetaWord* p = NULL;
 497   while ( (helper3.allocate_from_arena_with_tests(&amp;p, 1), p != NULL) &amp;&amp;
 498          ++allocated_from_3 &lt; Settings::commit_granule_words() * 2);
 499 
 500   EXPECT_LE(allocated_from_3, Settings::commit_granule_words() * 2);
 501 
 502   // We expect the freelist to be empty of committed space...
 503   EXPECT_0(context.cm().total_committed_word_size());
 504 
 505   //msthelper.cm().print_on(tty);
 506 
 507   // Release the first MetaspaceArena.
 508   helper1.delete_arena_with_tests();
 509 
 510   //msthelper.cm().print_on(tty);
 511 
 512   // Should have populated the freelist with committed space
 513   // We expect the freelist to be empty of committed space...
 514   EXPECT_GT(context.cm().total_committed_word_size(), (size_t)0);
 515 
 516   // Repeat allocation from helper3, should now work.
 517   helper3.allocate_from_arena_with_tests_expect_success(1);
 518 
 519 }
 520 
 521 TEST_VM(metaspace, MetaspaceArena_recover_from_limit_hit) {
 522   test_recover_from_commit_limit_hit();
 523 }
 524 
 525 static void test_controlled_growth(Metaspace::MetaspaceType type, bool is_class,
 526                                    size_t expected_starting_capacity,
 527                                    bool test_in_place_enlargement)
 528 {
 529 
 530   if (Settings::use_allocation_guard()) {
 531     return;
 532   }
 533 
 534   // From a MetaspaceArena in a clean room allocate tiny amounts;
 535   // watch it grow. Used/committed/capacity should not grow in
 536   // large jumps. Also, different types of MetaspaceArena should
 537   // have different initial capacities.
 538 
 539   MetaspaceGtestContext context;
 540   MetaspaceArenaTestHelper smhelper(context, type, is_class, "Grower");
 541 
 542   MetaspaceArenaTestHelper smhelper_harrasser(context, Metaspace::ReflectionMetaspaceType, true, "Harasser");
 543 
 544   size_t used = 0, committed = 0, capacity = 0;
 545   const size_t alloc_words = 16;
 546 
 547   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 548   ASSERT_0(used);
 549   ASSERT_0(committed);
 550   ASSERT_0(capacity);
 551 
 552   ///// First allocation //
 553 
 554   smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
 555 
 556   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 557 
 558   ASSERT_EQ(used, alloc_words);
 559   ASSERT_GE(committed, used);
 560   ASSERT_GE(capacity, committed);
 561 
 562   ASSERT_EQ(capacity, expected_starting_capacity);
 563 
 564   if (!(Settings::new_chunks_are_fully_committed() &amp;&amp; type == Metaspace::BootMetaspaceType)) {
 565     // Initial commit charge for the whole context should be one granule
 566     ASSERT_EQ(context.committed_words(), Settings::commit_granule_words());
 567     // Initial commit number for the arena should be less since - apart from boot loader - no
 568     //  space type has large initial chunks.
 569     ASSERT_LE(committed, Settings::commit_granule_words());
 570   }
 571 
 572   ///// subsequent allocations //
 573 
 574   DEBUG_ONLY(const uintx num_chunk_enlarged = metaspace::InternalStats::num_chunks_enlarged();)
 575 
 576   size_t words_allocated = 0;
 577   int num_allocated = 0;
 578   const size_t safety = MAX_CHUNK_WORD_SIZE * 1.2;
 579   size_t highest_capacity_jump = capacity;
 580   int num_capacity_jumps = 0;
 581 
 582   while (words_allocated &lt; safety &amp;&amp; num_capacity_jumps &lt; 15) {
 583 
 584     // if we want to test growth with in-place chunk enlargement, leave MetaspaceArena
 585     // undisturbed; it will have all the place to grow. Otherwise allocate from a little
 586     // side arena to increase fragmentation.
 587     // (Note that this does not completely prevent in-place chunk enlargement but makes it
 588     //  rather improbable)
 589     if (!test_in_place_enlargement) {
 590       smhelper_harrasser.allocate_from_arena_with_tests_expect_success(alloc_words * 2);
 591     }
 592 
 593     smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
 594     words_allocated += alloc_words;
 595     num_allocated++;
 596 
 597     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 598 
 599     smhelper.arena()-&gt;usage_numbers(&amp;used2, &amp;committed2, &amp;capacity2);
 600 
 601     // used should not grow larger than what we allocated, plus possible overhead.
 602     ASSERT_GE(used2, used);
 603     ASSERT_LE(used2, used + alloc_words * 2);
 604     ASSERT_LE(used2, words_allocated + 100);
 605     used = used2;
 606 
 607     // A jump in committed words should not be larger than commit granule size.
 608     // It can be smaller, since the current chunk of the MetaspaceArena may be
 609     // smaller than a commit granule.
 610     // (Note: unless root chunks are born fully committed)
 611     ASSERT_GE(committed2, used2);
 612     ASSERT_GE(committed2, committed);
 613     const size_t committed_jump = committed2 - committed;
 614     if (committed_jump &gt; 0 &amp;&amp; !Settings::new_chunks_are_fully_committed()) {
 615       ASSERT_LE(committed_jump, Settings::commit_granule_words());
 616     }
 617     committed = committed2;
 618 
 619     // Capacity jumps: Test that arenas capacity does not grow too fast.
 620     ASSERT_GE(capacity2, committed2);
 621     ASSERT_GE(capacity2, capacity);
 622     const size_t capacity_jump = capacity2 - capacity;
 623     if (capacity_jump &gt; 0) {
 624       LOG("&gt;" SIZE_FORMAT "-&gt;" SIZE_FORMAT "(+" SIZE_FORMAT ")", capacity, capacity2, capacity_jump)
 625       if (capacity_jump &gt; highest_capacity_jump) {
 626         /* Disabled for now since this is rather shaky. The way it is tested makes it too dependent
 627          * on allocation history. Need to rethink this.
 628         ASSERT_LE(capacity_jump, highest_capacity_jump * 2);
 629         ASSERT_GE(capacity_jump, MIN_CHUNK_WORD_SIZE);
 630         ASSERT_LE(capacity_jump, MAX_CHUNK_WORD_SIZE);
 631         */
 632         highest_capacity_jump = capacity_jump;
 633       }
 634       num_capacity_jumps++;
 635     }
 636 
 637     capacity = capacity2;
 638 
 639   }
 640 
 641   // After all this work, we should see an increase in number of chunk-in-place-enlargements
 642   //  (this especially is vulnerable to regression: the decisions of when to do in-place-enlargements are somewhat
 643   //   complicated, see MetaspaceArena::attempt_enlarge_current_chunk())
 644 #ifdef ASSERT
 645   if (test_in_place_enlargement) {
 646     const uintx num_chunk_enlarged_2 = metaspace::InternalStats::num_chunks_enlarged();
 647     ASSERT_GT(num_chunk_enlarged_2, num_chunk_enlarged);
 648   }
 649 #endif
 650 }
 651 
 652 // these numbers have to be in sync with arena policy numbers (see memory/metaspace/arenaGrowthPolicy.cpp)
 653 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_inplace) {
 654   test_controlled_growth(Metaspace::ReflectionMetaspaceType, true,
 655                          word_size_for_level(CHUNK_LEVEL_1K), true);
 656 }
 657 
 658 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_not_inplace) {
 659   test_controlled_growth(Metaspace::ReflectionMetaspaceType, true,
 660                          word_size_for_level(CHUNK_LEVEL_1K), false);
 661 }
 662 
 663 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_inplace) {
 664   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, true,
 665                          word_size_for_level(CHUNK_LEVEL_1K), true);
 666 }
 667 
 668 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_not_inplace) {
 669   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, true,
 670                          word_size_for_level(CHUNK_LEVEL_1K), false);
 671 }
 672 
 673 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_inplace) {
 674   test_controlled_growth(Metaspace::StandardMetaspaceType, true,
 675                          word_size_for_level(CHUNK_LEVEL_2K), true);
 676 }
 677 
 678 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_not_inplace) {
 679   test_controlled_growth(Metaspace::StandardMetaspaceType, true,
 680                          word_size_for_level(CHUNK_LEVEL_2K), false);
 681 }
 682 
 683 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 684  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 685 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_inplace) {
 686   test_controlled_growth(Metaspace::BootMetaspaceType, true,
 687                          word_size_for_level(CHUNK_LEVEL_1M), true);
 688 }
 689 
 690 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_not_inplace) {
 691   test_controlled_growth(Metaspace::BootMetaspaceType, true,
 692                          word_size_for_level(CHUNK_LEVEL_1M), false);
 693 }
 694 */
 695 
 696 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_inplace) {
 697   test_controlled_growth(Metaspace::ReflectionMetaspaceType, false,
 698                          word_size_for_level(CHUNK_LEVEL_2K), true);
 699 }
 700 
 701 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_not_inplace) {
 702   test_controlled_growth(Metaspace::ReflectionMetaspaceType, false,
 703                          word_size_for_level(CHUNK_LEVEL_2K), false);
 704 }
 705 
 706 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_inplace) {
 707   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, false,
 708                          word_size_for_level(CHUNK_LEVEL_1K), true);
 709 }
 710 
 711 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_not_inplace) {
 712   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, false,
 713                          word_size_for_level(CHUNK_LEVEL_1K), false);
 714 }
 715 
 716 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_inplace) {
 717   test_controlled_growth(Metaspace::StandardMetaspaceType, false,
 718                          word_size_for_level(CHUNK_LEVEL_4K), true);
 719 }
 720 
 721 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_not_inplace) {
 722   test_controlled_growth(Metaspace::StandardMetaspaceType, false,
 723                          word_size_for_level(CHUNK_LEVEL_4K), false);
 724 }
 725 
 726 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 727  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 728 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_inplace) {
 729   test_controlled_growth(Metaspace::BootMetaspaceType, false,
 730                          word_size_for_level(CHUNK_LEVEL_4M), true);
 731 }
 732 
 733 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_not_inplace) {
 734   test_controlled_growth(Metaspace::BootMetaspaceType, false,
 735                          word_size_for_level(CHUNK_LEVEL_4M), false);
 736 }
 737 */
</pre></body></html>
