<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60811">60811</a> : imported patch jep387-all.patch
rev <a href="https://bugs.openjdk.java.net/browse/JDK-60812">60812</a> : [mq]: diff1</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 
<a name="2" id="anc2"></a><span class="changed">  28 #include "memory/metaspace/msArena.hpp"</span>
<span class="changed">  29 #include "memory/metaspace/msArenaGrowthPolicy.hpp"</span>
<span class="changed">  30 #include "memory/metaspace/msCommitLimiter.hpp"</span>
<span class="changed">  31 #include "memory/metaspace/msCounter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/msInternalStats.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/msSettings.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/msStatistics.hpp"</span>
<span class="changed">  35 #include "runtime/mutex.hpp"</span>
<span class="changed">  36 #include "runtime/mutexLocker.hpp"</span>
<span class="changed">  37 #include "utilities/debug.hpp"</span>
<span class="changed">  38 #include "utilities/globalDefinitions.hpp"</span>
  39 
<a name="3" id="anc3"></a><span class="new">  40 //#define LOG_PLEASE</span>
<span class="new">  41 #include "metaspaceGtestCommon.hpp"</span>
<span class="new">  42 #include "metaspaceGtestContexts.hpp"</span>
<span class="new">  43 #include "metaspaceGtestRangeHelpers.hpp"</span>
<span class="new">  44 </span>
<span class="new">  45 using metaspace::ArenaGrowthPolicy;</span>
<span class="new">  46 using metaspace::CommitLimiter;</span>
<span class="new">  47 using metaspace::InternalStats;</span>
<span class="new">  48 using metaspace::MemRangeCounter;</span>
<span class="new">  49 using metaspace::MetaspaceArena;</span>
<span class="new">  50 using metaspace::SizeAtomicCounter;</span>
<span class="new">  51 using metaspace::Settings;</span>
<span class="new">  52 using metaspace::ArenaStats;</span>
<span class="new">  53 </span>
<span class="new">  54 // See metaspaceArena.cpp : needed for predicting commit sizes.</span>
<span class="new">  55 namespace metaspace {</span>
<span class="new">  56   extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);</span>
<span class="new">  57 }</span>
  58 
<a name="4" id="anc4"></a>

  59 class MetaspaceArenaTestHelper {
  60 
<a name="5" id="anc5"></a><span class="changed">  61   MetaspaceGtestContext&amp; _context;</span>
  62 
  63   Mutex* _lock;
  64   const ArenaGrowthPolicy* _growth_policy;
  65   SizeAtomicCounter _used_words_counter;
  66   MetaspaceArena* _arena;
  67 
<a name="6" id="anc6"></a><span class="changed">  68   void initialize(const ArenaGrowthPolicy* growth_policy, const char* name = "gtest-MetaspaceArena") {</span>
<span class="changed">  69     _growth_policy = growth_policy;</span>









  70     _lock = new Mutex(Monitor::native, "gtest-MetaspaceArenaTest-lock", false, Monitor::_safepoint_check_never);
  71     // Lock during space creation, since this is what happens in the VM too
  72     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
  73     {
  74       MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
<a name="7" id="anc7"></a><span class="changed">  75       _arena = new MetaspaceArena(&amp;_context.cm(), _growth_policy, _lock, &amp;_used_words_counter, name);</span>
<span class="changed">  76     }</span>
<span class="changed">  77     DEBUG_ONLY(_arena-&gt;verify());</span>
<span class="changed">  78 </span>
<span class="changed">  79   }</span>
<span class="changed">  80 </span>
<span class="changed">  81 public:</span>
<span class="changed">  82 </span>
<span class="changed">  83   // Create a helper; growth policy for arena is determined by the given spacetype|class tupel</span>
<span class="changed">  84   MetaspaceArenaTestHelper(MetaspaceGtestContext&amp; helper,</span>
<span class="changed">  85                             Metaspace::MetaspaceType space_type, bool is_class,</span>
<span class="changed">  86                             const char* name = "gtest-MetaspaceArena")</span>
<span class="changed">  87     :_context(helper)</span>
<span class="changed">  88   {</span>
<span class="changed">  89     initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), name);</span>
  90   }
<a name="8" id="anc8"></a><span class="changed">  91 </span>
<span class="changed">  92   // Create a helper; growth policy is directly specified</span>
<span class="changed">  93   MetaspaceArenaTestHelper(MetaspaceGtestContext&amp; helper, const ArenaGrowthPolicy* growth_policy,</span>
<span class="changed">  94                             const char* name = "gtest-MetaspaceArena")</span>
<span class="changed">  95     :_context(helper)</span>
<span class="changed">  96   {</span>
<span class="changed">  97     initialize(growth_policy, name);</span>
  98   }
  99 
 100   ~MetaspaceArenaTestHelper() {
 101     delete_arena_with_tests();
 102     delete _lock;
 103   }
 104 
<a name="9" id="anc9"></a><span class="changed"> 105   const CommitLimiter&amp; limiter() const { return _context.commit_limiter(); }</span>
 106   MetaspaceArena* arena() const { return _arena; }
 107   SizeAtomicCounter&amp; used_words_counter() { return _used_words_counter; }
 108 
 109   // Note: all test functions return void due to gtests limitation that we cannot use ASSERT
 110   // in non-void returning tests.
 111 
 112   void delete_arena_with_tests() {
 113     if (_arena != NULL) {
 114       size_t used_words_before = _used_words_counter.get();
 115       size_t committed_words_before = limiter().committed_words();
<a name="10" id="anc10"></a><span class="changed"> 116       DEBUG_ONLY(_arena-&gt;verify());</span>
 117       delete _arena;
 118       _arena = NULL;
 119       size_t used_words_after = _used_words_counter.get();
 120       size_t committed_words_after = limiter().committed_words();
 121       ASSERT_0(used_words_after);
 122       if (Settings::uncommit_free_chunks()) {
 123         ASSERT_LE(committed_words_after, committed_words_before);
 124       } else {
 125         ASSERT_EQ(committed_words_after, committed_words_before);
 126       }
 127     }
 128   }
 129 
 130   void usage_numbers_with_test(size_t* p_used, size_t* p_committed, size_t* p_capacity) const {
 131     _arena-&gt;usage_numbers(p_used, p_committed, p_capacity);
 132     if (p_used != NULL) {
 133       if (p_committed != NULL) {
 134         ASSERT_GE(*p_committed, *p_used);
 135       }
 136       // Since we own the used words counter, it should reflect our usage number 1:1
 137       ASSERT_EQ(_used_words_counter.get(), *p_used);
 138     }
 139     if (p_committed != NULL &amp;&amp; p_capacity != NULL) {
 140       ASSERT_GE(*p_capacity, *p_committed);
 141     }
 142   }
 143 
 144   // Allocate; caller expects success; return pointer in *p_return_value
 145   void allocate_from_arena_with_tests_expect_success(MetaWord** p_return_value, size_t word_size) {
 146     allocate_from_arena_with_tests(p_return_value, word_size);
 147     ASSERT_NOT_NULL(*p_return_value);
 148   }
 149 
 150   // Allocate; caller expects success but is not interested in return value
 151   void allocate_from_arena_with_tests_expect_success(size_t word_size) {
 152     MetaWord* dummy = NULL;
 153     allocate_from_arena_with_tests_expect_success(&amp;dummy, word_size);
 154   }
 155 
 156   // Allocate; caller expects failure
 157   void allocate_from_arena_with_tests_expect_failure(size_t word_size) {
 158     MetaWord* dummy = NULL;
 159     allocate_from_arena_with_tests(&amp;dummy, word_size);
 160     ASSERT_NULL(dummy);
 161   }
 162 
 163   // Allocate; it may or may not work; return value in *p_return_value
 164   void allocate_from_arena_with_tests(MetaWord** p_return_value, size_t word_size) {
 165 
 166     // Note: usage_numbers walks all chunks in use and counts.
 167     size_t used = 0, committed = 0, capacity = 0;
 168     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 169 
 170     size_t possible_expansion = limiter().possible_expansion_words();
 171 
 172     MetaWord* p = _arena-&gt;allocate(word_size);
 173 
<a name="11" id="anc11"></a><span class="changed"> 174     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify();))</span>
 175 
 176     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 177     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 178 
 179     if (p == NULL) {
 180       // Allocation failed.
 181       if (Settings::new_chunks_are_fully_committed()) {
 182         ASSERT_LT(possible_expansion, MAX_CHUNK_WORD_SIZE);
 183       } else {
 184         ASSERT_LT(possible_expansion, word_size);
 185       }
 186 
 187       ASSERT_EQ(used, used2);
 188       ASSERT_EQ(committed, committed2);
 189       ASSERT_EQ(capacity, capacity2);
 190     } else {
 191       // Allocation succeeded. Should be correctly aligned.
 192       ASSERT_TRUE(is_aligned(p, sizeof(MetaWord)));
 193       // used: may go up or may not (since our request may have been satisfied from the freeblocklist
 194       //   whose content already counts as used).
 195       // committed: may go up, may not
 196       // capacity: ditto
 197       ASSERT_GE(used2, used);
 198       ASSERT_GE(committed2, committed);
 199       ASSERT_GE(capacity2, capacity);
 200     }
 201 
 202     *p_return_value = p;
 203   }
 204 
 205   // Allocate; it may or may not work; but caller does not care for the result value
 206   void allocate_from_arena_with_tests(size_t word_size) {
 207     MetaWord* dummy = NULL;
 208     allocate_from_arena_with_tests(&amp;dummy, word_size);
 209   }
 210 
<a name="12" id="anc12"></a>
 211   void deallocate_with_tests(MetaWord* p, size_t word_size) {
 212     size_t used = 0, committed = 0, capacity = 0;
 213     usage_numbers_with_test(&amp;used, &amp;committed, &amp;capacity);
 214 
 215     _arena-&gt;deallocate(p, word_size);
 216 
<a name="13" id="anc13"></a><span class="changed"> 217     SOMETIMES(DEBUG_ONLY(_arena-&gt;verify();))</span>
 218 
 219     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 220     usage_numbers_with_test(&amp;used2, &amp;committed2, &amp;capacity2);
 221 
 222     // Nothing should have changed. Deallocated blocks are added to the free block list
 223     // which still counts as used.
 224     ASSERT_EQ(used2, used);
 225     ASSERT_EQ(committed2, committed);
 226     ASSERT_EQ(capacity2, capacity);
 227   }
 228 
<a name="14" id="anc14"></a><span class="new"> 229   ArenaStats get_arena_statistics() const {</span>
<span class="new"> 230     ArenaStats stats;</span>
<span class="new"> 231     _arena-&gt;add_to_statistics(&amp;stats);</span>
<span class="new"> 232     return stats;</span>
<span class="new"> 233   }</span>
 234 
<a name="15" id="anc15"></a><span class="changed"> 235   // Convenience method to return number of chunks in arena (including current chunk)</span>
<span class="changed"> 236   int get_number_of_chunks() const {</span>
<span class="changed"> 237     return get_arena_statistics().totals()._num;</span>
<span class="changed"> 238   }</span>
 239 
<a name="16" id="anc16"></a><span class="new"> 240 };</span>
 241 
 242 static void test_basics(size_t commit_limit, bool is_micro) {
<a name="17" id="anc17"></a><span class="changed"> 243   MetaspaceGtestContext context(commit_limit);</span>
<span class="changed"> 244   MetaspaceArenaTestHelper helper(context, is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType, false);</span>
 245 
 246   helper.allocate_from_arena_with_tests(1);
 247   helper.allocate_from_arena_with_tests(128);
 248   helper.allocate_from_arena_with_tests(128 * K);
 249   helper.allocate_from_arena_with_tests(1);
 250   helper.allocate_from_arena_with_tests(128);
 251   helper.allocate_from_arena_with_tests(128 * K);
 252 }
 253 
 254 TEST_VM(metaspace, MetaspaceArena_basics_micro_nolimit) {
 255   test_basics(max_uintx, true);
 256 }
 257 
 258 TEST_VM(metaspace, MetaspaceArena_basics_micro_limit) {
 259   test_basics(256 * K, true);
 260 }
 261 
 262 TEST_VM(metaspace, MetaspaceArena_basics_standard_nolimit) {
 263   test_basics(max_uintx, false);
 264 }
 265 
 266 TEST_VM(metaspace, MetaspaceArena_basics_standard_limit) {
 267   test_basics(256 * K, false);
 268 }
 269 
<a name="18" id="anc18"></a><span class="new"> 270 // Test chunk enlargement:</span>
<span class="new"> 271 //  A single MetaspaceArena, left undisturbed with place to grow. Slowly fill arena up.</span>
<span class="new"> 272 //  We should see at least some occurrences of chunk-in-place enlargement.</span>
<span class="new"> 273 static void test_chunk_enlargment_simple(Metaspace::MetaspaceType spacetype, bool is_class) {</span>
<span class="new"> 274 </span>
<span class="new"> 275   MetaspaceGtestContext context;</span>
<span class="new"> 276   MetaspaceArenaTestHelper helper(context, (Metaspace::MetaspaceType)spacetype, is_class);</span>
<span class="new"> 277 </span>
<span class="new"> 278   uint64_t n1 = metaspace::InternalStats::num_chunks_enlarged();</span>
<span class="new"> 279 </span>
<span class="new"> 280   size_t allocated = 0;</span>
<span class="new"> 281   while (allocated &lt;= MAX_CHUNK_WORD_SIZE &amp;&amp;</span>
<span class="new"> 282          metaspace::InternalStats::num_chunks_enlarged() == n1) {</span>
<span class="new"> 283     size_t s = IntRange(32, 128).random_value();</span>
<span class="new"> 284     helper.allocate_from_arena_with_tests_expect_success(s);</span>
<span class="new"> 285     allocated += metaspace::get_raw_word_size_for_requested_word_size(s);</span>
<span class="new"> 286   }</span>
<span class="new"> 287 </span>
<span class="new"> 288   EXPECT_GT(metaspace::InternalStats::num_chunks_enlarged(), n1);</span>
<span class="new"> 289 </span>
<span class="new"> 290 }</span>
<span class="new"> 291 </span>
<span class="new"> 292 // Do this test for some of the standard types; don't do it for the boot loader type</span>
<span class="new"> 293 //  since that one starts out with max chunk size so we would not see any enlargement.</span>
 294 
<a name="19" id="anc19"></a><span class="changed"> 295 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_standard_c) {</span>
<span class="changed"> 296   test_chunk_enlargment_simple(Metaspace::StandardMetaspaceType, true);</span>
<span class="changed"> 297 }</span>
<span class="changed"> 298 </span>
<span class="changed"> 299 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_standard_nc) {</span>
<span class="changed"> 300   test_chunk_enlargment_simple(Metaspace::StandardMetaspaceType, false);</span>
<span class="changed"> 301 }</span>
<span class="changed"> 302 </span>
<span class="changed"> 303 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_micro_c) {</span>
<span class="changed"> 304   test_chunk_enlargment_simple(Metaspace::ReflectionMetaspaceType, true);</span>
<span class="changed"> 305 }</span>
<span class="changed"> 306 </span>
<span class="changed"> 307 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_micro_nc) {</span>
<span class="changed"> 308   test_chunk_enlargment_simple(Metaspace::ReflectionMetaspaceType, false);</span>
<span class="changed"> 309 }</span>
<span class="changed"> 310 </span>
<span class="changed"> 311 // Test chunk enlargement:</span>
<span class="changed"> 312 // A single MetaspaceArena, left undisturbed with place to grow. Slowly fill arena up.</span>
<span class="changed"> 313 //  We should see occurrences of chunk-in-place enlargement.</span>
<span class="changed"> 314 //  Here, we give it an ideal policy which should enable the initial chunk to grow unmolested</span>
<span class="changed"> 315 //  until finish.</span>
<span class="changed"> 316 TEST_VM(metaspace, MetaspaceArena_test_enlarge_in_place_2) {</span>
 317 
 318   if (Settings::use_allocation_guard()) {
 319     return;
 320   }
 321 
<a name="20" id="anc20"></a><span class="changed"> 322   // Note: internally, chunk in-place enlargement is disallowed if growing the chunk</span>
<span class="changed"> 323   //  would cause the arena to claim more memory than its growth policy allows. This</span>
<span class="changed"> 324   //  is done to prevent the arena to grow too fast.</span>
<span class="changed"> 325   //</span>
<span class="changed"> 326   // In order to test in-place growth here without that restriction I give it an</span>
<span class="changed"> 327   //  artificial growth policy which starts out with a tiny chunk size, then balloons</span>
<span class="changed"> 328   //  right up to max chunk size. This will cause the initial chunk to be tiny, and</span>
<span class="changed"> 329   //  then the arena is able to grow it without violating growth policy.</span>
<span class="changed"> 330   chunklevel_t growth[] = { HIGHEST_CHUNK_LEVEL, ROOT_CHUNK_LEVEL };</span>
<span class="changed"> 331   ArenaGrowthPolicy growth_policy(growth, 2);</span>
<span class="changed"> 332 </span>
<span class="changed"> 333   MetaspaceGtestContext context;</span>
<span class="changed"> 334   MetaspaceArenaTestHelper helper(context, &amp;growth_policy);</span>
<span class="changed"> 335 </span>
<span class="changed"> 336   uint64_t n1 = metaspace::InternalStats::num_chunks_enlarged();</span>
<span class="changed"> 337 </span>
<span class="changed"> 338   size_t allocated = 0;</span>
<span class="changed"> 339   while (allocated &lt;= MAX_CHUNK_WORD_SIZE) {</span>
<span class="changed"> 340     size_t s = IntRange(32, 128).random_value();</span>
<span class="changed"> 341     helper.allocate_from_arena_with_tests_expect_success(s);</span>
<span class="changed"> 342     allocated += metaspace::get_raw_word_size_for_requested_word_size(s);</span>
<span class="changed"> 343     if (allocated &lt;= MAX_CHUNK_WORD_SIZE) {</span>
<span class="changed"> 344       // Chunk should have been enlarged in place</span>
<span class="changed"> 345       ASSERT_EQ(1, helper.get_number_of_chunks());</span>
<span class="changed"> 346     } else {</span>
<span class="changed"> 347       // Next chunk should have started</span>
<span class="changed"> 348       ASSERT_EQ(2, helper.get_number_of_chunks());</span>
<span class="changed"> 349     }</span>
<span class="changed"> 350   }</span>
<span class="changed"> 351 </span>
<span class="changed"> 352   int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;</span>
<span class="changed"> 353   LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);</span>
<span class="changed"> 354 </span>
<span class="changed"> 355   ASSERT_GT0(times_chunk_were_enlarged);</span>
<span class="changed"> 356 </span>
 357 }
 358 
<a name="21" id="anc21"></a><span class="changed"> 359 // Regression test: Given a single MetaspaceArena, left undisturbed with place to grow,</span>
<span class="changed"> 360 //  test that in place enlargement correctly fails if growing the chunk would bring us</span>
<span class="changed"> 361 //  beyond the max. size of a chunk.</span>
<span class="changed"> 362 TEST_VM(metaspace, MetaspaceArena_test_failing_to_enlarge_in_place_max_chunk_size) {</span>
 363 
 364   if (Settings::use_allocation_guard()) {
 365     return;
 366   }
 367 
<a name="22" id="anc22"></a><span class="changed"> 368   MetaspaceGtestContext context;</span>
<span class="changed"> 369 </span>
<span class="changed"> 370   for (size_t first_allocation_size = 1; first_allocation_size &lt;= MAX_CHUNK_WORD_SIZE / 2; first_allocation_size *= 2) {</span>
<span class="changed"> 371 </span>
<span class="changed"> 372     MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);</span>
<span class="changed"> 373 </span>
<span class="changed"> 374     // we allocate first a small amount, then the full amount possible.</span>
<span class="changed"> 375     // The sum of first and second allocation should bring us above root chunk size.</span>
<span class="changed"> 376     // This should work, we should not see any problems, but no chunk enlargement should</span>
<span class="changed"> 377     // happen.</span>
<span class="changed"> 378     int n1 = metaspace::InternalStats::num_chunks_enlarged();</span>
<span class="changed"> 379 </span>
<span class="changed"> 380     helper.allocate_from_arena_with_tests_expect_success(first_allocation_size);</span>
<span class="changed"> 381     EXPECT_EQ(helper.get_number_of_chunks(), 1);</span>
<span class="changed"> 382 </span>
<span class="changed"> 383     helper.allocate_from_arena_with_tests_expect_success(MAX_CHUNK_WORD_SIZE - first_allocation_size + 1);</span>
<span class="changed"> 384     EXPECT_EQ(helper.get_number_of_chunks(), 2);</span>
<span class="changed"> 385 </span>
<span class="changed"> 386     int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;</span>
<span class="changed"> 387     LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);</span>
<span class="changed"> 388 </span>
<span class="changed"> 389     EXPECT_0(times_chunk_were_enlarged);</span>
<span class="changed"> 390 </span>
<span class="changed"> 391   }</span>
 392 }
 393 
<a name="23" id="anc23"></a><span class="changed"> 394 // Regression test: Given a single MetaspaceArena, left undisturbed with place to grow,</span>
<span class="changed"> 395 //  test that in place enlargement correctly fails if growing the chunk would cause more</span>
<span class="changed"> 396 //  than doubling its size</span>
<span class="changed"> 397 TEST_VM(metaspace, MetaspaceArena_test_failing_to_enlarge_in_place_doubling_chunk_size) {</span>
 398 
 399   if (Settings::use_allocation_guard()) {
 400     return;
 401   }
 402 
<a name="24" id="anc24"></a><span class="changed"> 403   MetaspaceGtestContext context;</span>
<span class="changed"> 404   MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);</span>
<span class="changed"> 405 </span>
<span class="changed"> 406   int n1 = metaspace::InternalStats::num_chunks_enlarged();</span>
<span class="changed"> 407 </span>
<span class="changed"> 408   helper.allocate_from_arena_with_tests_expect_success(1000);</span>
<span class="changed"> 409   EXPECT_EQ(helper.get_number_of_chunks(), 1);</span>
<span class="changed"> 410 </span>
<span class="changed"> 411   helper.allocate_from_arena_with_tests_expect_success(4000);</span>
<span class="changed"> 412   EXPECT_EQ(helper.get_number_of_chunks(), 2);</span>
<span class="changed"> 413 </span>
<span class="changed"> 414   int times_chunk_were_enlarged = metaspace::InternalStats::num_chunks_enlarged() - n1;</span>
<span class="changed"> 415   LOG("chunk was enlarged %d times.", times_chunk_were_enlarged);</span>
<span class="changed"> 416 </span>
<span class="changed"> 417   EXPECT_0(times_chunk_were_enlarged);</span>
<span class="changed"> 418 </span>
 419 }
 420 
 421 // Test the MetaspaceArenas' free block list:
 422 // Allocate, deallocate, then allocate the same block again. The second allocate should
 423 // reuse the deallocated block.
 424 TEST_VM(metaspace, MetaspaceArena_deallocate) {
 425   if (Settings::use_allocation_guard()) {
 426     return;
 427   }
 428   for (size_t s = 2; s &lt;= MAX_CHUNK_WORD_SIZE; s *= 2) {
<a name="25" id="anc25"></a><span class="changed"> 429     MetaspaceGtestContext context;</span>
<span class="changed"> 430     MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);</span>
 431 
 432     MetaWord* p1 = NULL;
 433     helper.allocate_from_arena_with_tests_expect_success(&amp;p1, s);
 434 
 435     size_t used1 = 0, capacity1 = 0;
 436     helper.usage_numbers_with_test(&amp;used1, NULL, &amp;capacity1);
 437     ASSERT_EQ(used1, s);
 438 
 439     helper.deallocate_with_tests(p1, s);
 440 
 441     size_t used2 = 0, capacity2 = 0;
 442     helper.usage_numbers_with_test(&amp;used2, NULL, &amp;capacity2);
 443     ASSERT_EQ(used1, used2);
 444     ASSERT_EQ(capacity2, capacity2);
 445 
 446     MetaWord* p2 = NULL;
 447     helper.allocate_from_arena_with_tests_expect_success(&amp;p2, s);
 448 
 449     size_t used3 = 0, capacity3 = 0;
 450     helper.usage_numbers_with_test(&amp;used3, NULL, &amp;capacity3);
 451     ASSERT_EQ(used3, used2);
 452     ASSERT_EQ(capacity3, capacity2);
 453 
 454     // Actually, we should get the very same allocation back
 455     ASSERT_EQ(p1, p2);
 456   }
 457 }
 458 
 459 static void test_recover_from_commit_limit_hit() {
 460 
 461   if (Settings::new_chunks_are_fully_committed()) {
 462     return; // This would throw off the commit counting in this test.
 463   }
 464 
 465   // Test:
 466   // - Multiple MetaspaceArena allocate (operating under the same commit limiter).
 467   // - One, while attempting to commit parts of its current chunk on demand,
 468   //   triggers the limit and cannot commit its chunk further.
 469   // - We release the other MetaspaceArena - its content is put back to the
 470   //   freelists.
 471   // - We re-attempt allocation from the first manager. It should now succeed.
 472   //
 473   // This means if the first MetaspaceArena may have to let go of its current chunk and
 474   // retire it and take a fresh chunk from the freelist.
 475 
 476   const size_t commit_limit = Settings::commit_granule_words() * 10;
<a name="26" id="anc26"></a><span class="changed"> 477   MetaspaceGtestContext context(commit_limit);</span>
 478 
 479   // The first MetaspaceArena mimicks a micro loader. This will fill the free
 480   //  chunk list with very small chunks. We allocate from them in an interleaved
 481   //  way to cause fragmentation.
<a name="27" id="anc27"></a><span class="changed"> 482   MetaspaceArenaTestHelper helper1(context, Metaspace::ReflectionMetaspaceType, false);</span>
<span class="changed"> 483   MetaspaceArenaTestHelper helper2(context, Metaspace::ReflectionMetaspaceType, false);</span>
 484 
 485   // This MetaspaceArena should hit the limit. We use BootMetaspaceType here since
 486   // it gets a large initial chunk which is committed
 487   // on demand and we are likely to hit a commit limit while trying to expand it.
<a name="28" id="anc28"></a><span class="changed"> 488   MetaspaceArenaTestHelper helper3(context, Metaspace::BootMetaspaceType, false);</span>
 489 
 490   // Allocate space until we have below two but above one granule left
 491   size_t allocated_from_1_and_2 = 0;
<a name="29" id="anc29"></a><span class="changed"> 492   while (context.commit_limiter().possible_expansion_words() &gt;= Settings::commit_granule_words() * 2 &amp;&amp;</span>
 493       allocated_from_1_and_2 &lt; commit_limit) {
 494     helper1.allocate_from_arena_with_tests_expect_success(1);
 495     helper2.allocate_from_arena_with_tests_expect_success(1);
 496     allocated_from_1_and_2 += 2;
 497   }
 498 
 499   // Now, allocating from helper3, creep up on the limit
 500   size_t allocated_from_3 = 0;
 501   MetaWord* p = NULL;
 502   while ( (helper3.allocate_from_arena_with_tests(&amp;p, 1), p != NULL) &amp;&amp;
 503          ++allocated_from_3 &lt; Settings::commit_granule_words() * 2);
 504 
 505   EXPECT_LE(allocated_from_3, Settings::commit_granule_words() * 2);
 506 
 507   // We expect the freelist to be empty of committed space...
<a name="30" id="anc30"></a><span class="changed"> 508   EXPECT_0(context.cm().total_committed_word_size());</span>
 509 
 510   //msthelper.cm().print_on(tty);
 511 
 512   // Release the first MetaspaceArena.
 513   helper1.delete_arena_with_tests();
 514 
 515   //msthelper.cm().print_on(tty);
 516 
 517   // Should have populated the freelist with committed space
 518   // We expect the freelist to be empty of committed space...
<a name="31" id="anc31"></a><span class="changed"> 519   EXPECT_GT(context.cm().total_committed_word_size(), (size_t)0);</span>
 520 
 521   // Repeat allocation from helper3, should now work.
 522   helper3.allocate_from_arena_with_tests_expect_success(1);
 523 
 524 }
 525 
<a name="32" id="anc32"></a>
 526 TEST_VM(metaspace, MetaspaceArena_recover_from_limit_hit) {
 527   test_recover_from_commit_limit_hit();
 528 }
 529 
 530 static void test_controlled_growth(Metaspace::MetaspaceType type, bool is_class,
 531                                    size_t expected_starting_capacity,
 532                                    bool test_in_place_enlargement)
 533 {
 534 
 535   if (Settings::use_allocation_guard()) {
 536     return;
 537   }
 538 
 539   // From a MetaspaceArena in a clean room allocate tiny amounts;
 540   // watch it grow. Used/committed/capacity should not grow in
 541   // large jumps. Also, different types of MetaspaceArena should
 542   // have different initial capacities.
 543 
<a name="33" id="anc33"></a><span class="changed"> 544   MetaspaceGtestContext context;</span>
<span class="changed"> 545   MetaspaceArenaTestHelper smhelper(context, type, is_class, "Grower");</span>
 546 
<a name="34" id="anc34"></a><span class="changed"> 547   MetaspaceArenaTestHelper smhelper_harrasser(context, Metaspace::ReflectionMetaspaceType, true, "Harasser");</span>
 548 
 549   size_t used = 0, committed = 0, capacity = 0;
 550   const size_t alloc_words = 16;
 551 
 552   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 553   ASSERT_0(used);
 554   ASSERT_0(committed);
 555   ASSERT_0(capacity);
 556 
 557   ///// First allocation //
 558 
 559   smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
 560 
 561   smhelper.arena()-&gt;usage_numbers(&amp;used, &amp;committed, &amp;capacity);
 562 
 563   ASSERT_EQ(used, alloc_words);
 564   ASSERT_GE(committed, used);
 565   ASSERT_GE(capacity, committed);
 566 
 567   ASSERT_EQ(capacity, expected_starting_capacity);
 568 
 569   if (!(Settings::new_chunks_are_fully_committed() &amp;&amp; type == Metaspace::BootMetaspaceType)) {
 570     // Initial commit charge for the whole context should be one granule
<a name="35" id="anc35"></a><span class="changed"> 571     ASSERT_EQ(context.committed_words(), Settings::commit_granule_words());</span>
 572     // Initial commit number for the arena should be less since - apart from boot loader - no
 573     //  space type has large initial chunks.
 574     ASSERT_LE(committed, Settings::commit_granule_words());
 575   }
 576 
 577   ///// subsequent allocations //
 578 
 579   DEBUG_ONLY(const uintx num_chunk_enlarged = metaspace::InternalStats::num_chunks_enlarged();)
 580 
 581   size_t words_allocated = 0;
 582   int num_allocated = 0;
 583   const size_t safety = MAX_CHUNK_WORD_SIZE * 1.2;
 584   size_t highest_capacity_jump = capacity;
 585   int num_capacity_jumps = 0;
 586 
 587   while (words_allocated &lt; safety &amp;&amp; num_capacity_jumps &lt; 15) {
 588 
 589     // if we want to test growth with in-place chunk enlargement, leave MetaspaceArena
 590     // undisturbed; it will have all the place to grow. Otherwise allocate from a little
 591     // side arena to increase fragmentation.
 592     // (Note that this does not completely prevent in-place chunk enlargement but makes it
 593     //  rather improbable)
 594     if (!test_in_place_enlargement) {
 595       smhelper_harrasser.allocate_from_arena_with_tests_expect_success(alloc_words * 2);
 596     }
 597 
 598     smhelper.allocate_from_arena_with_tests_expect_success(alloc_words);
<a name="36" id="anc36"></a><span class="changed"> 599     words_allocated += metaspace::get_raw_word_size_for_requested_word_size(alloc_words);</span>
<span class="changed"> 600     num_allocated++;</span>
 601 
 602     size_t used2 = 0, committed2 = 0, capacity2 = 0;
 603 
 604     smhelper.arena()-&gt;usage_numbers(&amp;used2, &amp;committed2, &amp;capacity2);
 605 
 606     // used should not grow larger than what we allocated, plus possible overhead.
 607     ASSERT_GE(used2, used);
 608     ASSERT_LE(used2, used + alloc_words * 2);
 609     ASSERT_LE(used2, words_allocated + 100);
 610     used = used2;
 611 
 612     // A jump in committed words should not be larger than commit granule size.
 613     // It can be smaller, since the current chunk of the MetaspaceArena may be
 614     // smaller than a commit granule.
 615     // (Note: unless root chunks are born fully committed)
 616     ASSERT_GE(committed2, used2);
 617     ASSERT_GE(committed2, committed);
 618     const size_t committed_jump = committed2 - committed;
 619     if (committed_jump &gt; 0 &amp;&amp; !Settings::new_chunks_are_fully_committed()) {
 620       ASSERT_LE(committed_jump, Settings::commit_granule_words());
 621     }
 622     committed = committed2;
 623 
 624     // Capacity jumps: Test that arenas capacity does not grow too fast.
 625     ASSERT_GE(capacity2, committed2);
 626     ASSERT_GE(capacity2, capacity);
 627     const size_t capacity_jump = capacity2 - capacity;
 628     if (capacity_jump &gt; 0) {
 629       LOG("&gt;" SIZE_FORMAT "-&gt;" SIZE_FORMAT "(+" SIZE_FORMAT ")", capacity, capacity2, capacity_jump)
 630       if (capacity_jump &gt; highest_capacity_jump) {
 631         /* Disabled for now since this is rather shaky. The way it is tested makes it too dependent
 632          * on allocation history. Need to rethink this.
 633         ASSERT_LE(capacity_jump, highest_capacity_jump * 2);
 634         ASSERT_GE(capacity_jump, MIN_CHUNK_WORD_SIZE);
 635         ASSERT_LE(capacity_jump, MAX_CHUNK_WORD_SIZE);
 636         */
 637         highest_capacity_jump = capacity_jump;
 638       }
<a name="37" id="anc37"></a><span class="changed"> 639       num_capacity_jumps++;</span>
 640     }
 641 
 642     capacity = capacity2;
 643 
 644   }
 645 
 646   // After all this work, we should see an increase in number of chunk-in-place-enlargements
 647   //  (this especially is vulnerable to regression: the decisions of when to do in-place-enlargements are somewhat
 648   //   complicated, see MetaspaceArena::attempt_enlarge_current_chunk())
 649 #ifdef ASSERT
 650   if (test_in_place_enlargement) {
 651     const uintx num_chunk_enlarged_2 = metaspace::InternalStats::num_chunks_enlarged();
 652     ASSERT_GT(num_chunk_enlarged_2, num_chunk_enlarged);
 653   }
 654 #endif
 655 }
 656 
 657 // these numbers have to be in sync with arena policy numbers (see memory/metaspace/arenaGrowthPolicy.cpp)
 658 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_inplace) {
 659   test_controlled_growth(Metaspace::ReflectionMetaspaceType, true,
 660                          word_size_for_level(CHUNK_LEVEL_1K), true);
 661 }
 662 
 663 TEST_VM(metaspace, MetaspaceArena_growth_refl_c_not_inplace) {
 664   test_controlled_growth(Metaspace::ReflectionMetaspaceType, true,
 665                          word_size_for_level(CHUNK_LEVEL_1K), false);
 666 }
 667 
 668 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_inplace) {
 669   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, true,
 670                          word_size_for_level(CHUNK_LEVEL_1K), true);
 671 }
 672 
 673 TEST_VM(metaspace, MetaspaceArena_growth_anon_c_not_inplace) {
 674   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, true,
 675                          word_size_for_level(CHUNK_LEVEL_1K), false);
 676 }
 677 
 678 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_inplace) {
 679   test_controlled_growth(Metaspace::StandardMetaspaceType, true,
 680                          word_size_for_level(CHUNK_LEVEL_2K), true);
 681 }
 682 
 683 TEST_VM(metaspace, MetaspaceArena_growth_standard_c_not_inplace) {
 684   test_controlled_growth(Metaspace::StandardMetaspaceType, true,
 685                          word_size_for_level(CHUNK_LEVEL_2K), false);
 686 }
 687 
 688 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 689  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 690 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_inplace) {
 691   test_controlled_growth(Metaspace::BootMetaspaceType, true,
 692                          word_size_for_level(CHUNK_LEVEL_1M), true);
 693 }
 694 
 695 TEST_VM(metaspace, MetaspaceArena_growth_boot_c_not_inplace) {
 696   test_controlled_growth(Metaspace::BootMetaspaceType, true,
 697                          word_size_for_level(CHUNK_LEVEL_1M), false);
 698 }
 699 */
 700 
 701 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_inplace) {
 702   test_controlled_growth(Metaspace::ReflectionMetaspaceType, false,
 703                          word_size_for_level(CHUNK_LEVEL_2K), true);
 704 }
 705 
 706 TEST_VM(metaspace, MetaspaceArena_growth_refl_nc_not_inplace) {
 707   test_controlled_growth(Metaspace::ReflectionMetaspaceType, false,
 708                          word_size_for_level(CHUNK_LEVEL_2K), false);
 709 }
 710 
 711 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_inplace) {
 712   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, false,
 713                          word_size_for_level(CHUNK_LEVEL_1K), true);
 714 }
 715 
 716 TEST_VM(metaspace, MetaspaceArena_growth_anon_nc_not_inplace) {
 717   test_controlled_growth(Metaspace::ClassMirrorHolderMetaspaceType, false,
 718                          word_size_for_level(CHUNK_LEVEL_1K), false);
 719 }
 720 
 721 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_inplace) {
 722   test_controlled_growth(Metaspace::StandardMetaspaceType, false,
 723                          word_size_for_level(CHUNK_LEVEL_4K), true);
 724 }
 725 
 726 TEST_VM(metaspace, MetaspaceArena_growth_standard_nc_not_inplace) {
 727   test_controlled_growth(Metaspace::StandardMetaspaceType, false,
 728                          word_size_for_level(CHUNK_LEVEL_4K), false);
 729 }
 730 
 731 /* Disabled growth tests for BootMetaspaceType: there, the growth steps are too rare,
 732  * and too large, to make any reliable guess as toward chunks get enlarged in place.
 733 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_inplace) {
 734   test_controlled_growth(Metaspace::BootMetaspaceType, false,
 735                          word_size_for_level(CHUNK_LEVEL_4M), true);
 736 }
 737 
 738 TEST_VM(metaspace, MetaspaceArena_growth_boot_nc_not_inplace) {
 739   test_controlled_growth(Metaspace::BootMetaspaceType, false,
 740                          word_size_for_level(CHUNK_LEVEL_4M), false);
 741 }
 742 */
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="38" type="hidden" /></form></body></html>
