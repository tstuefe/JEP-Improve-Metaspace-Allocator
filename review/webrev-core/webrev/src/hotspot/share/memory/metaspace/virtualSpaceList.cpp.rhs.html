<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-core.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
<a name="2" id="anc2"></a>
  26 #include "precompiled.hpp"
  27 #include "logging/log.hpp"
<a name="3" id="anc3"></a>
  28 #include "memory/metaspace.hpp"
  29 #include "memory/metaspace/chunkManager.hpp"
<a name="4" id="anc4"></a><span class="changed">  30 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  31 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/freeChunkList.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/metaspaceContext.hpp"</span>
  35 #include "memory/metaspace/virtualSpaceList.hpp"
  36 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="5" id="anc5"></a>

  37 #include "runtime/mutexLocker.hpp"
<a name="6" id="anc6"></a><span class="changed">  38 </span>
  39 
  40 namespace metaspace {
  41 
<a name="7" id="anc7"></a><span class="new">  42 #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"</span>
<span class="new">  43 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  44 
<a name="8" id="anc8"></a><span class="changed">  45 // Create a new, empty, expandable list.</span>
<span class="changed">  46 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">  47   : _name(name),</span>
<span class="changed">  48     _first_node(NULL),</span>
<span class="changed">  49     _can_expand(true),</span>
<span class="changed">  50     _can_purge(true),</span>
<span class="changed">  51     _commit_limiter(commit_limiter),</span>
<span class="changed">  52     _reserved_words_counter(),</span>
<span class="changed">  53     _committed_words_counter()</span>
<span class="changed">  54 {</span>
<span class="changed">  55 }</span>
<span class="changed">  56 </span>
<span class="changed">  57 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">  58 // It will be not expandable beyond that first node.</span>
<span class="changed">  59 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">  60 : _name(name),</span>
<span class="changed">  61   _first_node(NULL),</span>
<span class="changed">  62   _can_expand(false),</span>
<span class="changed">  63   _can_purge(false),</span>
<span class="changed">  64   _commit_limiter(commit_limiter),</span>
<span class="changed">  65   _reserved_words_counter(),</span>
<span class="changed">  66   _committed_words_counter()</span>
<span class="changed">  67 {</span>
<span class="changed">  68   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">  69   // for this list since we cannot expand.</span>
<span class="changed">  70   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(rs, _commit_limiter,</span>
<span class="changed">  71                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">  72   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">  73   _first_node = vsn;</span>
<span class="changed">  74   _first_node-&gt;set_next(NULL);</span>
<span class="changed">  75   _nodes_counter.increment();</span>
  76 }
  77 
<a name="9" id="anc9"></a><span class="changed">  78 VirtualSpaceList::~VirtualSpaceList() {</span>




  79   assert_lock_strong(MetaspaceExpand_lock);
<a name="10" id="anc10"></a><span class="changed">  80   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">  81   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">  82   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">  83   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">  84   while (vsn != NULL) {</span>
<span class="changed">  85     vsn2 = vsn-&gt;next();</span>
<span class="changed">  86     delete vsn;</span>
<span class="changed">  87     vsn = vsn2;</span>
<span class="changed">  88   }</span>
  89 }
  90 
<a name="11" id="anc11"></a><span class="changed">  91 // Create a new node and append it to the list. After</span>
<span class="changed">  92 // this function, _current_node shall point to a new empty node.</span>
<span class="changed">  93 // List must be expandable for this to work.</span>
<span class="changed">  94 void VirtualSpaceList::create_new_node() {</span>
<span class="changed">  95   assert(_can_expand, "List is not expandable");</span>


  96   assert_lock_strong(MetaspaceExpand_lock);
<a name="12" id="anc12"></a>
  97 
<a name="13" id="anc13"></a><span class="changed">  98   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(Settings::virtual_space_node_default_word_size(),</span>
<span class="changed">  99                                                         _commit_limiter,</span>
<span class="changed"> 100                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed"> 101   assert(vsn != NULL, "node creation failed");</span>
<span class="changed"> 102   vsn-&gt;set_next(_first_node);</span>
<span class="changed"> 103   _first_node = vsn;</span>
<span class="changed"> 104   _nodes_counter.increment();</span>
 105 }
<a name="14" id="anc14"></a>


 106 
<a name="15" id="anc15"></a><span class="changed"> 107 // Allocate a root chunk from this list.</span>
<span class="changed"> 108 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 109 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 110 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 111 Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
 112   assert_lock_strong(MetaspaceExpand_lock);
<a name="16" id="anc16"></a>






 113 
<a name="17" id="anc17"></a><span class="changed"> 114   if (_first_node == NULL ||</span>
<span class="changed"> 115       _first_node-&gt;free_words() == 0) {</span>


























 116 
<a name="18" id="anc18"></a><span class="changed"> 117     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="changed"> 118     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="changed"> 119     // we should never have left-over space.</span>
<span class="changed"> 120     assert(_first_node == NULL ||</span>
<span class="changed"> 121            _first_node-&gt;free_words() == 0, "Sanity");</span>
<span class="changed"> 122 </span>
<span class="changed"> 123     if (_can_expand) {</span>
<span class="changed"> 124       create_new_node();</span>
<span class="changed"> 125       UL2(debug, "added new node (now: %d).", num_nodes());</span>
 126     } else {
<a name="19" id="anc19"></a><span class="changed"> 127       UL(debug, "list cannot expand.");</span>
<span class="changed"> 128       return NULL; // We cannot expand this list.</span>






 129     }
<a name="20" id="anc20"></a>















 130   }
<a name="21" id="anc21"></a>



 131 
<a name="22" id="anc22"></a><span class="changed"> 132   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>

 133 
<a name="23" id="anc23"></a><span class="changed"> 134   assert(c != NULL, "This should have worked");</span>
 135 
<a name="24" id="anc24"></a><span class="changed"> 136   return c;</span>

 137 
<a name="25" id="anc25"></a>
 138 }
 139 
<a name="26" id="anc26"></a><span class="changed"> 140 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed"> 141 // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed"> 142 // Return number of purged nodes.</span>
<span class="changed"> 143 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>
































 144 
<a name="27" id="anc27"></a>

 145   assert_lock_strong(MetaspaceExpand_lock);
 146 
<a name="28" id="anc28"></a><span class="changed"> 147   if (_can_purge == false) {</span>
<span class="changed"> 148     return 0;</span>



 149   }
 150 
<a name="29" id="anc29"></a><span class="changed"> 151   UL(debug, "purging.");</span>



 152 
<a name="30" id="anc30"></a><span class="changed"> 153   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 154   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed"> 155   int num = 0, num_purged = 0;</span>
<span class="changed"> 156   while (vsn != NULL) {</span>
<span class="changed"> 157     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed"> 158     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed"> 159     if (purged) {</span>
<span class="changed"> 160       // Note: from now on do not dereference vsn!</span>
<span class="changed"> 161       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));</span>
<span class="changed"> 162       if (_first_node == vsn) {</span>
<span class="changed"> 163         _first_node = next_vsn;</span>
<span class="changed"> 164       }</span>
<span class="changed"> 165       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed"> 166       if (prev_vsn != NULL) {</span>
<span class="changed"> 167         prev_vsn-&gt;set_next(next_vsn);</span>



 168       }
<a name="31" id="anc31"></a><span class="changed"> 169       num_purged ++;</span>
<span class="changed"> 170       _nodes_counter.decrement();</span>






 171     } else {
<a name="32" id="anc32"></a><span class="changed"> 172       prev_vsn = vsn;</span>
 173     }
<a name="33" id="anc33"></a><span class="changed"> 174     vsn = next_vsn;</span>
<span class="changed"> 175     num ++;</span>











 176   }
<a name="34" id="anc34"></a>







 177 
<a name="35" id="anc35"></a><span class="changed"> 178   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());</span>
 179 
<a name="36" id="anc36"></a><span class="changed"> 180   return num_purged;</span>


 181 
<a name="37" id="anc37"></a>
 182 }
 183 
<a name="38" id="anc38"></a><span class="changed"> 184 // Print all nodes in this space list.</span>
<span class="changed"> 185 void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed"> 186   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>

 187 
<a name="39" id="anc39"></a><span class="changed"> 188   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed"> 189   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 190   int n = 0;</span>
<span class="changed"> 191   while (vsn != NULL) {</span>
<span class="changed"> 192     st-&gt;print("- node #%d: ", n);</span>
<span class="changed"> 193     vsn-&gt;print_on(st);</span>
<span class="changed"> 194     vsn = vsn-&gt;next();</span>
<span class="changed"> 195     n ++;</span>





 196   }
<a name="40" id="anc40"></a><span class="new"> 197   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="new"> 198                n, reserved_words(), committed_words());</span>
<span class="new"> 199 }</span>
 200 
<a name="41" id="anc41"></a><span class="changed"> 201 #ifdef ASSERT</span>
<span class="changed"> 202 void VirtualSpaceList::verify_locked(bool slow) const {</span>
 203 
<a name="42" id="anc42"></a><span class="changed"> 204   assert_lock_strong(MetaspaceExpand_lock);</span>
























 205 
<a name="43" id="anc43"></a><span class="changed"> 206   assert(_name != NULL, "Sanity");</span>



 207 
<a name="44" id="anc44"></a><span class="changed"> 208   int n = 0;</span>

 209 
<a name="45" id="anc45"></a><span class="changed"> 210   if (_first_node != NULL) {</span>















 211 
<a name="46" id="anc46"></a><span class="new"> 212     size_t total_reserved_words = 0;</span>
<span class="new"> 213     size_t total_committed_words = 0;</span>
<span class="new"> 214     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="new"> 215     while (vsn != NULL) {</span>
<span class="new"> 216       n ++;</span>
<span class="new"> 217       vsn-&gt;verify_locked(slow);</span>
<span class="new"> 218       total_reserved_words += vsn-&gt;word_size();</span>
<span class="new"> 219       total_committed_words += vsn-&gt;committed_words();</span>
<span class="new"> 220       vsn = vsn-&gt;next();</span>
<span class="new"> 221     }</span>
<span class="new"> 222 </span>
<span class="new"> 223     _nodes_counter.check(n);</span>
<span class="new"> 224     _reserved_words_counter.check(total_reserved_words);</span>
<span class="new"> 225     _committed_words_counter.check(total_committed_words);</span>
 226 
<a name="47" id="anc47"></a><span class="changed"> 227   } else {</span>
 228 
<a name="48" id="anc48"></a><span class="changed"> 229     _reserved_words_counter.check(0);</span>
<span class="changed"> 230     _committed_words_counter.check(0);</span>
 231 
<a name="49" id="anc49"></a>

 232   }
<a name="50" id="anc50"></a><span class="new"> 233 }</span>
 234 
<a name="51" id="anc51"></a><span class="changed"> 235 void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed"> 236   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 237   verify_locked(slow);</span>
<span class="changed"> 238 }</span>
<span class="changed"> 239 #endif</span>

 240 
<a name="52" id="anc52"></a><span class="changed"> 241 // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed"> 242 bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed"> 243   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 244   while (vsn != NULL) {</span>
<span class="changed"> 245     if (vsn-&gt;contains(p)) {</span>
<span class="changed"> 246       return true;</span>
 247     }
<a name="53" id="anc53"></a><span class="changed"> 248     vsn = vsn-&gt;next();</span>




 249   }
<a name="54" id="anc54"></a><span class="changed"> 250   return false;</span>

 251 }
 252 
<a name="55" id="anc55"></a><span class="changed"> 253 // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed"> 254 // can be allocated.</span>
<span class="changed"> 255 bool VirtualSpaceList::is_full() const {</span>
<span class="changed"> 256   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed"> 257     return true;</span>



 258   }
<a name="56" id="anc56"></a><span class="new"> 259   return false;</span>
 260 }
 261 
<a name="57" id="anc57"></a><span class="changed"> 262 // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed"> 263 //  and non-class chunkmanager, respectively.</span>
<span class="changed"> 264 VirtualSpaceList* VirtualSpaceList::vslist_class() {</span>
<span class="changed"> 265   return MetaspaceContext::context_class() == NULL ? NULL : MetaspaceContext::context_class()-&gt;vslist();</span>






 266 }
 267 
<a name="58" id="anc58"></a><span class="changed"> 268 VirtualSpaceList* VirtualSpaceList::vslist_nonclass() {</span>
<span class="changed"> 269   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;vslist();</span>


 270 }
 271 
 272 
<a name="59" id="anc59"></a>



























 273 
 274 } // namespace metaspace
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="60" type="hidden" /></form></body></html>
