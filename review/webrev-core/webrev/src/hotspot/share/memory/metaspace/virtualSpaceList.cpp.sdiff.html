<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/memory/metaspace </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/metaspaceStatistics.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/virtualSpaceList.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60538">60538</a> : imported patch jep387-core.patch</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
<span class="removed">  25 </span>
  26 #include "precompiled.hpp"
  27 #include "logging/log.hpp"
<span class="removed">  28 #include "logging/logStream.hpp"</span>
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<span class="changed">  31 #include "memory/metaspace/metachunk.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/metaspaceCommon.hpp"</span>



  33 #include "memory/metaspace/virtualSpaceList.hpp"
  34 #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="removed">  35 #include "runtime/atomic.hpp"</span>
<span class="removed">  36 #include "runtime/orderAccess.hpp"</span>
  37 #include "runtime/mutexLocker.hpp"
<span class="changed">  38 #include "runtime/safepoint.hpp"</span>
  39 
  40 namespace metaspace {
  41 


  42 
<span class="changed">  43 VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="changed">  44   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed">  45   while (iter.repeat()) {</span>
<span class="changed">  46     VirtualSpaceNode* vsl = iter.get_next();</span>
<span class="changed">  47     delete vsl;</span>
<span class="changed">  48   }</span>

























  49 }
  50 
<span class="changed">  51 void VirtualSpaceList::inc_reserved_words(size_t v) {</span>
<span class="changed">  52   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  53   _reserved_words = _reserved_words + v;</span>
<span class="changed">  54 }</span>
<span class="changed">  55 void VirtualSpaceList::dec_reserved_words(size_t v) {</span>
  56   assert_lock_strong(MetaspaceExpand_lock);
<span class="changed">  57   _reserved_words = _reserved_words - v;</span>








  58 }
  59 
<span class="changed">  60 #define assert_committed_below_limit()                        \</span>
<span class="changed">  61   assert(MetaspaceUtils::committed_bytes() &lt;= MaxMetaspaceSize, \</span>
<span class="changed">  62          "Too much committed memory. Committed: " SIZE_FORMAT \</span>
<span class="changed">  63          " limit (MaxMetaspaceSize): " SIZE_FORMAT,           \</span>
<span class="changed">  64           MetaspaceUtils::committed_bytes(), MaxMetaspaceSize);</span>
<span class="changed">  65 </span>
<span class="changed">  66 void VirtualSpaceList::inc_committed_words(size_t v) {</span>
  67   assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">  68   _committed_words = _committed_words + v;</span>
  69 
<span class="changed">  70   assert_committed_below_limit();</span>






  71 }
<span class="removed">  72 void VirtualSpaceList::dec_committed_words(size_t v) {</span>
<span class="removed">  73   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed">  74   _committed_words = _committed_words - v;</span>
  75 
<span class="changed">  76   assert_committed_below_limit();</span>
<span class="changed">  77 }</span>
<span class="changed">  78 </span>
<span class="changed">  79 void VirtualSpaceList::inc_virtual_space_count() {</span>

  80   assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">  81   _virtual_space_count++;</span>
<span class="removed">  82 }</span>
<span class="removed">  83 </span>
<span class="removed">  84 void VirtualSpaceList::dec_virtual_space_count() {</span>
<span class="removed">  85   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed">  86   _virtual_space_count--;</span>
<span class="removed">  87 }</span>
  88 
<span class="changed">  89 // Walk the list of VirtualSpaceNodes and delete</span>
<span class="changed">  90 // nodes with a 0 container_count.  Remove Metachunks in</span>
<span class="changed">  91 // the node from their respective freelists.</span>
<span class="changed">  92 void VirtualSpaceList::purge(ChunkManager* chunk_manager) {</span>
<span class="changed">  93   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  94   // Don't use a VirtualSpaceListIterator because this</span>
<span class="changed">  95   // list is being changed and a straightforward use of an iterator is not safe.</span>
<span class="changed">  96   VirtualSpaceNode* prev_vsl = virtual_space_list();</span>
<span class="changed">  97   VirtualSpaceNode* next_vsl = prev_vsl;</span>
<span class="changed">  98   int num_purged_nodes = 0;</span>
<span class="changed">  99   while (next_vsl != NULL) {</span>
<span class="changed"> 100     VirtualSpaceNode* vsl = next_vsl;</span>
<span class="changed"> 101     DEBUG_ONLY(vsl-&gt;verify(false);)</span>
<span class="changed"> 102     next_vsl = vsl-&gt;next();</span>
<span class="changed"> 103     // Don't free the current virtual space since it will likely</span>
<span class="changed"> 104     // be needed soon.</span>
<span class="changed"> 105     if (vsl-&gt;container_count() == 0 &amp;&amp; vsl != current_virtual_space()) {</span>
<span class="changed"> 106       log_trace(gc, metaspace, freelist)("Purging VirtualSpaceNode " PTR_FORMAT " (capacity: " SIZE_FORMAT</span>
<span class="changed"> 107                                          ", used: " SIZE_FORMAT ").", p2i(vsl), vsl-&gt;capacity_words_in_vs(), vsl-&gt;used_words_in_vs());</span>
<span class="changed"> 108       DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_purged));</span>
<span class="changed"> 109       // Unlink it from the list</span>
<span class="changed"> 110       if (prev_vsl == vsl) {</span>
<span class="changed"> 111         // This is the case of the current node being the first node.</span>
<span class="changed"> 112         assert(vsl == virtual_space_list(), "Expected to be the first node");</span>
<span class="changed"> 113         set_virtual_space_list(vsl-&gt;next());</span>
<span class="changed"> 114       } else {</span>
<span class="changed"> 115         prev_vsl-&gt;set_next(vsl-&gt;next());</span>
<span class="changed"> 116       }</span>
 117 
<span class="changed"> 118       vsl-&gt;purge(chunk_manager);</span>
<span class="changed"> 119       dec_reserved_words(vsl-&gt;reserved_words());</span>
<span class="changed"> 120       dec_committed_words(vsl-&gt;committed_words());</span>
<span class="changed"> 121       dec_virtual_space_count();</span>
<span class="changed"> 122       delete vsl;</span>
<span class="changed"> 123       num_purged_nodes ++;</span>



 124     } else {
<span class="changed"> 125       prev_vsl = vsl;</span>
<span class="changed"> 126     }</span>
<span class="changed"> 127   }</span>
<span class="changed"> 128 </span>
<span class="changed"> 129   // Verify list</span>
<span class="changed"> 130 #ifdef ASSERT</span>
<span class="changed"> 131   if (num_purged_nodes &gt; 0) {</span>
<span class="changed"> 132     verify(false);</span>
 133   }
<span class="removed"> 134 #endif</span>
<span class="removed"> 135 }</span>
<span class="removed"> 136 </span>
<span class="removed"> 137 </span>
<span class="removed"> 138 // This function looks at the mmap regions in the metaspace without locking.</span>
<span class="removed"> 139 // The chunks are added with store ordering and not deleted except for at</span>
<span class="removed"> 140 // unloading time during a safepoint.</span>
<span class="removed"> 141 VirtualSpaceNode* VirtualSpaceList::find_enclosing_space(const void* ptr) {</span>
<span class="removed"> 142   // List should be stable enough to use an iterator here because removing virtual</span>
<span class="removed"> 143   // space nodes is only allowed at a safepoint.</span>
<span class="removed"> 144   if (is_within_envelope((address)ptr)) {</span>
<span class="removed"> 145     VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="removed"> 146     while (iter.repeat()) {</span>
<span class="removed"> 147       VirtualSpaceNode* vsn = iter.get_next();</span>
<span class="removed"> 148       if (vsn-&gt;contains(ptr)) {</span>
<span class="removed"> 149         return vsn;</span>
 150       }
<span class="removed"> 151     }</span>
<span class="removed"> 152   }</span>
<span class="removed"> 153   return NULL;</span>
<span class="removed"> 154 }</span>
 155 
<span class="changed"> 156 void VirtualSpaceList::retire_current_virtual_space() {</span>
<span class="changed"> 157   assert_lock_strong(MetaspaceExpand_lock);</span>
 158 
<span class="changed"> 159   VirtualSpaceNode* vsn = current_virtual_space();</span>
 160 
<span class="changed"> 161   ChunkManager* cm = is_class() ? Metaspace::chunk_manager_class() :</span>
<span class="changed"> 162                                   Metaspace::chunk_manager_metadata();</span>
 163 
<span class="removed"> 164   vsn-&gt;retire(cm);</span>
 165 }
 166 
<span class="changed"> 167 VirtualSpaceList::VirtualSpaceList(size_t word_size) :</span>
<span class="changed"> 168                                    _virtual_space_list(NULL),</span>
<span class="changed"> 169                                    _current_virtual_space(NULL),</span>
<span class="changed"> 170                                    _is_class(false),</span>
<span class="changed"> 171                                    _reserved_words(0),</span>
<span class="changed"> 172                                    _committed_words(0),</span>
<span class="changed"> 173                                    _virtual_space_count(0),</span>
<span class="changed"> 174                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 175                                    _envelope_hi(NULL) {</span>
<span class="changed"> 176   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 177   create_new_virtual_space(word_size);</span>
<span class="changed"> 178 }</span>
<span class="changed"> 179 </span>
<span class="changed"> 180 VirtualSpaceList::VirtualSpaceList(ReservedSpace rs) :</span>
<span class="changed"> 181                                    _virtual_space_list(NULL),</span>
<span class="changed"> 182                                    _current_virtual_space(NULL),</span>
<span class="changed"> 183                                    _is_class(true),</span>
<span class="changed"> 184                                    _reserved_words(0),</span>
<span class="changed"> 185                                    _committed_words(0),</span>
<span class="changed"> 186                                    _virtual_space_count(0),</span>
<span class="changed"> 187                                    _envelope_lo((address)max_uintx),</span>
<span class="changed"> 188                                    _envelope_hi(NULL) {</span>
<span class="changed"> 189   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 190   VirtualSpaceNode* class_entry = new VirtualSpaceNode(is_class(), rs);</span>
<span class="changed"> 191   bool succeeded = class_entry-&gt;initialize();</span>
<span class="changed"> 192   if (succeeded) {</span>
<span class="changed"> 193     expand_envelope_to_include_node(class_entry);</span>
<span class="changed"> 194     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 195     OrderAccess::storestore();</span>
<span class="changed"> 196     link_vs(class_entry);</span>
<span class="changed"> 197   }</span>
<span class="changed"> 198 }</span>
<span class="changed"> 199 </span>
<span class="changed"> 200 size_t VirtualSpaceList::free_bytes() {</span>
<span class="changed"> 201   return current_virtual_space()-&gt;free_words_in_vs() * BytesPerWord;</span>
<span class="changed"> 202 }</span>
 203 
<span class="removed"> 204 // Allocate another meta virtual space and add it to the list.</span>
<span class="removed"> 205 bool VirtualSpaceList::create_new_virtual_space(size_t vs_word_size) {</span>
 206   assert_lock_strong(MetaspaceExpand_lock);
 207 
<span class="changed"> 208   if (is_class()) {</span>
<span class="changed"> 209     assert(false, "We currently don't support more than one VirtualSpace for"</span>
<span class="changed"> 210                   " the compressed class space. The initialization of the"</span>
<span class="changed"> 211                   " CCS uses another code path and should not hit this path.");</span>
<span class="changed"> 212     return false;</span>
 213   }
 214 
<span class="changed"> 215   if (vs_word_size == 0) {</span>
<span class="changed"> 216     assert(false, "vs_word_size should always be at least _reserve_alignment large.");</span>
<span class="changed"> 217     return false;</span>
<span class="changed"> 218   }</span>
 219 
<span class="changed"> 220   // Reserve the space</span>
<span class="changed"> 221   size_t vs_byte_size = vs_word_size * BytesPerWord;</span>
<span class="changed"> 222   assert_is_aligned(vs_byte_size, Metaspace::reserve_alignment());</span>
<span class="changed"> 223 </span>
<span class="changed"> 224   // Allocate the meta virtual space and initialize it.</span>
<span class="changed"> 225   VirtualSpaceNode* new_entry = new VirtualSpaceNode(is_class(), vs_byte_size);</span>
<span class="changed"> 226   if (!new_entry-&gt;initialize()) {</span>
<span class="changed"> 227     delete new_entry;</span>
<span class="changed"> 228     return false;</span>
<span class="changed"> 229   } else {</span>
<span class="changed"> 230     assert(new_entry-&gt;reserved_words() == vs_word_size,</span>
<span class="changed"> 231         "Reserved memory size differs from requested memory size");</span>
<span class="changed"> 232     expand_envelope_to_include_node(new_entry);</span>
<span class="changed"> 233     // ensure lock-free iteration sees fully initialized node</span>
<span class="changed"> 234     OrderAccess::storestore();</span>
<span class="changed"> 235     link_vs(new_entry);</span>
<span class="changed"> 236     DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_vsnodes_created));</span>
<span class="changed"> 237     return true;</span>
 238   }
<span class="changed"> 239 </span>
<span class="changed"> 240   DEBUG_ONLY(verify(false);)</span>
<span class="changed"> 241 </span>
<span class="changed"> 242 }</span>
<span class="changed"> 243 </span>
<span class="changed"> 244 void VirtualSpaceList::link_vs(VirtualSpaceNode* new_entry) {</span>
<span class="changed"> 245   if (virtual_space_list() == NULL) {</span>
<span class="changed"> 246       set_virtual_space_list(new_entry);</span>
 247   } else {
<span class="changed"> 248     current_virtual_space()-&gt;set_next(new_entry);</span>
 249   }
<span class="changed"> 250   set_current_virtual_space(new_entry);</span>
<span class="changed"> 251   inc_reserved_words(new_entry-&gt;reserved_words());</span>
<span class="changed"> 252   inc_committed_words(new_entry-&gt;committed_words());</span>
<span class="changed"> 253   inc_virtual_space_count();</span>
<span class="changed"> 254 #ifdef ASSERT</span>
<span class="changed"> 255   new_entry-&gt;mangle();</span>
<span class="changed"> 256 #endif</span>
<span class="changed"> 257   LogTarget(Trace, gc, metaspace) lt;</span>
<span class="changed"> 258   if (lt.is_enabled()) {</span>
<span class="changed"> 259     LogStream ls(lt);</span>
<span class="changed"> 260     VirtualSpaceNode* vsl = current_virtual_space();</span>
<span class="changed"> 261     ResourceMark rm;</span>
<span class="changed"> 262     vsl-&gt;print_on(&amp;ls);</span>
 263   }
<span class="removed"> 264 }</span>
<span class="removed"> 265 </span>
<span class="removed"> 266 bool VirtualSpaceList::expand_node_by(VirtualSpaceNode* node,</span>
<span class="removed"> 267                                       size_t min_words,</span>
<span class="removed"> 268                                       size_t preferred_words) {</span>
<span class="removed"> 269   size_t before = node-&gt;committed_words();</span>
<span class="removed"> 270 </span>
<span class="removed"> 271   bool result = node-&gt;expand_by(min_words, preferred_words);</span>
 272 
<span class="changed"> 273   size_t after = node-&gt;committed_words();</span>
 274 
<span class="changed"> 275   // after and before can be the same if the memory was pre-committed.</span>
<span class="changed"> 276   assert(after &gt;= before, "Inconsistency");</span>
<span class="changed"> 277   inc_committed_words(after - before);</span>
 278 
<span class="removed"> 279   return result;</span>
 280 }
 281 
<span class="changed"> 282 bool VirtualSpaceList::expand_by(size_t min_words, size_t preferred_words) {</span>
<span class="changed"> 283   assert_is_aligned(min_words,       Metaspace::commit_alignment_words());</span>
<span class="changed"> 284   assert_is_aligned(preferred_words, Metaspace::commit_alignment_words());</span>
<span class="changed"> 285   assert(min_words &lt;= preferred_words, "Invalid arguments");</span>
 286 
<span class="changed"> 287   const char* const class_or_not = (is_class() ? "class" : "non-class");</span>
<span class="changed"> 288 </span>
<span class="changed"> 289   if (!MetaspaceGC::can_expand(min_words, this-&gt;is_class())) {</span>
<span class="changed"> 290     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list.",</span>
<span class="changed"> 291               class_or_not);</span>
<span class="changed"> 292     return  false;</span>
<span class="changed"> 293   }</span>
<span class="changed"> 294 </span>
<span class="changed"> 295   size_t allowed_expansion_words = MetaspaceGC::allowed_expansion();</span>
<span class="changed"> 296   if (allowed_expansion_words &lt; min_words) {</span>
<span class="changed"> 297     log_trace(gc, metaspace, freelist)("Cannot expand %s virtual space list (must try gc first).",</span>
<span class="changed"> 298               class_or_not);</span>
<span class="changed"> 299     return false;</span>
 300   }



 301 
<span class="changed"> 302   size_t max_expansion_words = MIN2(preferred_words, allowed_expansion_words);</span>

 303 
<span class="changed"> 304   // Commit more memory from the the current virtual space.</span>
<span class="changed"> 305   bool vs_expanded = expand_node_by(current_virtual_space(),</span>
<span class="changed"> 306                                     min_words,</span>
<span class="changed"> 307                                     max_expansion_words);</span>
<span class="changed"> 308   if (vs_expanded) {</span>
<span class="changed"> 309      log_trace(gc, metaspace, freelist)("Expanded %s virtual space list.",</span>
<span class="changed"> 310                class_or_not);</span>
<span class="changed"> 311      return true;</span>
<span class="changed"> 312   }</span>
<span class="changed"> 313   log_trace(gc, metaspace, freelist)("%s virtual space list: retire current node.",</span>
<span class="changed"> 314             class_or_not);</span>
<span class="changed"> 315   retire_current_virtual_space();</span>
<span class="changed"> 316 </span>
<span class="changed"> 317   // Get another virtual space.</span>
<span class="changed"> 318   size_t grow_vs_words = MAX2((size_t)VirtualSpaceSize, preferred_words);</span>
<span class="changed"> 319   grow_vs_words = align_up(grow_vs_words, Metaspace::reserve_alignment_words());</span>
<span class="changed"> 320 </span>
<span class="changed"> 321   if (create_new_virtual_space(grow_vs_words)) {</span>
<span class="changed"> 322     if (current_virtual_space()-&gt;is_pre_committed()) {</span>
<span class="changed"> 323       // The memory was pre-committed, so we are done here.</span>
<span class="changed"> 324       assert(min_words &lt;= current_virtual_space()-&gt;committed_words(),</span>
<span class="changed"> 325           "The new VirtualSpace was pre-committed, so it"</span>
<span class="changed"> 326           "should be large enough to fit the alloc request.");</span>
<span class="changed"> 327       return true;</span>
<span class="changed"> 328     }</span>
 329 
<span class="changed"> 330     return expand_node_by(current_virtual_space(),</span>
<span class="changed"> 331                           min_words,</span>
<span class="changed"> 332                           max_expansion_words);</span>
<span class="changed"> 333   }</span>
 334 
<span class="changed"> 335   return false;</span>
<span class="changed"> 336 }</span>
 337 
<span class="changed"> 338 // Given a chunk, calculate the largest possible padding space which</span>
<span class="changed"> 339 // could be required when allocating it.</span>
<span class="changed"> 340 static size_t largest_possible_padding_size_for_chunk(size_t chunk_word_size, bool is_class) {</span>
<span class="changed"> 341   const ChunkIndex chunk_type = get_chunk_type_by_size(chunk_word_size, is_class);</span>
<span class="changed"> 342   if (chunk_type != HumongousIndex) {</span>
<span class="changed"> 343     // Normal, non-humongous chunks are allocated at chunk size</span>
<span class="changed"> 344     // boundaries, so the largest padding space required would be that</span>
<span class="changed"> 345     // minus the smallest chunk size.</span>
<span class="changed"> 346     const size_t smallest_chunk_size = is_class ? ClassSpecializedChunk : SpecializedChunk;</span>
<span class="changed"> 347     return chunk_word_size - smallest_chunk_size;</span>
<span class="changed"> 348   } else {</span>
<span class="changed"> 349     // Humongous chunks are allocated at smallest-chunksize</span>
<span class="changed"> 350     // boundaries, so there is no padding required.</span>
<span class="changed"> 351     return 0;</span>
<span class="changed"> 352   }</span>
<span class="changed"> 353 }</span>
 354 














 355 
<span class="changed"> 356 Metachunk* VirtualSpaceList::get_new_chunk(size_t chunk_word_size, size_t suggested_commit_granularity) {</span>
 357 
<span class="changed"> 358   // Allocate a chunk out of the current virtual space.</span>
<span class="changed"> 359   Metachunk* next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
 360 
<span class="removed"> 361   if (next != NULL) {</span>
<span class="removed"> 362     return next;</span>
 363   }

 364 
<span class="changed"> 365   // The expand amount is currently only determined by the requested sizes</span>
<span class="changed"> 366   // and not how much committed memory is left in the current virtual space.</span>
<span class="changed"> 367 </span>
<span class="changed"> 368   // We must have enough space for the requested size and any</span>
<span class="changed"> 369   // additional reqired padding chunks.</span>
<span class="changed"> 370   const size_t size_for_padding = largest_possible_padding_size_for_chunk(chunk_word_size, this-&gt;is_class());</span>
 371 
<span class="changed"> 372   size_t min_word_size       = align_up(chunk_word_size + size_for_padding, Metaspace::commit_alignment_words());</span>
<span class="changed"> 373   size_t preferred_word_size = align_up(suggested_commit_granularity, Metaspace::commit_alignment_words());</span>
<span class="changed"> 374   if (min_word_size &gt;= preferred_word_size) {</span>
<span class="changed"> 375     // Can happen when humongous chunks are allocated.</span>
<span class="changed"> 376     preferred_word_size = min_word_size;</span>

 377   }
<span class="changed"> 378 </span>
<span class="changed"> 379   bool expanded = expand_by(min_word_size, preferred_word_size);</span>
<span class="changed"> 380   if (expanded) {</span>
<span class="changed"> 381     next = current_virtual_space()-&gt;get_chunk_vs(chunk_word_size);</span>
<span class="changed"> 382     assert(next != NULL, "The allocation was expected to succeed after the expansion");</span>
 383   }
<span class="changed"> 384 </span>
<span class="changed"> 385    return next;</span>
 386 }
 387 
<span class="changed"> 388 void VirtualSpaceList::print_on(outputStream* st, size_t scale) const {</span>
<span class="changed"> 389   st-&gt;print_cr(SIZE_FORMAT " nodes, current node: " PTR_FORMAT,</span>
<span class="changed"> 390       _virtual_space_count, p2i(_current_virtual_space));</span>
<span class="changed"> 391   VirtualSpaceListIterator iter(virtual_space_list());</span>
<span class="changed"> 392   while (iter.repeat()) {</span>
<span class="changed"> 393     st-&gt;cr();</span>
<span class="changed"> 394     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 395     node-&gt;print_on(st, scale);</span>
 396   }

 397 }
 398 
<span class="changed"> 399 void VirtualSpaceList::print_map(outputStream* st) const {</span>
<span class="changed"> 400   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="changed"> 401   VirtualSpaceListIterator iter(list);</span>
<span class="changed"> 402   unsigned i = 0;</span>
<span class="changed"> 403   while (iter.repeat()) {</span>
<span class="changed"> 404     st-&gt;print_cr("Node %u:", i);</span>
<span class="changed"> 405     VirtualSpaceNode* node = iter.get_next();</span>
<span class="changed"> 406     node-&gt;print_map(st, this-&gt;is_class());</span>
<span class="changed"> 407     i ++;</span>
<span class="changed"> 408   }</span>
 409 }
 410 
<span class="changed"> 411 // Given a node, expand range such that it includes the node.</span>
<span class="changed"> 412 void VirtualSpaceList::expand_envelope_to_include_node(const VirtualSpaceNode* node) {</span>
<span class="changed"> 413   _envelope_lo = MIN2(_envelope_lo, (address)node-&gt;low_boundary());</span>
<span class="changed"> 414   _envelope_hi = MAX2(_envelope_hi, (address)node-&gt;high_boundary());</span>
 415 }
 416 
 417 
<span class="removed"> 418 #ifdef ASSERT</span>
<span class="removed"> 419 void VirtualSpaceList::verify(bool slow) {</span>
<span class="removed"> 420   VirtualSpaceNode* list = virtual_space_list();</span>
<span class="removed"> 421   VirtualSpaceListIterator iter(list);</span>
<span class="removed"> 422   size_t reserved = 0;</span>
<span class="removed"> 423   size_t committed = 0;</span>
<span class="removed"> 424   size_t node_count = 0;</span>
<span class="removed"> 425   while (iter.repeat()) {</span>
<span class="removed"> 426     VirtualSpaceNode* node = iter.get_next();</span>
<span class="removed"> 427     if (slow) {</span>
<span class="removed"> 428       node-&gt;verify(true);</span>
<span class="removed"> 429     }</span>
<span class="removed"> 430     // Check that the node resides fully within our envelope.</span>
<span class="removed"> 431     assert((address)node-&gt;low_boundary() &gt;= _envelope_lo &amp;&amp; (address)node-&gt;high_boundary() &lt;= _envelope_hi,</span>
<span class="removed"> 432            "Node " SIZE_FORMAT " [" PTR_FORMAT ", " PTR_FORMAT ") outside envelope [" PTR_FORMAT ", " PTR_FORMAT ").",</span>
<span class="removed"> 433            node_count, p2i(node-&gt;low_boundary()), p2i(node-&gt;high_boundary()), p2i(_envelope_lo), p2i(_envelope_hi));</span>
<span class="removed"> 434     reserved += node-&gt;reserved_words();</span>
<span class="removed"> 435     committed += node-&gt;committed_words();</span>
<span class="removed"> 436     node_count ++;</span>
<span class="removed"> 437   }</span>
<span class="removed"> 438   assert(reserved == reserved_words() &amp;&amp; committed == committed_words() &amp;&amp; node_count == _virtual_space_count,</span>
<span class="removed"> 439       "Mismatch: reserved real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed"> 440       ", committed real: " SIZE_FORMAT " expected: " SIZE_FORMAT</span>
<span class="removed"> 441       ", node count real: " SIZE_FORMAT " expected: " SIZE_FORMAT ".",</span>
<span class="removed"> 442       reserved, reserved_words(), committed, committed_words(),</span>
<span class="removed"> 443       node_count, _virtual_space_count);</span>
<span class="removed"> 444 }</span>
<span class="removed"> 445 #endif // ASSERT</span>
 446 
 447 } // namespace metaspace
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 

  26 #include "precompiled.hpp"
  27 #include "logging/log.hpp"

  28 #include "memory/metaspace.hpp"
  29 #include "memory/metaspace/chunkManager.hpp"
<span class="changed">  30 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  31 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/freeChunkList.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/metaspaceContext.hpp"</span>
  35 #include "memory/metaspace/virtualSpaceList.hpp"
  36 #include "memory/metaspace/virtualSpaceNode.hpp"


  37 #include "runtime/mutexLocker.hpp"
<span class="changed">  38 </span>
  39 
  40 namespace metaspace {
  41 
<span class="new">  42 #define LOGFMT         "VsList @" PTR_FORMAT " (%s)"</span>
<span class="new">  43 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  44 
<span class="changed">  45 // Create a new, empty, expandable list.</span>
<span class="changed">  46 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">  47   : _name(name),</span>
<span class="changed">  48     _first_node(NULL),</span>
<span class="changed">  49     _can_expand(true),</span>
<span class="changed">  50     _can_purge(true),</span>
<span class="changed">  51     _commit_limiter(commit_limiter),</span>
<span class="changed">  52     _reserved_words_counter(),</span>
<span class="changed">  53     _committed_words_counter()</span>
<span class="changed">  54 {</span>
<span class="changed">  55 }</span>
<span class="changed">  56 </span>
<span class="changed">  57 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">  58 // It will be not expandable beyond that first node.</span>
<span class="changed">  59 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">  60 : _name(name),</span>
<span class="changed">  61   _first_node(NULL),</span>
<span class="changed">  62   _can_expand(false),</span>
<span class="changed">  63   _can_purge(false),</span>
<span class="changed">  64   _commit_limiter(commit_limiter),</span>
<span class="changed">  65   _reserved_words_counter(),</span>
<span class="changed">  66   _committed_words_counter()</span>
<span class="changed">  67 {</span>
<span class="changed">  68   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">  69   // for this list since we cannot expand.</span>
<span class="changed">  70   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(rs, _commit_limiter,</span>
<span class="changed">  71                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">  72   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">  73   _first_node = vsn;</span>
<span class="changed">  74   _first_node-&gt;set_next(NULL);</span>
<span class="changed">  75   _nodes_counter.increment();</span>
  76 }
  77 
<span class="changed">  78 VirtualSpaceList::~VirtualSpaceList() {</span>




  79   assert_lock_strong(MetaspaceExpand_lock);
<span class="changed">  80   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">  81   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">  82   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">  83   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">  84   while (vsn != NULL) {</span>
<span class="changed">  85     vsn2 = vsn-&gt;next();</span>
<span class="changed">  86     delete vsn;</span>
<span class="changed">  87     vsn = vsn2;</span>
<span class="changed">  88   }</span>
  89 }
  90 
<span class="changed">  91 // Create a new node and append it to the list. After</span>
<span class="changed">  92 // this function, _current_node shall point to a new empty node.</span>
<span class="changed">  93 // List must be expandable for this to work.</span>
<span class="changed">  94 void VirtualSpaceList::create_new_node() {</span>
<span class="changed">  95   assert(_can_expand, "List is not expandable");</span>


  96   assert_lock_strong(MetaspaceExpand_lock);

  97 
<span class="changed">  98   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(Settings::virtual_space_node_default_word_size(),</span>
<span class="changed">  99                                                         _commit_limiter,</span>
<span class="changed"> 100                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed"> 101   assert(vsn != NULL, "node creation failed");</span>
<span class="changed"> 102   vsn-&gt;set_next(_first_node);</span>
<span class="changed"> 103   _first_node = vsn;</span>
<span class="changed"> 104   _nodes_counter.increment();</span>
 105 }



 106 
<span class="changed"> 107 // Allocate a root chunk from this list.</span>
<span class="changed"> 108 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 109 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 110 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 111 Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
 112   assert_lock_strong(MetaspaceExpand_lock);







 113 
<span class="changed"> 114   if (_first_node == NULL ||</span>
<span class="changed"> 115       _first_node-&gt;free_words() == 0) {</span>


























 116 
<span class="changed"> 117     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="changed"> 118     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="changed"> 119     // we should never have left-over space.</span>
<span class="changed"> 120     assert(_first_node == NULL ||</span>
<span class="changed"> 121            _first_node-&gt;free_words() == 0, "Sanity");</span>
<span class="changed"> 122 </span>
<span class="changed"> 123     if (_can_expand) {</span>
<span class="changed"> 124       create_new_node();</span>
<span class="changed"> 125       UL2(debug, "added new node (now: %d).", num_nodes());</span>
 126     } else {
<span class="changed"> 127       UL(debug, "list cannot expand.");</span>
<span class="changed"> 128       return NULL; // We cannot expand this list.</span>






 129     }
















 130   }




 131 
<span class="changed"> 132   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>

 133 
<span class="changed"> 134   assert(c != NULL, "This should have worked");</span>
 135 
<span class="changed"> 136   return c;</span>

 137 

 138 }
 139 
<span class="changed"> 140 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed"> 141 // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed"> 142 // Return number of purged nodes.</span>
<span class="changed"> 143 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>
































 144 


 145   assert_lock_strong(MetaspaceExpand_lock);
 146 
<span class="changed"> 147   if (_can_purge == false) {</span>
<span class="changed"> 148     return 0;</span>



 149   }
 150 
<span class="changed"> 151   UL(debug, "purging.");</span>



 152 
<span class="changed"> 153   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 154   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed"> 155   int num = 0, num_purged = 0;</span>
<span class="changed"> 156   while (vsn != NULL) {</span>
<span class="changed"> 157     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed"> 158     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed"> 159     if (purged) {</span>
<span class="changed"> 160       // Note: from now on do not dereference vsn!</span>
<span class="changed"> 161       UL2(debug, "purged node @" PTR_FORMAT ".", p2i(vsn));</span>
<span class="changed"> 162       if (_first_node == vsn) {</span>
<span class="changed"> 163         _first_node = next_vsn;</span>
<span class="changed"> 164       }</span>
<span class="changed"> 165       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed"> 166       if (prev_vsn != NULL) {</span>
<span class="changed"> 167         prev_vsn-&gt;set_next(next_vsn);</span>



 168       }
<span class="changed"> 169       num_purged ++;</span>
<span class="changed"> 170       _nodes_counter.decrement();</span>






 171     } else {
<span class="changed"> 172       prev_vsn = vsn;</span>
 173     }
<span class="changed"> 174     vsn = next_vsn;</span>
<span class="changed"> 175     num ++;</span>











 176   }








 177 
<span class="changed"> 178   UL2(debug, "purged %d nodes (now: %d)", num_purged, num_nodes());</span>
 179 
<span class="changed"> 180   return num_purged;</span>


 181 

 182 }
 183 
<span class="changed"> 184 // Print all nodes in this space list.</span>
<span class="changed"> 185 void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed"> 186   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>

 187 
<span class="changed"> 188   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed"> 189   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 190   int n = 0;</span>
<span class="changed"> 191   while (vsn != NULL) {</span>
<span class="changed"> 192     st-&gt;print("- node #%d: ", n);</span>
<span class="changed"> 193     vsn-&gt;print_on(st);</span>
<span class="changed"> 194     vsn = vsn-&gt;next();</span>
<span class="changed"> 195     n ++;</span>





 196   }
<span class="new"> 197   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="new"> 198                n, reserved_words(), committed_words());</span>
<span class="new"> 199 }</span>
 200 
<span class="changed"> 201 #ifdef ASSERT</span>
<span class="changed"> 202 void VirtualSpaceList::verify_locked(bool slow) const {</span>
 203 
<span class="changed"> 204   assert_lock_strong(MetaspaceExpand_lock);</span>
























 205 
<span class="changed"> 206   assert(_name != NULL, "Sanity");</span>



 207 
<span class="changed"> 208   int n = 0;</span>

 209 
<span class="changed"> 210   if (_first_node != NULL) {</span>















 211 
<span class="new"> 212     size_t total_reserved_words = 0;</span>
<span class="new"> 213     size_t total_committed_words = 0;</span>
<span class="new"> 214     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="new"> 215     while (vsn != NULL) {</span>
<span class="new"> 216       n ++;</span>
<span class="new"> 217       vsn-&gt;verify_locked(slow);</span>
<span class="new"> 218       total_reserved_words += vsn-&gt;word_size();</span>
<span class="new"> 219       total_committed_words += vsn-&gt;committed_words();</span>
<span class="new"> 220       vsn = vsn-&gt;next();</span>
<span class="new"> 221     }</span>
<span class="new"> 222 </span>
<span class="new"> 223     _nodes_counter.check(n);</span>
<span class="new"> 224     _reserved_words_counter.check(total_reserved_words);</span>
<span class="new"> 225     _committed_words_counter.check(total_committed_words);</span>
 226 
<span class="changed"> 227   } else {</span>
 228 
<span class="changed"> 229     _reserved_words_counter.check(0);</span>
<span class="changed"> 230     _committed_words_counter.check(0);</span>
 231 


 232   }
<span class="new"> 233 }</span>
 234 
<span class="changed"> 235 void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed"> 236   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 237   verify_locked(slow);</span>
<span class="changed"> 238 }</span>
<span class="changed"> 239 #endif</span>

 240 
<span class="changed"> 241 // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed"> 242 bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed"> 243   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 244   while (vsn != NULL) {</span>
<span class="changed"> 245     if (vsn-&gt;contains(p)) {</span>
<span class="changed"> 246       return true;</span>
 247     }
<span class="changed"> 248     vsn = vsn-&gt;next();</span>




 249   }
<span class="changed"> 250   return false;</span>

 251 }
 252 
<span class="changed"> 253 // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed"> 254 // can be allocated.</span>
<span class="changed"> 255 bool VirtualSpaceList::is_full() const {</span>
<span class="changed"> 256   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed"> 257     return true;</span>



 258   }
<span class="new"> 259   return false;</span>
 260 }
 261 
<span class="changed"> 262 // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed"> 263 //  and non-class chunkmanager, respectively.</span>
<span class="changed"> 264 VirtualSpaceList* VirtualSpaceList::vslist_class() {</span>
<span class="changed"> 265   return MetaspaceContext::context_class() == NULL ? NULL : MetaspaceContext::context_class()-&gt;vslist();</span>






 266 }
 267 
<span class="changed"> 268 VirtualSpaceList* VirtualSpaceList::vslist_nonclass() {</span>
<span class="changed"> 269   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;vslist();</span>


 270 }
 271 
 272 




























 273 
 274 } // namespace metaspace
</pre></td>
</tr></table>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/metaspaceStatistics.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceList.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
