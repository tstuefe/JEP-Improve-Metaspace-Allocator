<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/memory/metaspace </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/metachunk.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-core.patch</pre>

<table><tr valign="top">
<td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
<span class="changed">  26 #include "memory/allocation.hpp"</span>


  27 #include "memory/metaspace/metachunk.hpp"
<span class="changed">  28 #include "memory/metaspace/occupancyMap.hpp"</span>

  29 #include "memory/metaspace/virtualSpaceNode.hpp"


  30 #include "utilities/align.hpp"
  31 #include "utilities/copy.hpp"
  32 #include "utilities/debug.hpp"
  33 
  34 namespace metaspace {
  35 
<span class="changed">  36 size_t Metachunk::object_alignment() {</span>
<span class="changed">  37   // Must align pointers and sizes to 8,</span>
<span class="changed">  38   // so that 64 bit types get correctly aligned.</span>
<span class="changed">  39   const size_t alignment = 8;</span>
<span class="changed">  40 </span>
<span class="changed">  41   // Make sure that the Klass alignment also agree.</span>
<span class="changed">  42   STATIC_ASSERT(alignment == (size_t)KlassAlignmentInBytes);</span>
<span class="changed">  43 </span>
<span class="changed">  44   return alignment;</span>
<span class="changed">  45 }</span>
<span class="changed">  46 </span>
<span class="changed">  47 size_t Metachunk::overhead() {</span>
<span class="changed">  48   return align_up(sizeof(Metachunk), object_alignment()) / BytesPerWord;</span>
<span class="changed">  49 }</span>
<span class="changed">  50 </span>
<span class="changed">  51 // Metachunk methods</span>
<span class="changed">  52 </span>
<span class="changed">  53 Metachunk::Metachunk(ChunkIndex chunktype, bool is_class, size_t word_size,</span>
<span class="changed">  54                      VirtualSpaceNode* container)</span>
<span class="changed">  55     : Metabase&lt;Metachunk&gt;(word_size),</span>
<span class="changed">  56     _container(container),</span>
<span class="changed">  57     _top(NULL),</span>
<span class="changed">  58     _sentinel(CHUNK_SENTINEL),</span>
<span class="changed">  59     _chunk_type(chunktype),</span>
<span class="changed">  60     _is_class(is_class),</span>
<span class="changed">  61     _origin(origin_normal),</span>
<span class="changed">  62     _use_count(0)</span>
<span class="changed">  63 {</span>
<span class="changed">  64   _top = initial_top();</span>
<span class="changed">  65   set_is_tagged_free(false);</span>
  66 #ifdef ASSERT
<span class="changed">  67   mangle(uninitMetaWordVal);</span>
<span class="changed">  68   verify();</span>
<span class="changed">  69 #endif</span>
  70 }

















































  71 
<span class="changed">  72 MetaWord* Metachunk::allocate(size_t word_size) {</span>
<span class="changed">  73   MetaWord* result = NULL;</span>
<span class="changed">  74   // If available, bump the pointer to allocate.</span>
<span class="changed">  75   if (free_word_size() &gt;= word_size) {</span>
<span class="changed">  76     result = _top;</span>
<span class="changed">  77     _top = _top + word_size;</span>

  78   }
<span class="changed">  79   return result;</span>








  80 }
  81 
<span class="changed">  82 // _bottom points to the start of the chunk including the overhead.</span>
<span class="changed">  83 size_t Metachunk::used_word_size() const {</span>
<span class="changed">  84   return pointer_delta(_top, bottom(), sizeof(MetaWord));</span>











  85 }
  86 
<span class="changed">  87 size_t Metachunk::free_word_size() const {</span>
<span class="changed">  88   return pointer_delta(end(), _top, sizeof(MetaWord));</span>











  89 }
  90 
<span class="changed">  91 void Metachunk::print_on(outputStream* st) const {</span>
<span class="changed">  92   st-&gt;print_cr("Metachunk:"</span>
<span class="changed">  93                " bottom " PTR_FORMAT " top " PTR_FORMAT</span>
<span class="changed">  94                " end " PTR_FORMAT " size " SIZE_FORMAT " (%s)",</span>
<span class="changed">  95                p2i(bottom()), p2i(_top), p2i(end()), word_size(),</span>
<span class="changed">  96                chunk_size_name(get_chunk_type()));</span>
<span class="changed">  97   if (Verbose) {</span>
<span class="changed">  98     st-&gt;print_cr("    used " SIZE_FORMAT " free " SIZE_FORMAT,</span>
<span class="changed">  99                  used_word_size(), free_word_size());</span>








 100   }
 101 }































 102 
 103 #ifdef ASSERT
<span class="changed"> 104 void Metachunk::mangle(juint word_value) {</span>
<span class="changed"> 105   // Overwrite the payload of the chunk and not the links that</span>
<span class="changed"> 106   // maintain list of chunks.</span>
<span class="changed"> 107   HeapWord* start = (HeapWord*)initial_top();</span>
<span class="changed"> 108   size_t size = word_size() - overhead();</span>
<span class="changed"> 109   Copy::fill_to_words(start, size, word_value);</span>
<span class="changed"> 110 }</span>
<span class="changed"> 111 </span>
<span class="changed"> 112 void Metachunk::verify() const {</span>
<span class="changed"> 113   assert(is_valid_sentinel(), "Chunk " PTR_FORMAT ": sentinel invalid", p2i(this));</span>
<span class="changed"> 114   const ChunkIndex chunk_type = get_chunk_type();</span>
<span class="changed"> 115   assert(is_valid_chunktype(chunk_type), "Chunk " PTR_FORMAT ": Invalid chunk type.", p2i(this));</span>
<span class="changed"> 116   if (chunk_type != HumongousIndex) {</span>
<span class="changed"> 117     assert(word_size() == get_size_for_nonhumongous_chunktype(chunk_type, is_class()),</span>
<span class="changed"> 118            "Chunk " PTR_FORMAT ": wordsize " SIZE_FORMAT " does not fit chunk type %s.",</span>
<span class="changed"> 119            p2i(this), word_size(), chunk_size_name(chunk_type));</span>
<span class="changed"> 120   }</span>
<span class="changed"> 121   assert(is_valid_chunkorigin(get_origin()), "Chunk " PTR_FORMAT ": Invalid chunk origin.", p2i(this));</span>
<span class="changed"> 122   assert(bottom() &lt;= _top &amp;&amp; _top &lt;= (MetaWord*)end(),</span>
<span class="changed"> 123          "Chunk " PTR_FORMAT ": Chunk top out of chunk bounds.", p2i(this));</span>
<span class="changed"> 124 </span>
<span class="changed"> 125   // For non-humongous chunks, starting address shall be aligned</span>
<span class="changed"> 126   // to its chunk size. Humongous chunks start address is</span>
<span class="changed"> 127   // aligned to specialized chunk size.</span>
<span class="changed"> 128   const size_t required_alignment =</span>
<span class="changed"> 129     (chunk_type != HumongousIndex ? word_size() : get_size_for_nonhumongous_chunktype(SpecializedIndex, is_class())) * sizeof(MetaWord);</span>
<span class="changed"> 130   assert(is_aligned((address)this, required_alignment),</span>
<span class="changed"> 131          "Chunk " PTR_FORMAT ": (size " SIZE_FORMAT ") not aligned to " SIZE_FORMAT ".",</span>
<span class="changed"> 132          p2i(this), word_size() * sizeof(MetaWord), required_alignment);</span>
 133 }
 134 
<span class="changed"> 135 #endif // ASSERT</span>











































































































































 136 
<span class="removed"> 137 // Helper, returns a descriptive name for the given index.</span>
<span class="removed"> 138 const char* chunk_size_name(ChunkIndex index) {</span>
<span class="removed"> 139   switch (index) {</span>
<span class="removed"> 140     case SpecializedIndex:</span>
<span class="removed"> 141       return "specialized";</span>
<span class="removed"> 142     case SmallIndex:</span>
<span class="removed"> 143       return "small";</span>
<span class="removed"> 144     case MediumIndex:</span>
<span class="removed"> 145       return "medium";</span>
<span class="removed"> 146     case HumongousIndex:</span>
<span class="removed"> 147       return "humongous";</span>
<span class="removed"> 148     default:</span>
<span class="removed"> 149       return "Invalid index";</span>
 150   }
 151 }
 152 
<span class="changed"> 153 #ifdef ASSERT</span>
<span class="changed"> 154 void do_verify_chunk(Metachunk* chunk) {</span>
<span class="changed"> 155   guarantee(chunk != NULL, "Sanity");</span>
<span class="changed"> 156   // Verify chunk itself; then verify that it is consistent with the</span>
<span class="changed"> 157   // occupany map of its containing node.</span>
<span class="changed"> 158   chunk-&gt;verify();</span>
<span class="changed"> 159   VirtualSpaceNode* const vsn = chunk-&gt;container();</span>
<span class="changed"> 160   OccupancyMap* const ocmap = vsn-&gt;occupancy_map();</span>
<span class="changed"> 161   ocmap-&gt;verify_for_chunk(chunk);</span>












































































 162 }
<span class="removed"> 163 #endif</span>
 164 
<span class="changed"> 165 void do_update_in_use_info_for_chunk(Metachunk* chunk, bool inuse) {</span>
<span class="changed"> 166   chunk-&gt;set_is_tagged_free(!inuse);</span>
<span class="changed"> 167   OccupancyMap* const ocmap = chunk-&gt;container()-&gt;occupancy_map();</span>
<span class="changed"> 168   ocmap-&gt;set_region_in_use((MetaWord*)chunk, chunk-&gt;word_size(), inuse);</span>























































 169 }
 170 
 171 } // namespace metaspace
 172 
</pre></td><td><pre>
   1 /*
<span class="changed">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2017, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
<span class="changed">  27 </span>
<span class="changed">  28 #include "logging/log.hpp"</span>
<span class="changed">  29 #include "memory/metaspace/chunkLevel.hpp"</span>
  30 #include "memory/metaspace/metachunk.hpp"
<span class="changed">  31 #include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/settings.hpp"</span>
  33 #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="new">  34 #include "runtime/mutexLocker.hpp"</span>
<span class="new">  35 </span>
  36 #include "utilities/align.hpp"
  37 #include "utilities/copy.hpp"
  38 #include "utilities/debug.hpp"
  39 
  40 namespace metaspace {
  41 
<span class="changed">  42 // Return a single char presentation of the state ('f', 'u', 'd')</span>
<span class="changed">  43 char Metachunk::get_state_char() const {</span>
<span class="changed">  44   switch (_state) {</span>
<span class="changed">  45   case state_free:    return 'f';</span>
<span class="changed">  46   case state_in_use:  return 'u';</span>
<span class="changed">  47   case state_dead:    return 'd';</span>
<span class="changed">  48   }</span>
<span class="changed">  49   return '?';</span>
<span class="changed">  50 }</span>
<span class="changed">  51 </span>




















  52 #ifdef ASSERT
<span class="changed">  53 void Metachunk::assert_have_expand_lock() {</span>
<span class="changed">  54   assert_lock_strong(MetaspaceExpand_lock);</span>

  55 }
<span class="new">  56 #endif</span>
<span class="new">  57 </span>
<span class="new">  58 // Commit uncommitted section of the chunk.</span>
<span class="new">  59 // Fails if we hit a commit limit.</span>
<span class="new">  60 bool Metachunk::commit_up_to(size_t new_committed_words) {</span>
<span class="new">  61 </span>
<span class="new">  62   // Please note:</span>
<span class="new">  63   //</span>
<span class="new">  64   // VirtualSpaceNode::ensure_range_is_committed(), when called over a range containing both committed and uncommitted parts,</span>
<span class="new">  65   // will replace the whole range with a new mapping, thus erasing the existing content in the committed parts. Therefore</span>
<span class="new">  66   // we must make sure never to call VirtualSpaceNode::ensure_range_is_committed() over a range containing live data.</span>
<span class="new">  67   //</span>
<span class="new">  68   // Luckily, this cannot happen by design. We have two cases:</span>
<span class="new">  69   //</span>
<span class="new">  70   // 1) chunks equal or larger than a commit granule.</span>
<span class="new">  71   //    In this case, due to chunk geometry, the chunk should cover whole commit granules (in other words, a chunk equal or larger than</span>
<span class="new">  72   //    a commit granule will never share a granule with a neighbor). That means whatever we commit or uncommit here does not affect</span>
<span class="new">  73   //    neighboring chunks. We only have to take care not to re-commit used parts of ourself. We do this by moving the committed_words</span>
<span class="new">  74   //    limit in multiple of commit granules.</span>
<span class="new">  75   //</span>
<span class="new">  76   // 2) chunks smaller than a commit granule.</span>
<span class="new">  77   //    In this case, a chunk shares a single commit granule with its neighbors. But this never can be a problem:</span>
<span class="new">  78   //    - Either the commit granule is already committed (and maybe the neighbors contain live data). In that case calling</span>
<span class="new">  79   //      ensure_range_is_committed() will do nothing.</span>
<span class="new">  80   //    - Or the commit granule is not committed, but in this case, the neighbors are uncommitted too and cannot contain live data.</span>
<span class="new">  81 </span>
<span class="new">  82 #ifdef ASSERT</span>
<span class="new">  83   if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="new">  84     // case (1)</span>
<span class="new">  85     assert(is_aligned(base(), Settings::commit_granule_bytes()) &amp;&amp;</span>
<span class="new">  86            is_aligned(end(), Settings::commit_granule_bytes()),</span>
<span class="new">  87            "Chunks larger than a commit granule must cover whole granules.");</span>
<span class="new">  88     assert(is_aligned(_committed_words, Settings::commit_granule_words()),</span>
<span class="new">  89            "The commit boundary must be aligned to commit granule size");</span>
<span class="new">  90     assert(_used_words &lt;= _committed_words, "Sanity");</span>
<span class="new">  91   } else {</span>
<span class="new">  92     // case (2)</span>
<span class="new">  93     assert(_committed_words == 0 || _committed_words == word_size(), "Sanity");</span>
<span class="new">  94   }</span>
<span class="new">  95 #endif</span>
<span class="new">  96 </span>
<span class="new">  97   // We should hold the expand lock at this point.</span>
<span class="new">  98   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">  99 </span>
<span class="new"> 100   const size_t commit_from = _committed_words;</span>
<span class="new"> 101   const size_t commit_to =   MIN2(align_up(new_committed_words, Settings::commit_granule_words()), word_size());</span>
<span class="new"> 102 </span>
<span class="new"> 103   assert(commit_from &gt;= used_words(), "Sanity");</span>
<span class="new"> 104   assert(commit_to &lt;= word_size(), "Sanity");</span>
 105 
<span class="changed"> 106   if (commit_to &gt; commit_from) {</span>
<span class="changed"> 107     log_debug(metaspace)("Chunk " METACHUNK_FORMAT ": attempting to move commit line to "</span>
<span class="changed"> 108                          SIZE_FORMAT " words.", METACHUNK_FORMAT_ARGS(this), commit_to);</span>
<span class="changed"> 109 </span>
<span class="changed"> 110     if (!_vsnode-&gt;ensure_range_is_committed(base() + commit_from, commit_to - commit_from)) {</span>
<span class="changed"> 111       DEBUG_ONLY(verify(true);)</span>
<span class="changed"> 112       return false;</span>
 113     }
<span class="changed"> 114   }</span>
<span class="changed"> 115 </span>
<span class="changed"> 116   // Remember how far we have committed.</span>
<span class="changed"> 117   _committed_words = commit_to;</span>
<span class="changed"> 118 </span>
<span class="changed"> 119   DEBUG_ONLY(verify(true);)</span>
<span class="changed"> 120 </span>
<span class="changed"> 121   return true;</span>
<span class="changed"> 122 </span>
 123 }
 124 
<span class="changed"> 125 </span>
<span class="changed"> 126 // Ensure that chunk is committed up to at least new_committed_words words.</span>
<span class="changed"> 127 // Fails if we hit a commit limit.</span>
<span class="changed"> 128 bool Metachunk::ensure_committed(size_t new_committed_words) {</span>
<span class="changed"> 129 </span>
<span class="changed"> 130   bool rc = true;</span>
<span class="changed"> 131 </span>
<span class="changed"> 132   if (new_committed_words &gt; committed_words()) {</span>
<span class="changed"> 133     MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 134     rc = commit_up_to(new_committed_words);</span>
<span class="changed"> 135   }</span>
<span class="changed"> 136 </span>
<span class="changed"> 137   return rc;</span>
<span class="changed"> 138 </span>
 139 }
 140 
<span class="changed"> 141 bool Metachunk::ensure_committed_locked(size_t new_committed_words) {</span>
<span class="changed"> 142 </span>
<span class="changed"> 143   // the .._locked() variant should be called if we own the lock already.</span>
<span class="changed"> 144   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 145 </span>
<span class="changed"> 146   bool rc = true;</span>
<span class="changed"> 147 </span>
<span class="changed"> 148   if (new_committed_words &gt; committed_words()) {</span>
<span class="changed"> 149     rc = commit_up_to(new_committed_words);</span>
<span class="changed"> 150   }</span>
<span class="changed"> 151 </span>
<span class="changed"> 152   return rc;</span>
<span class="changed"> 153 </span>
 154 }
 155 
<span class="changed"> 156 // Uncommit chunk area. The area must be a common multiple of the</span>
<span class="changed"> 157 // commit granule size (in other words, we cannot uncommit chunks smaller than</span>
<span class="changed"> 158 // a commit granule size).</span>
<span class="changed"> 159 void Metachunk::uncommit() {</span>
<span class="changed"> 160   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 161   uncommit_locked();</span>
<span class="changed"> 162 }</span>
<span class="changed"> 163 </span>
<span class="changed"> 164 void Metachunk::uncommit_locked() {</span>
<span class="changed"> 165   // Only uncommit chunks which are free, have no used words set (extra precaution) and are equal or larger in size than a single commit granule.</span>
<span class="changed"> 166   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 167   assert(_state == state_free &amp;&amp; _used_words == 0 &amp;&amp; word_size() &gt;= Settings::commit_granule_words(),</span>
<span class="changed"> 168          "Only free chunks equal or larger than commit granule size can be uncommitted "</span>
<span class="changed"> 169          "(chunk " METACHUNK_FULL_FORMAT ").", METACHUNK_FULL_FORMAT_ARGS(this));</span>
<span class="changed"> 170   if (word_size() &gt;= Settings::commit_granule_words()) {</span>
<span class="changed"> 171     _vsnode-&gt;uncommit_range(base(), word_size());</span>
<span class="changed"> 172     _committed_words = 0;</span>
 173   }
 174 }
<span class="new"> 175 void Metachunk::set_committed_words(size_t v) {</span>
<span class="new"> 176   // Set committed words. Since we know that we only commit whole commit granules, we can round up v here.</span>
<span class="new"> 177   v = MIN2(align_up(v, Settings::commit_granule_words()), word_size());</span>
<span class="new"> 178  _committed_words = v;</span>
<span class="new"> 179 }</span>
<span class="new"> 180 </span>
<span class="new"> 181 </span>
<span class="new"> 182 // Allocate word_size words from this chunk (word_size must be aligned to</span>
<span class="new"> 183 //  allocation_alignment_words).</span>
<span class="new"> 184 //</span>
<span class="new"> 185 // Caller must make sure the chunk is both large enough and committed far enough</span>
<span class="new"> 186 // to hold the allocation. Will always work.</span>
<span class="new"> 187 //</span>
<span class="new"> 188 MetaWord* Metachunk::allocate(size_t request_word_size) {</span>
<span class="new"> 189 </span>
<span class="new"> 190   log_trace(metaspace)("Chunk " METACHUNK_FULL_FORMAT ": allocating " SIZE_FORMAT " words.",</span>
<span class="new"> 191                        METACHUNK_FULL_FORMAT_ARGS(this), request_word_size);</span>
<span class="new"> 192 </span>
<span class="new"> 193   // Caller must have made sure this works</span>
<span class="new"> 194   assert(free_words() &gt;= request_word_size, "Chunk too small.");</span>
<span class="new"> 195   assert(free_below_committed_words() &gt;= request_word_size, "Chunk not committed.");</span>
<span class="new"> 196 </span>
<span class="new"> 197   MetaWord* const p = top();</span>
<span class="new"> 198 </span>
<span class="new"> 199   _used_words += request_word_size;</span>
<span class="new"> 200 </span>
<span class="new"> 201   SOMETIMES(verify(false);)</span>
<span class="new"> 202 </span>
<span class="new"> 203   return p;</span>
<span class="new"> 204 </span>
<span class="new"> 205 }</span>
 206 
 207 #ifdef ASSERT
<span class="changed"> 208 </span>
<span class="changed"> 209 // Zap this structure.</span>
<span class="changed"> 210 void Metachunk::zap_header(uint8_t c) {</span>
<span class="changed"> 211   memset(this, c, sizeof(Metachunk));</span>

























 212 }
 213 
<span class="changed"> 214 void Metachunk::fill_with_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="changed"> 215   assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="changed"> 216   for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="changed"> 217     _base[l] = pattern;</span>
<span class="changed"> 218   }</span>
<span class="changed"> 219 }</span>
<span class="changed"> 220 </span>
<span class="changed"> 221 void Metachunk::check_pattern(MetaWord pattern, size_t word_size) {</span>
<span class="changed"> 222   assert(word_size &lt;= committed_words(), "Sanity");</span>
<span class="changed"> 223   for (size_t l = 0; l &lt; word_size; l ++) {</span>
<span class="changed"> 224     assert(_base[l] == pattern,</span>
<span class="changed"> 225            "chunk " METACHUNK_FULL_FORMAT ": pattern change at " PTR_FORMAT ": expected " UINTX_FORMAT " but got " UINTX_FORMAT ".",</span>
<span class="changed"> 226            METACHUNK_FULL_FORMAT_ARGS(this), p2i(_base + l), (uintx)pattern, (uintx)_base[l]);</span>
<span class="changed"> 227 </span>
<span class="changed"> 228     ////////////////////////////////////////////</span>
<span class="changed"> 229     // A double-headed list of Metachunks.</span>
<span class="changed"> 230 </span>
<span class="changed"> 231     class AbstractMetachunkList {</span>
<span class="changed"> 232 </span>
<span class="changed"> 233       Metachunk* _first;</span>
<span class="changed"> 234       Metachunk* _last;</span>
<span class="changed"> 235 </span>
<span class="changed"> 236       // Number of chunks</span>
<span class="changed"> 237       IntCounter _num;</span>
<span class="changed"> 238 </span>
<span class="changed"> 239     protected:</span>
<span class="changed"> 240 </span>
<span class="changed"> 241       AbstractMetachunkList() : _first(NULL), _last(NULL), _num() {}</span>
<span class="changed"> 242 </span>
<span class="changed"> 243       Metachunk* first() const { return _first; }</span>
<span class="changed"> 244       int count() const { return _num.get(); }</span>
<span class="changed"> 245 </span>
<span class="changed"> 246       // Add chunk to the front of the list.</span>
<span class="changed"> 247       void add_front(Metachunk* c) {</span>
<span class="changed"> 248         if (_first == NULL) {</span>
<span class="changed"> 249           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 250           _first = _last = c;</span>
<span class="changed"> 251           c-&gt;set_prev(NULL);</span>
<span class="changed"> 252           c-&gt;set_next(NULL);</span>
<span class="changed"> 253         } else {</span>
<span class="changed"> 254           assert(_last != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="changed"> 255           c-&gt;set_next(_first);</span>
<span class="changed"> 256           c-&gt;set_prev(NULL);</span>
<span class="changed"> 257           _first-&gt;set_prev(c);</span>
<span class="changed"> 258           _first = c;</span>
<span class="changed"> 259         }</span>
<span class="changed"> 260         _num.increment();</span>
<span class="changed"> 261       }</span>
<span class="changed"> 262 </span>
<span class="changed"> 263       // Add chunk to the back of the list.</span>
<span class="changed"> 264       void add_back(Metachunk* c) {</span>
<span class="changed"> 265         if (_last == NULL) {</span>
<span class="changed"> 266           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 267           _last = _first = c;</span>
<span class="changed"> 268           c-&gt;set_prev(NULL);</span>
<span class="changed"> 269           c-&gt;set_next(NULL);</span>
<span class="changed"> 270         } else {</span>
<span class="changed"> 271           assert(_first != NULL &amp;&amp; _num.get() &gt; 0, "Sanity");</span>
<span class="changed"> 272           c-&gt;set_next(NULL);</span>
<span class="changed"> 273           c-&gt;set_prev(_last);</span>
<span class="changed"> 274           _last-&gt;set_next(c);</span>
<span class="changed"> 275           _last = c;</span>
<span class="changed"> 276         }</span>
<span class="changed"> 277         _num.increment();</span>
<span class="changed"> 278       }</span>
<span class="changed"> 279 </span>
<span class="changed"> 280       // Remove chunk from the front of the list. Returns NULL if list is empty.</span>
<span class="changed"> 281       Metachunk* remove_front() {</span>
<span class="changed"> 282         Metachunk* c = NULL;</span>
<span class="changed"> 283         if (_first == NULL) {</span>
<span class="changed"> 284           assert(_last == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 285         } else {</span>
<span class="changed"> 286           c = _first;</span>
<span class="changed"> 287           assert(c-&gt;prev() == NULL, "Sanity");</span>
<span class="changed"> 288           if (_first == _last) {</span>
<span class="changed"> 289             assert(_num.get() == 1, "Sanity");</span>
<span class="changed"> 290             _first = _last = NULL;</span>
<span class="changed"> 291           } else {</span>
<span class="changed"> 292             assert(_num.get() &gt; 1, "Sanity");</span>
<span class="changed"> 293             _first = _first-&gt;next();</span>
<span class="changed"> 294             _first-&gt;set_prev(NULL);</span>
<span class="changed"> 295           }</span>
<span class="changed"> 296           _num.decrement();</span>
<span class="changed"> 297           c-&gt;set_next(NULL);</span>
<span class="changed"> 298         }</span>
<span class="changed"> 299         return c;</span>
<span class="changed"> 300       }</span>
<span class="changed"> 301 </span>
<span class="changed"> 302       // Remove chunk from the back of the list. Returns NULL if list is empty.</span>
<span class="changed"> 303       Metachunk* remove_back() {</span>
<span class="changed"> 304         Metachunk* c = NULL;</span>
<span class="changed"> 305         if (_last == NULL) {</span>
<span class="changed"> 306           assert(_first == NULL &amp;&amp; _num.get() == 0, "Sanity");</span>
<span class="changed"> 307         } else {</span>
<span class="changed"> 308           c = _last;</span>
<span class="changed"> 309           assert(c-&gt;next() == NULL, "Sanity");</span>
<span class="changed"> 310           if (_first == _last) {</span>
<span class="changed"> 311             assert(_num.get() == 1, "Sanity");</span>
<span class="changed"> 312             _first = _last = NULL;</span>
<span class="changed"> 313           } else {</span>
<span class="changed"> 314             assert(_num.get() &gt; 1, "Sanity");</span>
<span class="changed"> 315             _last = _last-&gt;prev();</span>
<span class="changed"> 316             _last-&gt;set_next(NULL);</span>
<span class="changed"> 317           }</span>
<span class="changed"> 318           _num.decrement();</span>
<span class="changed"> 319           c-&gt;set_prev(NULL);</span>
<span class="changed"> 320         }</span>
<span class="changed"> 321         return c;</span>
<span class="changed"> 322       }</span>
<span class="changed"> 323 </span>
<span class="changed"> 324     public:</span>
<span class="changed"> 325 </span>
<span class="changed"> 326     #ifdef ASSERT</span>
<span class="changed"> 327       bool contains(const Metachunk* c) const;</span>
<span class="changed"> 328       void verify() const;</span>
<span class="changed"> 329     #endif</span>
<span class="changed"> 330 </span>
<span class="changed"> 331       // Returns size, in words, of committed space of all chunks in this list.</span>
<span class="changed"> 332       // Note: walks list.</span>
<span class="changed"> 333       size_t committed_word_size() const {</span>
<span class="changed"> 334         size_t l = 0;</span>
<span class="changed"> 335         for (const Metachunk* c = _first; c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 336           l += c-&gt;committed_words();</span>
<span class="changed"> 337         }</span>
<span class="changed"> 338         return l;</span>
<span class="changed"> 339       }</span>
<span class="changed"> 340 </span>
<span class="changed"> 341       void print_on(outputStream* st) const;</span>
<span class="changed"> 342 </span>
<span class="changed"> 343     };</span>
<span class="changed"> 344 </span>
<span class="changed"> 345     class UnsortedMetachunkList : public AbstractMetachunkList {</span>
<span class="changed"> 346     public:</span>
<span class="changed"> 347 </span>
<span class="changed"> 348 </span>
<span class="changed"> 349 </span>
<span class="changed"> 350 </span>
<span class="changed"> 351 </span>
<span class="changed"> 352     };</span>
<span class="changed"> 353 </span>
 354 













 355   }
 356 }
 357 
<span class="changed"> 358 </span>
<span class="changed"> 359 // Verifies linking with neighbors in virtual space.</span>
<span class="changed"> 360 // Can only be done under expand lock protection.</span>
<span class="changed"> 361 void Metachunk::verify_neighborhood() const {</span>
<span class="changed"> 362 </span>
<span class="changed"> 363   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 364   assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="changed"> 365 </span>
<span class="changed"> 366   if (is_root_chunk()) {</span>
<span class="changed"> 367 </span>
<span class="changed"> 368     // Root chunks are all alone in the world.</span>
<span class="changed"> 369     assert(next_in_vs() == NULL || prev_in_vs() == NULL, "Root chunks should have no neighbors");</span>
<span class="changed"> 370 </span>
<span class="changed"> 371   } else {</span>
<span class="changed"> 372 </span>
<span class="changed"> 373     // Non-root chunks have neighbors, at least one, possibly two.</span>
<span class="changed"> 374 </span>
<span class="changed"> 375     assert(next_in_vs() != NULL || prev_in_vs() != NULL,</span>
<span class="changed"> 376            "A non-root chunk should have neighbors (chunk @" PTR_FORMAT</span>
<span class="changed"> 377            ", base " PTR_FORMAT ", level " CHKLVL_FORMAT ".",</span>
<span class="changed"> 378            p2i(this), p2i(base()), level());</span>
<span class="changed"> 379 </span>
<span class="changed"> 380     if (prev_in_vs() != NULL) {</span>
<span class="changed"> 381       assert(prev_in_vs()-&gt;end() == base(),</span>
<span class="changed"> 382              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to predecessor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="changed"> 383              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()));</span>
<span class="changed"> 384       assert(prev_in_vs()-&gt;next_in_vs() == this,</span>
<span class="changed"> 385              "Chunk " METACHUNK_FULL_FORMAT ": broken link to left neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="changed"> 386              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(prev_in_vs()), p2i(prev_in_vs()-&gt;next_in_vs()));</span>
<span class="changed"> 387     }</span>
<span class="changed"> 388 </span>
<span class="changed"> 389     if (next_in_vs() != NULL) {</span>
<span class="changed"> 390       assert(end() == next_in_vs()-&gt;base(),</span>
<span class="changed"> 391              "Chunk " METACHUNK_FULL_FORMAT ": should be adjacent to successor: " METACHUNK_FULL_FORMAT ".",</span>
<span class="changed"> 392              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()));</span>
<span class="changed"> 393       assert(next_in_vs()-&gt;prev_in_vs() == this,</span>
<span class="changed"> 394              "Chunk " METACHUNK_FULL_FORMAT ": broken link to right neighbor: " METACHUNK_FULL_FORMAT " (" PTR_FORMAT ").",</span>
<span class="changed"> 395              METACHUNK_FULL_FORMAT_ARGS(this), METACHUNK_FULL_FORMAT_ARGS(next_in_vs()), p2i(next_in_vs()-&gt;prev_in_vs()));</span>
<span class="changed"> 396     }</span>
<span class="changed"> 397 </span>
<span class="changed"> 398     // One of the neighbors must be the buddy. It can be whole or splintered.</span>
<span class="changed"> 399 </span>
<span class="changed"> 400     // The chunk following us or preceeding us may be our buddy or a splintered part of it.</span>
<span class="changed"> 401     Metachunk* buddy = is_leader() ? next_in_vs() : prev_in_vs();</span>
<span class="changed"> 402 </span>
<span class="changed"> 403     assert(buddy != NULL, "Missing neighbor.");</span>
<span class="changed"> 404     assert(!buddy-&gt;is_dead(), "Invalid buddy state.");</span>
<span class="changed"> 405 </span>
<span class="changed"> 406     // This neighbor is either or buddy (same level) or a splinter of our buddy - hence</span>
<span class="changed"> 407     // the level can never be smaller (aka the chunk size cannot be larger).</span>
<span class="changed"> 408     assert(buddy-&gt;level() &gt;= level(), "Wrong level.");</span>
<span class="changed"> 409 </span>
<span class="changed"> 410     if (buddy-&gt;level() == level()) {</span>
<span class="changed"> 411 </span>
<span class="changed"> 412       // If the buddy is of the same size as us, it is unsplintered.</span>
<span class="changed"> 413       assert(buddy-&gt;is_leader() == !is_leader(),</span>
<span class="changed"> 414              "Only one chunk can be leader in a pair");</span>
<span class="changed"> 415 </span>
<span class="changed"> 416       // When direct buddies are neighbors, one or both should be in use, otherwise they should</span>
<span class="changed"> 417       // have been merged.</span>
<span class="changed"> 418 </span>
<span class="changed"> 419       // But since we call this verification function from internal functions where we are about to merge or just did split,</span>
<span class="changed"> 420       // do not test this. We have RootChunkArea::verify_area_is_ideally_merged() for testing that.</span>
<span class="changed"> 421 </span>
<span class="changed"> 422       // assert(buddy-&gt;is_in_use() || is_in_use(), "incomplete merging?");</span>
<span class="changed"> 423 </span>
<span class="changed"> 424       if (is_leader()) {</span>
<span class="changed"> 425         assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="changed"> 426         assert(is_aligned(base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="changed"> 427       } else {</span>
<span class="changed"> 428         assert(buddy-&gt;end() == base(), "Sanity");</span>
<span class="changed"> 429         assert(is_aligned(buddy-&gt;base(), word_size() * 2 * BytesPerWord), "Sanity");</span>
<span class="changed"> 430       }</span>
<span class="changed"> 431 </span>
<span class="changed"> 432     } else {</span>
<span class="changed"> 433 </span>
<span class="changed"> 434       // Buddy, but splintered, and this is a part of it.</span>
<span class="changed"> 435       if (is_leader()) {</span>
<span class="changed"> 436         assert(buddy-&gt;base() == end(), "Sanity");</span>
<span class="changed"> 437       } else {</span>
<span class="changed"> 438         assert(buddy-&gt;end() &gt; (base() - word_size()), "Sanity");</span>
<span class="changed"> 439       }</span>
<span class="changed"> 440 </span>
<span class="changed"> 441     }</span>
<span class="changed"> 442   }</span>
 443 }

 444 
<span class="changed"> 445 volatile MetaWord dummy = 0;</span>
<span class="changed"> 446 </span>
<span class="changed"> 447 void Metachunk::verify(bool slow) const {</span>
<span class="changed"> 448 </span>
<span class="changed"> 449   // Note. This should be called under CLD lock protection.</span>
<span class="changed"> 450 </span>
<span class="changed"> 451   // We can verify everything except the _prev_in_vs/_next_in_vs pair.</span>
<span class="changed"> 452   // This is because neighbor chunks may be added concurrently, so we cannot rely</span>
<span class="changed"> 453   //  on the content of _next_in_vs/_prev_in_vs unless we have the expand lock.</span>
<span class="changed"> 454 </span>
<span class="changed"> 455   assert(!is_dead(), "Do not call on dead chunks.");</span>
<span class="changed"> 456 </span>
<span class="changed"> 457   if (is_free()) {</span>
<span class="changed"> 458     assert(used_words() == 0, "free chunks are not used.");</span>
<span class="changed"> 459   }</span>
<span class="changed"> 460 </span>
<span class="changed"> 461   // Note: only call this on a life Metachunk.</span>
<span class="changed"> 462   chunklevel::check_valid_level(level());</span>
<span class="changed"> 463 </span>
<span class="changed"> 464   assert(base() != NULL, "No base ptr");</span>
<span class="changed"> 465 </span>
<span class="changed"> 466   assert(committed_words() &gt;= used_words(),</span>
<span class="changed"> 467          "mismatch: committed: " SIZE_FORMAT ", used: " SIZE_FORMAT ".",</span>
<span class="changed"> 468          committed_words(), used_words());</span>
<span class="changed"> 469 </span>
<span class="changed"> 470   assert(word_size() &gt;= committed_words(),</span>
<span class="changed"> 471          "mismatch: word_size: " SIZE_FORMAT ", committed: " SIZE_FORMAT ".",</span>
<span class="changed"> 472          word_size(), committed_words());</span>
<span class="changed"> 473 </span>
<span class="changed"> 474   // Test base pointer</span>
<span class="changed"> 475   assert(base() != NULL, "Base pointer NULL");</span>
<span class="changed"> 476   assert(vsnode() != NULL, "No space");</span>
<span class="changed"> 477   vsnode()-&gt;check_pointer(base());</span>
<span class="changed"> 478 </span>
<span class="changed"> 479   // Starting address shall be aligned to chunk size.</span>
<span class="changed"> 480   const size_t required_alignment = word_size() * sizeof(MetaWord);</span>
<span class="changed"> 481   assert_is_aligned(base(), required_alignment);</span>
<span class="changed"> 482 </span>
<span class="changed"> 483   // If slow, test the committed area</span>
<span class="changed"> 484   if (slow &amp;&amp; _committed_words &gt; 0) {</span>
<span class="changed"> 485     for (const MetaWord* p = _base; p &lt; _base + _committed_words; p += os::vm_page_size()) {</span>
<span class="changed"> 486       dummy = *p;</span>
<span class="changed"> 487     }</span>
<span class="changed"> 488     dummy = *(_base + _committed_words - 1);</span>
<span class="changed"> 489   }</span>
<span class="changed"> 490 </span>
<span class="changed"> 491 }</span>
<span class="changed"> 492 #endif // ASSERT</span>
<span class="changed"> 493 </span>
<span class="changed"> 494 void Metachunk::print_on(outputStream* st) const {</span>
<span class="changed"> 495 </span>
<span class="changed"> 496   // Note: must also work with invalid/random data. (e.g. do not call word_size())</span>
<span class="changed"> 497   st-&gt;print("Chunk @" PTR_FORMAT ", state %c, base " PTR_FORMAT ", "</span>
<span class="changed"> 498             "level " CHKLVL_FORMAT " (" SIZE_FORMAT " words), "</span>
<span class="changed"> 499             "used " SIZE_FORMAT " words, committed " SIZE_FORMAT " words.",</span>
<span class="changed"> 500             p2i(this), get_state_char(), p2i(base()), level(),</span>
<span class="changed"> 501             (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : (size_t)-1),</span>
<span class="changed"> 502             used_words(), committed_words());</span>
<span class="changed"> 503 </span>
 504 }
 505 
 506 } // namespace metaspace
 507 
</pre></td>
</tr></table>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/metachunk.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
