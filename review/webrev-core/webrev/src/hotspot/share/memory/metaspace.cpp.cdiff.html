<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace.cpp</title>
</head>
<body id="SUNWwebrev">
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace.hpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-core.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 21,87 ****</span>
   * questions.
   *
   */
  
  #include "precompiled.hpp"
  #include "aot/aotLoader.hpp"
<span class="removed">- #include "classfile/classLoaderDataGraph.hpp"</span>
  #include "gc/shared/collectedHeap.hpp"
  #include "logging/log.hpp"
  #include "logging/logStream.hpp"
  #include "memory/filemap.hpp"
  #include "memory/metaspace.hpp"
  #include "memory/metaspace/chunkManager.hpp"
<span class="changed">! #include "memory/metaspace/metachunk.hpp"</span>
  #include "memory/metaspace/metaspaceCommon.hpp"
<span class="changed">! #include "memory/metaspace/printCLDMetaspaceInfoClosure.hpp"</span>
<span class="changed">! #include "memory/metaspace/spaceManager.hpp"</span>
  #include "memory/metaspace/virtualSpaceList.hpp"
<span class="removed">- #include "memory/metaspaceShared.hpp"</span>
<span class="removed">- #include "memory/metaspaceTracer.hpp"</span>
  #include "memory/universe.hpp"
  #include "oops/compressedOops.hpp"
  #include "runtime/atomic.hpp"
  #include "runtime/init.hpp"
  #include "services/memTracker.hpp"
  #include "utilities/copy.hpp"
  #include "utilities/debug.hpp"
  #include "utilities/formatBuffer.hpp"
  #include "utilities/globalDefinitions.hpp"
<span class="removed">- #include "utilities/vmError.hpp"</span>
  
  
<span class="changed">! using namespace metaspace;</span>
  
<span class="removed">- MetaWord* last_allocated = 0;</span>
  
<span class="changed">! size_t Metaspace::_compressed_class_space_size;</span>
<span class="changed">! const MetaspaceTracer* Metaspace::_tracer = NULL;</span>
  
<span class="changed">! DEBUG_ONLY(bool Metaspace::_frozen = false;)</span>
  
<span class="changed">! static const char* space_type_name(Metaspace::MetaspaceType t) {</span>
<span class="changed">!   const char* s = NULL;</span>
<span class="changed">!   switch (t) {</span>
<span class="changed">!     case Metaspace::StandardMetaspaceType: s = "Standard"; break;</span>
<span class="changed">!     case Metaspace::BootMetaspaceType: s = "Boot"; break;</span>
<span class="changed">!     case Metaspace::ClassMirrorHolderMetaspaceType: s = "ClassMirrorHolder"; break;</span>
<span class="changed">!     case Metaspace::ReflectionMetaspaceType: s = "Reflection"; break;</span>
<span class="changed">!     default: ShouldNotReachHere();</span>
    }
<span class="removed">-   return s;</span>
  }
  
<span class="changed">! volatile size_t MetaspaceGC::_capacity_until_GC = 0;</span>
<span class="changed">! uint MetaspaceGC::_shrink_factor = 0;</span>
  
<span class="changed">! // BlockFreelist methods</span>
  
<span class="changed">! // VirtualSpaceNode methods</span>
  
  // MetaspaceGC methods
  
  // VM_CollectForMetadataAllocation is the vm operation used to GC.
  // Within the VM operation after the GC the attempt to allocate the metadata
  // should succeed.  If the GC did not free enough space for the metaspace
  // allocation, the HWM is increased so that another virtualspace will be
  // allocated for the metadata.  With perm gen the increase in the perm
<span class="newmarker">--- 21,214 ----</span>
   * questions.
   *
   */
  
  #include "precompiled.hpp"
<span class="new">+ </span>
  #include "aot/aotLoader.hpp"
  #include "gc/shared/collectedHeap.hpp"
  #include "logging/log.hpp"
  #include "logging/logStream.hpp"
  #include "memory/filemap.hpp"
  #include "memory/metaspace.hpp"
<span class="new">+ #include "memory/metaspaceShared.hpp"</span>
<span class="new">+ #include "memory/metaspaceTracer.hpp"</span>
<span class="new">+ #include "memory/metaspace/chunkHeaderPool.hpp"</span>
  #include "memory/metaspace/chunkManager.hpp"
<span class="changed">! #include "memory/metaspace/commitLimiter.hpp"</span>
  #include "memory/metaspace/metaspaceCommon.hpp"
<span class="changed">! #include "memory/metaspace/metaspaceContext.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceEnums.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceReport.hpp"</span>
<span class="changed">! #include "memory/metaspace/metaspaceSizesSnapshot.hpp"</span>
<span class="changed">! #include "memory/metaspace/runningCounters.hpp"</span>
<span class="changed">! #include "memory/metaspace/settings.hpp"</span>
  #include "memory/metaspace/virtualSpaceList.hpp"
  #include "memory/universe.hpp"
  #include "oops/compressedOops.hpp"
  #include "runtime/atomic.hpp"
  #include "runtime/init.hpp"
<span class="new">+ #include "runtime/java.hpp"</span>
  #include "services/memTracker.hpp"
  #include "utilities/copy.hpp"
  #include "utilities/debug.hpp"
  #include "utilities/formatBuffer.hpp"
  #include "utilities/globalDefinitions.hpp"
  
  
<span class="changed">! using metaspace::ChunkManager;</span>
<span class="changed">! using metaspace::CommitLimiter;</span>
<span class="changed">! using metaspace::MetaspaceContext;</span>
<span class="changed">! using metaspace::MetaspaceReporter;</span>
<span class="changed">! using metaspace::RunningCounters;</span>
<span class="changed">! using metaspace::VirtualSpaceList;</span>
  
  
<span class="changed">! size_t MetaspaceUtils::used_words() {</span>
<span class="changed">!   return RunningCounters::used_words();</span>
<span class="changed">! }</span>
  
<span class="changed">! size_t MetaspaceUtils::used_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   return metaspace::is_class(mdtype) ? RunningCounters::used_words_class() : RunningCounters::used_words_nonclass();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::reserved_words() {</span>
<span class="changed">!   return RunningCounters::reserved_words();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::reserved_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   return metaspace::is_class(mdtype) ? RunningCounters::reserved_words_class() : RunningCounters::reserved_words_nonclass();</span>
<span class="changed">! }</span>
  
<span class="changed">! size_t MetaspaceUtils::committed_words() {</span>
<span class="changed">!   return RunningCounters::committed_words();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::committed_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   return metaspace::is_class(mdtype) ? RunningCounters::committed_words_class() : RunningCounters::committed_words_nonclass();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values) {</span>
<span class="changed">!   const metaspace::MetaspaceSizesSnapshot meta_values;</span>
<span class="changed">! </span>
<span class="changed">!   // We print used and committed since these are the most useful at-a-glance vitals for Metaspace:</span>
<span class="changed">!   // - used tells you how much memory is actually used for metadata</span>
<span class="changed">!   // - committed tells you how much memory is committed for the purpose of metadata</span>
<span class="changed">!   // The difference between those two would be waste, which can have various forms (freelists,</span>
<span class="changed">!   //   unused parts of committed chunks etc)</span>
<span class="changed">!   //</span>
<span class="changed">!   // Left out is reserved, since this is not as exciting as the first two values: for class space,</span>
<span class="changed">!   // it is a constant (to uninformed users, often confusingly large). For non-class space, it would</span>
<span class="changed">!   // be interesting since free chunks can be uncommitted, but for now it is left out.</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT" "</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT" "</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT,</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed">!                                                     pre_meta_values.used(),</span>
<span class="changed">!                                                     pre_meta_values.committed(),</span>
<span class="changed">!                                                     meta_values.used(),</span>
<span class="changed">!                                                     meta_values.committed()),</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("NonClass",</span>
<span class="changed">!                                                     pre_meta_values.non_class_used(),</span>
<span class="changed">!                                                     pre_meta_values.non_class_committed(),</span>
<span class="changed">!                                                     meta_values.non_class_used(),</span>
<span class="changed">!                                                     meta_values.non_class_committed()),</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Class",</span>
<span class="changed">!                                                     pre_meta_values.class_used(),</span>
<span class="changed">!                                                     pre_meta_values.class_committed(),</span>
<span class="changed">!                                                     meta_values.class_used(),</span>
<span class="changed">!                                                     meta_values.class_committed()));</span>
<span class="changed">!   } else {</span>
<span class="changed">!     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed">!                                                     pre_meta_values.used(),</span>
<span class="changed">!                                                     pre_meta_values.committed(),</span>
<span class="changed">!                                                     meta_values.used(),</span>
<span class="changed">!                                                     meta_values.committed()));</span>
    }
  }
  
<span class="changed">! // This will print out a basic metaspace usage report but</span>
<span class="changed">! // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="changed">! void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {</span>
<span class="changed">!   MetaspaceReporter::print_basic_report(out, scale);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Prints a report about the current metaspace state.</span>
<span class="changed">! // Optional parts can be enabled via flags.</span>
<span class="changed">! // Function will walk the CLDG and will lock the expand lock; if that is not</span>
<span class="changed">! // convenient, use print_basic_report() instead.</span>
<span class="changed">! void MetaspaceUtils::print_report(outputStream* out, size_t scale) {</span>
<span class="changed">!   const int flags =</span>
<span class="changed">!       MetaspaceReporter::rf_show_loaders |</span>
<span class="changed">!       MetaspaceReporter::rf_break_down_by_chunktype |</span>
<span class="changed">!       MetaspaceReporter::rf_show_classes;</span>
<span class="changed">!   MetaspaceReporter::print_report(out, scale, flags);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_on(outputStream* out) {</span>
<span class="changed">! </span>
<span class="changed">!   // Used from all GCs. It first prints out totals, then, separately, the class space portion.</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;print_cr(" Metaspace       "</span>
<span class="changed">!                 "used "      SIZE_FORMAT "K, "</span>
<span class="changed">!                 "committed " SIZE_FORMAT "K, "</span>
<span class="changed">!                 "reserved "  SIZE_FORMAT "K",</span>
<span class="changed">!                 used_bytes()/K,</span>
<span class="changed">!                 committed_bytes()/K,</span>
<span class="changed">!                 reserved_bytes()/K);</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     const Metaspace::MetadataType ct = Metaspace::ClassType;</span>
<span class="changed">!     out-&gt;print_cr("  class space    "</span>
<span class="changed">!                   "used "      SIZE_FORMAT "K, "</span>
<span class="changed">!                   "committed " SIZE_FORMAT "K, "</span>
<span class="changed">!                   "reserved "  SIZE_FORMAT "K",</span>
<span class="changed">!                   used_bytes(ct)/K,</span>
<span class="changed">!                   committed_bytes(ct)/K,</span>
<span class="changed">!                   reserved_bytes(ct)/K);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
  
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">! void MetaspaceUtils::verify(bool slow) {</span>
<span class="changed">!   if (Metaspace::initialized()) {</span>
  
<span class="changed">!     // Verify non-class chunkmanager...</span>
<span class="changed">!     ChunkManager* cm = ChunkManager::chunkmanager_nonclass();</span>
<span class="changed">!     cm-&gt;verify(slow);</span>
<span class="changed">! </span>
<span class="changed">!     // ... and space list.</span>
<span class="changed">!     VirtualSpaceList* vsl = VirtualSpaceList::vslist_nonclass();</span>
<span class="changed">!     vsl-&gt;verify(slow);</span>
<span class="changed">! </span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       // If we use compressed class pointers, verify class chunkmanager...</span>
<span class="changed">!       cm = ChunkManager::chunkmanager_class();</span>
<span class="changed">!       assert(cm != NULL, "Sanity");</span>
<span class="changed">!       cm-&gt;verify(slow);</span>
<span class="changed">! </span>
<span class="changed">!       // ... and class spacelist.</span>
<span class="changed">!       VirtualSpaceList* vsl = VirtualSpaceList::vslist_nonclass();</span>
<span class="changed">!       assert(vsl != NULL, "Sanity");</span>
<span class="changed">!       vsl-&gt;verify(slow);</span>
<span class="changed">!     }</span>
  
<span class="new">+   }</span>
<span class="new">+ }</span>
<span class="new">+ #endif</span>
<span class="new">+ </span>
<span class="new">+ ////////////////////////////////7</span>
  // MetaspaceGC methods
  
<span class="new">+ volatile size_t MetaspaceGC::_capacity_until_GC = 0;</span>
<span class="new">+ uint MetaspaceGC::_shrink_factor = 0;</span>
<span class="new">+ </span>
  // VM_CollectForMetadataAllocation is the vm operation used to GC.
  // Within the VM operation after the GC the attempt to allocate the metadata
  // should succeed.  If the GC did not free enough space for the metaspace
  // allocation, the HWM is increased so that another virtualspace will be
  // allocated for the metadata.  With perm gen the increase in the perm
<hr /><span class="oldmarker">*** 349,1014 ****</span>
                                               new_capacity_until_GC,
                                               MetaspaceGCThresholdUpdater::ComputeNewSize);
    }
  }
  
<span class="removed">- // MetaspaceUtils</span>
<span class="removed">- size_t MetaspaceUtils::_capacity_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
<span class="removed">- size_t MetaspaceUtils::_overhead_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
<span class="removed">- volatile size_t MetaspaceUtils::_used_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
<span class="removed">- </span>
<span class="removed">- // Collect used metaspace statistics. This involves walking the CLDG. The resulting</span>
<span class="removed">- // output will be the accumulated values for all live metaspaces.</span>
<span class="removed">- // Note: method does not do any locking.</span>
<span class="removed">- void MetaspaceUtils::collect_statistics(ClassLoaderMetaspaceStatistics* out) {</span>
<span class="removed">-   out-&gt;reset();</span>
<span class="removed">-   ClassLoaderDataGraphMetaspaceIterator iter;</span>
<span class="removed">-    while (iter.repeat()) {</span>
<span class="removed">-      ClassLoaderMetaspace* msp = iter.get_next();</span>
<span class="removed">-      if (msp != NULL) {</span>
<span class="removed">-        msp-&gt;add_to_statistics(out);</span>
<span class="removed">-      }</span>
<span class="removed">-    }</span>
<span class="removed">- }</span>
<span class="removed">- </span>
<span class="removed">- size_t MetaspaceUtils::free_in_vs_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="removed">-   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="removed">-   return list == NULL ? 0 : list-&gt;free_bytes();</span>
<span class="removed">- }</span>
  
<span class="removed">- size_t MetaspaceUtils::free_in_vs_bytes() {</span>
<span class="removed">-   return free_in_vs_bytes(Metaspace::ClassType) + free_in_vs_bytes(Metaspace::NonClassType);</span>
<span class="removed">- }</span>
  
<span class="changed">! static void inc_stat_nonatomically(size_t* pstat, size_t words) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   (*pstat) += words;</span>
<span class="changed">! }</span>
  
<span class="changed">! static void dec_stat_nonatomically(size_t* pstat, size_t words) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   const size_t size_now = *pstat;</span>
<span class="changed">!   assert(size_now &gt;= words, "About to decrement counter below zero "</span>
<span class="changed">!          "(current value: " SIZE_FORMAT ", decrement value: " SIZE_FORMAT ".",</span>
<span class="changed">!          size_now, words);</span>
<span class="changed">!   *pstat = size_now - words;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! static void inc_stat_atomically(volatile size_t* pstat, size_t words) {</span>
<span class="changed">!   Atomic::add(pstat, words);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! static void dec_stat_atomically(volatile size_t* pstat, size_t words) {</span>
<span class="changed">!   const size_t size_now = *pstat;</span>
<span class="changed">!   assert(size_now &gt;= words, "About to decrement counter below zero "</span>
<span class="changed">!          "(current value: " SIZE_FORMAT ", decrement value: " SIZE_FORMAT ".",</span>
<span class="changed">!          size_now, words);</span>
<span class="changed">!   Atomic::sub(pstat, words);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::dec_capacity(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   dec_stat_nonatomically(&amp;_capacity_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! void MetaspaceUtils::inc_capacity(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   inc_stat_nonatomically(&amp;_capacity_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! void MetaspaceUtils::dec_used(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   dec_stat_atomically(&amp;_used_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! void MetaspaceUtils::inc_used(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   inc_stat_atomically(&amp;_used_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! void MetaspaceUtils::dec_overhead(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   dec_stat_nonatomically(&amp;_overhead_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! void MetaspaceUtils::inc_overhead(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed">!   inc_stat_nonatomically(&amp;_overhead_words[mdtype], words);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::reserved_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="changed">!   return list == NULL ? 0 : list-&gt;reserved_bytes();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::committed_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="changed">!   return list == NULL ? 0 : list-&gt;committed_bytes();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::min_chunk_size_words() { return Metaspace::first_chunk_word_size(); }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::free_chunks_total_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   ChunkManager* chunk_manager = Metaspace::get_chunk_manager(mdtype);</span>
<span class="changed">!   if (chunk_manager == NULL) {</span>
<span class="changed">!     return 0;</span>
<span class="changed">!   }</span>
<span class="changed">!   return chunk_manager-&gt;free_chunks_total_words();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::free_chunks_total_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   return free_chunks_total_words(mdtype) * BytesPerWord;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::free_chunks_total_words() {</span>
<span class="changed">!   return free_chunks_total_words(Metaspace::ClassType) +</span>
<span class="changed">!          free_chunks_total_words(Metaspace::NonClassType);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t MetaspaceUtils::free_chunks_total_bytes() {</span>
<span class="changed">!   return free_chunks_total_words() * BytesPerWord;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! bool MetaspaceUtils::has_chunk_free_list(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   return Metaspace::get_chunk_manager(mdtype) != NULL;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! MetaspaceChunkFreeListSummary MetaspaceUtils::chunk_free_list_summary(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   if (!has_chunk_free_list(mdtype)) {</span>
<span class="changed">!     return MetaspaceChunkFreeListSummary();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   const ChunkManager* cm = Metaspace::get_chunk_manager(mdtype);</span>
<span class="changed">!   return cm-&gt;chunk_free_list_summary();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values) {</span>
<span class="changed">!   const metaspace::MetaspaceSizesSnapshot meta_values;</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT" "</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT" "</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT,</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed">!                                                     pre_meta_values.used(),</span>
<span class="changed">!                                                     pre_meta_values.committed(),</span>
<span class="changed">!                                                     meta_values.used(),</span>
<span class="changed">!                                                     meta_values.committed()),</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("NonClass",</span>
<span class="changed">!                                                     pre_meta_values.non_class_used(),</span>
<span class="changed">!                                                     pre_meta_values.non_class_committed(),</span>
<span class="changed">!                                                     meta_values.non_class_used(),</span>
<span class="changed">!                                                     meta_values.non_class_committed()),</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Class",</span>
<span class="changed">!                                                     pre_meta_values.class_used(),</span>
<span class="changed">!                                                     pre_meta_values.class_committed(),</span>
<span class="changed">!                                                     meta_values.class_used(),</span>
<span class="changed">!                                                     meta_values.class_committed()));</span>
<span class="changed">!   } else {</span>
<span class="changed">!     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,</span>
<span class="changed">!                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed">!                                                     pre_meta_values.used(),</span>
<span class="changed">!                                                     pre_meta_values.committed(),</span>
<span class="changed">!                                                     meta_values.used(),</span>
<span class="changed">!                                                     meta_values.committed()));</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_on(outputStream* out) {</span>
<span class="changed">!   Metaspace::MetadataType nct = Metaspace::NonClassType;</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;print_cr(" Metaspace       "</span>
<span class="changed">!                 "used "      SIZE_FORMAT "K, "</span>
<span class="changed">!                 "capacity "  SIZE_FORMAT "K, "</span>
<span class="changed">!                 "committed " SIZE_FORMAT "K, "</span>
<span class="changed">!                 "reserved "  SIZE_FORMAT "K",</span>
<span class="changed">!                 used_bytes()/K,</span>
<span class="changed">!                 capacity_bytes()/K,</span>
<span class="changed">!                 committed_bytes()/K,</span>
<span class="changed">!                 reserved_bytes()/K);</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     Metaspace::MetadataType ct = Metaspace::ClassType;</span>
<span class="changed">!     out-&gt;print_cr("  class space    "</span>
<span class="changed">!                   "used "      SIZE_FORMAT "K, "</span>
<span class="changed">!                   "capacity "  SIZE_FORMAT "K, "</span>
<span class="changed">!                   "committed " SIZE_FORMAT "K, "</span>
<span class="changed">!                   "reserved "  SIZE_FORMAT "K",</span>
<span class="changed">!                   used_bytes(ct)/K,</span>
<span class="changed">!                   capacity_bytes(ct)/K,</span>
<span class="changed">!                   committed_bytes(ct)/K,</span>
<span class="changed">!                   reserved_bytes(ct)/K);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_vs(outputStream* out, size_t scale) {</span>
<span class="changed">!   const size_t reserved_nonclass_words = reserved_bytes(Metaspace::NonClassType) / sizeof(MetaWord);</span>
<span class="changed">!   const size_t committed_nonclass_words = committed_bytes(Metaspace::NonClassType) / sizeof(MetaWord);</span>
<span class="changed">!   {</span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       out-&gt;print("  Non-class space:  ");</span>
<span class="changed">!     }</span>
<span class="changed">!     print_scaled_words(out, reserved_nonclass_words, scale, 7);</span>
<span class="changed">!     out-&gt;print(" reserved, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, committed_nonclass_words, reserved_nonclass_words, scale, 7);</span>
<span class="changed">!     out-&gt;print_cr(" committed ");</span>
<span class="changed">! </span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       const size_t reserved_class_words = reserved_bytes(Metaspace::ClassType) / sizeof(MetaWord);</span>
<span class="changed">!       const size_t committed_class_words = committed_bytes(Metaspace::ClassType) / sizeof(MetaWord);</span>
<span class="changed">!       out-&gt;print("      Class space:  ");</span>
<span class="changed">!       print_scaled_words(out, reserved_class_words, scale, 7);</span>
<span class="changed">!       out-&gt;print(" reserved, ");</span>
<span class="changed">!       print_scaled_words_and_percentage(out, committed_class_words, reserved_class_words, scale, 7);</span>
<span class="changed">!       out-&gt;print_cr(" committed ");</span>
<span class="changed">! </span>
<span class="changed">!       const size_t reserved_words = reserved_nonclass_words + reserved_class_words;</span>
<span class="changed">!       const size_t committed_words = committed_nonclass_words + committed_class_words;</span>
<span class="changed">!       out-&gt;print("             Both:  ");</span>
<span class="changed">!       print_scaled_words(out, reserved_words, scale, 7);</span>
<span class="changed">!       out-&gt;print(" reserved, ");</span>
<span class="changed">!       print_scaled_words_and_percentage(out, committed_words, reserved_words, scale, 7);</span>
<span class="changed">!       out-&gt;print_cr(" committed ");</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! static void print_basic_switches(outputStream* out, size_t scale) {</span>
<span class="changed">!   out-&gt;print("MaxMetaspaceSize: ");</span>
<span class="changed">!   if (MaxMetaspaceSize &gt;= (max_uintx) - (2 * os::vm_page_size())) {</span>
<span class="changed">!     // aka "very big". Default is max_uintx, but due to rounding in arg parsing the real</span>
<span class="changed">!     // value is smaller.</span>
<span class="changed">!     out-&gt;print("unlimited");</span>
<span class="changed">!   } else {</span>
<span class="changed">!     print_human_readable_size(out, MaxMetaspaceSize, scale);</span>
<span class="changed">!   }</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     out-&gt;print("CompressedClassSpaceSize: ");</span>
<span class="changed">!     print_human_readable_size(out, CompressedClassSpaceSize, scale);</span>
<span class="changed">!   }</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // This will print out a basic metaspace usage report but</span>
<span class="changed">! // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="changed">! void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {</span>
<span class="changed">! </span>
<span class="changed">!   if (!Metaspace::initialized()) {</span>
<span class="changed">!     out-&gt;print_cr("Metaspace not yet initialized.");</span>
<span class="changed">!     return;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Usage:");</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     out-&gt;print("  Non-class:  ");</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // In its most basic form, we do not require walking the CLDG. Instead, just print the running totals from</span>
<span class="changed">!   // MetaspaceUtils.</span>
<span class="changed">!   const size_t cap_nc = MetaspaceUtils::capacity_words(Metaspace::NonClassType);</span>
<span class="changed">!   const size_t overhead_nc = MetaspaceUtils::overhead_words(Metaspace::NonClassType);</span>
<span class="changed">!   const size_t used_nc = MetaspaceUtils::used_words(Metaspace::NonClassType);</span>
<span class="changed">!   const size_t free_and_waste_nc = cap_nc - overhead_nc - used_nc;</span>
<span class="changed">! </span>
<span class="changed">!   print_scaled_words(out, cap_nc, scale, 5);</span>
<span class="changed">!   out-&gt;print(" capacity, ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, used_nc, cap_nc, scale, 5);</span>
<span class="changed">!   out-&gt;print(" used, ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, free_and_waste_nc, cap_nc, scale, 5);</span>
<span class="changed">!   out-&gt;print(" free+waste, ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, overhead_nc, cap_nc, scale, 5);</span>
<span class="changed">!   out-&gt;print(" overhead. ");</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     const size_t cap_c = MetaspaceUtils::capacity_words(Metaspace::ClassType);</span>
<span class="changed">!     const size_t overhead_c = MetaspaceUtils::overhead_words(Metaspace::ClassType);</span>
<span class="changed">!     const size_t used_c = MetaspaceUtils::used_words(Metaspace::ClassType);</span>
<span class="changed">!     const size_t free_and_waste_c = cap_c - overhead_c - used_c;</span>
<span class="changed">!     out-&gt;print("      Class:  ");</span>
<span class="changed">!     print_scaled_words(out, cap_c, scale, 5);</span>
<span class="changed">!     out-&gt;print(" capacity, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, used_c, cap_c, scale, 5);</span>
<span class="changed">!     out-&gt;print(" used, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, free_and_waste_c, cap_c, scale, 5);</span>
<span class="changed">!     out-&gt;print(" free+waste, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, overhead_c, cap_c, scale, 5);</span>
<span class="changed">!     out-&gt;print(" overhead. ");</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!     out-&gt;print("       Both:  ");</span>
<span class="changed">!     const size_t cap = cap_nc + cap_c;</span>
<span class="changed">! </span>
<span class="changed">!     print_scaled_words(out, cap, scale, 5);</span>
<span class="changed">!     out-&gt;print(" capacity, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, used_nc + used_c, cap, scale, 5);</span>
<span class="changed">!     out-&gt;print(" used, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, free_and_waste_nc + free_and_waste_c, cap, scale, 5);</span>
<span class="changed">!     out-&gt;print(" free+waste, ");</span>
<span class="changed">!     print_scaled_words_and_percentage(out, overhead_nc + overhead_c, cap, scale, 5);</span>
<span class="changed">!     out-&gt;print(" overhead. ");</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Virtual space:");</span>
<span class="changed">! </span>
<span class="changed">!   print_vs(out, scale);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Chunk freelists:");</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     out-&gt;print("   Non-Class:  ");</span>
<span class="changed">!   }</span>
<span class="changed">!   print_human_readable_size(out, Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     out-&gt;print("       Class:  ");</span>
<span class="changed">!     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print("        Both:  ");</span>
<span class="changed">!     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes() +</span>
<span class="changed">!                               Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print basic settings</span>
<span class="changed">!   print_basic_switches(out, scale);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void MetaspaceUtils::print_report(outputStream* out, size_t scale, int flags) {</span>
<span class="changed">! </span>
<span class="changed">!   if (!Metaspace::initialized()) {</span>
<span class="changed">!     out-&gt;print_cr("Metaspace not yet initialized.");</span>
<span class="changed">!     return;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   const bool print_loaders = (flags &amp; rf_show_loaders) &gt; 0;</span>
<span class="changed">!   const bool print_classes = (flags &amp; rf_show_classes) &gt; 0;</span>
<span class="changed">!   const bool print_by_chunktype = (flags &amp; rf_break_down_by_chunktype) &gt; 0;</span>
<span class="changed">!   const bool print_by_spacetype = (flags &amp; rf_break_down_by_spacetype) &gt; 0;</span>
<span class="changed">! </span>
<span class="changed">!   // Some report options require walking the class loader data graph.</span>
<span class="changed">!   PrintCLDMetaspaceInfoClosure cl(out, scale, print_loaders, print_classes, print_by_chunktype);</span>
<span class="changed">!   if (print_loaders) {</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print_cr("Usage per loader:");</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   ClassLoaderDataGraph::loaded_cld_do(&amp;cl); // collect data and optionally print</span>
<span class="changed">! </span>
<span class="changed">!   // Print totals, broken up by space type.</span>
<span class="changed">!   if (print_by_spacetype) {</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print_cr("Usage per space type:");</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     for (int space_type = (int)Metaspace::ZeroMetaspaceType;</span>
<span class="changed">!          space_type &lt; (int)Metaspace::MetaspaceTypeCount; space_type ++)</span>
<span class="changed">!     {</span>
<span class="changed">!       uintx num_loaders = cl._num_loaders_by_spacetype[space_type];</span>
<span class="changed">!       uintx num_classes = cl._num_classes_by_spacetype[space_type];</span>
<span class="changed">!       out-&gt;print("%s - " UINTX_FORMAT " %s",</span>
<span class="changed">!         space_type_name((Metaspace::MetaspaceType)space_type),</span>
<span class="changed">!         num_loaders, loaders_plural(num_loaders));</span>
<span class="changed">!       if (num_classes &gt; 0) {</span>
<span class="changed">!         out-&gt;print(", ");</span>
<span class="changed">!         print_number_of_classes(out, num_classes, cl._num_classes_shared_by_spacetype[space_type]);</span>
<span class="changed">!         out-&gt;print(":");</span>
<span class="changed">!         cl._stats_by_spacetype[space_type].print_on(out, scale, print_by_chunktype);</span>
<span class="changed">!       } else {</span>
<span class="changed">!         out-&gt;print(".");</span>
<span class="changed">!         out-&gt;cr();</span>
<span class="changed">!       }</span>
<span class="changed">!       out-&gt;cr();</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // Print totals for in-use data:</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   {</span>
<span class="changed">!     uintx num_loaders = cl._num_loaders;</span>
<span class="changed">!     out-&gt;print("Total Usage - " UINTX_FORMAT " %s, ",</span>
<span class="changed">!       num_loaders, loaders_plural(num_loaders));</span>
<span class="changed">!     print_number_of_classes(out, cl._num_classes, cl._num_classes_shared);</span>
<span class="changed">!     out-&gt;print(":");</span>
<span class="changed">!     cl._stats_total.print_on(out, scale, print_by_chunktype);</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // -- Print Virtual space.</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Virtual space:");</span>
<span class="changed">! </span>
<span class="changed">!   print_vs(out, scale);</span>
<span class="changed">! </span>
<span class="changed">!   // -- Print VirtualSpaceList details.</span>
<span class="changed">!   if ((flags &amp; rf_show_vslist) &gt; 0) {</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print_cr("Virtual space list%s:", Metaspace::using_class_space() ? "s" : "");</span>
<span class="changed">! </span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       out-&gt;print_cr("   Non-Class:");</span>
<span class="changed">!     }</span>
<span class="changed">!     Metaspace::space_list()-&gt;print_on(out, scale);</span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       out-&gt;print_cr("       Class:");</span>
<span class="changed">!       Metaspace::class_space_list()-&gt;print_on(out, scale);</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // -- Print VirtualSpaceList map.</span>
<span class="changed">!   if ((flags &amp; rf_show_vsmap) &gt; 0) {</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print_cr("Virtual space map:");</span>
<span class="changed">! </span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       out-&gt;print_cr("   Non-Class:");</span>
<span class="changed">!     }</span>
<span class="changed">!     Metaspace::space_list()-&gt;print_map(out);</span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       out-&gt;print_cr("       Class:");</span>
<span class="changed">!       Metaspace::class_space_list()-&gt;print_map(out);</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // -- Print Freelists (ChunkManager) details</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Chunk freelist%s:", Metaspace::using_class_space() ? "s" : "");</span>
<span class="changed">! </span>
<span class="changed">!   ChunkManagerStatistics non_class_cm_stat;</span>
<span class="changed">!   Metaspace::chunk_manager_metadata()-&gt;collect_statistics(&amp;non_class_cm_stat);</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     out-&gt;print_cr("   Non-Class:");</span>
<span class="changed">!   }</span>
<span class="changed">!   non_class_cm_stat.print_on(out, scale);</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     ChunkManagerStatistics class_cm_stat;</span>
<span class="changed">!     Metaspace::chunk_manager_class()-&gt;collect_statistics(&amp;class_cm_stat);</span>
<span class="changed">!     out-&gt;print_cr("       Class:");</span>
<span class="changed">!     class_cm_stat.print_on(out, scale);</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // As a convenience, print a summary of common waste.</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print("Waste ");</span>
<span class="changed">!   // For all wastages, print percentages from total. As total use the total size of memory committed for metaspace.</span>
<span class="changed">!   const size_t committed_words = committed_bytes() / BytesPerWord;</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;print("(percentages refer to total committed size ");</span>
<span class="changed">!   print_scaled_words(out, committed_words, scale);</span>
<span class="changed">!   out-&gt;print_cr("):");</span>
<span class="changed">! </span>
<span class="changed">!   // Print space committed but not yet used by any class loader</span>
<span class="changed">!   const size_t unused_words_in_vs = MetaspaceUtils::free_in_vs_bytes() / BytesPerWord;</span>
<span class="changed">!   out-&gt;print("              Committed unused: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, unused_words_in_vs, committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print waste for in-use chunks.</span>
<span class="changed">!   UsedChunksStatistics ucs_nonclass = cl._stats_total.nonclass_sm_stats().totals();</span>
<span class="changed">!   UsedChunksStatistics ucs_class = cl._stats_total.class_sm_stats().totals();</span>
<span class="changed">!   UsedChunksStatistics ucs_all;</span>
<span class="changed">!   ucs_all.add(ucs_nonclass);</span>
<span class="changed">!   ucs_all.add(ucs_class);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;print("        Waste in chunks in use: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, ucs_all.waste(), committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print("         Free in chunks in use: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, ucs_all.free(), committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print("     Overhead in chunks in use: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, ucs_all.overhead(), committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print waste in free chunks.</span>
<span class="changed">!   const size_t total_capacity_in_free_chunks =</span>
<span class="changed">!       Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_words() +</span>
<span class="changed">!      (Metaspace::using_class_space() ? Metaspace::chunk_manager_class()-&gt;free_chunks_total_words() : 0);</span>
<span class="changed">!   out-&gt;print("                In free chunks: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, total_capacity_in_free_chunks, committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print waste in deallocated blocks.</span>
<span class="changed">!   const uintx free_blocks_num =</span>
<span class="changed">!       cl._stats_total.nonclass_sm_stats().free_blocks_num() +</span>
<span class="changed">!       cl._stats_total.class_sm_stats().free_blocks_num();</span>
<span class="changed">!   const size_t free_blocks_cap_words =</span>
<span class="changed">!       cl._stats_total.nonclass_sm_stats().free_blocks_cap_words() +</span>
<span class="changed">!       cl._stats_total.class_sm_stats().free_blocks_cap_words();</span>
<span class="changed">!   out-&gt;print("Deallocated from chunks in use: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, free_blocks_cap_words, committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;print(" (" UINTX_FORMAT " blocks)", free_blocks_num);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print total waste.</span>
<span class="changed">!   const size_t total_waste = ucs_all.waste() + ucs_all.free() + ucs_all.overhead() + total_capacity_in_free_chunks</span>
<span class="changed">!       + free_blocks_cap_words + unused_words_in_vs;</span>
<span class="changed">!   out-&gt;print("                       -total-: ");</span>
<span class="changed">!   print_scaled_words_and_percentage(out, total_waste, committed_words, scale, 6);</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">!   // Print internal statistics</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Internal statistics:");</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print_cr("Number of allocations: " UINTX_FORMAT ".", g_internal_statistics.num_allocs);</span>
<span class="changed">!   out-&gt;print_cr("Number of space births: " UINTX_FORMAT ".", g_internal_statistics.num_metaspace_births);</span>
<span class="changed">!   out-&gt;print_cr("Number of space deaths: " UINTX_FORMAT ".", g_internal_statistics.num_metaspace_deaths);</span>
<span class="changed">!   out-&gt;print_cr("Number of virtual space node births: " UINTX_FORMAT ".", g_internal_statistics.num_vsnodes_created);</span>
<span class="changed">!   out-&gt;print_cr("Number of virtual space node deaths: " UINTX_FORMAT ".", g_internal_statistics.num_vsnodes_purged);</span>
<span class="changed">!   out-&gt;print_cr("Number of times virtual space nodes were expanded: " UINTX_FORMAT ".", g_internal_statistics.num_committed_space_expanded);</span>
<span class="changed">!   out-&gt;print_cr("Number of deallocations: " UINTX_FORMAT " (" UINTX_FORMAT " external).", g_internal_statistics.num_deallocs, g_internal_statistics.num_external_deallocs);</span>
<span class="changed">!   out-&gt;print_cr("Allocations from deallocated blocks: " UINTX_FORMAT ".", g_internal_statistics.num_allocs_from_deallocated_blocks);</span>
<span class="changed">!   out-&gt;print_cr("Number of chunks added to freelist: " UINTX_FORMAT ".",</span>
<span class="changed">!                 g_internal_statistics.num_chunks_added_to_freelist);</span>
<span class="changed">!   out-&gt;print_cr("Number of chunks removed from freelist: " UINTX_FORMAT ".",</span>
<span class="changed">!                 g_internal_statistics.num_chunks_removed_from_freelist);</span>
<span class="changed">!   out-&gt;print_cr("Number of chunk merges: " UINTX_FORMAT ", split-ups: " UINTX_FORMAT ".",</span>
<span class="changed">!                 g_internal_statistics.num_chunk_merges, g_internal_statistics.num_chunk_splits);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! #endif</span>
<span class="changed">! </span>
<span class="changed">!   // Print some interesting settings</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   print_basic_switches(out, scale);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;print("InitialBootClassLoaderMetaspaceSize: ");</span>
<span class="changed">!   print_human_readable_size(out, InitialBootClassLoaderMetaspaceSize, scale);</span>
<span class="changed">! </span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">!   out-&gt;cr();</span>
<span class="changed">! </span>
<span class="changed">! } // MetaspaceUtils::print_report()</span>
<span class="changed">! </span>
<span class="changed">! // Prints an ASCII representation of the given space.</span>
<span class="changed">! void MetaspaceUtils::print_metaspace_map(outputStream* out, Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   const bool for_class = mdtype == Metaspace::ClassType ? true : false;</span>
<span class="changed">!   VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();</span>
<span class="changed">!   if (vsl != NULL) {</span>
<span class="changed">!     if (for_class) {</span>
<span class="changed">!       if (!Metaspace::using_class_space()) {</span>
<span class="changed">!         out-&gt;print_cr("No Class Space.");</span>
<span class="changed">!         return;</span>
<span class="changed">!       }</span>
<span class="changed">!       out-&gt;print_raw("---- Metaspace Map (Class Space) ----");</span>
<span class="changed">!     } else {</span>
<span class="changed">!       out-&gt;print_raw("---- Metaspace Map (Non-Class Space) ----");</span>
<span class="changed">!     }</span>
<span class="changed">!     // Print legend:</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     out-&gt;print_cr("Chunk Types (uppercase chunks are in use): x-specialized, s-small, m-medium, h-humongous.");</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!     VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();</span>
<span class="changed">!     vsl-&gt;print_map(out);</span>
<span class="changed">!     out-&gt;cr();</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
  
<span class="changed">! void MetaspaceUtils::verify_free_chunks() {</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   Metaspace::chunk_manager_metadata()-&gt;verify(false);</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     Metaspace::chunk_manager_class()-&gt;verify(false);</span>
<span class="changed">!   }</span>
<span class="changed">! #endif</span>
<span class="changed">! }</span>
  
<span class="changed">! void MetaspaceUtils::verify_metrics() {</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   // Please note: there are time windows where the internal counters are out of sync with</span>
<span class="changed">!   // reality. For example, when a newly created ClassLoaderMetaspace creates its first chunk -</span>
<span class="changed">!   // the ClassLoaderMetaspace is not yet attached to its ClassLoaderData object and hence will</span>
<span class="changed">!   // not be counted when iterating the CLDG. So be careful when you call this method.</span>
<span class="changed">!   ClassLoaderMetaspaceStatistics total_stat;</span>
<span class="changed">!   collect_statistics(&amp;total_stat);</span>
<span class="changed">!   UsedChunksStatistics nonclass_chunk_stat = total_stat.nonclass_sm_stats().totals();</span>
<span class="changed">!   UsedChunksStatistics class_chunk_stat = total_stat.class_sm_stats().totals();</span>
<span class="changed">! </span>
<span class="changed">!   bool mismatch = false;</span>
<span class="changed">!   for (int i = 0; i &lt; Metaspace::MetadataTypeCount; i ++) {</span>
<span class="changed">!     Metaspace::MetadataType mdtype = (Metaspace::MetadataType)i;</span>
<span class="changed">!     UsedChunksStatistics chunk_stat = total_stat.sm_stats(mdtype).totals();</span>
<span class="changed">!     if (capacity_words(mdtype) != chunk_stat.cap() ||</span>
<span class="changed">!         used_words(mdtype) != chunk_stat.used() ||</span>
<span class="changed">!         overhead_words(mdtype) != chunk_stat.overhead()) {</span>
<span class="changed">!       mismatch = true;</span>
<span class="changed">!       tty-&gt;print_cr("MetaspaceUtils::verify_metrics: counter mismatch for mdtype=%u:", mdtype);</span>
<span class="changed">!       tty-&gt;print_cr("Expected cap " SIZE_FORMAT ", used " SIZE_FORMAT ", overhead " SIZE_FORMAT ".",</span>
<span class="changed">!                     capacity_words(mdtype), used_words(mdtype), overhead_words(mdtype));</span>
<span class="changed">!       tty-&gt;print_cr("Got cap " SIZE_FORMAT ", used " SIZE_FORMAT ", overhead " SIZE_FORMAT ".",</span>
<span class="changed">!                     chunk_stat.cap(), chunk_stat.used(), chunk_stat.overhead());</span>
<span class="changed">!       tty-&gt;flush();</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">!   assert(mismatch == false, "MetaspaceUtils::verify_metrics: counter mismatch.");</span>
<span class="changed">! #endif</span>
  }
  
<span class="removed">- // Metaspace methods</span>
<span class="removed">- </span>
<span class="removed">- size_t Metaspace::_first_chunk_word_size = 0;</span>
<span class="removed">- size_t Metaspace::_first_class_chunk_word_size = 0;</span>
<span class="removed">- </span>
<span class="removed">- size_t Metaspace::_commit_alignment = 0;</span>
<span class="removed">- size_t Metaspace::_reserve_alignment = 0;</span>
<span class="removed">- </span>
<span class="removed">- VirtualSpaceList* Metaspace::_space_list = NULL;</span>
<span class="removed">- VirtualSpaceList* Metaspace::_class_space_list = NULL;</span>
<span class="removed">- </span>
<span class="removed">- ChunkManager* Metaspace::_chunk_manager_metadata = NULL;</span>
<span class="removed">- ChunkManager* Metaspace::_chunk_manager_class = NULL;</span>
<span class="removed">- </span>
<span class="removed">- bool Metaspace::_initialized = false;</span>
<span class="removed">- </span>
<span class="removed">- #define VIRTUALSPACEMULTIPLIER 2</span>
<span class="removed">- </span>
  #ifdef _LP64
  
  void Metaspace::print_compressed_class_space(outputStream* st) {
<span class="changed">!   if (_class_space_list != NULL) {</span>
<span class="changed">!     address base = (address)_class_space_list-&gt;current_virtual_space()-&gt;bottom();</span>
<span class="changed">!     address top = base + compressed_class_space_size();</span>
<span class="changed">!     st-&gt;print("Compressed class space mapped at: " PTR_FORMAT "-" PTR_FORMAT ", size: " SIZE_FORMAT,</span>
<span class="changed">!                p2i(base), p2i(top), top - base);</span>
      st-&gt;cr();
    }
  }
  
  // Given a prereserved space, use that to set up the compressed class space list.
  void Metaspace::initialize_class_space(ReservedSpace rs) {
    assert(using_class_space(), "Must be using class space");
<span class="removed">-   assert(_class_space_list == NULL &amp;&amp; _chunk_manager_class == NULL, "Only call once");</span>
  
    assert(rs.size() == CompressedClassSpaceSize, SIZE_FORMAT " != " SIZE_FORMAT,
           rs.size(), CompressedClassSpaceSize);
    assert(is_aligned(rs.base(), Metaspace::reserve_alignment()) &amp;&amp;
           is_aligned(rs.size(), Metaspace::reserve_alignment()),
           "wrong alignment");
  
<span class="changed">!   _class_space_list = new VirtualSpaceList(rs);</span>
<span class="changed">!   _chunk_manager_class = new ChunkManager(true/*is_class*/);</span>
  
    // This does currently not work because rs may be the result of a split
    // operation and NMT seems not to be able to handle splits.
    // Will be fixed with JDK-8243535.
    // MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);
  
<span class="changed">!   if (!_class_space_list-&gt;initialization_succeeded()) {</span>
<span class="changed">!     vm_exit_during_initialization("Failed to setup compressed class space virtual space list.");</span>
<span class="changed">!   }</span>
  
  }
  
  // Reserve a range of memory at an address suitable for en/decoding narrow
  // Klass pointers (see: CompressedClassPointers::is_valid_base()).
  // The returned address shall both be suitable as a compressed class pointers
<span class="newmarker">--- 476,535 ----</span>
                                               new_capacity_until_GC,
                                               MetaspaceGCThresholdUpdater::ComputeNewSize);
    }
  }
  
  
  
<span class="changed">! //////  Metaspace methods /////</span>
  
<span class="changed">! const MetaspaceTracer* Metaspace::_tracer = NULL;</span>
  
<span class="changed">! DEBUG_ONLY(bool Metaspace::_frozen = false;)</span>
  
<span class="changed">! bool Metaspace::initialized() {</span>
<span class="changed">!   return metaspace::MetaspaceContext::context_nonclass() != NULL &amp;&amp;</span>
<span class="changed">!       (using_class_space() ? metaspace::MetaspaceContext::context_class() != NULL : true);</span>
  }
  
  #ifdef _LP64
  
  void Metaspace::print_compressed_class_space(outputStream* st) {
<span class="changed">!   if (VirtualSpaceList::vslist_class() != NULL) {</span>
<span class="changed">!     MetaWord* base = VirtualSpaceList::vslist_class()-&gt;base_of_first_node();</span>
<span class="changed">!     size_t size = VirtualSpaceList::vslist_class()-&gt;word_size_of_first_node();</span>
<span class="changed">!     MetaWord* top = base + size;</span>
<span class="changed">!     st-&gt;print("Compressed class space mapped at: " PTR_FORMAT "-" PTR_FORMAT ", reserved size: " SIZE_FORMAT,</span>
<span class="changed">!                p2i(base), p2i(top), (top - base) * BytesPerWord);</span>
      st-&gt;cr();
    }
  }
  
  // Given a prereserved space, use that to set up the compressed class space list.
  void Metaspace::initialize_class_space(ReservedSpace rs) {
<span class="new">+   assert(rs.size() &gt;= CompressedClassSpaceSize,</span>
<span class="new">+          SIZE_FORMAT " != " SIZE_FORMAT, rs.size(), CompressedClassSpaceSize);</span>
    assert(using_class_space(), "Must be using class space");
  
    assert(rs.size() == CompressedClassSpaceSize, SIZE_FORMAT " != " SIZE_FORMAT,
           rs.size(), CompressedClassSpaceSize);
    assert(is_aligned(rs.base(), Metaspace::reserve_alignment()) &amp;&amp;
           is_aligned(rs.size(), Metaspace::reserve_alignment()),
           "wrong alignment");
  
<span class="changed">!   MetaspaceContext::initialize_class_space_context(rs);</span>
  
    // This does currently not work because rs may be the result of a split
    // operation and NMT seems not to be able to handle splits.
    // Will be fixed with JDK-8243535.
    // MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);
  
<span class="changed">! }</span>
  
<span class="new">+ // Returns true if class space has been setup (initialize_class_space).</span>
<span class="new">+ bool Metaspace::class_space_is_initialized() {</span>
<span class="new">+   return MetaspaceContext::context_class() != NULL;</span>
  }
  
  // Reserve a range of memory at an address suitable for en/decoding narrow
  // Klass pointers (see: CompressedClassPointers::is_valid_base()).
  // The returned address shall both be suitable as a compressed class pointers
<hr /><span class="oldmarker">*** 1061,1136 ****</span>
  }
  
  #endif // _LP64
  
  
<span class="changed">! void Metaspace::ergo_initialize() {</span>
<span class="changed">!   if (DumpSharedSpaces) {</span>
<span class="changed">!     // Using large pages when dumping the shared archive is currently not implemented.</span>
<span class="changed">!     FLAG_SET_ERGO(UseLargePagesInMetaspace, false);</span>
<span class="changed">!   }</span>
  
<span class="changed">!   size_t page_size = os::vm_page_size();</span>
<span class="changed">!   if (UseLargePages &amp;&amp; UseLargePagesInMetaspace) {</span>
<span class="changed">!     page_size = os::large_page_size();</span>
<span class="changed">!   }</span>
  
<span class="changed">!   _commit_alignment  = page_size;</span>
<span class="changed">!   _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());</span>
  
<span class="changed">!   // The upcoming Metaspace rewrite will impose a higher alignment granularity.</span>
<span class="changed">!   // To prepare for that and to catch/prevent any misuse of Metaspace alignment</span>
<span class="changed">!   // which may creep in, up the alignment a bit.</span>
<span class="changed">!   if (_reserve_alignment == 4 * K) {</span>
<span class="changed">!     _reserve_alignment *= 4;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   // Do not use FLAG_SET_ERGO to update MaxMetaspaceSize, since this will</span>
<span class="changed">!   // override if MaxMetaspaceSize was set on the command line or not.</span>
<span class="changed">!   // This information is needed later to conform to the specification of the</span>
<span class="changed">!   // java.lang.management.MemoryUsage API.</span>
    //
<span class="changed">!   // Ideally, we would be able to set the default value of MaxMetaspaceSize in</span>
<span class="changed">!   // globals.hpp to the aligned value, but this is not possible, since the</span>
<span class="changed">!   // alignment depends on other flags being parsed.</span>
<span class="changed">!   MaxMetaspaceSize = align_down_bounded(MaxMetaspaceSize, _reserve_alignment);</span>
  
    if (MetaspaceSize &gt; MaxMetaspaceSize) {
      MetaspaceSize = MaxMetaspaceSize;
    }
  
<span class="changed">!   MetaspaceSize = align_down_bounded(MetaspaceSize, _commit_alignment);</span>
  
    assert(MetaspaceSize &lt;= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");
  
<span class="changed">!   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, _commit_alignment);</span>
<span class="changed">!   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, _commit_alignment);</span>
<span class="changed">! </span>
<span class="changed">!   CompressedClassSpaceSize = align_down_bounded(CompressedClassSpaceSize, _reserve_alignment);</span>
<span class="changed">! </span>
<span class="changed">!   // Initial virtual space size will be calculated at global_initialize()</span>
<span class="changed">!   size_t min_metaspace_sz =</span>
<span class="changed">!       VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;</span>
<span class="changed">!   if (UseCompressedClassPointers) {</span>
<span class="changed">!     if ((min_metaspace_sz + CompressedClassSpaceSize) &gt;  MaxMetaspaceSize) {</span>
<span class="changed">!       if (min_metaspace_sz &gt;= MaxMetaspaceSize) {</span>
<span class="changed">!         vm_exit_during_initialization("MaxMetaspaceSize is too small.");</span>
<span class="changed">!       } else {</span>
<span class="changed">!         FLAG_SET_ERGO(CompressedClassSpaceSize,</span>
<span class="changed">!                       MaxMetaspaceSize - min_metaspace_sz);</span>
<span class="changed">!       }</span>
<span class="changed">!     }</span>
<span class="changed">!   } else if (min_metaspace_sz &gt;= MaxMetaspaceSize) {</span>
<span class="changed">!     FLAG_SET_ERGO(InitialBootClassLoaderMetaspaceSize,</span>
<span class="changed">!                   min_metaspace_sz);</span>
<span class="changed">!   }</span>
  
<span class="removed">-   set_compressed_class_space_size(CompressedClassSpaceSize);</span>
  }
  
  void Metaspace::global_initialize() {
<span class="changed">!   MetaspaceGC::initialize();</span>
  
    // If UseCompressedClassPointers=1, we have two cases:
    // a) if CDS is active (either dump time or runtime), it will create the ccs
    //    for us, initialize it and set up CompressedKlassPointers encoding.
    //    Class space will be reserved above the mapped archives.
<span class="newmarker">--- 582,675 ----</span>
  }
  
  #endif // _LP64
  
  
<span class="changed">! size_t Metaspace::reserve_alignment_words() {</span>
<span class="changed">!   return metaspace::Settings::virtual_space_node_reserve_alignment_words();</span>
<span class="changed">! }</span>
  
<span class="changed">! size_t Metaspace::commit_alignment_words() {</span>
<span class="changed">!   return metaspace::Settings::commit_granule_words();</span>
<span class="changed">! }</span>
  
<span class="changed">! void Metaspace::ergo_initialize() {</span>
  
<span class="changed">!   // Must happen before using any setting from Settings::---</span>
<span class="changed">!   metaspace::Settings::ergo_initialize();</span>
  
<span class="changed">!   // MaxMetaspaceSize and CompressedClassSpaceSize:</span>
    //
<span class="changed">!   // MaxMetaspaceSize is the maximum size, in bytes, of memory we are allowed</span>
<span class="changed">!   //  to commit for the Metaspace.</span>
<span class="changed">!   //  It is just a number; a limit we compare against before committing. It</span>
<span class="changed">!   //  does not have to be aligned to anything.</span>
<span class="changed">!   //  It gets used as compare value in class CommitLimiter.</span>
<span class="changed">!   //  It is set to max_uintx in globals.hpp by default, so by default it does</span>
<span class="changed">!   //  not limit anything.</span>
<span class="changed">!   //</span>
<span class="changed">!   // CompressedClassSpaceSize is the size, in bytes, of the address range we</span>
<span class="changed">!   //  pre-reserve for the compressed class space (if we use class space).</span>
<span class="changed">!   //  This size has to be aligned to the metaspace reserve alignment (to the</span>
<span class="changed">!   //  size of a root chunk). It gets aligned up from whatever value the caller</span>
<span class="changed">!   //  gave us to the next multiple of root chunk size.</span>
<span class="changed">!   //</span>
<span class="changed">!   // Note: Strictly speaking MaxMetaspaceSize and CompressedClassSpaceSize have</span>
<span class="changed">!   //  very little to do with each other. The notion often encountered:</span>
<span class="changed">!   //  MaxMetaspaceSize = CompressedClassSpaceSize + &lt;non-class metadata size&gt;</span>
<span class="changed">!   //  is subtly wrong: MaxMetaspaceSize can besmaller than CompressedClassSpaceSize,</span>
<span class="changed">!   //  in which case we just would not be able to fully commit the class space range.</span>
<span class="changed">!   //</span>
<span class="changed">!   // We still adjust CompressedClassSpaceSize to reasonable limits, mainly to</span>
<span class="changed">!   //  save on reserved space, and to make ergnonomics less confusing.</span>
<span class="changed">! </span>
<span class="changed">!   // (aligned just for cleanliness:)</span>
<span class="changed">!   MaxMetaspaceSize = MAX2(align_down(MaxMetaspaceSize, commit_alignment()), commit_alignment());</span>
<span class="changed">! </span>
<span class="changed">!   if (UseCompressedClassPointers) {</span>
<span class="changed">!     // Let CCS size not be larger than 80% of MaxMetaspaceSize. Note that is</span>
<span class="changed">!     // grossly over-dimensioned for most usage scenarios; typical ratio of</span>
<span class="changed">!     // class space : non class space usage is about 1:6. With many small classes,</span>
<span class="changed">!     // it can get as low as 1:2. It is not a big deal though since ccs is only</span>
<span class="changed">!     // reserved and will be committed on demand only.</span>
<span class="changed">!     size_t max_ccs_size = MaxMetaspaceSize * 0.8;</span>
<span class="changed">!     size_t adjusted_ccs_size = MIN2(CompressedClassSpaceSize, max_ccs_size);</span>
<span class="changed">! </span>
<span class="changed">!     // CCS must be aligned to root chunk size, and be at least the size of one</span>
<span class="changed">!     //  root chunk.</span>
<span class="changed">!     adjusted_ccs_size = align_up(adjusted_ccs_size, reserve_alignment());</span>
<span class="changed">!     adjusted_ccs_size = MAX2(adjusted_ccs_size, reserve_alignment());</span>
<span class="changed">! </span>
<span class="changed">!     // Note: re-adjusting may have us left with a CompressedClassSpaceSize</span>
<span class="changed">!     //  larger than MaxMetaspaceSize for very small values of MaxMetaspaceSize.</span>
<span class="changed">!     //  Lets just live with that, its not a big deal.</span>
<span class="changed">! </span>
<span class="changed">!     if (adjusted_ccs_size != CompressedClassSpaceSize) {</span>
<span class="changed">!       FLAG_SET_ERGO(CompressedClassSpaceSize, adjusted_ccs_size);</span>
<span class="changed">!       log_info(metaspace)("Setting CompressedClassSpaceSize to " SIZE_FORMAT ".",</span>
<span class="changed">!                           CompressedClassSpaceSize);</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
  
<span class="new">+   // Set MetaspaceSize, MinMetaspaceExpansion and MaxMetaspaceExpansion</span>
    if (MetaspaceSize &gt; MaxMetaspaceSize) {
      MetaspaceSize = MaxMetaspaceSize;
    }
  
<span class="changed">!   MetaspaceSize = align_down_bounded(MetaspaceSize, commit_alignment());</span>
  
    assert(MetaspaceSize &lt;= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");
  
<span class="changed">!   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, commit_alignment());</span>
<span class="changed">!   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, commit_alignment());</span>
  
  }
  
  void Metaspace::global_initialize() {
<span class="changed">!   MetaspaceGC::initialize(); // &lt;- since we do not prealloc init chunks anymore is this still needed?</span>
<span class="changed">! </span>
<span class="changed">!   metaspace::ChunkHeaderPool::initialize();</span>
  
    // If UseCompressedClassPointers=1, we have two cases:
    // a) if CDS is active (either dump time or runtime), it will create the ccs
    //    for us, initialize it and set up CompressedKlassPointers encoding.
    //    Class space will be reserved above the mapped archives.
<hr /><span class="oldmarker">*** 1186,1196 ****</span>
  
      // ...failing that, give up.
      if (!rs.is_reserved()) {
        vm_exit_during_initialization(
            err_msg("Could not allocate compressed class space: " SIZE_FORMAT " bytes",
<span class="changed">!                    compressed_class_space_size()));</span>
      }
  
      // Initialize space
      Metaspace::initialize_class_space(rs);
  
<span class="newmarker">--- 725,735 ----</span>
  
      // ...failing that, give up.
      if (!rs.is_reserved()) {
        vm_exit_during_initialization(
            err_msg("Could not allocate compressed class space: " SIZE_FORMAT " bytes",
<span class="changed">!                    CompressedClassSpaceSize));</span>
      }
  
      // Initialize space
      Metaspace::initialize_class_space(rs);
  
<hr /><span class="oldmarker">*** 1198,1232 ****</span>
      CompressedKlassPointers::initialize((address)rs.base(), rs.size());
    }
  
  #endif
  
<span class="changed">!   // Initialize these before initializing the VirtualSpaceList</span>
<span class="changed">!   _first_chunk_word_size = InitialBootClassLoaderMetaspaceSize / BytesPerWord;</span>
<span class="changed">!   _first_chunk_word_size = align_word_size_up(_first_chunk_word_size);</span>
<span class="changed">!   // Make the first class chunk bigger than a medium chunk so it's not put</span>
<span class="changed">!   // on the medium chunk list.   The next chunk will be small and progress</span>
<span class="changed">!   // from there.  This size calculated by -version.</span>
<span class="changed">!   _first_class_chunk_word_size = MIN2((size_t)MediumChunk*6,</span>
<span class="changed">!                                      (CompressedClassSpaceSize/BytesPerWord)*2);</span>
<span class="changed">!   _first_class_chunk_word_size = align_word_size_up(_first_class_chunk_word_size);</span>
<span class="changed">!   // Arbitrarily set the initial virtual space to a multiple</span>
<span class="changed">!   // of the boot class loader size.</span>
<span class="changed">!   size_t word_size = VIRTUALSPACEMULTIPLIER * _first_chunk_word_size;</span>
<span class="changed">!   word_size = align_up(word_size, Metaspace::reserve_alignment_words());</span>
<span class="changed">! </span>
<span class="changed">!   // Initialize the list of virtual spaces.</span>
<span class="changed">!   _space_list = new VirtualSpaceList(word_size);</span>
<span class="changed">!   _chunk_manager_metadata = new ChunkManager(false/*metaspace*/);</span>
<span class="changed">! </span>
<span class="changed">!   if (!_space_list-&gt;initialization_succeeded()) {</span>
<span class="changed">!     vm_exit_during_initialization("Unable to setup metadata virtual space list.", NULL);</span>
<span class="changed">!   }</span>
  
    _tracer = new MetaspaceTracer();
  
<span class="changed">!   _initialized = true;</span>
  
  #ifdef _LP64
    if (UseCompressedClassPointers) {
      // Note: "cds" would be a better fit but keep this for backward compatibility.
      LogTarget(Info, gc, metaspace) lt;
<span class="newmarker">--- 737,764 ----</span>
      CompressedKlassPointers::initialize((address)rs.base(), rs.size());
    }
  
  #endif
  
<span class="changed">!   // Initialize non-class virtual space list, and its chunk manager:</span>
<span class="changed">!   MetaspaceContext::initialize_nonclass_space_context();</span>
  
    _tracer = new MetaspaceTracer();
  
<span class="changed">!   // We must prevent the very first address of the ccs from being used to store</span>
<span class="changed">!   // metadata, since that address would translate to a narrow pointer of 0, and the</span>
<span class="changed">!   // VM does not distinguish between "narrow 0 as in NULL" and "narrow 0 as in start</span>
<span class="changed">!   //  of ccs".</span>
<span class="changed">!   // Before Elastic Metaspace that did not happen due to the fact that every Metachunk</span>
<span class="changed">!   // had a header and therefore could not allocate anything at offset 0.</span>
<span class="changed">! #ifdef _LP64</span>
<span class="changed">!   if (using_class_space()) {</span>
<span class="changed">!     // The simplest way to fix this is to allocate a tiny dummy chunk right at the</span>
<span class="changed">!     // start of ccs and do not use it for anything.</span>
<span class="changed">!     MetaspaceContext::context_class()-&gt;cm()-&gt;get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);</span>
<span class="changed">!   }</span>
<span class="changed">! #endif</span>
  
  #ifdef _LP64
    if (UseCompressedClassPointers) {
      // Note: "cds" would be a better fit but keep this for backward compatibility.
      LogTarget(Info, gc, metaspace) lt;
<hr /><span class="oldmarker">*** 1244,1270 ****</span>
  
  void Metaspace::post_initialize() {
    MetaspaceGC::post_initialize();
  }
  
<span class="changed">! void Metaspace::verify_global_initialization() {</span>
<span class="changed">!   assert(space_list() != NULL, "Metadata VirtualSpaceList has not been initialized");</span>
<span class="changed">!   assert(chunk_manager_metadata() != NULL, "Metadata ChunkManager has not been initialized");</span>
<span class="changed">! </span>
<span class="changed">!   if (using_class_space()) {</span>
<span class="changed">!     assert(class_space_list() != NULL, "Class VirtualSpaceList has not been initialized");</span>
<span class="changed">!     assert(chunk_manager_class() != NULL, "Class ChunkManager has not been initialized");</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t Metaspace::align_word_size_up(size_t word_size) {</span>
<span class="changed">!   size_t byte_size = word_size * wordSize;</span>
<span class="changed">!   return ReservedSpace::allocation_align_size_up(byte_size) / wordSize;</span>
  }
  
  MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,
                                MetaspaceObj::Type type, TRAPS) {
    assert(!_frozen, "sanity");
    assert(!(DumpSharedSpaces &amp;&amp; THREAD-&gt;is_VM_thread()), "sanity");
  
    if (HAS_PENDING_EXCEPTION) {
      assert(false, "Should not allocate with exception pending");
<span class="newmarker">--- 776,794 ----</span>
  
  void Metaspace::post_initialize() {
    MetaspaceGC::post_initialize();
  }
  
<span class="changed">! size_t Metaspace::max_allocation_word_size() {</span>
<span class="changed">!   const size_t max_overhead_words = metaspace::get_raw_word_size_for_requested_word_size(1);</span>
<span class="changed">!   return metaspace::chunklevel::MAX_CHUNK_WORD_SIZE - max_overhead_words;</span>
  }
  
  MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,
                                MetaspaceObj::Type type, TRAPS) {
<span class="new">+   assert(word_size &lt;= Metaspace::max_allocation_word_size(),</span>
<span class="new">+          "allocation size too large (" SIZE_FORMAT ")", word_size);</span>
    assert(!_frozen, "sanity");
    assert(!(DumpSharedSpaces &amp;&amp; THREAD-&gt;is_VM_thread()), "sanity");
  
    if (HAS_PENDING_EXCEPTION) {
      assert(false, "Should not allocate with exception pending");
<hr /><span class="oldmarker">*** 1272,1282 ****</span>
    }
  
    assert(loader_data != NULL, "Should never pass around a NULL loader_data. "
          "ClassLoaderData::the_null_class_loader_data() should have been used.");
  
<span class="changed">!   MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;</span>
  
    // Try to allocate metadata.
    MetaWord* result = loader_data-&gt;metaspace_non_null()-&gt;allocate(word_size, mdtype);
  
    if (result == NULL) {
<span class="newmarker">--- 796,806 ----</span>
    }
  
    assert(loader_data != NULL, "Should never pass around a NULL loader_data. "
          "ClassLoaderData::the_null_class_loader_data() should have been used.");
  
<span class="changed">!   Metaspace::MetadataType mdtype = (type == MetaspaceObj::ClassType) ? Metaspace::ClassType : Metaspace::NonClassType;</span>
  
    // Try to allocate metadata.
    MetaWord* result = loader_data-&gt;metaspace_non_null()-&gt;allocate(word_size, mdtype);
  
    if (result == NULL) {
<hr /><span class="oldmarker">*** 1305,1325 ****</span>
    }
  
    // Zero initialize.
    Copy::fill_to_words((HeapWord*)result, word_size, 0);
  
    return result;
  }
  
  void Metaspace::report_metadata_oome(ClassLoaderData* loader_data, size_t word_size, MetaspaceObj::Type type, MetadataType mdtype, TRAPS) {
    tracer()-&gt;report_metadata_oom(loader_data, word_size, type, mdtype);
  
    // If result is still null, we are out of memory.
    Log(gc, metaspace, freelist, oom) log;
    if (log.is_info()) {
      log.info("Metaspace (%s) allocation failed for size " SIZE_FORMAT,
<span class="changed">!              is_class_space_allocation(mdtype) ? "class" : "data", word_size);</span>
      ResourceMark rm;
      if (log.is_debug()) {
        if (loader_data-&gt;metaspace_or_null() != NULL) {
          LogStream ls(log.debug());
          loader_data-&gt;print_value_on(&amp;ls);
<span class="newmarker">--- 829,851 ----</span>
    }
  
    // Zero initialize.
    Copy::fill_to_words((HeapWord*)result, word_size, 0);
  
<span class="new">+   log_trace(metaspace)("Metaspace::allocate: type %d return " PTR_FORMAT ".", (int)type, p2i(result));</span>
<span class="new">+ </span>
    return result;
  }
  
  void Metaspace::report_metadata_oome(ClassLoaderData* loader_data, size_t word_size, MetaspaceObj::Type type, MetadataType mdtype, TRAPS) {
    tracer()-&gt;report_metadata_oom(loader_data, word_size, type, mdtype);
  
    // If result is still null, we are out of memory.
    Log(gc, metaspace, freelist, oom) log;
    if (log.is_info()) {
      log.info("Metaspace (%s) allocation failed for size " SIZE_FORMAT,
<span class="changed">!              metaspace::is_class(mdtype) ? "class" : "data", word_size);</span>
      ResourceMark rm;
      if (log.is_debug()) {
        if (loader_data-&gt;metaspace_or_null() != NULL) {
          LogStream ls(log.debug());
          loader_data-&gt;print_value_on(&amp;ls);
<hr /><span class="oldmarker">*** 1328,1343 ****</span>
      LogStream ls(log.info());
      // In case of an OOM, log out a short but still useful report.
      MetaspaceUtils::print_basic_report(&amp;ls, 0);
    }
  
    bool out_of_compressed_class_space = false;
<span class="changed">!   if (is_class_space_allocation(mdtype)) {</span>
      ClassLoaderMetaspace* metaspace = loader_data-&gt;metaspace_non_null();
      out_of_compressed_class_space =
        MetaspaceUtils::committed_bytes(Metaspace::ClassType) +
<span class="changed">!       (metaspace-&gt;class_chunk_size(word_size) * BytesPerWord) &gt;</span>
        CompressedClassSpaceSize;
    }
  
    // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support
    const char* space_string = out_of_compressed_class_space ?
<span class="newmarker">--- 854,874 ----</span>
      LogStream ls(log.info());
      // In case of an OOM, log out a short but still useful report.
      MetaspaceUtils::print_basic_report(&amp;ls, 0);
    }
  
<span class="new">+   // Which limit did we hit? CompressedClassSpaceSize or MaxMetaspaceSize?</span>
    bool out_of_compressed_class_space = false;
<span class="changed">!   if (metaspace::is_class(mdtype)) {</span>
      ClassLoaderMetaspace* metaspace = loader_data-&gt;metaspace_non_null();
      out_of_compressed_class_space =
        MetaspaceUtils::committed_bytes(Metaspace::ClassType) +
<span class="changed">!       // TODO: Okay this is just cheesy.</span>
<span class="changed">!       // Of course this may fail and return incorrect results.</span>
<span class="changed">!       // Think this over - we need some clean way to remember which limit</span>
<span class="changed">!       // exactly we hit during an allocation. Some sort of allocation context structure?</span>
<span class="changed">!       align_up(word_size * BytesPerWord, 4 * M) &gt;</span>
        CompressedClassSpaceSize;
    }
  
    // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support
    const char* space_string = out_of_compressed_class_space ?
<hr /><span class="oldmarker">*** 1360,1389 ****</span>
    } else {
      THROW_OOP(Universe::out_of_memory_error_metaspace());
    }
  }
  
<span class="removed">- const char* Metaspace::metadata_type_name(Metaspace::MetadataType mdtype) {</span>
<span class="removed">-   switch (mdtype) {</span>
<span class="removed">-     case Metaspace::ClassType: return "Class";</span>
<span class="removed">-     case Metaspace::NonClassType: return "Metadata";</span>
<span class="removed">-     default:</span>
<span class="removed">-       assert(false, "Got bad mdtype: %d", (int) mdtype);</span>
<span class="removed">-       return NULL;</span>
<span class="removed">-   }</span>
<span class="removed">- }</span>
<span class="removed">- </span>
<span class="removed">- void Metaspace::purge(MetadataType mdtype) {</span>
<span class="removed">-   get_space_list(mdtype)-&gt;purge(get_chunk_manager(mdtype));</span>
<span class="removed">- }</span>
<span class="removed">- </span>
  void Metaspace::purge() {
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock,</span>
<span class="changed">!                  Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   purge(NonClassType);</span>
    if (using_class_space()) {
<span class="changed">!     purge(ClassType);</span>
    }
  }
  
  bool Metaspace::contains(const void* ptr) {
    if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
<span class="newmarker">--- 891,910 ----</span>
    } else {
      THROW_OOP(Universe::out_of_memory_error_metaspace());
    }
  }
  
  void Metaspace::purge() {
<span class="changed">!   ChunkManager* cm = ChunkManager::chunkmanager_nonclass();</span>
<span class="changed">!   if (cm != NULL) {</span>
<span class="changed">!     cm-&gt;purge();</span>
<span class="changed">!   }</span>
    if (using_class_space()) {
<span class="changed">!     cm = ChunkManager::chunkmanager_class();</span>
<span class="changed">!     if (cm != NULL) {</span>
<span class="changed">!       cm-&gt;purge();</span>
<span class="changed">!     }</span>
    }
  }
  
  bool Metaspace::contains(const void* ptr) {
    if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
<hr /><span class="oldmarker">*** 1391,1606 ****</span>
    }
    return contains_non_shared(ptr);
  }
  
  bool Metaspace::contains_non_shared(const void* ptr) {
<span class="changed">!   if (using_class_space() &amp;&amp; get_space_list(ClassType)-&gt;contains(ptr)) {</span>
       return true;
    }
  
<span class="changed">!   return get_space_list(NonClassType)-&gt;contains(ptr);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // ClassLoaderMetaspace</span>
<span class="changed">! </span>
<span class="changed">! ClassLoaderMetaspace::ClassLoaderMetaspace(Mutex* lock, Metaspace::MetaspaceType type)</span>
<span class="changed">!   : _space_type(type)</span>
<span class="changed">!   , _lock(lock)</span>
<span class="changed">!   , _vsm(NULL)</span>
<span class="changed">!   , _class_vsm(NULL)</span>
<span class="changed">! {</span>
<span class="changed">!   initialize(lock, type);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! ClassLoaderMetaspace::~ClassLoaderMetaspace() {</span>
<span class="changed">!   Metaspace::assert_not_frozen();</span>
<span class="changed">!   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_deaths));</span>
<span class="changed">!   delete _vsm;</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     delete _class_vsm;</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::initialize_first_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   Metachunk* chunk = get_initialization_chunk(type, mdtype);</span>
<span class="changed">!   if (chunk != NULL) {</span>
<span class="changed">!     // Add to this manager's list of chunks in use and make it the current_chunk().</span>
<span class="changed">!     get_space_manager(mdtype)-&gt;add_chunk(chunk, true);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! Metachunk* ClassLoaderMetaspace::get_initialization_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   size_t chunk_word_size = get_space_manager(mdtype)-&gt;get_initial_chunk_size(type);</span>
<span class="changed">! </span>
<span class="changed">!   // Get a chunk from the chunk freelist</span>
<span class="changed">!   Metachunk* chunk = Metaspace::get_chunk_manager(mdtype)-&gt;chunk_freelist_allocate(chunk_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   if (chunk == NULL) {</span>
<span class="changed">!     chunk = Metaspace::get_space_list(mdtype)-&gt;get_new_chunk(chunk_word_size,</span>
<span class="changed">!                                                   get_space_manager(mdtype)-&gt;medium_chunk_bunch());</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   return chunk;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::initialize(Mutex* lock, Metaspace::MetaspaceType type) {</span>
<span class="changed">!   Metaspace::verify_global_initialization();</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_births));</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate SpaceManager for metadata objects.</span>
<span class="changed">!   _vsm = new SpaceManager(Metaspace::NonClassType, type, lock);</span>
<span class="changed">! </span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     // Allocate SpaceManager for classes.</span>
<span class="changed">!     _class_vsm = new SpaceManager(Metaspace::ClassType, type, lock);</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate chunk for metadata objects</span>
<span class="changed">!   initialize_first_chunk(type, Metaspace::NonClassType);</span>
<span class="changed">! </span>
<span class="changed">!   // Allocate chunk for class metadata objects</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     initialize_first_chunk(type, Metaspace::ClassType);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   Metaspace::assert_not_frozen();</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs));</span>
<span class="changed">! </span>
<span class="changed">!   // Don't use class_vsm() unless UseCompressedClassPointers is true.</span>
<span class="changed">!   if (Metaspace::is_class_space_allocation(mdtype)) {</span>
<span class="changed">!     return  class_vsm()-&gt;allocate(word_size);</span>
<span class="changed">!   } else {</span>
<span class="changed">!     return  vsm()-&gt;allocate(word_size);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! MetaWord* ClassLoaderMetaspace::expand_and_allocate(size_t word_size, Metaspace::MetadataType mdtype) {</span>
<span class="changed">!   Metaspace::assert_not_frozen();</span>
<span class="changed">!   size_t delta_bytes = MetaspaceGC::delta_capacity_until_GC(word_size * BytesPerWord);</span>
<span class="changed">!   assert(delta_bytes &gt; 0, "Must be");</span>
<span class="changed">! </span>
<span class="changed">!   size_t before = 0;</span>
<span class="changed">!   size_t after = 0;</span>
<span class="changed">!   bool can_retry = true;</span>
<span class="changed">!   MetaWord* res;</span>
<span class="changed">!   bool incremented;</span>
<span class="changed">! </span>
<span class="changed">!   // Each thread increments the HWM at most once. Even if the thread fails to increment</span>
<span class="changed">!   // the HWM, an allocation is still attempted. This is because another thread must then</span>
<span class="changed">!   // have incremented the HWM and therefore the allocation might still succeed.</span>
<span class="changed">!   do {</span>
<span class="changed">!     incremented = MetaspaceGC::inc_capacity_until_GC(delta_bytes, &amp;after, &amp;before, &amp;can_retry);</span>
<span class="changed">!     res = allocate(word_size, mdtype);</span>
<span class="changed">!   } while (!incremented &amp;&amp; res == NULL &amp;&amp; can_retry);</span>
<span class="changed">! </span>
<span class="changed">!   if (incremented) {</span>
<span class="changed">!     Metaspace::tracer()-&gt;report_gc_threshold(before, after,</span>
<span class="changed">!                                   MetaspaceGCThresholdUpdater::ExpandAndAllocate);</span>
<span class="changed">!     log_trace(gc, metaspace)("Increase capacity to GC from " SIZE_FORMAT " to " SIZE_FORMAT, before, after);</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   return res;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t ClassLoaderMetaspace::allocated_blocks_bytes() const {</span>
<span class="changed">!   return (vsm()-&gt;used_words() +</span>
<span class="changed">!       (Metaspace::using_class_space() ? class_vsm()-&gt;used_words() : 0)) * BytesPerWord;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t ClassLoaderMetaspace::allocated_chunks_bytes() const {</span>
<span class="changed">!   return (vsm()-&gt;capacity_words() +</span>
<span class="changed">!       (Metaspace::using_class_space() ? class_vsm()-&gt;capacity_words() : 0)) * BytesPerWord;</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {</span>
<span class="changed">!   Metaspace::assert_not_frozen();</span>
<span class="changed">!   assert(!SafepointSynchronize::is_at_safepoint()</span>
<span class="changed">!          || Thread::current()-&gt;is_VM_thread(), "should be the VM thread");</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_external_deallocs));</span>
<span class="changed">! </span>
<span class="changed">!   MutexLocker ml(vsm()-&gt;lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed">! </span>
<span class="changed">!   if (is_class &amp;&amp; Metaspace::using_class_space()) {</span>
<span class="changed">!     class_vsm()-&gt;deallocate(ptr, word_size);</span>
<span class="changed">!   } else {</span>
<span class="changed">!     vsm()-&gt;deallocate(ptr, word_size);</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t ClassLoaderMetaspace::class_chunk_size(size_t word_size) {</span>
<span class="changed">!   assert(Metaspace::using_class_space(), "Has to use class space");</span>
<span class="changed">!   return class_vsm()-&gt;calc_chunk_size(word_size);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::print_on(outputStream* out) const {</span>
<span class="changed">!   // Print both class virtual space counts and metaspace.</span>
<span class="changed">!   if (Verbose) {</span>
<span class="changed">!     vsm()-&gt;print_on(out);</span>
<span class="changed">!     if (Metaspace::using_class_space()) {</span>
<span class="changed">!       class_vsm()-&gt;print_on(out);</span>
<span class="changed">!     }</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::verify() {</span>
<span class="changed">!   vsm()-&gt;verify();</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     class_vsm()-&gt;verify();</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::add_to_statistics_locked(ClassLoaderMetaspaceStatistics* out) const {</span>
<span class="changed">!   assert_lock_strong(lock());</span>
<span class="changed">!   vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;nonclass_sm_stats());</span>
<span class="changed">!   if (Metaspace::using_class_space()) {</span>
<span class="changed">!     class_vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;class_sm_stats());</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! void ClassLoaderMetaspace::add_to_statistics(ClassLoaderMetaspaceStatistics* out) const {</span>
<span class="changed">!   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   add_to_statistics_locked(out);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! /////////////// Unit tests ///////////////</span>
<span class="changed">! </span>
<span class="changed">! struct chunkmanager_statistics_t {</span>
<span class="changed">!   int num_specialized_chunks;</span>
<span class="changed">!   int num_small_chunks;</span>
<span class="changed">!   int num_medium_chunks;</span>
<span class="changed">!   int num_humongous_chunks;</span>
<span class="changed">! };</span>
<span class="changed">! </span>
<span class="changed">! extern void test_metaspace_retrieve_chunkmanager_statistics(Metaspace::MetadataType mdType, chunkmanager_statistics_t* out) {</span>
<span class="changed">!   ChunkManager* const chunk_manager = Metaspace::get_chunk_manager(mdType);</span>
<span class="changed">!   ChunkManagerStatistics stat;</span>
<span class="changed">!   chunk_manager-&gt;collect_statistics(&amp;stat);</span>
<span class="changed">!   out-&gt;num_specialized_chunks = (int)stat.chunk_stats(SpecializedIndex).num();</span>
<span class="changed">!   out-&gt;num_small_chunks = (int)stat.chunk_stats(SmallIndex).num();</span>
<span class="changed">!   out-&gt;num_medium_chunks = (int)stat.chunk_stats(MediumIndex).num();</span>
<span class="changed">!   out-&gt;num_humongous_chunks = (int)stat.chunk_stats(HumongousIndex).num();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! struct chunk_geometry_t {</span>
<span class="changed">!   size_t specialized_chunk_word_size;</span>
<span class="changed">!   size_t small_chunk_word_size;</span>
<span class="changed">!   size_t medium_chunk_word_size;</span>
<span class="changed">! };</span>
<span class="changed">! </span>
<span class="changed">! extern void test_metaspace_retrieve_chunk_geometry(Metaspace::MetadataType mdType, chunk_geometry_t* out) {</span>
<span class="changed">!   if (mdType == Metaspace::NonClassType) {</span>
<span class="changed">!     out-&gt;specialized_chunk_word_size = SpecializedChunk;</span>
<span class="changed">!     out-&gt;small_chunk_word_size = SmallChunk;</span>
<span class="changed">!     out-&gt;medium_chunk_word_size = MediumChunk;</span>
<span class="changed">!   } else {</span>
<span class="changed">!     out-&gt;specialized_chunk_word_size = ClassSpecializedChunk;</span>
<span class="changed">!     out-&gt;small_chunk_word_size = ClassSmallChunk;</span>
<span class="changed">!     out-&gt;medium_chunk_word_size = ClassMediumChunk;</span>
<span class="changed">!   }</span>
  }
<span class="newmarker">--- 912,922 ----</span>
    }
    return contains_non_shared(ptr);
  }
  
  bool Metaspace::contains_non_shared(const void* ptr) {
<span class="changed">!   if (using_class_space() &amp;&amp; VirtualSpaceList::vslist_class()-&gt;contains((MetaWord*)ptr)) {</span>
       return true;
    }
  
<span class="changed">!   return VirtualSpaceList::vslist_nonclass()-&gt;contains((MetaWord*)ptr);</span>
  }
</pre>
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace.hpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

