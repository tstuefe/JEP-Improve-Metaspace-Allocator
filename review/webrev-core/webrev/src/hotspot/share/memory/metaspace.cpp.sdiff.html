<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/memory </title>
</head><body id="SUNWwebrev">
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60811">60811</a> : imported patch jep387-core.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"

  26 #include "aot/aotLoader.hpp"
<span class="removed">  27 #include "classfile/classLoaderDataGraph.hpp"</span>
  28 #include "gc/shared/collectedHeap.hpp"
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
  31 #include "memory/filemap.hpp"










  32 #include "memory/metaspace.hpp"
<span class="removed">  33 #include "memory/metaspace/chunkManager.hpp"</span>
<span class="removed">  34 #include "memory/metaspace/metachunk.hpp"</span>
<span class="removed">  35 #include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="removed">  36 #include "memory/metaspace/printCLDMetaspaceInfoClosure.hpp"</span>
<span class="removed">  37 #include "memory/metaspace/spaceManager.hpp"</span>
<span class="removed">  38 #include "memory/metaspace/virtualSpaceList.hpp"</span>
  39 #include "memory/metaspaceShared.hpp"
  40 #include "memory/metaspaceTracer.hpp"
  41 #include "memory/universe.hpp"
  42 #include "oops/compressedOops.hpp"
  43 #include "runtime/arguments.hpp"
  44 #include "runtime/atomic.hpp"
  45 #include "runtime/init.hpp"

  46 #include "services/memTracker.hpp"
  47 #include "utilities/copy.hpp"
  48 #include "utilities/debug.hpp"
  49 #include "utilities/formatBuffer.hpp"
  50 #include "utilities/globalDefinitions.hpp"
<span class="removed">  51 #include "utilities/vmError.hpp"</span>
  52 
  53 
<span class="changed">  54 using namespace metaspace;</span>





  55 
<span class="removed">  56 MetaWord* last_allocated = 0;</span>
  57 
<span class="changed">  58 size_t Metaspace::_compressed_class_space_size;</span>
<span class="changed">  59 const MetaspaceTracer* Metaspace::_tracer = NULL;</span>

  60 
<span class="changed">  61 DEBUG_ONLY(bool Metaspace::_frozen = false;)</span>


















  62 
<span class="changed">  63 static const char* space_type_name(Metaspace::MetaspaceType t) {</span>
<span class="changed">  64   const char* s = NULL;</span>
<span class="changed">  65   switch (t) {</span>
<span class="changed">  66     case Metaspace::StandardMetaspaceType: s = "Standard"; break;</span>
<span class="changed">  67     case Metaspace::BootMetaspaceType: s = "Boot"; break;</span>
<span class="changed">  68     case Metaspace::ClassMirrorHolderMetaspaceType: s = "ClassMirrorHolder"; break;</span>
<span class="changed">  69     case Metaspace::ReflectionMetaspaceType: s = "Reflection"; break;</span>
<span class="changed">  70     default: ShouldNotReachHere();</span>

































  71   }
<span class="removed">  72   return s;</span>
  73 }
  74 
<span class="changed">  75 volatile size_t MetaspaceGC::_capacity_until_GC = 0;</span>
<span class="changed">  76 uint MetaspaceGC::_shrink_factor = 0;</span>



  77 
<span class="changed">  78 // BlockFreelist methods</span>










































  79 
<span class="changed">  80 // VirtualSpaceNode methods</span>


  81 















  82 // MetaspaceGC methods
  83 



  84 // VM_CollectForMetadataAllocation is the vm operation used to GC.
  85 // Within the VM operation after the GC the attempt to allocate the metadata
  86 // should succeed.  If the GC did not free enough space for the metaspace
  87 // allocation, the HWM is increased so that another virtualspace will be
  88 // allocated for the metadata.  With perm gen the increase in the perm
  89 // gen had bounds, MinMetaspaceExpansion and MaxMetaspaceExpansion.  The
  90 // metaspace policy uses those as the small and large steps for the HWM.
  91 //
  92 // After the GC the compute_new_size() for MetaspaceGC is called to
  93 // resize the capacity of the metaspaces.  The current implementation
  94 // is based on the flags MinMetaspaceFreeRatio and MaxMetaspaceFreeRatio used
  95 // to resize the Java heap by some GC's.  New flags can be implemented
  96 // if really needed.  MinMetaspaceFreeRatio is used to calculate how much
  97 // free space is desirable in the metaspace capacity to decide how much
  98 // to increase the HWM.  MaxMetaspaceFreeRatio is used to decide how much
  99 // free space is desirable in the metaspace capacity before decreasing
 100 // the HWM.
 101 
 102 // Calculate the amount to increase the high water mark (HWM).
 103 // Increase by a minimum amount (MinMetaspaceExpansion) so that

</pre><hr></hr><pre>
 335       } else {
 336         _shrink_factor = MIN2(current_shrink_factor * 4, (uint) 100);
 337       }
 338       log_trace(gc, metaspace)("    shrinking:  initThreshold: %.1fK  maximum_desired_capacity: %.1fK",
 339                                MetaspaceSize / (double) K, maximum_desired_capacity / (double) K);
 340       log_trace(gc, metaspace)("    shrink_bytes: %.1fK  current_shrink_factor: %d  new shrink factor: %d  MinMetaspaceExpansion: %.1fK",
 341                                shrink_bytes / (double) K, current_shrink_factor, _shrink_factor, MinMetaspaceExpansion / (double) K);
 342     }
 343   }
 344 
 345   // Don't shrink unless it's significant
 346   if (shrink_bytes &gt;= MinMetaspaceExpansion &amp;&amp;
 347       ((capacity_until_GC - shrink_bytes) &gt;= MetaspaceSize)) {
 348     size_t new_capacity_until_GC = MetaspaceGC::dec_capacity_until_GC(shrink_bytes);
 349     Metaspace::tracer()-&gt;report_gc_threshold(capacity_until_GC,
 350                                              new_capacity_until_GC,
 351                                              MetaspaceGCThresholdUpdater::ComputeNewSize);
 352   }
 353 }
 354 
<span class="removed"> 355 // MetaspaceUtils</span>
<span class="removed"> 356 size_t MetaspaceUtils::_capacity_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
<span class="removed"> 357 size_t MetaspaceUtils::_overhead_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
<span class="removed"> 358 volatile size_t MetaspaceUtils::_used_words [Metaspace:: MetadataTypeCount] = {0, 0};</span>
 359 
<span class="removed"> 360 // Collect used metaspace statistics. This involves walking the CLDG. The resulting</span>
<span class="removed"> 361 // output will be the accumulated values for all live metaspaces.</span>
<span class="removed"> 362 // Note: method does not do any locking.</span>
<span class="removed"> 363 void MetaspaceUtils::collect_statistics(ClassLoaderMetaspaceStatistics* out) {</span>
<span class="removed"> 364   out-&gt;reset();</span>
<span class="removed"> 365   ClassLoaderDataGraphMetaspaceIterator iter;</span>
<span class="removed"> 366    while (iter.repeat()) {</span>
<span class="removed"> 367      ClassLoaderMetaspace* msp = iter.get_next();</span>
<span class="removed"> 368      if (msp != NULL) {</span>
<span class="removed"> 369        msp-&gt;add_to_statistics(out);</span>
<span class="removed"> 370      }</span>
<span class="removed"> 371    }</span>
<span class="removed"> 372 }</span>
<span class="removed"> 373 </span>
<span class="removed"> 374 size_t MetaspaceUtils::free_in_vs_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="removed"> 375   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="removed"> 376   return list == NULL ? 0 : list-&gt;free_bytes();</span>
<span class="removed"> 377 }</span>
<span class="removed"> 378 </span>
<span class="removed"> 379 size_t MetaspaceUtils::free_in_vs_bytes() {</span>
<span class="removed"> 380   return free_in_vs_bytes(Metaspace::ClassType) + free_in_vs_bytes(Metaspace::NonClassType);</span>
<span class="removed"> 381 }</span>
<span class="removed"> 382 </span>
<span class="removed"> 383 static void inc_stat_nonatomically(size_t* pstat, size_t words) {</span>
<span class="removed"> 384   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed"> 385   (*pstat) += words;</span>
<span class="removed"> 386 }</span>
<span class="removed"> 387 </span>
<span class="removed"> 388 static void dec_stat_nonatomically(size_t* pstat, size_t words) {</span>
<span class="removed"> 389   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed"> 390   const size_t size_now = *pstat;</span>
<span class="removed"> 391   assert(size_now &gt;= words, "About to decrement counter below zero "</span>
<span class="removed"> 392          "(current value: " SIZE_FORMAT ", decrement value: " SIZE_FORMAT ".",</span>
<span class="removed"> 393          size_now, words);</span>
<span class="removed"> 394   *pstat = size_now - words;</span>
<span class="removed"> 395 }</span>
 396 
<span class="changed"> 397 static void inc_stat_atomically(volatile size_t* pstat, size_t words) {</span>
<span class="changed"> 398   Atomic::add(pstat, words);</span>
<span class="changed"> 399 }</span>
<span class="changed"> 400 </span>
<span class="changed"> 401 static void dec_stat_atomically(volatile size_t* pstat, size_t words) {</span>
<span class="changed"> 402   const size_t size_now = *pstat;</span>
<span class="changed"> 403   assert(size_now &gt;= words, "About to decrement counter below zero "</span>
<span class="changed"> 404          "(current value: " SIZE_FORMAT ", decrement value: " SIZE_FORMAT ".",</span>
<span class="changed"> 405          size_now, words);</span>
<span class="changed"> 406   Atomic::sub(pstat, words);</span>
<span class="changed"> 407 }</span>
<span class="changed"> 408 </span>
<span class="changed"> 409 void MetaspaceUtils::dec_capacity(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 410   dec_stat_nonatomically(&amp;_capacity_words[mdtype], words);</span>
<span class="changed"> 411 }</span>
<span class="changed"> 412 void MetaspaceUtils::inc_capacity(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 413   inc_stat_nonatomically(&amp;_capacity_words[mdtype], words);</span>
<span class="changed"> 414 }</span>
<span class="changed"> 415 void MetaspaceUtils::dec_used(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 416   dec_stat_atomically(&amp;_used_words[mdtype], words);</span>
<span class="changed"> 417 }</span>
<span class="changed"> 418 void MetaspaceUtils::inc_used(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 419   inc_stat_atomically(&amp;_used_words[mdtype], words);</span>
<span class="changed"> 420 }</span>
<span class="changed"> 421 void MetaspaceUtils::dec_overhead(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 422   dec_stat_nonatomically(&amp;_overhead_words[mdtype], words);</span>
<span class="changed"> 423 }</span>
<span class="changed"> 424 void MetaspaceUtils::inc_overhead(Metaspace::MetadataType mdtype, size_t words) {</span>
<span class="changed"> 425   inc_stat_nonatomically(&amp;_overhead_words[mdtype], words);</span>
<span class="changed"> 426 }</span>
<span class="changed"> 427 </span>
<span class="changed"> 428 size_t MetaspaceUtils::reserved_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 429   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="changed"> 430   return list == NULL ? 0 : list-&gt;reserved_bytes();</span>
<span class="changed"> 431 }</span>
<span class="changed"> 432 </span>
<span class="changed"> 433 size_t MetaspaceUtils::committed_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 434   VirtualSpaceList* list = Metaspace::get_space_list(mdtype);</span>
<span class="changed"> 435   return list == NULL ? 0 : list-&gt;committed_bytes();</span>
<span class="changed"> 436 }</span>
<span class="changed"> 437 </span>
<span class="changed"> 438 size_t MetaspaceUtils::min_chunk_size_words() { return Metaspace::first_chunk_word_size(); }</span>
<span class="changed"> 439 </span>
<span class="changed"> 440 size_t MetaspaceUtils::free_chunks_total_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 441   ChunkManager* chunk_manager = Metaspace::get_chunk_manager(mdtype);</span>
<span class="changed"> 442   if (chunk_manager == NULL) {</span>
<span class="changed"> 443     return 0;</span>
<span class="changed"> 444   }</span>
<span class="changed"> 445   return chunk_manager-&gt;free_chunks_total_words();</span>
<span class="changed"> 446 }</span>
<span class="changed"> 447 </span>
<span class="changed"> 448 size_t MetaspaceUtils::free_chunks_total_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 449   return free_chunks_total_words(mdtype) * BytesPerWord;</span>
<span class="changed"> 450 }</span>
<span class="changed"> 451 </span>
<span class="changed"> 452 size_t MetaspaceUtils::free_chunks_total_words() {</span>
<span class="changed"> 453   return free_chunks_total_words(Metaspace::ClassType) +</span>
<span class="changed"> 454          free_chunks_total_words(Metaspace::NonClassType);</span>
<span class="changed"> 455 }</span>
<span class="changed"> 456 </span>
<span class="changed"> 457 size_t MetaspaceUtils::free_chunks_total_bytes() {</span>
<span class="changed"> 458   return free_chunks_total_words() * BytesPerWord;</span>
<span class="changed"> 459 }</span>
<span class="changed"> 460 </span>
<span class="changed"> 461 bool MetaspaceUtils::has_chunk_free_list(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 462   return Metaspace::get_chunk_manager(mdtype) != NULL;</span>
<span class="changed"> 463 }</span>
<span class="changed"> 464 </span>
<span class="changed"> 465 MetaspaceChunkFreeListSummary MetaspaceUtils::chunk_free_list_summary(Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 466   if (!has_chunk_free_list(mdtype)) {</span>
<span class="changed"> 467     return MetaspaceChunkFreeListSummary();</span>
<span class="changed"> 468   }</span>
<span class="changed"> 469 </span>
<span class="changed"> 470   const ChunkManager* cm = Metaspace::get_chunk_manager(mdtype);</span>
<span class="changed"> 471   return cm-&gt;chunk_free_list_summary();</span>
<span class="changed"> 472 }</span>
<span class="changed"> 473 </span>
<span class="changed"> 474 void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values) {</span>
<span class="changed"> 475   const metaspace::MetaspaceSizesSnapshot meta_values;</span>
<span class="changed"> 476 </span>
<span class="changed"> 477   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 478     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT" "</span>
<span class="changed"> 479                             HEAP_CHANGE_FORMAT" "</span>
<span class="changed"> 480                             HEAP_CHANGE_FORMAT,</span>
<span class="changed"> 481                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed"> 482                                                     pre_meta_values.used(),</span>
<span class="changed"> 483                                                     pre_meta_values.committed(),</span>
<span class="changed"> 484                                                     meta_values.used(),</span>
<span class="changed"> 485                                                     meta_values.committed()),</span>
<span class="changed"> 486                             HEAP_CHANGE_FORMAT_ARGS("NonClass",</span>
<span class="changed"> 487                                                     pre_meta_values.non_class_used(),</span>
<span class="changed"> 488                                                     pre_meta_values.non_class_committed(),</span>
<span class="changed"> 489                                                     meta_values.non_class_used(),</span>
<span class="changed"> 490                                                     meta_values.non_class_committed()),</span>
<span class="changed"> 491                             HEAP_CHANGE_FORMAT_ARGS("Class",</span>
<span class="changed"> 492                                                     pre_meta_values.class_used(),</span>
<span class="changed"> 493                                                     pre_meta_values.class_committed(),</span>
<span class="changed"> 494                                                     meta_values.class_used(),</span>
<span class="changed"> 495                                                     meta_values.class_committed()));</span>
<span class="changed"> 496   } else {</span>
<span class="changed"> 497     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,</span>
<span class="changed"> 498                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed"> 499                                                     pre_meta_values.used(),</span>
<span class="changed"> 500                                                     pre_meta_values.committed(),</span>
<span class="changed"> 501                                                     meta_values.used(),</span>
<span class="changed"> 502                                                     meta_values.committed()));</span>
<span class="changed"> 503   }</span>
<span class="changed"> 504 }</span>
<span class="changed"> 505 </span>
<span class="changed"> 506 void MetaspaceUtils::print_on(outputStream* out) {</span>
<span class="changed"> 507   Metaspace::MetadataType nct = Metaspace::NonClassType;</span>
<span class="changed"> 508 </span>
<span class="changed"> 509   out-&gt;print_cr(" Metaspace       "</span>
<span class="changed"> 510                 "used "      SIZE_FORMAT "K, "</span>
<span class="changed"> 511                 "capacity "  SIZE_FORMAT "K, "</span>
<span class="changed"> 512                 "committed " SIZE_FORMAT "K, "</span>
<span class="changed"> 513                 "reserved "  SIZE_FORMAT "K",</span>
<span class="changed"> 514                 used_bytes()/K,</span>
<span class="changed"> 515                 capacity_bytes()/K,</span>
<span class="changed"> 516                 committed_bytes()/K,</span>
<span class="changed"> 517                 reserved_bytes()/K);</span>
<span class="changed"> 518 </span>
<span class="changed"> 519   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 520     Metaspace::MetadataType ct = Metaspace::ClassType;</span>
<span class="changed"> 521     out-&gt;print_cr("  class space    "</span>
<span class="changed"> 522                   "used "      SIZE_FORMAT "K, "</span>
<span class="changed"> 523                   "capacity "  SIZE_FORMAT "K, "</span>
<span class="changed"> 524                   "committed " SIZE_FORMAT "K, "</span>
<span class="changed"> 525                   "reserved "  SIZE_FORMAT "K",</span>
<span class="changed"> 526                   used_bytes(ct)/K,</span>
<span class="changed"> 527                   capacity_bytes(ct)/K,</span>
<span class="changed"> 528                   committed_bytes(ct)/K,</span>
<span class="changed"> 529                   reserved_bytes(ct)/K);</span>
<span class="changed"> 530   }</span>
<span class="changed"> 531 }</span>
<span class="changed"> 532 </span>
<span class="changed"> 533 </span>
<span class="changed"> 534 void MetaspaceUtils::print_vs(outputStream* out, size_t scale) {</span>
<span class="changed"> 535   const size_t reserved_nonclass_words = reserved_bytes(Metaspace::NonClassType) / sizeof(MetaWord);</span>
<span class="changed"> 536   const size_t committed_nonclass_words = committed_bytes(Metaspace::NonClassType) / sizeof(MetaWord);</span>
<span class="changed"> 537   {</span>
<span class="changed"> 538     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 539       out-&gt;print("  Non-class space:  ");</span>
<span class="changed"> 540     }</span>
<span class="changed"> 541     print_scaled_words(out, reserved_nonclass_words, scale, 7);</span>
<span class="changed"> 542     out-&gt;print(" reserved, ");</span>
<span class="changed"> 543     print_scaled_words_and_percentage(out, committed_nonclass_words, reserved_nonclass_words, scale, 7);</span>
<span class="changed"> 544     out-&gt;print_cr(" committed ");</span>
<span class="changed"> 545 </span>
<span class="changed"> 546     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 547       const size_t reserved_class_words = reserved_bytes(Metaspace::ClassType) / sizeof(MetaWord);</span>
<span class="changed"> 548       const size_t committed_class_words = committed_bytes(Metaspace::ClassType) / sizeof(MetaWord);</span>
<span class="changed"> 549       out-&gt;print("      Class space:  ");</span>
<span class="changed"> 550       print_scaled_words(out, reserved_class_words, scale, 7);</span>
<span class="changed"> 551       out-&gt;print(" reserved, ");</span>
<span class="changed"> 552       print_scaled_words_and_percentage(out, committed_class_words, reserved_class_words, scale, 7);</span>
<span class="changed"> 553       out-&gt;print_cr(" committed ");</span>
<span class="changed"> 554 </span>
<span class="changed"> 555       const size_t reserved_words = reserved_nonclass_words + reserved_class_words;</span>
<span class="changed"> 556       const size_t committed_words = committed_nonclass_words + committed_class_words;</span>
<span class="changed"> 557       out-&gt;print("             Both:  ");</span>
<span class="changed"> 558       print_scaled_words(out, reserved_words, scale, 7);</span>
<span class="changed"> 559       out-&gt;print(" reserved, ");</span>
<span class="changed"> 560       print_scaled_words_and_percentage(out, committed_words, reserved_words, scale, 7);</span>
<span class="changed"> 561       out-&gt;print_cr(" committed ");</span>
<span class="changed"> 562     }</span>
<span class="changed"> 563   }</span>
<span class="changed"> 564 }</span>
<span class="changed"> 565 </span>
<span class="changed"> 566 static void print_basic_switches(outputStream* out, size_t scale) {</span>
<span class="changed"> 567   out-&gt;print("MaxMetaspaceSize: ");</span>
<span class="changed"> 568   if (MaxMetaspaceSize &gt;= (max_uintx) - (2 * os::vm_page_size())) {</span>
<span class="changed"> 569     // aka "very big". Default is max_uintx, but due to rounding in arg parsing the real</span>
<span class="changed"> 570     // value is smaller.</span>
<span class="changed"> 571     out-&gt;print("unlimited");</span>
<span class="changed"> 572   } else {</span>
<span class="changed"> 573     print_human_readable_size(out, MaxMetaspaceSize, scale);</span>
<span class="changed"> 574   }</span>
<span class="changed"> 575   out-&gt;cr();</span>
<span class="changed"> 576   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 577     out-&gt;print("CompressedClassSpaceSize: ");</span>
<span class="changed"> 578     print_human_readable_size(out, CompressedClassSpaceSize, scale);</span>
<span class="changed"> 579   }</span>
<span class="changed"> 580   out-&gt;cr();</span>
<span class="changed"> 581 }</span>
<span class="changed"> 582 </span>
<span class="changed"> 583 // This will print out a basic metaspace usage report but</span>
<span class="changed"> 584 // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="changed"> 585 void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {</span>
<span class="changed"> 586 </span>
<span class="changed"> 587   if (!Metaspace::initialized()) {</span>
<span class="changed"> 588     out-&gt;print_cr("Metaspace not yet initialized.");</span>
<span class="changed"> 589     return;</span>
<span class="changed"> 590   }</span>
 591 
<span class="changed"> 592   out-&gt;cr();</span>
<span class="changed"> 593   out-&gt;print_cr("Usage:");</span>
<span class="changed"> 594 </span>
<span class="changed"> 595   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 596     out-&gt;print("  Non-class:  ");</span>
<span class="changed"> 597   }</span>
<span class="changed"> 598 </span>
<span class="changed"> 599   // In its most basic form, we do not require walking the CLDG. Instead, just print the running totals from</span>
<span class="changed"> 600   // MetaspaceUtils.</span>
<span class="changed"> 601   const size_t cap_nc = MetaspaceUtils::capacity_words(Metaspace::NonClassType);</span>
<span class="changed"> 602   const size_t overhead_nc = MetaspaceUtils::overhead_words(Metaspace::NonClassType);</span>
<span class="changed"> 603   const size_t used_nc = MetaspaceUtils::used_words(Metaspace::NonClassType);</span>
<span class="changed"> 604   const size_t free_and_waste_nc = cap_nc - overhead_nc - used_nc;</span>
<span class="changed"> 605 </span>
<span class="changed"> 606   print_scaled_words(out, cap_nc, scale, 5);</span>
<span class="changed"> 607   out-&gt;print(" capacity, ");</span>
<span class="changed"> 608   print_scaled_words_and_percentage(out, used_nc, cap_nc, scale, 5);</span>
<span class="changed"> 609   out-&gt;print(" used, ");</span>
<span class="changed"> 610   print_scaled_words_and_percentage(out, free_and_waste_nc, cap_nc, scale, 5);</span>
<span class="changed"> 611   out-&gt;print(" free+waste, ");</span>
<span class="changed"> 612   print_scaled_words_and_percentage(out, overhead_nc, cap_nc, scale, 5);</span>
<span class="changed"> 613   out-&gt;print(" overhead. ");</span>
<span class="changed"> 614   out-&gt;cr();</span>
<span class="changed"> 615 </span>
<span class="changed"> 616   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 617     const size_t cap_c = MetaspaceUtils::capacity_words(Metaspace::ClassType);</span>
<span class="changed"> 618     const size_t overhead_c = MetaspaceUtils::overhead_words(Metaspace::ClassType);</span>
<span class="changed"> 619     const size_t used_c = MetaspaceUtils::used_words(Metaspace::ClassType);</span>
<span class="changed"> 620     const size_t free_and_waste_c = cap_c - overhead_c - used_c;</span>
<span class="changed"> 621     out-&gt;print("      Class:  ");</span>
<span class="changed"> 622     print_scaled_words(out, cap_c, scale, 5);</span>
<span class="changed"> 623     out-&gt;print(" capacity, ");</span>
<span class="changed"> 624     print_scaled_words_and_percentage(out, used_c, cap_c, scale, 5);</span>
<span class="changed"> 625     out-&gt;print(" used, ");</span>
<span class="changed"> 626     print_scaled_words_and_percentage(out, free_and_waste_c, cap_c, scale, 5);</span>
<span class="changed"> 627     out-&gt;print(" free+waste, ");</span>
<span class="changed"> 628     print_scaled_words_and_percentage(out, overhead_c, cap_c, scale, 5);</span>
<span class="changed"> 629     out-&gt;print(" overhead. ");</span>
<span class="changed"> 630     out-&gt;cr();</span>
<span class="changed"> 631 </span>
<span class="changed"> 632     out-&gt;print("       Both:  ");</span>
<span class="changed"> 633     const size_t cap = cap_nc + cap_c;</span>
<span class="changed"> 634 </span>
<span class="changed"> 635     print_scaled_words(out, cap, scale, 5);</span>
<span class="changed"> 636     out-&gt;print(" capacity, ");</span>
<span class="changed"> 637     print_scaled_words_and_percentage(out, used_nc + used_c, cap, scale, 5);</span>
<span class="changed"> 638     out-&gt;print(" used, ");</span>
<span class="changed"> 639     print_scaled_words_and_percentage(out, free_and_waste_nc + free_and_waste_c, cap, scale, 5);</span>
<span class="changed"> 640     out-&gt;print(" free+waste, ");</span>
<span class="changed"> 641     print_scaled_words_and_percentage(out, overhead_nc + overhead_c, cap, scale, 5);</span>
<span class="changed"> 642     out-&gt;print(" overhead. ");</span>
<span class="changed"> 643     out-&gt;cr();</span>
<span class="changed"> 644   }</span>
<span class="changed"> 645 </span>
<span class="changed"> 646   out-&gt;cr();</span>
<span class="changed"> 647   out-&gt;print_cr("Virtual space:");</span>
<span class="changed"> 648 </span>
<span class="changed"> 649   print_vs(out, scale);</span>
<span class="changed"> 650 </span>
<span class="changed"> 651   out-&gt;cr();</span>
<span class="changed"> 652   out-&gt;print_cr("Chunk freelists:");</span>
<span class="changed"> 653 </span>
<span class="changed"> 654   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 655     out-&gt;print("   Non-Class:  ");</span>
<span class="changed"> 656   }</span>
<span class="changed"> 657   print_human_readable_size(out, Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed"> 658   out-&gt;cr();</span>
<span class="changed"> 659   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 660     out-&gt;print("       Class:  ");</span>
<span class="changed"> 661     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed"> 662     out-&gt;cr();</span>
<span class="changed"> 663     out-&gt;print("        Both:  ");</span>
<span class="changed"> 664     print_human_readable_size(out, Metaspace::chunk_manager_class()-&gt;free_chunks_total_bytes() +</span>
<span class="changed"> 665                               Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_bytes(), scale);</span>
<span class="changed"> 666     out-&gt;cr();</span>
<span class="changed"> 667   }</span>
<span class="changed"> 668 </span>
<span class="changed"> 669   out-&gt;cr();</span>
<span class="changed"> 670 </span>
<span class="changed"> 671   // Print basic settings</span>
<span class="changed"> 672   print_basic_switches(out, scale);</span>
<span class="changed"> 673 </span>
<span class="changed"> 674   out-&gt;cr();</span>
<span class="changed"> 675 </span>
<span class="changed"> 676 }</span>
<span class="changed"> 677 </span>
<span class="changed"> 678 void MetaspaceUtils::print_report(outputStream* out, size_t scale, int flags) {</span>
<span class="changed"> 679 </span>
<span class="changed"> 680   if (!Metaspace::initialized()) {</span>
<span class="changed"> 681     out-&gt;print_cr("Metaspace not yet initialized.");</span>
<span class="changed"> 682     return;</span>
<span class="changed"> 683   }</span>
<span class="changed"> 684 </span>
<span class="changed"> 685   const bool print_loaders = (flags &amp; rf_show_loaders) &gt; 0;</span>
<span class="changed"> 686   const bool print_classes = (flags &amp; rf_show_classes) &gt; 0;</span>
<span class="changed"> 687   const bool print_by_chunktype = (flags &amp; rf_break_down_by_chunktype) &gt; 0;</span>
<span class="changed"> 688   const bool print_by_spacetype = (flags &amp; rf_break_down_by_spacetype) &gt; 0;</span>
<span class="changed"> 689 </span>
<span class="changed"> 690   // Some report options require walking the class loader data graph.</span>
<span class="changed"> 691   PrintCLDMetaspaceInfoClosure cl(out, scale, print_loaders, print_classes, print_by_chunktype);</span>
<span class="changed"> 692   if (print_loaders) {</span>
<span class="changed"> 693     out-&gt;cr();</span>
<span class="changed"> 694     out-&gt;print_cr("Usage per loader:");</span>
<span class="changed"> 695     out-&gt;cr();</span>
<span class="changed"> 696   }</span>
<span class="changed"> 697 </span>
<span class="changed"> 698   ClassLoaderDataGraph::loaded_cld_do(&amp;cl); // collect data and optionally print</span>
<span class="changed"> 699 </span>
<span class="changed"> 700   // Print totals, broken up by space type.</span>
<span class="changed"> 701   if (print_by_spacetype) {</span>
<span class="changed"> 702     out-&gt;cr();</span>
<span class="changed"> 703     out-&gt;print_cr("Usage per space type:");</span>
<span class="changed"> 704     out-&gt;cr();</span>
<span class="changed"> 705     for (int space_type = (int)Metaspace::ZeroMetaspaceType;</span>
<span class="changed"> 706          space_type &lt; (int)Metaspace::MetaspaceTypeCount; space_type ++)</span>
<span class="changed"> 707     {</span>
<span class="changed"> 708       uintx num_loaders = cl._num_loaders_by_spacetype[space_type];</span>
<span class="changed"> 709       uintx num_classes = cl._num_classes_by_spacetype[space_type];</span>
<span class="changed"> 710       out-&gt;print("%s - " UINTX_FORMAT " %s",</span>
<span class="changed"> 711         space_type_name((Metaspace::MetaspaceType)space_type),</span>
<span class="changed"> 712         num_loaders, loaders_plural(num_loaders));</span>
<span class="changed"> 713       if (num_classes &gt; 0) {</span>
<span class="changed"> 714         out-&gt;print(", ");</span>
<span class="changed"> 715         print_number_of_classes(out, num_classes, cl._num_classes_shared_by_spacetype[space_type]);</span>
<span class="changed"> 716         out-&gt;print(":");</span>
<span class="changed"> 717         cl._stats_by_spacetype[space_type].print_on(out, scale, print_by_chunktype);</span>
<span class="changed"> 718       } else {</span>
<span class="changed"> 719         out-&gt;print(".");</span>
<span class="changed"> 720         out-&gt;cr();</span>
<span class="changed"> 721       }</span>
<span class="changed"> 722       out-&gt;cr();</span>
<span class="changed"> 723     }</span>
<span class="changed"> 724   }</span>
<span class="changed"> 725 </span>
<span class="changed"> 726   // Print totals for in-use data:</span>
<span class="changed"> 727   out-&gt;cr();</span>
<span class="changed"> 728   {</span>
<span class="changed"> 729     uintx num_loaders = cl._num_loaders;</span>
<span class="changed"> 730     out-&gt;print("Total Usage - " UINTX_FORMAT " %s, ",</span>
<span class="changed"> 731       num_loaders, loaders_plural(num_loaders));</span>
<span class="changed"> 732     print_number_of_classes(out, cl._num_classes, cl._num_classes_shared);</span>
<span class="changed"> 733     out-&gt;print(":");</span>
<span class="changed"> 734     cl._stats_total.print_on(out, scale, print_by_chunktype);</span>
<span class="changed"> 735     out-&gt;cr();</span>
<span class="changed"> 736   }</span>
<span class="changed"> 737 </span>
<span class="changed"> 738   // -- Print Virtual space.</span>
<span class="changed"> 739   out-&gt;cr();</span>
<span class="changed"> 740   out-&gt;print_cr("Virtual space:");</span>
<span class="changed"> 741 </span>
<span class="changed"> 742   print_vs(out, scale);</span>
<span class="changed"> 743 </span>
<span class="changed"> 744   // -- Print VirtualSpaceList details.</span>
<span class="changed"> 745   if ((flags &amp; rf_show_vslist) &gt; 0) {</span>
<span class="changed"> 746     out-&gt;cr();</span>
<span class="changed"> 747     out-&gt;print_cr("Virtual space list%s:", Metaspace::using_class_space() ? "s" : "");</span>
<span class="changed"> 748 </span>
<span class="changed"> 749     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 750       out-&gt;print_cr("   Non-Class:");</span>
<span class="changed"> 751     }</span>
<span class="changed"> 752     Metaspace::space_list()-&gt;print_on(out, scale);</span>
<span class="changed"> 753     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 754       out-&gt;print_cr("       Class:");</span>
<span class="changed"> 755       Metaspace::class_space_list()-&gt;print_on(out, scale);</span>
<span class="changed"> 756     }</span>
<span class="changed"> 757   }</span>
<span class="changed"> 758   out-&gt;cr();</span>
<span class="changed"> 759 </span>
<span class="changed"> 760   // -- Print VirtualSpaceList map.</span>
<span class="changed"> 761   if ((flags &amp; rf_show_vsmap) &gt; 0) {</span>
<span class="changed"> 762     out-&gt;cr();</span>
<span class="changed"> 763     out-&gt;print_cr("Virtual space map:");</span>
<span class="changed"> 764 </span>
<span class="changed"> 765     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 766       out-&gt;print_cr("   Non-Class:");</span>
<span class="changed"> 767     }</span>
<span class="changed"> 768     Metaspace::space_list()-&gt;print_map(out);</span>
<span class="changed"> 769     if (Metaspace::using_class_space()) {</span>
<span class="changed"> 770       out-&gt;print_cr("       Class:");</span>
<span class="changed"> 771       Metaspace::class_space_list()-&gt;print_map(out);</span>
<span class="changed"> 772     }</span>
<span class="changed"> 773   }</span>
<span class="changed"> 774   out-&gt;cr();</span>
<span class="changed"> 775 </span>
<span class="changed"> 776   // -- Print Freelists (ChunkManager) details</span>
<span class="changed"> 777   out-&gt;cr();</span>
<span class="changed"> 778   out-&gt;print_cr("Chunk freelist%s:", Metaspace::using_class_space() ? "s" : "");</span>
<span class="changed"> 779 </span>
<span class="changed"> 780   ChunkManagerStatistics non_class_cm_stat;</span>
<span class="changed"> 781   Metaspace::chunk_manager_metadata()-&gt;collect_statistics(&amp;non_class_cm_stat);</span>
<span class="changed"> 782 </span>
<span class="changed"> 783   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 784     out-&gt;print_cr("   Non-Class:");</span>
<span class="changed"> 785   }</span>
<span class="changed"> 786   non_class_cm_stat.print_on(out, scale);</span>
<span class="changed"> 787 </span>
<span class="changed"> 788   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 789     ChunkManagerStatistics class_cm_stat;</span>
<span class="changed"> 790     Metaspace::chunk_manager_class()-&gt;collect_statistics(&amp;class_cm_stat);</span>
<span class="changed"> 791     out-&gt;print_cr("       Class:");</span>
<span class="changed"> 792     class_cm_stat.print_on(out, scale);</span>
<span class="changed"> 793   }</span>
<span class="changed"> 794 </span>
<span class="changed"> 795   // As a convenience, print a summary of common waste.</span>
<span class="changed"> 796   out-&gt;cr();</span>
<span class="changed"> 797   out-&gt;print("Waste ");</span>
<span class="changed"> 798   // For all wastages, print percentages from total. As total use the total size of memory committed for metaspace.</span>
<span class="changed"> 799   const size_t committed_words = committed_bytes() / BytesPerWord;</span>
<span class="changed"> 800 </span>
<span class="changed"> 801   out-&gt;print("(percentages refer to total committed size ");</span>
<span class="changed"> 802   print_scaled_words(out, committed_words, scale);</span>
<span class="changed"> 803   out-&gt;print_cr("):");</span>
<span class="changed"> 804 </span>
<span class="changed"> 805   // Print space committed but not yet used by any class loader</span>
<span class="changed"> 806   const size_t unused_words_in_vs = MetaspaceUtils::free_in_vs_bytes() / BytesPerWord;</span>
<span class="changed"> 807   out-&gt;print("              Committed unused: ");</span>
<span class="changed"> 808   print_scaled_words_and_percentage(out, unused_words_in_vs, committed_words, scale, 6);</span>
<span class="changed"> 809   out-&gt;cr();</span>
<span class="changed"> 810 </span>
<span class="changed"> 811   // Print waste for in-use chunks.</span>
<span class="changed"> 812   UsedChunksStatistics ucs_nonclass = cl._stats_total.nonclass_sm_stats().totals();</span>
<span class="changed"> 813   UsedChunksStatistics ucs_class = cl._stats_total.class_sm_stats().totals();</span>
<span class="changed"> 814   UsedChunksStatistics ucs_all;</span>
<span class="changed"> 815   ucs_all.add(ucs_nonclass);</span>
<span class="changed"> 816   ucs_all.add(ucs_class);</span>
<span class="changed"> 817 </span>
<span class="changed"> 818   out-&gt;print("        Waste in chunks in use: ");</span>
<span class="changed"> 819   print_scaled_words_and_percentage(out, ucs_all.waste(), committed_words, scale, 6);</span>
<span class="changed"> 820   out-&gt;cr();</span>
<span class="changed"> 821   out-&gt;print("         Free in chunks in use: ");</span>
<span class="changed"> 822   print_scaled_words_and_percentage(out, ucs_all.free(), committed_words, scale, 6);</span>
<span class="changed"> 823   out-&gt;cr();</span>
<span class="changed"> 824   out-&gt;print("     Overhead in chunks in use: ");</span>
<span class="changed"> 825   print_scaled_words_and_percentage(out, ucs_all.overhead(), committed_words, scale, 6);</span>
<span class="changed"> 826   out-&gt;cr();</span>
<span class="changed"> 827 </span>
<span class="changed"> 828   // Print waste in free chunks.</span>
<span class="changed"> 829   const size_t total_capacity_in_free_chunks =</span>
<span class="changed"> 830       Metaspace::chunk_manager_metadata()-&gt;free_chunks_total_words() +</span>
<span class="changed"> 831      (Metaspace::using_class_space() ? Metaspace::chunk_manager_class()-&gt;free_chunks_total_words() : 0);</span>
<span class="changed"> 832   out-&gt;print("                In free chunks: ");</span>
<span class="changed"> 833   print_scaled_words_and_percentage(out, total_capacity_in_free_chunks, committed_words, scale, 6);</span>
<span class="changed"> 834   out-&gt;cr();</span>
<span class="changed"> 835 </span>
<span class="changed"> 836   // Print waste in deallocated blocks.</span>
<span class="changed"> 837   const uintx free_blocks_num =</span>
<span class="changed"> 838       cl._stats_total.nonclass_sm_stats().free_blocks_num() +</span>
<span class="changed"> 839       cl._stats_total.class_sm_stats().free_blocks_num();</span>
<span class="changed"> 840   const size_t free_blocks_cap_words =</span>
<span class="changed"> 841       cl._stats_total.nonclass_sm_stats().free_blocks_cap_words() +</span>
<span class="changed"> 842       cl._stats_total.class_sm_stats().free_blocks_cap_words();</span>
<span class="changed"> 843   out-&gt;print("Deallocated from chunks in use: ");</span>
<span class="changed"> 844   print_scaled_words_and_percentage(out, free_blocks_cap_words, committed_words, scale, 6);</span>
<span class="changed"> 845   out-&gt;print(" (" UINTX_FORMAT " blocks)", free_blocks_num);</span>
<span class="changed"> 846   out-&gt;cr();</span>
<span class="changed"> 847 </span>
<span class="changed"> 848   // Print total waste.</span>
<span class="changed"> 849   const size_t total_waste = ucs_all.waste() + ucs_all.free() + ucs_all.overhead() + total_capacity_in_free_chunks</span>
<span class="changed"> 850       + free_blocks_cap_words + unused_words_in_vs;</span>
<span class="changed"> 851   out-&gt;print("                       -total-: ");</span>
<span class="changed"> 852   print_scaled_words_and_percentage(out, total_waste, committed_words, scale, 6);</span>
<span class="changed"> 853   out-&gt;cr();</span>
<span class="changed"> 854 </span>
<span class="changed"> 855   // Print internal statistics</span>
<span class="changed"> 856 #ifdef ASSERT</span>
<span class="changed"> 857   out-&gt;cr();</span>
<span class="changed"> 858   out-&gt;cr();</span>
<span class="changed"> 859   out-&gt;print_cr("Internal statistics:");</span>
<span class="changed"> 860   out-&gt;cr();</span>
<span class="changed"> 861   out-&gt;print_cr("Number of allocations: " UINTX_FORMAT ".", g_internal_statistics.num_allocs);</span>
<span class="changed"> 862   out-&gt;print_cr("Number of space births: " UINTX_FORMAT ".", g_internal_statistics.num_metaspace_births);</span>
<span class="changed"> 863   out-&gt;print_cr("Number of space deaths: " UINTX_FORMAT ".", g_internal_statistics.num_metaspace_deaths);</span>
<span class="changed"> 864   out-&gt;print_cr("Number of virtual space node births: " UINTX_FORMAT ".", g_internal_statistics.num_vsnodes_created);</span>
<span class="changed"> 865   out-&gt;print_cr("Number of virtual space node deaths: " UINTX_FORMAT ".", g_internal_statistics.num_vsnodes_purged);</span>
<span class="changed"> 866   out-&gt;print_cr("Number of times virtual space nodes were expanded: " UINTX_FORMAT ".", g_internal_statistics.num_committed_space_expanded);</span>
<span class="changed"> 867   out-&gt;print_cr("Number of deallocations: " UINTX_FORMAT " (" UINTX_FORMAT " external).", g_internal_statistics.num_deallocs, g_internal_statistics.num_external_deallocs);</span>
<span class="changed"> 868   out-&gt;print_cr("Allocations from deallocated blocks: " UINTX_FORMAT ".", g_internal_statistics.num_allocs_from_deallocated_blocks);</span>
<span class="changed"> 869   out-&gt;print_cr("Number of chunks added to freelist: " UINTX_FORMAT ".",</span>
<span class="changed"> 870                 g_internal_statistics.num_chunks_added_to_freelist);</span>
<span class="changed"> 871   out-&gt;print_cr("Number of chunks removed from freelist: " UINTX_FORMAT ".",</span>
<span class="changed"> 872                 g_internal_statistics.num_chunks_removed_from_freelist);</span>
<span class="changed"> 873   out-&gt;print_cr("Number of chunk merges: " UINTX_FORMAT ", split-ups: " UINTX_FORMAT ".",</span>
<span class="changed"> 874                 g_internal_statistics.num_chunk_merges, g_internal_statistics.num_chunk_splits);</span>
<span class="changed"> 875 </span>
<span class="changed"> 876   out-&gt;cr();</span>
<span class="changed"> 877 #endif</span>
<span class="changed"> 878 </span>
<span class="changed"> 879   // Print some interesting settings</span>
<span class="changed"> 880   out-&gt;cr();</span>
<span class="changed"> 881   out-&gt;cr();</span>
<span class="changed"> 882   print_basic_switches(out, scale);</span>
<span class="changed"> 883 </span>
<span class="changed"> 884   out-&gt;cr();</span>
<span class="changed"> 885   out-&gt;print("InitialBootClassLoaderMetaspaceSize: ");</span>
<span class="changed"> 886   print_human_readable_size(out, InitialBootClassLoaderMetaspaceSize, scale);</span>
<span class="changed"> 887 </span>
<span class="changed"> 888   out-&gt;cr();</span>
<span class="changed"> 889   out-&gt;cr();</span>
<span class="changed"> 890 </span>
<span class="changed"> 891 } // MetaspaceUtils::print_report()</span>
<span class="changed"> 892 </span>
<span class="changed"> 893 // Prints an ASCII representation of the given space.</span>
<span class="changed"> 894 void MetaspaceUtils::print_metaspace_map(outputStream* out, Metaspace::MetadataType mdtype) {</span>
<span class="changed"> 895   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 896   const bool for_class = mdtype == Metaspace::ClassType ? true : false;</span>
<span class="changed"> 897   VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();</span>
<span class="changed"> 898   if (vsl != NULL) {</span>
<span class="changed"> 899     if (for_class) {</span>
<span class="changed"> 900       if (!Metaspace::using_class_space()) {</span>
<span class="changed"> 901         out-&gt;print_cr("No Class Space.");</span>
<span class="changed"> 902         return;</span>
<span class="changed"> 903       }</span>
<span class="changed"> 904       out-&gt;print_raw("---- Metaspace Map (Class Space) ----");</span>
<span class="changed"> 905     } else {</span>
<span class="changed"> 906       out-&gt;print_raw("---- Metaspace Map (Non-Class Space) ----");</span>
<span class="changed"> 907     }</span>
<span class="changed"> 908     // Print legend:</span>
<span class="changed"> 909     out-&gt;cr();</span>
<span class="changed"> 910     out-&gt;print_cr("Chunk Types (uppercase chunks are in use): x-specialized, s-small, m-medium, h-humongous.");</span>
<span class="changed"> 911     out-&gt;cr();</span>
<span class="changed"> 912     VirtualSpaceList* const vsl = for_class ? Metaspace::class_space_list() : Metaspace::space_list();</span>
<span class="changed"> 913     vsl-&gt;print_map(out);</span>
<span class="changed"> 914     out-&gt;cr();</span>
<span class="changed"> 915   }</span>
<span class="changed"> 916 }</span>
 917 
<span class="changed"> 918 void MetaspaceUtils::verify_free_chunks() {</span>
<span class="changed"> 919 #ifdef ASSERT</span>
<span class="changed"> 920   Metaspace::chunk_manager_metadata()-&gt;verify(false);</span>
<span class="changed"> 921   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 922     Metaspace::chunk_manager_class()-&gt;verify(false);</span>
<span class="changed"> 923   }</span>
<span class="changed"> 924 #endif</span>
<span class="changed"> 925 }</span>
 926 
<span class="changed"> 927 void MetaspaceUtils::verify_metrics() {</span>
<span class="changed"> 928 #ifdef ASSERT</span>
<span class="changed"> 929   // Please note: there are time windows where the internal counters are out of sync with</span>
<span class="changed"> 930   // reality. For example, when a newly created ClassLoaderMetaspace creates its first chunk -</span>
<span class="changed"> 931   // the ClassLoaderMetaspace is not yet attached to its ClassLoaderData object and hence will</span>
<span class="changed"> 932   // not be counted when iterating the CLDG. So be careful when you call this method.</span>
<span class="changed"> 933   ClassLoaderMetaspaceStatistics total_stat;</span>
<span class="changed"> 934   collect_statistics(&amp;total_stat);</span>
<span class="changed"> 935   UsedChunksStatistics nonclass_chunk_stat = total_stat.nonclass_sm_stats().totals();</span>
<span class="changed"> 936   UsedChunksStatistics class_chunk_stat = total_stat.class_sm_stats().totals();</span>
<span class="changed"> 937 </span>
<span class="changed"> 938   bool mismatch = false;</span>
<span class="changed"> 939   for (int i = 0; i &lt; Metaspace::MetadataTypeCount; i ++) {</span>
<span class="changed"> 940     Metaspace::MetadataType mdtype = (Metaspace::MetadataType)i;</span>
<span class="changed"> 941     UsedChunksStatistics chunk_stat = total_stat.sm_stats(mdtype).totals();</span>
<span class="changed"> 942     if (capacity_words(mdtype) != chunk_stat.cap() ||</span>
<span class="changed"> 943         used_words(mdtype) != chunk_stat.used() ||</span>
<span class="changed"> 944         overhead_words(mdtype) != chunk_stat.overhead()) {</span>
<span class="changed"> 945       mismatch = true;</span>
<span class="changed"> 946       tty-&gt;print_cr("MetaspaceUtils::verify_metrics: counter mismatch for mdtype=%u:", mdtype);</span>
<span class="changed"> 947       tty-&gt;print_cr("Expected cap " SIZE_FORMAT ", used " SIZE_FORMAT ", overhead " SIZE_FORMAT ".",</span>
<span class="changed"> 948                     capacity_words(mdtype), used_words(mdtype), overhead_words(mdtype));</span>
<span class="changed"> 949       tty-&gt;print_cr("Got cap " SIZE_FORMAT ", used " SIZE_FORMAT ", overhead " SIZE_FORMAT ".",</span>
<span class="changed"> 950                     chunk_stat.cap(), chunk_stat.used(), chunk_stat.overhead());</span>
<span class="changed"> 951       tty-&gt;flush();</span>
<span class="changed"> 952     }</span>
<span class="changed"> 953   }</span>
<span class="changed"> 954   assert(mismatch == false, "MetaspaceUtils::verify_metrics: counter mismatch.");</span>
<span class="changed"> 955 #endif</span>
 956 }
 957 
<span class="removed"> 958 // Metaspace methods</span>
<span class="removed"> 959 </span>
<span class="removed"> 960 size_t Metaspace::_first_chunk_word_size = 0;</span>
<span class="removed"> 961 size_t Metaspace::_first_class_chunk_word_size = 0;</span>
<span class="removed"> 962 </span>
<span class="removed"> 963 size_t Metaspace::_commit_alignment = 0;</span>
<span class="removed"> 964 size_t Metaspace::_reserve_alignment = 0;</span>
<span class="removed"> 965 </span>
<span class="removed"> 966 VirtualSpaceList* Metaspace::_space_list = NULL;</span>
<span class="removed"> 967 VirtualSpaceList* Metaspace::_class_space_list = NULL;</span>
<span class="removed"> 968 </span>
<span class="removed"> 969 ChunkManager* Metaspace::_chunk_manager_metadata = NULL;</span>
<span class="removed"> 970 ChunkManager* Metaspace::_chunk_manager_class = NULL;</span>
<span class="removed"> 971 </span>
<span class="removed"> 972 bool Metaspace::_initialized = false;</span>
<span class="removed"> 973 </span>
<span class="removed"> 974 #define VIRTUALSPACEMULTIPLIER 2</span>
<span class="removed"> 975 </span>
 976 #ifdef _LP64
 977 
 978 void Metaspace::print_compressed_class_space(outputStream* st) {
<span class="changed"> 979   if (_class_space_list != NULL) {</span>
<span class="changed"> 980     address base = (address)_class_space_list-&gt;current_virtual_space()-&gt;bottom();</span>
<span class="changed"> 981     address top = base + compressed_class_space_size();</span>
<span class="changed"> 982     st-&gt;print("Compressed class space mapped at: " PTR_FORMAT "-" PTR_FORMAT ", size: " SIZE_FORMAT,</span>
<span class="changed"> 983                p2i(base), p2i(top), top - base);</span>

 984     st-&gt;cr();
 985   }
 986 }
 987 
 988 // Given a prereserved space, use that to set up the compressed class space list.
 989 void Metaspace::initialize_class_space(ReservedSpace rs) {


 990   assert(using_class_space(), "Must be using class space");
<span class="removed"> 991   assert(_class_space_list == NULL &amp;&amp; _chunk_manager_class == NULL, "Only call once");</span>
 992 
 993   assert(rs.size() == CompressedClassSpaceSize, SIZE_FORMAT " != " SIZE_FORMAT,
 994          rs.size(), CompressedClassSpaceSize);
 995   assert(is_aligned(rs.base(), Metaspace::reserve_alignment()) &amp;&amp;
 996          is_aligned(rs.size(), Metaspace::reserve_alignment()),
 997          "wrong alignment");
 998 
<span class="changed"> 999   _class_space_list = new VirtualSpaceList(rs);</span>
<span class="changed">1000   _chunk_manager_class = new ChunkManager(true/*is_class*/);</span>
1001 
1002   // This does currently not work because rs may be the result of a split
1003   // operation and NMT seems not to be able to handle splits.
1004   // Will be fixed with JDK-8243535.
1005   // MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);
1006 
<span class="changed">1007   if (!_class_space_list-&gt;initialization_succeeded()) {</span>
<span class="changed">1008     vm_exit_during_initialization("Failed to setup compressed class space virtual space list.");</span>
<span class="changed">1009   }</span>
1010 



1011 }
1012 
1013 // Reserve a range of memory at an address suitable for en/decoding narrow
1014 // Klass pointers (see: CompressedClassPointers::is_valid_base()).
1015 // The returned address shall both be suitable as a compressed class pointers
1016 //  base, and aligned to Metaspace::reserve_alignment (which is equal to or a
1017 //  multiple of allocation granularity).
1018 // On error, returns an unreserved space.
1019 ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size) {
1020 
1021 #ifdef AARCH64
1022   const size_t alignment = Metaspace::reserve_alignment();
1023 
1024   // AArch64: Try to align metaspace so that we can decode a compressed
1025   // klass with a single MOVK instruction. We can do this iff the
1026   // compressed class base is a multiple of 4G.
1027   // Additionally, above 32G, ensure the lower LogKlassAlignmentInBytes bits
1028   // of the upper 32-bits of the address are zero so we can handle a shift
1029   // when decoding.
1030 

</pre><hr></hr><pre>
1047       if (rs.is_reserved()) {
1048         assert(a == (address)rs.base(), "Sanity");
1049         return rs;
1050       }
1051       a +=  search_ranges[i].increment;
1052     }
1053   }
1054 
1055   // Note: on AARCH64, if the code above does not find any good placement, we
1056   // have no recourse. We return an empty space and the VM will exit.
1057   return ReservedSpace();
1058 #else
1059   // Default implementation: Just reserve anywhere.
1060   return ReservedSpace(size, Metaspace::reserve_alignment(), false, (char*)NULL);
1061 #endif // AARCH64
1062 }
1063 
1064 #endif // _LP64
1065 
1066 
<span class="changed">1067 void Metaspace::ergo_initialize() {</span>
<span class="changed">1068   if (DumpSharedSpaces) {</span>
<span class="changed">1069     // Using large pages when dumping the shared archive is currently not implemented.</span>
<span class="changed">1070     FLAG_SET_ERGO(UseLargePagesInMetaspace, false);</span>
<span class="changed">1071   }</span>
1072 
<span class="changed">1073   size_t page_size = os::vm_page_size();</span>
<span class="changed">1074   if (UseLargePages &amp;&amp; UseLargePagesInMetaspace) {</span>
<span class="changed">1075     page_size = os::large_page_size();</span>
<span class="changed">1076   }</span>
1077 
<span class="changed">1078   _commit_alignment  = page_size;</span>
<span class="changed">1079   _reserve_alignment = MAX2(page_size, (size_t)os::vm_allocation_granularity());</span>
1080 
<span class="changed">1081   // The upcoming Metaspace rewrite will impose a higher alignment granularity.</span>
<span class="changed">1082   // To prepare for that and to catch/prevent any misuse of Metaspace alignment</span>
<span class="changed">1083   // which may creep in, up the alignment a bit.</span>
<span class="changed">1084   if (_reserve_alignment == 4 * K) {</span>
<span class="changed">1085     _reserve_alignment *= 4;</span>
<span class="changed">1086   }</span>
1087 
<span class="changed">1088   // Do not use FLAG_SET_ERGO to update MaxMetaspaceSize, since this will</span>
<span class="changed">1089   // override if MaxMetaspaceSize was set on the command line or not.</span>
<span class="changed">1090   // This information is needed later to conform to the specification of the</span>
<span class="changed">1091   // java.lang.management.MemoryUsage API.</span>

















1092   //
<span class="changed">1093   // Ideally, we would be able to set the default value of MaxMetaspaceSize in</span>
<span class="changed">1094   // globals.hpp to the aligned value, but this is not possible, since the</span>
<span class="changed">1095   // alignment depends on other flags being parsed.</span>
<span class="changed">1096   MaxMetaspaceSize = align_down_bounded(MaxMetaspaceSize, _reserve_alignment);</span>
1097 





























1098   if (MetaspaceSize &gt; MaxMetaspaceSize) {
1099     MetaspaceSize = MaxMetaspaceSize;
1100   }
1101 
<span class="changed">1102   MetaspaceSize = align_down_bounded(MetaspaceSize, _commit_alignment);</span>
1103 
1104   assert(MetaspaceSize &lt;= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");
1105 
<span class="changed">1106   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, _commit_alignment);</span>
<span class="changed">1107   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, _commit_alignment);</span>
<span class="changed">1108 </span>
<span class="changed">1109   CompressedClassSpaceSize = align_down_bounded(CompressedClassSpaceSize, _reserve_alignment);</span>
1110 
<span class="removed">1111   // Initial virtual space size will be calculated at global_initialize()</span>
<span class="removed">1112   size_t min_metaspace_sz =</span>
<span class="removed">1113       VIRTUALSPACEMULTIPLIER * InitialBootClassLoaderMetaspaceSize;</span>
<span class="removed">1114   if (UseCompressedClassPointers) {</span>
<span class="removed">1115     if ((min_metaspace_sz + CompressedClassSpaceSize) &gt;  MaxMetaspaceSize) {</span>
<span class="removed">1116       if (min_metaspace_sz &gt;= MaxMetaspaceSize) {</span>
<span class="removed">1117         vm_exit_during_initialization("MaxMetaspaceSize is too small.");</span>
<span class="removed">1118       } else {</span>
<span class="removed">1119         FLAG_SET_ERGO(CompressedClassSpaceSize,</span>
<span class="removed">1120                       MaxMetaspaceSize - min_metaspace_sz);</span>
<span class="removed">1121       }</span>
<span class="removed">1122     }</span>
<span class="removed">1123   } else if (min_metaspace_sz &gt;= MaxMetaspaceSize) {</span>
<span class="removed">1124     FLAG_SET_ERGO(InitialBootClassLoaderMetaspaceSize,</span>
<span class="removed">1125                   min_metaspace_sz);</span>
<span class="removed">1126   }</span>
<span class="removed">1127 </span>
<span class="removed">1128   set_compressed_class_space_size(CompressedClassSpaceSize);</span>
1129 }
1130 
1131 void Metaspace::global_initialize() {
<span class="changed">1132   MetaspaceGC::initialize();</span>


1133 
1134   // If UseCompressedClassPointers=1, we have two cases:
1135   // a) if CDS is active (either dump time or runtime), it will create the ccs
1136   //    for us, initialize it and set up CompressedKlassPointers encoding.
1137   //    Class space will be reserved above the mapped archives.
1138   // b) if CDS is not active, we will create the ccs on our own. It will be
1139   //    placed above the java heap, since we assume it has been placed in low
1140   //    address regions. We may rethink this (see JDK-8244943). Failing that,
1141   //    it will be placed anywhere.
1142 
1143 #if INCLUDE_CDS
1144   // case (a)
1145   if (DumpSharedSpaces) {
1146     MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();
1147   } else if (UseSharedSpaces) {
1148     // If any of the archived space fails to map, UseSharedSpaces
1149     // is reset to false.
1150     MetaspaceShared::initialize_runtime_shared_and_meta_spaces();
1151   }
1152 

</pre><hr></hr><pre>
1172     address base = UseCompressedOops ? CompressedOops::end() : (address)HeapBaseMinAddress;
1173     base = align_up(base, Metaspace::reserve_alignment());
1174 
1175     const size_t size = align_up(CompressedClassSpaceSize, Metaspace::reserve_alignment());
1176     if (base != NULL) {
1177       if (CompressedKlassPointers::is_valid_base(base)) {
1178         rs = ReservedSpace(size, Metaspace::reserve_alignment(),
1179                            false /* large */, (char*)base);
1180       }
1181     }
1182 
1183     // ...failing that, reserve anywhere, but let platform do optimized placement:
1184     if (!rs.is_reserved()) {
1185       rs = Metaspace::reserve_address_space_for_compressed_classes(size);
1186     }
1187 
1188     // ...failing that, give up.
1189     if (!rs.is_reserved()) {
1190       vm_exit_during_initialization(
1191           err_msg("Could not allocate compressed class space: " SIZE_FORMAT " bytes",
<span class="changed">1192                    compressed_class_space_size()));</span>
1193     }
1194 
1195     // Initialize space
1196     Metaspace::initialize_class_space(rs);
1197 
1198     // Set up compressed class pointer encoding.
1199     CompressedKlassPointers::initialize((address)rs.base(), rs.size());
1200   }
1201 
1202 #endif
1203 
<span class="changed">1204   // Initialize these before initializing the VirtualSpaceList</span>
<span class="changed">1205   _first_chunk_word_size = InitialBootClassLoaderMetaspaceSize / BytesPerWord;</span>
<span class="changed">1206   _first_chunk_word_size = align_word_size_up(_first_chunk_word_size);</span>
<span class="changed">1207   // Make the first class chunk bigger than a medium chunk so it's not put</span>
<span class="changed">1208   // on the medium chunk list.   The next chunk will be small and progress</span>
<span class="changed">1209   // from there.  This size calculated by -version.</span>
<span class="changed">1210   _first_class_chunk_word_size = MIN2((size_t)MediumChunk*6,</span>
<span class="changed">1211                                      (CompressedClassSpaceSize/BytesPerWord)*2);</span>
<span class="changed">1212   _first_class_chunk_word_size = align_word_size_up(_first_class_chunk_word_size);</span>
<span class="changed">1213   // Arbitrarily set the initial virtual space to a multiple</span>
<span class="changed">1214   // of the boot class loader size.</span>
<span class="changed">1215   size_t word_size = VIRTUALSPACEMULTIPLIER * _first_chunk_word_size;</span>
<span class="changed">1216   word_size = align_up(word_size, Metaspace::reserve_alignment_words());</span>
<span class="changed">1217 </span>
<span class="changed">1218   // Initialize the list of virtual spaces.</span>
<span class="changed">1219   _space_list = new VirtualSpaceList(word_size);</span>
<span class="changed">1220   _chunk_manager_metadata = new ChunkManager(false/*metaspace*/);</span>
<span class="changed">1221 </span>
<span class="changed">1222   if (!_space_list-&gt;initialization_succeeded()) {</span>
<span class="changed">1223     vm_exit_during_initialization("Unable to setup metadata virtual space list.", NULL);</span>
<span class="changed">1224   }</span>
1225 
1226   _tracer = new MetaspaceTracer();
1227 
<span class="changed">1228   _initialized = true;</span>












1229 
1230 #ifdef _LP64
1231   if (UseCompressedClassPointers) {
1232     // Note: "cds" would be a better fit but keep this for backward compatibility.
1233     LogTarget(Info, gc, metaspace) lt;
1234     if (lt.is_enabled()) {
1235       ResourceMark rm;
1236       LogStream ls(lt);
1237       CDS_ONLY(MetaspaceShared::print_on(&amp;ls);)
1238       Metaspace::print_compressed_class_space(&amp;ls);
1239       CompressedKlassPointers::print_mode(&amp;ls);
1240     }
1241   }
1242 #endif
1243 
1244 }
1245 
1246 void Metaspace::post_initialize() {
1247   MetaspaceGC::post_initialize();
1248 }
1249 
<span class="changed">1250 void Metaspace::verify_global_initialization() {</span>
<span class="changed">1251   assert(space_list() != NULL, "Metadata VirtualSpaceList has not been initialized");</span>
<span class="changed">1252   assert(chunk_manager_metadata() != NULL, "Metadata ChunkManager has not been initialized");</span>
<span class="changed">1253 </span>
<span class="changed">1254   if (using_class_space()) {</span>
<span class="changed">1255     assert(class_space_list() != NULL, "Class VirtualSpaceList has not been initialized");</span>
<span class="changed">1256     assert(chunk_manager_class() != NULL, "Class ChunkManager has not been initialized");</span>
<span class="changed">1257   }</span>
<span class="changed">1258 }</span>
<span class="changed">1259 </span>
<span class="changed">1260 size_t Metaspace::align_word_size_up(size_t word_size) {</span>
<span class="changed">1261   size_t byte_size = word_size * wordSize;</span>
<span class="changed">1262   return ReservedSpace::allocation_align_size_up(byte_size) / wordSize;</span>
1263 }
1264 
1265 MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,
1266                               MetaspaceObj::Type type, TRAPS) {


1267   assert(!_frozen, "sanity");
1268   assert(!(DumpSharedSpaces &amp;&amp; THREAD-&gt;is_VM_thread()), "sanity");
1269 
1270   if (HAS_PENDING_EXCEPTION) {
1271     assert(false, "Should not allocate with exception pending");
1272     return NULL;  // caller does a CHECK_NULL too
1273   }
1274 
1275   assert(loader_data != NULL, "Should never pass around a NULL loader_data. "
1276         "ClassLoaderData::the_null_class_loader_data() should have been used.");
1277 
1278   MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;
1279 
1280   // Try to allocate metadata.
1281   MetaWord* result = loader_data-&gt;metaspace_non_null()-&gt;allocate(word_size, mdtype);
1282 
1283   if (result == NULL) {
1284     tracer()-&gt;report_metaspace_allocation_failure(loader_data, word_size, type, mdtype);
1285 
1286     // Allocation failed.

</pre><hr></hr><pre>
1291       result = Universe::heap()-&gt;satisfy_failed_metadata_allocation(loader_data, word_size, mdtype);
1292     }
1293   }
1294 
1295   if (result == NULL) {
1296     if (DumpSharedSpaces) {
1297       // CDS dumping keeps loading classes, so if we hit an OOM we probably will keep hitting OOM.
1298       // We should abort to avoid generating a potentially bad archive.
1299       vm_exit_during_cds_dumping(err_msg("Failed allocating metaspace object type %s of size " SIZE_FORMAT ". CDS dump aborted.",
1300           MetaspaceObj::type_name(type), word_size * BytesPerWord),
1301         err_msg("Please increase MaxMetaspaceSize (currently " SIZE_FORMAT " bytes).", MaxMetaspaceSize));
1302     }
1303     report_metadata_oome(loader_data, word_size, type, mdtype, THREAD);
1304     assert(HAS_PENDING_EXCEPTION, "sanity");
1305     return NULL;
1306   }
1307 
1308   // Zero initialize.
1309   Copy::fill_to_words((HeapWord*)result, word_size, 0);
1310 


1311   return result;
1312 }
1313 
1314 void Metaspace::report_metadata_oome(ClassLoaderData* loader_data, size_t word_size, MetaspaceObj::Type type, MetadataType mdtype, TRAPS) {
1315   tracer()-&gt;report_metadata_oom(loader_data, word_size, type, mdtype);
1316 
1317   // If result is still null, we are out of memory.
1318   Log(gc, metaspace, freelist, oom) log;
1319   if (log.is_info()) {
1320     log.info("Metaspace (%s) allocation failed for size " SIZE_FORMAT,
1321              is_class_space_allocation(mdtype) ? "class" : "data", word_size);
1322     ResourceMark rm;
1323     if (log.is_debug()) {
1324       if (loader_data-&gt;metaspace_or_null() != NULL) {
1325         LogStream ls(log.debug());
1326         loader_data-&gt;print_value_on(&amp;ls);
1327       }
1328     }
1329     LogStream ls(log.info());
1330     // In case of an OOM, log out a short but still useful report.
1331     MetaspaceUtils::print_basic_report(&amp;ls, 0);
1332   }
1333 

1334   bool out_of_compressed_class_space = false;
1335   if (is_class_space_allocation(mdtype)) {
1336     ClassLoaderMetaspace* metaspace = loader_data-&gt;metaspace_non_null();
1337     out_of_compressed_class_space =
1338       MetaspaceUtils::committed_bytes(Metaspace::ClassType) +
<span class="changed">1339       (metaspace-&gt;class_chunk_size(word_size) * BytesPerWord) &gt;</span>
1340       CompressedClassSpaceSize;
1341   }
1342 
1343   // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support
1344   const char* space_string = out_of_compressed_class_space ?
1345     "Compressed class space" : "Metaspace";
1346 
1347   report_java_out_of_memory(space_string);
1348 
1349   if (JvmtiExport::should_post_resource_exhausted()) {
1350     JvmtiExport::post_resource_exhausted(
1351         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
1352         space_string);
1353   }
1354 
1355   if (!is_init_completed()) {
1356     vm_exit_during_initialization("OutOfMemoryError", space_string);
1357   }
1358 
1359   if (out_of_compressed_class_space) {
1360     THROW_OOP(Universe::out_of_memory_error_class_metaspace());
1361   } else {
1362     THROW_OOP(Universe::out_of_memory_error_metaspace());
1363   }
1364 }
1365 
1366 const char* Metaspace::metadata_type_name(Metaspace::MetadataType mdtype) {
1367   switch (mdtype) {
1368     case Metaspace::ClassType: return "Class";
1369     case Metaspace::NonClassType: return "Metadata";
1370     default:
1371       assert(false, "Got bad mdtype: %d", (int) mdtype);
1372       return NULL;
1373   }
1374 }
1375 
<span class="removed">1376 void Metaspace::purge(MetadataType mdtype) {</span>
<span class="removed">1377   get_space_list(mdtype)-&gt;purge(get_chunk_manager(mdtype));</span>
<span class="removed">1378 }</span>
<span class="removed">1379 </span>
1380 void Metaspace::purge() {
<span class="changed">1381   MutexLocker cl(MetaspaceExpand_lock,</span>
<span class="changed">1382                  Mutex::_no_safepoint_check_flag);</span>
<span class="changed">1383   purge(NonClassType);</span>

1384   if (using_class_space()) {
<span class="changed">1385     purge(ClassType);</span>



1386   }
1387 }
1388 
1389 bool Metaspace::contains(const void* ptr) {
1390   if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
1391     return true;
1392   }
1393   return contains_non_shared(ptr);
1394 }
1395 
1396 bool Metaspace::contains_non_shared(const void* ptr) {
<span class="changed">1397   if (using_class_space() &amp;&amp; get_space_list(ClassType)-&gt;contains(ptr)) {</span>
1398      return true;
1399   }
1400 
<span class="changed">1401   return get_space_list(NonClassType)-&gt;contains(ptr);</span>
<span class="changed">1402 }</span>
<span class="changed">1403 </span>
<span class="changed">1404 // ClassLoaderMetaspace</span>
<span class="changed">1405 </span>
<span class="changed">1406 ClassLoaderMetaspace::ClassLoaderMetaspace(Mutex* lock, Metaspace::MetaspaceType type)</span>
<span class="changed">1407   : _space_type(type)</span>
<span class="changed">1408   , _lock(lock)</span>
<span class="changed">1409   , _vsm(NULL)</span>
<span class="changed">1410   , _class_vsm(NULL)</span>
<span class="changed">1411 {</span>
<span class="changed">1412   initialize(lock, type);</span>
<span class="changed">1413 }</span>
<span class="changed">1414 </span>
<span class="changed">1415 ClassLoaderMetaspace::~ClassLoaderMetaspace() {</span>
<span class="changed">1416   Metaspace::assert_not_frozen();</span>
<span class="changed">1417   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_deaths));</span>
<span class="changed">1418   delete _vsm;</span>
<span class="changed">1419   if (Metaspace::using_class_space()) {</span>
<span class="changed">1420     delete _class_vsm;</span>
<span class="changed">1421   }</span>
<span class="changed">1422 }</span>
<span class="changed">1423 </span>
<span class="changed">1424 void ClassLoaderMetaspace::initialize_first_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype) {</span>
<span class="changed">1425   Metachunk* chunk = get_initialization_chunk(type, mdtype);</span>
<span class="changed">1426   if (chunk != NULL) {</span>
<span class="changed">1427     // Add to this manager's list of chunks in use and make it the current_chunk().</span>
<span class="changed">1428     get_space_manager(mdtype)-&gt;add_chunk(chunk, true);</span>
<span class="changed">1429   }</span>
<span class="changed">1430 }</span>
<span class="changed">1431 </span>
<span class="changed">1432 Metachunk* ClassLoaderMetaspace::get_initialization_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype) {</span>
<span class="changed">1433   size_t chunk_word_size = get_space_manager(mdtype)-&gt;get_initial_chunk_size(type);</span>
<span class="changed">1434 </span>
<span class="changed">1435   // Get a chunk from the chunk freelist</span>
<span class="changed">1436   Metachunk* chunk = Metaspace::get_chunk_manager(mdtype)-&gt;chunk_freelist_allocate(chunk_word_size);</span>
<span class="changed">1437 </span>
<span class="changed">1438   if (chunk == NULL) {</span>
<span class="changed">1439     chunk = Metaspace::get_space_list(mdtype)-&gt;get_new_chunk(chunk_word_size,</span>
<span class="changed">1440                                                   get_space_manager(mdtype)-&gt;medium_chunk_bunch());</span>
<span class="changed">1441   }</span>
<span class="changed">1442 </span>
<span class="changed">1443   return chunk;</span>
<span class="changed">1444 }</span>
<span class="changed">1445 </span>
<span class="changed">1446 void ClassLoaderMetaspace::initialize(Mutex* lock, Metaspace::MetaspaceType type) {</span>
<span class="changed">1447   Metaspace::verify_global_initialization();</span>
<span class="changed">1448 </span>
<span class="changed">1449   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_metaspace_births));</span>
<span class="changed">1450 </span>
<span class="changed">1451   // Allocate SpaceManager for metadata objects.</span>
<span class="changed">1452   _vsm = new SpaceManager(Metaspace::NonClassType, type, lock);</span>
<span class="changed">1453 </span>
<span class="changed">1454   if (Metaspace::using_class_space()) {</span>
<span class="changed">1455     // Allocate SpaceManager for classes.</span>
<span class="changed">1456     _class_vsm = new SpaceManager(Metaspace::ClassType, type, lock);</span>
<span class="changed">1457   }</span>
<span class="changed">1458 </span>
<span class="changed">1459   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">1460 </span>
<span class="changed">1461   // Allocate chunk for metadata objects</span>
<span class="changed">1462   initialize_first_chunk(type, Metaspace::NonClassType);</span>
<span class="changed">1463 </span>
<span class="changed">1464   // Allocate chunk for class metadata objects</span>
<span class="changed">1465   if (Metaspace::using_class_space()) {</span>
<span class="changed">1466     initialize_first_chunk(type, Metaspace::ClassType);</span>
<span class="changed">1467   }</span>
<span class="changed">1468 }</span>
<span class="changed">1469 </span>
<span class="changed">1470 MetaWord* ClassLoaderMetaspace::allocate(size_t word_size, Metaspace::MetadataType mdtype) {</span>
<span class="changed">1471   Metaspace::assert_not_frozen();</span>
<span class="changed">1472 </span>
<span class="changed">1473   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs));</span>
<span class="changed">1474 </span>
<span class="changed">1475   // Don't use class_vsm() unless UseCompressedClassPointers is true.</span>
<span class="changed">1476   if (Metaspace::is_class_space_allocation(mdtype)) {</span>
<span class="changed">1477     return  class_vsm()-&gt;allocate(word_size);</span>
<span class="changed">1478   } else {</span>
<span class="changed">1479     return  vsm()-&gt;allocate(word_size);</span>
<span class="changed">1480   }</span>
<span class="changed">1481 }</span>
<span class="changed">1482 </span>
<span class="changed">1483 MetaWord* ClassLoaderMetaspace::expand_and_allocate(size_t word_size, Metaspace::MetadataType mdtype) {</span>
<span class="changed">1484   Metaspace::assert_not_frozen();</span>
<span class="changed">1485   size_t delta_bytes = MetaspaceGC::delta_capacity_until_GC(word_size * BytesPerWord);</span>
<span class="changed">1486   assert(delta_bytes &gt; 0, "Must be");</span>
<span class="changed">1487 </span>
<span class="changed">1488   size_t before = 0;</span>
<span class="changed">1489   size_t after = 0;</span>
<span class="changed">1490   bool can_retry = true;</span>
<span class="changed">1491   MetaWord* res;</span>
<span class="changed">1492   bool incremented;</span>
<span class="changed">1493 </span>
<span class="changed">1494   // Each thread increments the HWM at most once. Even if the thread fails to increment</span>
<span class="changed">1495   // the HWM, an allocation is still attempted. This is because another thread must then</span>
<span class="changed">1496   // have incremented the HWM and therefore the allocation might still succeed.</span>
<span class="changed">1497   do {</span>
<span class="changed">1498     incremented = MetaspaceGC::inc_capacity_until_GC(delta_bytes, &amp;after, &amp;before, &amp;can_retry);</span>
<span class="changed">1499     res = allocate(word_size, mdtype);</span>
<span class="changed">1500   } while (!incremented &amp;&amp; res == NULL &amp;&amp; can_retry);</span>
<span class="changed">1501 </span>
<span class="changed">1502   if (incremented) {</span>
<span class="changed">1503     Metaspace::tracer()-&gt;report_gc_threshold(before, after,</span>
<span class="changed">1504                                   MetaspaceGCThresholdUpdater::ExpandAndAllocate);</span>
<span class="changed">1505     log_trace(gc, metaspace)("Increase capacity to GC from " SIZE_FORMAT " to " SIZE_FORMAT, before, after);</span>
<span class="changed">1506   }</span>
<span class="changed">1507 </span>
<span class="changed">1508   return res;</span>
<span class="changed">1509 }</span>
<span class="changed">1510 </span>
<span class="changed">1511 size_t ClassLoaderMetaspace::allocated_blocks_bytes() const {</span>
<span class="changed">1512   return (vsm()-&gt;used_words() +</span>
<span class="changed">1513       (Metaspace::using_class_space() ? class_vsm()-&gt;used_words() : 0)) * BytesPerWord;</span>
<span class="changed">1514 }</span>
<span class="changed">1515 </span>
<span class="changed">1516 size_t ClassLoaderMetaspace::allocated_chunks_bytes() const {</span>
<span class="changed">1517   return (vsm()-&gt;capacity_words() +</span>
<span class="changed">1518       (Metaspace::using_class_space() ? class_vsm()-&gt;capacity_words() : 0)) * BytesPerWord;</span>
<span class="changed">1519 }</span>
<span class="changed">1520 </span>
<span class="changed">1521 void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {</span>
<span class="changed">1522   Metaspace::assert_not_frozen();</span>
<span class="changed">1523   assert(!SafepointSynchronize::is_at_safepoint()</span>
<span class="changed">1524          || Thread::current()-&gt;is_VM_thread(), "should be the VM thread");</span>
<span class="changed">1525 </span>
<span class="changed">1526   DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_external_deallocs));</span>
<span class="changed">1527 </span>
<span class="changed">1528   MutexLocker ml(vsm()-&gt;lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed">1529 </span>
<span class="changed">1530   if (is_class &amp;&amp; Metaspace::using_class_space()) {</span>
<span class="changed">1531     class_vsm()-&gt;deallocate(ptr, word_size);</span>
<span class="changed">1532   } else {</span>
<span class="changed">1533     vsm()-&gt;deallocate(ptr, word_size);</span>
<span class="changed">1534   }</span>
<span class="changed">1535 }</span>
<span class="changed">1536 </span>
<span class="changed">1537 size_t ClassLoaderMetaspace::class_chunk_size(size_t word_size) {</span>
<span class="changed">1538   assert(Metaspace::using_class_space(), "Has to use class space");</span>
<span class="changed">1539   return class_vsm()-&gt;calc_chunk_size(word_size);</span>
<span class="changed">1540 }</span>
<span class="changed">1541 </span>
<span class="changed">1542 void ClassLoaderMetaspace::print_on(outputStream* out) const {</span>
<span class="changed">1543   // Print both class virtual space counts and metaspace.</span>
<span class="changed">1544   if (Verbose) {</span>
<span class="changed">1545     vsm()-&gt;print_on(out);</span>
<span class="changed">1546     if (Metaspace::using_class_space()) {</span>
<span class="changed">1547       class_vsm()-&gt;print_on(out);</span>
<span class="changed">1548     }</span>
<span class="changed">1549   }</span>
<span class="changed">1550 }</span>
<span class="changed">1551 </span>
<span class="changed">1552 void ClassLoaderMetaspace::verify() {</span>
<span class="changed">1553   vsm()-&gt;verify();</span>
<span class="changed">1554   if (Metaspace::using_class_space()) {</span>
<span class="changed">1555     class_vsm()-&gt;verify();</span>
<span class="changed">1556   }</span>
<span class="changed">1557 }</span>
<span class="changed">1558 </span>
<span class="changed">1559 void ClassLoaderMetaspace::add_to_statistics_locked(ClassLoaderMetaspaceStatistics* out) const {</span>
<span class="changed">1560   assert_lock_strong(lock());</span>
<span class="changed">1561   vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;nonclass_sm_stats());</span>
<span class="changed">1562   if (Metaspace::using_class_space()) {</span>
<span class="changed">1563     class_vsm()-&gt;add_to_statistics_locked(&amp;out-&gt;class_sm_stats());</span>
<span class="changed">1564   }</span>
<span class="changed">1565 }</span>
<span class="changed">1566 </span>
<span class="changed">1567 void ClassLoaderMetaspace::add_to_statistics(ClassLoaderMetaspaceStatistics* out) const {</span>
<span class="changed">1568   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed">1569   add_to_statistics_locked(out);</span>
<span class="changed">1570 }</span>
<span class="changed">1571 </span>
<span class="changed">1572 /////////////// Unit tests ///////////////</span>
<span class="changed">1573 </span>
<span class="changed">1574 struct chunkmanager_statistics_t {</span>
<span class="changed">1575   int num_specialized_chunks;</span>
<span class="changed">1576   int num_small_chunks;</span>
<span class="changed">1577   int num_medium_chunks;</span>
<span class="changed">1578   int num_humongous_chunks;</span>
<span class="changed">1579 };</span>
<span class="changed">1580 </span>
<span class="changed">1581 extern void test_metaspace_retrieve_chunkmanager_statistics(Metaspace::MetadataType mdType, chunkmanager_statistics_t* out) {</span>
<span class="changed">1582   ChunkManager* const chunk_manager = Metaspace::get_chunk_manager(mdType);</span>
<span class="changed">1583   ChunkManagerStatistics stat;</span>
<span class="changed">1584   chunk_manager-&gt;collect_statistics(&amp;stat);</span>
<span class="changed">1585   out-&gt;num_specialized_chunks = (int)stat.chunk_stats(SpecializedIndex).num();</span>
<span class="changed">1586   out-&gt;num_small_chunks = (int)stat.chunk_stats(SmallIndex).num();</span>
<span class="changed">1587   out-&gt;num_medium_chunks = (int)stat.chunk_stats(MediumIndex).num();</span>
<span class="changed">1588   out-&gt;num_humongous_chunks = (int)stat.chunk_stats(HumongousIndex).num();</span>
<span class="changed">1589 }</span>
<span class="changed">1590 </span>
<span class="changed">1591 struct chunk_geometry_t {</span>
<span class="changed">1592   size_t specialized_chunk_word_size;</span>
<span class="changed">1593   size_t small_chunk_word_size;</span>
<span class="changed">1594   size_t medium_chunk_word_size;</span>
<span class="changed">1595 };</span>
<span class="changed">1596 </span>
<span class="changed">1597 extern void test_metaspace_retrieve_chunk_geometry(Metaspace::MetadataType mdType, chunk_geometry_t* out) {</span>
<span class="changed">1598   if (mdType == Metaspace::NonClassType) {</span>
<span class="changed">1599     out-&gt;specialized_chunk_word_size = SpecializedChunk;</span>
<span class="changed">1600     out-&gt;small_chunk_word_size = SmallChunk;</span>
<span class="changed">1601     out-&gt;medium_chunk_word_size = MediumChunk;</span>
<span class="changed">1602   } else {</span>
<span class="changed">1603     out-&gt;specialized_chunk_word_size = ClassSpecializedChunk;</span>
<span class="changed">1604     out-&gt;small_chunk_word_size = ClassSmallChunk;</span>
<span class="changed">1605     out-&gt;medium_chunk_word_size = ClassMediumChunk;</span>
<span class="changed">1606   }</span>
1607 }
</pre></td><td><pre>

</pre><hr></hr><pre>
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
<span class="new">  26 </span>
  27 #include "aot/aotLoader.hpp"

  28 #include "gc/shared/collectedHeap.hpp"
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
  31 #include "memory/filemap.hpp"
<span class="new">  32 #include "memory/metaspace/metaspaceSizesSnapshot.hpp"</span>
<span class="new">  33 #include "memory/metaspace/msChunkHeaderPool.hpp"</span>
<span class="new">  34 #include "memory/metaspace/msChunkManager.hpp"</span>
<span class="new">  35 #include "memory/metaspace/msCommitLimiter.hpp"</span>
<span class="new">  36 #include "memory/metaspace/msCommon.hpp"</span>
<span class="new">  37 #include "memory/metaspace/msContext.hpp"</span>
<span class="new">  38 #include "memory/metaspace/msReport.hpp"</span>
<span class="new">  39 #include "memory/metaspace/msRunningCounters.hpp"</span>
<span class="new">  40 #include "memory/metaspace/msSettings.hpp"</span>
<span class="new">  41 #include "memory/metaspace/msVirtualSpaceList.hpp"</span>
  42 #include "memory/metaspace.hpp"






  43 #include "memory/metaspaceShared.hpp"
  44 #include "memory/metaspaceTracer.hpp"
  45 #include "memory/universe.hpp"
  46 #include "oops/compressedOops.hpp"
  47 #include "runtime/arguments.hpp"
  48 #include "runtime/atomic.hpp"
  49 #include "runtime/init.hpp"
<span class="new">  50 #include "runtime/java.hpp"</span>
  51 #include "services/memTracker.hpp"
  52 #include "utilities/copy.hpp"
  53 #include "utilities/debug.hpp"
  54 #include "utilities/formatBuffer.hpp"
  55 #include "utilities/globalDefinitions.hpp"

  56 
  57 
<span class="changed">  58 using metaspace::ChunkManager;</span>
<span class="changed">  59 using metaspace::CommitLimiter;</span>
<span class="changed">  60 using metaspace::MetaspaceContext;</span>
<span class="changed">  61 using metaspace::MetaspaceReporter;</span>
<span class="changed">  62 using metaspace::RunningCounters;</span>
<span class="changed">  63 using metaspace::VirtualSpaceList;</span>
  64 

  65 
<span class="changed">  66 size_t MetaspaceUtils::used_words() {</span>
<span class="changed">  67   return RunningCounters::used_words();</span>
<span class="changed">  68 }</span>
  69 
<span class="changed">  70 size_t MetaspaceUtils::used_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">  71   return Metaspace::is_class_space_allocation(mdtype) ? RunningCounters::used_words_class() : RunningCounters::used_words_nonclass();</span>
<span class="changed">  72 }</span>
<span class="changed">  73 </span>
<span class="changed">  74 size_t MetaspaceUtils::reserved_words() {</span>
<span class="changed">  75   return RunningCounters::reserved_words();</span>
<span class="changed">  76 }</span>
<span class="changed">  77 </span>
<span class="changed">  78 size_t MetaspaceUtils::reserved_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">  79   return Metaspace::is_class_space_allocation(mdtype) ? RunningCounters::reserved_words_class() : RunningCounters::reserved_words_nonclass();</span>
<span class="changed">  80 }</span>
<span class="changed">  81 </span>
<span class="changed">  82 size_t MetaspaceUtils::committed_words() {</span>
<span class="changed">  83   return RunningCounters::committed_words();</span>
<span class="changed">  84 }</span>
<span class="changed">  85 </span>
<span class="changed">  86 size_t MetaspaceUtils::committed_words(Metaspace::MetadataType mdtype) {</span>
<span class="changed">  87   return Metaspace::is_class_space_allocation(mdtype) ? RunningCounters::committed_words_class() : RunningCounters::committed_words_nonclass();</span>
<span class="changed">  88 }</span>
  89 
<span class="changed">  90 </span>
<span class="changed">  91 </span>
<span class="changed">  92 void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values) {</span>
<span class="changed">  93   const metaspace::MetaspaceSizesSnapshot meta_values;</span>
<span class="changed">  94 </span>
<span class="changed">  95   // We print used and committed since these are the most useful at-a-glance vitals for Metaspace:</span>
<span class="changed">  96   // - used tells you how much memory is actually used for metadata</span>
<span class="changed">  97   // - committed tells you how much memory is committed for the purpose of metadata</span>
<span class="changed">  98   // The difference between those two would be waste, which can have various forms (freelists,</span>
<span class="changed">  99   //   unused parts of committed chunks etc)</span>
<span class="changed"> 100   //</span>
<span class="changed"> 101   // Left out is reserved, since this is not as exciting as the first two values: for class space,</span>
<span class="changed"> 102   // it is a constant (to uninformed users, often confusingly large). For non-class space, it would</span>
<span class="changed"> 103   // be interesting since free chunks can be uncommitted, but for now it is left out.</span>
<span class="changed"> 104 </span>
<span class="changed"> 105   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 106     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT" "</span>
<span class="changed"> 107                             HEAP_CHANGE_FORMAT" "</span>
<span class="changed"> 108                             HEAP_CHANGE_FORMAT,</span>
<span class="changed"> 109                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed"> 110                                                     pre_meta_values.used(),</span>
<span class="changed"> 111                                                     pre_meta_values.committed(),</span>
<span class="changed"> 112                                                     meta_values.used(),</span>
<span class="changed"> 113                                                     meta_values.committed()),</span>
<span class="changed"> 114                             HEAP_CHANGE_FORMAT_ARGS("NonClass",</span>
<span class="changed"> 115                                                     pre_meta_values.non_class_used(),</span>
<span class="changed"> 116                                                     pre_meta_values.non_class_committed(),</span>
<span class="changed"> 117                                                     meta_values.non_class_used(),</span>
<span class="changed"> 118                                                     meta_values.non_class_committed()),</span>
<span class="changed"> 119                             HEAP_CHANGE_FORMAT_ARGS("Class",</span>
<span class="changed"> 120                                                     pre_meta_values.class_used(),</span>
<span class="changed"> 121                                                     pre_meta_values.class_committed(),</span>
<span class="changed"> 122                                                     meta_values.class_used(),</span>
<span class="changed"> 123                                                     meta_values.class_committed()));</span>
<span class="changed"> 124   } else {</span>
<span class="changed"> 125     log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,</span>
<span class="changed"> 126                             HEAP_CHANGE_FORMAT_ARGS("Metaspace",</span>
<span class="changed"> 127                                                     pre_meta_values.used(),</span>
<span class="changed"> 128                                                     pre_meta_values.committed(),</span>
<span class="changed"> 129                                                     meta_values.used(),</span>
<span class="changed"> 130                                                     meta_values.committed()));</span>
 131   }

 132 }
 133 
<span class="changed"> 134 // This will print out a basic metaspace usage report but</span>
<span class="changed"> 135 // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="changed"> 136 void MetaspaceUtils::print_basic_report(outputStream* out, size_t scale) {</span>
<span class="changed"> 137   MetaspaceReporter::print_basic_report(out, scale);</span>
<span class="changed"> 138 }</span>
 139 
<span class="changed"> 140 // Prints a report about the current metaspace state.</span>
<span class="changed"> 141 // Optional parts can be enabled via flags.</span>
<span class="changed"> 142 // Function will walk the CLDG and will lock the expand lock; if that is not</span>
<span class="changed"> 143 // convenient, use print_basic_report() instead.</span>
<span class="changed"> 144 void MetaspaceUtils::print_report(outputStream* out, size_t scale) {</span>
<span class="changed"> 145   const int flags =</span>
<span class="changed"> 146       (int)MetaspaceReporter::Option::ShowLoaders |</span>
<span class="changed"> 147       (int)MetaspaceReporter::Option::BreakDownByChunkType |</span>
<span class="changed"> 148       (int)MetaspaceReporter::Option::ShowClasses;</span>
<span class="changed"> 149   MetaspaceReporter::print_report(out, scale, flags);</span>
<span class="changed"> 150 }</span>
<span class="changed"> 151 </span>
<span class="changed"> 152 void MetaspaceUtils::print_on(outputStream* out) {</span>
<span class="changed"> 153 </span>
<span class="changed"> 154   // Used from all GCs. It first prints out totals, then, separately, the class space portion.</span>
<span class="changed"> 155 </span>
<span class="changed"> 156   out-&gt;print_cr(" Metaspace       "</span>
<span class="changed"> 157                 "used "      SIZE_FORMAT "K, "</span>
<span class="changed"> 158                 "committed " SIZE_FORMAT "K, "</span>
<span class="changed"> 159                 "reserved "  SIZE_FORMAT "K",</span>
<span class="changed"> 160                 used_bytes()/K,</span>
<span class="changed"> 161                 committed_bytes()/K,</span>
<span class="changed"> 162                 reserved_bytes()/K);</span>
<span class="changed"> 163 </span>
<span class="changed"> 164   if (Metaspace::using_class_space()) {</span>
<span class="changed"> 165     const Metaspace::MetadataType ct = Metaspace::ClassType;</span>
<span class="changed"> 166     out-&gt;print_cr("  class space    "</span>
<span class="changed"> 167                   "used "      SIZE_FORMAT "K, "</span>
<span class="changed"> 168                   "committed " SIZE_FORMAT "K, "</span>
<span class="changed"> 169                   "reserved "  SIZE_FORMAT "K",</span>
<span class="changed"> 170                   used_bytes(ct)/K,</span>
<span class="changed"> 171                   committed_bytes(ct)/K,</span>
<span class="changed"> 172                   reserved_bytes(ct)/K);</span>
<span class="changed"> 173   }</span>
<span class="changed"> 174 }</span>
<span class="changed"> 175 </span>
<span class="changed"> 176 #ifdef ASSERT</span>
<span class="changed"> 177 void MetaspaceUtils::verify() {</span>
<span class="changed"> 178   if (Metaspace::initialized()) {</span>
<span class="changed"> 179 </span>
<span class="changed"> 180     // Verify non-class chunkmanager...</span>
<span class="changed"> 181     ChunkManager* cm = ChunkManager::chunkmanager_nonclass();</span>
<span class="changed"> 182     cm-&gt;verify();</span>
 183 
<span class="changed"> 184     // ... and space list.</span>
<span class="changed"> 185     VirtualSpaceList* vsl = VirtualSpaceList::vslist_nonclass();</span>
<span class="changed"> 186     vsl-&gt;verify();</span>
 187 
<span class="new"> 188     if (Metaspace::using_class_space()) {</span>
<span class="new"> 189       // If we use compressed class pointers, verify class chunkmanager...</span>
<span class="new"> 190       cm = ChunkManager::chunkmanager_class();</span>
<span class="new"> 191       cm-&gt;verify();</span>
<span class="new"> 192 </span>
<span class="new"> 193       // ... and class spacelist.</span>
<span class="new"> 194       vsl = VirtualSpaceList::vslist_class();</span>
<span class="new"> 195       vsl-&gt;verify();</span>
<span class="new"> 196     }</span>
<span class="new"> 197 </span>
<span class="new"> 198   }</span>
<span class="new"> 199 }</span>
<span class="new"> 200 #endif</span>
<span class="new"> 201 </span>
<span class="new"> 202 ////////////////////////////////7</span>
 203 // MetaspaceGC methods
 204 
<span class="new"> 205 volatile size_t MetaspaceGC::_capacity_until_GC = 0;</span>
<span class="new"> 206 uint MetaspaceGC::_shrink_factor = 0;</span>
<span class="new"> 207 </span>
 208 // VM_CollectForMetadataAllocation is the vm operation used to GC.
 209 // Within the VM operation after the GC the attempt to allocate the metadata
 210 // should succeed.  If the GC did not free enough space for the metaspace
 211 // allocation, the HWM is increased so that another virtualspace will be
 212 // allocated for the metadata.  With perm gen the increase in the perm
 213 // gen had bounds, MinMetaspaceExpansion and MaxMetaspaceExpansion.  The
 214 // metaspace policy uses those as the small and large steps for the HWM.
 215 //
 216 // After the GC the compute_new_size() for MetaspaceGC is called to
 217 // resize the capacity of the metaspaces.  The current implementation
 218 // is based on the flags MinMetaspaceFreeRatio and MaxMetaspaceFreeRatio used
 219 // to resize the Java heap by some GC's.  New flags can be implemented
 220 // if really needed.  MinMetaspaceFreeRatio is used to calculate how much
 221 // free space is desirable in the metaspace capacity to decide how much
 222 // to increase the HWM.  MaxMetaspaceFreeRatio is used to decide how much
 223 // free space is desirable in the metaspace capacity before decreasing
 224 // the HWM.
 225 
 226 // Calculate the amount to increase the high water mark (HWM).
 227 // Increase by a minimum amount (MinMetaspaceExpansion) so that

</pre><hr></hr><pre>
 459       } else {
 460         _shrink_factor = MIN2(current_shrink_factor * 4, (uint) 100);
 461       }
 462       log_trace(gc, metaspace)("    shrinking:  initThreshold: %.1fK  maximum_desired_capacity: %.1fK",
 463                                MetaspaceSize / (double) K, maximum_desired_capacity / (double) K);
 464       log_trace(gc, metaspace)("    shrink_bytes: %.1fK  current_shrink_factor: %d  new shrink factor: %d  MinMetaspaceExpansion: %.1fK",
 465                                shrink_bytes / (double) K, current_shrink_factor, _shrink_factor, MinMetaspaceExpansion / (double) K);
 466     }
 467   }
 468 
 469   // Don't shrink unless it's significant
 470   if (shrink_bytes &gt;= MinMetaspaceExpansion &amp;&amp;
 471       ((capacity_until_GC - shrink_bytes) &gt;= MetaspaceSize)) {
 472     size_t new_capacity_until_GC = MetaspaceGC::dec_capacity_until_GC(shrink_bytes);
 473     Metaspace::tracer()-&gt;report_gc_threshold(capacity_until_GC,
 474                                              new_capacity_until_GC,
 475                                              MetaspaceGCThresholdUpdater::ComputeNewSize);
 476   }
 477 }
 478 




 479 




































 480 
<span class="changed"> 481 //////  Metaspace methods /////</span>

































































































































































































 482 
<span class="changed"> 483 const MetaspaceTracer* Metaspace::_tracer = NULL;</span>




































































































































































































































































































































 484 
<span class="changed"> 485 DEBUG_ONLY(bool Metaspace::_frozen = false;)</span>







 486 
<span class="changed"> 487 bool Metaspace::initialized() {</span>
<span class="changed"> 488   return metaspace::MetaspaceContext::context_nonclass() != NULL &amp;&amp;</span>
<span class="changed"> 489       (using_class_space() ? metaspace::MetaspaceContext::context_class() != NULL : true);</span>


























 490 }
 491 


















 492 #ifdef _LP64
 493 
 494 void Metaspace::print_compressed_class_space(outputStream* st) {
<span class="changed"> 495   if (VirtualSpaceList::vslist_class() != NULL) {</span>
<span class="changed"> 496     MetaWord* base = VirtualSpaceList::vslist_class()-&gt;base_of_first_node();</span>
<span class="changed"> 497     size_t size = VirtualSpaceList::vslist_class()-&gt;word_size_of_first_node();</span>
<span class="changed"> 498     MetaWord* top = base + size;</span>
<span class="changed"> 499     st-&gt;print("Compressed class space mapped at: " PTR_FORMAT "-" PTR_FORMAT ", reserved size: " SIZE_FORMAT,</span>
<span class="changed"> 500                p2i(base), p2i(top), (top - base) * BytesPerWord);</span>
 501     st-&gt;cr();
 502   }
 503 }
 504 
 505 // Given a prereserved space, use that to set up the compressed class space list.
 506 void Metaspace::initialize_class_space(ReservedSpace rs) {
<span class="new"> 507   assert(rs.size() &gt;= CompressedClassSpaceSize,</span>
<span class="new"> 508          SIZE_FORMAT " != " SIZE_FORMAT, rs.size(), CompressedClassSpaceSize);</span>
 509   assert(using_class_space(), "Must be using class space");

 510 
 511   assert(rs.size() == CompressedClassSpaceSize, SIZE_FORMAT " != " SIZE_FORMAT,
 512          rs.size(), CompressedClassSpaceSize);
 513   assert(is_aligned(rs.base(), Metaspace::reserve_alignment()) &amp;&amp;
 514          is_aligned(rs.size(), Metaspace::reserve_alignment()),
 515          "wrong alignment");
 516 
<span class="changed"> 517   MetaspaceContext::initialize_class_space_context(rs);</span>

 518 
 519   // This does currently not work because rs may be the result of a split
 520   // operation and NMT seems not to be able to handle splits.
 521   // Will be fixed with JDK-8243535.
 522   // MemTracker::record_virtual_memory_type((address)rs.base(), mtClass);
 523 
<span class="changed"> 524 }</span>


 525 
<span class="new"> 526 // Returns true if class space has been setup (initialize_class_space).</span>
<span class="new"> 527 bool Metaspace::class_space_is_initialized() {</span>
<span class="new"> 528   return MetaspaceContext::context_class() != NULL;</span>
 529 }
 530 
 531 // Reserve a range of memory at an address suitable for en/decoding narrow
 532 // Klass pointers (see: CompressedClassPointers::is_valid_base()).
 533 // The returned address shall both be suitable as a compressed class pointers
 534 //  base, and aligned to Metaspace::reserve_alignment (which is equal to or a
 535 //  multiple of allocation granularity).
 536 // On error, returns an unreserved space.
 537 ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size) {
 538 
 539 #ifdef AARCH64
 540   const size_t alignment = Metaspace::reserve_alignment();
 541 
 542   // AArch64: Try to align metaspace so that we can decode a compressed
 543   // klass with a single MOVK instruction. We can do this iff the
 544   // compressed class base is a multiple of 4G.
 545   // Additionally, above 32G, ensure the lower LogKlassAlignmentInBytes bits
 546   // of the upper 32-bits of the address are zero so we can handle a shift
 547   // when decoding.
 548 

</pre><hr></hr><pre>
 565       if (rs.is_reserved()) {
 566         assert(a == (address)rs.base(), "Sanity");
 567         return rs;
 568       }
 569       a +=  search_ranges[i].increment;
 570     }
 571   }
 572 
 573   // Note: on AARCH64, if the code above does not find any good placement, we
 574   // have no recourse. We return an empty space and the VM will exit.
 575   return ReservedSpace();
 576 #else
 577   // Default implementation: Just reserve anywhere.
 578   return ReservedSpace(size, Metaspace::reserve_alignment(), false, (char*)NULL);
 579 #endif // AARCH64
 580 }
 581 
 582 #endif // _LP64
 583 
 584 
<span class="changed"> 585 size_t Metaspace::reserve_alignment_words() {</span>
<span class="changed"> 586   return metaspace::Settings::virtual_space_node_reserve_alignment_words();</span>
<span class="changed"> 587 }</span>


 588 
<span class="changed"> 589 size_t Metaspace::commit_alignment_words() {</span>
<span class="changed"> 590   return metaspace::Settings::commit_granule_words();</span>
<span class="changed"> 591 }</span>

 592 
<span class="changed"> 593 void Metaspace::ergo_initialize() {</span>

 594 
<span class="changed"> 595   // Must happen before using any setting from Settings::---</span>
<span class="changed"> 596   metaspace::Settings::ergo_initialize();</span>




 597 
<span class="changed"> 598   // MaxMetaspaceSize and CompressedClassSpaceSize:</span>
<span class="changed"> 599   //</span>
<span class="changed"> 600   // MaxMetaspaceSize is the maximum size, in bytes, of memory we are allowed</span>
<span class="changed"> 601   //  to commit for the Metaspace.</span>
<span class="changed"> 602   //  It is just a number; a limit we compare against before committing. It</span>
<span class="changed"> 603   //  does not have to be aligned to anything.</span>
<span class="changed"> 604   //  It gets used as compare value in class CommitLimiter.</span>
<span class="changed"> 605   //  It is set to max_uintx in globals.hpp by default, so by default it does</span>
<span class="changed"> 606   //  not limit anything.</span>
<span class="changed"> 607   //</span>
<span class="changed"> 608   // CompressedClassSpaceSize is the size, in bytes, of the address range we</span>
<span class="changed"> 609   //  pre-reserve for the compressed class space (if we use class space).</span>
<span class="changed"> 610   //  This size has to be aligned to the metaspace reserve alignment (to the</span>
<span class="changed"> 611   //  size of a root chunk). It gets aligned up from whatever value the caller</span>
<span class="changed"> 612   //  gave us to the next multiple of root chunk size.</span>
<span class="changed"> 613   //</span>
<span class="changed"> 614   // Note: Strictly speaking MaxMetaspaceSize and CompressedClassSpaceSize have</span>
<span class="changed"> 615   //  very little to do with each other. The notion often encountered:</span>
<span class="changed"> 616   //  MaxMetaspaceSize = CompressedClassSpaceSize + &lt;non-class metadata size&gt;</span>
<span class="changed"> 617   //  is subtly wrong: MaxMetaspaceSize can besmaller than CompressedClassSpaceSize,</span>
<span class="changed"> 618   //  in which case we just would not be able to fully commit the class space range.</span>
 619   //
<span class="changed"> 620   // We still adjust CompressedClassSpaceSize to reasonable limits, mainly to</span>
<span class="changed"> 621   //  save on reserved space, and to make ergnonomics less confusing.</span>


 622 
<span class="new"> 623   // (aligned just for cleanliness:)</span>
<span class="new"> 624   MaxMetaspaceSize = MAX2(align_down(MaxMetaspaceSize, commit_alignment()), commit_alignment());</span>
<span class="new"> 625 </span>
<span class="new"> 626   if (UseCompressedClassPointers) {</span>
<span class="new"> 627     // Let CCS size not be larger than 80% of MaxMetaspaceSize. Note that is</span>
<span class="new"> 628     // grossly over-dimensioned for most usage scenarios; typical ratio of</span>
<span class="new"> 629     // class space : non class space usage is about 1:6. With many small classes,</span>
<span class="new"> 630     // it can get as low as 1:2. It is not a big deal though since ccs is only</span>
<span class="new"> 631     // reserved and will be committed on demand only.</span>
<span class="new"> 632     size_t max_ccs_size = MaxMetaspaceSize * 0.8;</span>
<span class="new"> 633     size_t adjusted_ccs_size = MIN2(CompressedClassSpaceSize, max_ccs_size);</span>
<span class="new"> 634 </span>
<span class="new"> 635     // CCS must be aligned to root chunk size, and be at least the size of one</span>
<span class="new"> 636     //  root chunk.</span>
<span class="new"> 637     adjusted_ccs_size = align_up(adjusted_ccs_size, reserve_alignment());</span>
<span class="new"> 638     adjusted_ccs_size = MAX2(adjusted_ccs_size, reserve_alignment());</span>
<span class="new"> 639 </span>
<span class="new"> 640     // Note: re-adjusting may have us left with a CompressedClassSpaceSize</span>
<span class="new"> 641     //  larger than MaxMetaspaceSize for very small values of MaxMetaspaceSize.</span>
<span class="new"> 642     //  Lets just live with that, its not a big deal.</span>
<span class="new"> 643 </span>
<span class="new"> 644     if (adjusted_ccs_size != CompressedClassSpaceSize) {</span>
<span class="new"> 645       FLAG_SET_ERGO(CompressedClassSpaceSize, adjusted_ccs_size);</span>
<span class="new"> 646       log_info(metaspace)("Setting CompressedClassSpaceSize to " SIZE_FORMAT ".",</span>
<span class="new"> 647                           CompressedClassSpaceSize);</span>
<span class="new"> 648     }</span>
<span class="new"> 649   }</span>
<span class="new"> 650 </span>
<span class="new"> 651   // Set MetaspaceSize, MinMetaspaceExpansion and MaxMetaspaceExpansion</span>
 652   if (MetaspaceSize &gt; MaxMetaspaceSize) {
 653     MetaspaceSize = MaxMetaspaceSize;
 654   }
 655 
<span class="changed"> 656   MetaspaceSize = align_down_bounded(MetaspaceSize, commit_alignment());</span>
 657 
 658   assert(MetaspaceSize &lt;= MaxMetaspaceSize, "MetaspaceSize should be limited by MaxMetaspaceSize");
 659 
<span class="changed"> 660   MinMetaspaceExpansion = align_down_bounded(MinMetaspaceExpansion, commit_alignment());</span>
<span class="changed"> 661   MaxMetaspaceExpansion = align_down_bounded(MaxMetaspaceExpansion, commit_alignment());</span>


 662 


















 663 }
 664 
 665 void Metaspace::global_initialize() {
<span class="changed"> 666   MetaspaceGC::initialize(); // &lt;- since we do not prealloc init chunks anymore is this still needed?</span>
<span class="changed"> 667 </span>
<span class="changed"> 668   metaspace::ChunkHeaderPool::initialize();</span>
 669 
 670   // If UseCompressedClassPointers=1, we have two cases:
 671   // a) if CDS is active (either dump time or runtime), it will create the ccs
 672   //    for us, initialize it and set up CompressedKlassPointers encoding.
 673   //    Class space will be reserved above the mapped archives.
 674   // b) if CDS is not active, we will create the ccs on our own. It will be
 675   //    placed above the java heap, since we assume it has been placed in low
 676   //    address regions. We may rethink this (see JDK-8244943). Failing that,
 677   //    it will be placed anywhere.
 678 
 679 #if INCLUDE_CDS
 680   // case (a)
 681   if (DumpSharedSpaces) {
 682     MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();
 683   } else if (UseSharedSpaces) {
 684     // If any of the archived space fails to map, UseSharedSpaces
 685     // is reset to false.
 686     MetaspaceShared::initialize_runtime_shared_and_meta_spaces();
 687   }
 688 

</pre><hr></hr><pre>
 708     address base = UseCompressedOops ? CompressedOops::end() : (address)HeapBaseMinAddress;
 709     base = align_up(base, Metaspace::reserve_alignment());
 710 
 711     const size_t size = align_up(CompressedClassSpaceSize, Metaspace::reserve_alignment());
 712     if (base != NULL) {
 713       if (CompressedKlassPointers::is_valid_base(base)) {
 714         rs = ReservedSpace(size, Metaspace::reserve_alignment(),
 715                            false /* large */, (char*)base);
 716       }
 717     }
 718 
 719     // ...failing that, reserve anywhere, but let platform do optimized placement:
 720     if (!rs.is_reserved()) {
 721       rs = Metaspace::reserve_address_space_for_compressed_classes(size);
 722     }
 723 
 724     // ...failing that, give up.
 725     if (!rs.is_reserved()) {
 726       vm_exit_during_initialization(
 727           err_msg("Could not allocate compressed class space: " SIZE_FORMAT " bytes",
<span class="changed"> 728                    CompressedClassSpaceSize));</span>
 729     }
 730 
 731     // Initialize space
 732     Metaspace::initialize_class_space(rs);
 733 
 734     // Set up compressed class pointer encoding.
 735     CompressedKlassPointers::initialize((address)rs.base(), rs.size());
 736   }
 737 
 738 #endif
 739 
<span class="changed"> 740   // Initialize non-class virtual space list, and its chunk manager:</span>
<span class="changed"> 741   MetaspaceContext::initialize_nonclass_space_context();</span>



















 742 
 743   _tracer = new MetaspaceTracer();
 744 
<span class="changed"> 745   // We must prevent the very first address of the ccs from being used to store</span>
<span class="changed"> 746   // metadata, since that address would translate to a narrow pointer of 0, and the</span>
<span class="changed"> 747   // VM does not distinguish between "narrow 0 as in NULL" and "narrow 0 as in start</span>
<span class="changed"> 748   //  of ccs".</span>
<span class="changed"> 749   // Before Elastic Metaspace that did not happen due to the fact that every Metachunk</span>
<span class="changed"> 750   // had a header and therefore could not allocate anything at offset 0.</span>
<span class="changed"> 751 #ifdef _LP64</span>
<span class="changed"> 752   if (using_class_space()) {</span>
<span class="changed"> 753     // The simplest way to fix this is to allocate a tiny dummy chunk right at the</span>
<span class="changed"> 754     // start of ccs and do not use it for anything.</span>
<span class="changed"> 755     MetaspaceContext::context_class()-&gt;cm()-&gt;get_chunk(metaspace::chunklevel::HIGHEST_CHUNK_LEVEL);</span>
<span class="changed"> 756   }</span>
<span class="changed"> 757 #endif</span>
 758 
 759 #ifdef _LP64
 760   if (UseCompressedClassPointers) {
 761     // Note: "cds" would be a better fit but keep this for backward compatibility.
 762     LogTarget(Info, gc, metaspace) lt;
 763     if (lt.is_enabled()) {
 764       ResourceMark rm;
 765       LogStream ls(lt);
 766       CDS_ONLY(MetaspaceShared::print_on(&amp;ls);)
 767       Metaspace::print_compressed_class_space(&amp;ls);
 768       CompressedKlassPointers::print_mode(&amp;ls);
 769     }
 770   }
 771 #endif
 772 
 773 }
 774 
 775 void Metaspace::post_initialize() {
 776   MetaspaceGC::post_initialize();
 777 }
 778 
<span class="changed"> 779 size_t Metaspace::max_allocation_word_size() {</span>
<span class="changed"> 780   const size_t max_overhead_words = metaspace::get_raw_word_size_for_requested_word_size(1);</span>
<span class="changed"> 781   return metaspace::chunklevel::MAX_CHUNK_WORD_SIZE - max_overhead_words;</span>










 782 }
 783 
 784 MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,
 785                               MetaspaceObj::Type type, TRAPS) {
<span class="new"> 786   assert(word_size &lt;= Metaspace::max_allocation_word_size(),</span>
<span class="new"> 787          "allocation size too large (" SIZE_FORMAT ")", word_size);</span>
 788   assert(!_frozen, "sanity");
 789   assert(!(DumpSharedSpaces &amp;&amp; THREAD-&gt;is_VM_thread()), "sanity");
 790 
 791   if (HAS_PENDING_EXCEPTION) {
 792     assert(false, "Should not allocate with exception pending");
 793     return NULL;  // caller does a CHECK_NULL too
 794   }
 795 
 796   assert(loader_data != NULL, "Should never pass around a NULL loader_data. "
 797         "ClassLoaderData::the_null_class_loader_data() should have been used.");
 798 
 799   MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;
 800 
 801   // Try to allocate metadata.
 802   MetaWord* result = loader_data-&gt;metaspace_non_null()-&gt;allocate(word_size, mdtype);
 803 
 804   if (result == NULL) {
 805     tracer()-&gt;report_metaspace_allocation_failure(loader_data, word_size, type, mdtype);
 806 
 807     // Allocation failed.

</pre><hr></hr><pre>
 812       result = Universe::heap()-&gt;satisfy_failed_metadata_allocation(loader_data, word_size, mdtype);
 813     }
 814   }
 815 
 816   if (result == NULL) {
 817     if (DumpSharedSpaces) {
 818       // CDS dumping keeps loading classes, so if we hit an OOM we probably will keep hitting OOM.
 819       // We should abort to avoid generating a potentially bad archive.
 820       vm_exit_during_cds_dumping(err_msg("Failed allocating metaspace object type %s of size " SIZE_FORMAT ". CDS dump aborted.",
 821           MetaspaceObj::type_name(type), word_size * BytesPerWord),
 822         err_msg("Please increase MaxMetaspaceSize (currently " SIZE_FORMAT " bytes).", MaxMetaspaceSize));
 823     }
 824     report_metadata_oome(loader_data, word_size, type, mdtype, THREAD);
 825     assert(HAS_PENDING_EXCEPTION, "sanity");
 826     return NULL;
 827   }
 828 
 829   // Zero initialize.
 830   Copy::fill_to_words((HeapWord*)result, word_size, 0);
 831 
<span class="new"> 832   log_trace(metaspace)("Metaspace::allocate: type %d return " PTR_FORMAT ".", (int)type, p2i(result));</span>
<span class="new"> 833 </span>
 834   return result;
 835 }
 836 
 837 void Metaspace::report_metadata_oome(ClassLoaderData* loader_data, size_t word_size, MetaspaceObj::Type type, MetadataType mdtype, TRAPS) {
 838   tracer()-&gt;report_metadata_oom(loader_data, word_size, type, mdtype);
 839 
 840   // If result is still null, we are out of memory.
 841   Log(gc, metaspace, freelist, oom) log;
 842   if (log.is_info()) {
 843     log.info("Metaspace (%s) allocation failed for size " SIZE_FORMAT,
 844              is_class_space_allocation(mdtype) ? "class" : "data", word_size);
 845     ResourceMark rm;
 846     if (log.is_debug()) {
 847       if (loader_data-&gt;metaspace_or_null() != NULL) {
 848         LogStream ls(log.debug());
 849         loader_data-&gt;print_value_on(&amp;ls);
 850       }
 851     }
 852     LogStream ls(log.info());
 853     // In case of an OOM, log out a short but still useful report.
 854     MetaspaceUtils::print_basic_report(&amp;ls, 0);
 855   }
 856 
<span class="new"> 857   // TODO: this exception text may be wrong and misleading. This needs more thinking. See JDK-8252189.</span>
 858   bool out_of_compressed_class_space = false;
 859   if (is_class_space_allocation(mdtype)) {
 860     ClassLoaderMetaspace* metaspace = loader_data-&gt;metaspace_non_null();
 861     out_of_compressed_class_space =
 862       MetaspaceUtils::committed_bytes(Metaspace::ClassType) +
<span class="changed"> 863       align_up(word_size * BytesPerWord, 4 * M) &gt;</span>
 864       CompressedClassSpaceSize;
 865   }
 866 
 867   // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support
 868   const char* space_string = out_of_compressed_class_space ?
 869     "Compressed class space" : "Metaspace";
 870 
 871   report_java_out_of_memory(space_string);
 872 
 873   if (JvmtiExport::should_post_resource_exhausted()) {
 874     JvmtiExport::post_resource_exhausted(
 875         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR,
 876         space_string);
 877   }
 878 
 879   if (!is_init_completed()) {
 880     vm_exit_during_initialization("OutOfMemoryError", space_string);
 881   }
 882 
 883   if (out_of_compressed_class_space) {
 884     THROW_OOP(Universe::out_of_memory_error_class_metaspace());
 885   } else {
 886     THROW_OOP(Universe::out_of_memory_error_metaspace());
 887   }
 888 }
 889 
 890 const char* Metaspace::metadata_type_name(Metaspace::MetadataType mdtype) {
 891   switch (mdtype) {
 892     case Metaspace::ClassType: return "Class";
 893     case Metaspace::NonClassType: return "Metadata";
 894     default:
 895       assert(false, "Got bad mdtype: %d", (int) mdtype);
 896       return NULL;
 897   }
 898 }
 899 




 900 void Metaspace::purge() {
<span class="changed"> 901   ChunkManager* cm = ChunkManager::chunkmanager_nonclass();</span>
<span class="changed"> 902   if (cm != NULL) {</span>
<span class="changed"> 903     cm-&gt;purge();</span>
<span class="changed"> 904   }</span>
 905   if (using_class_space()) {
<span class="changed"> 906     cm = ChunkManager::chunkmanager_class();</span>
<span class="changed"> 907     if (cm != NULL) {</span>
<span class="changed"> 908       cm-&gt;purge();</span>
<span class="changed"> 909     }</span>
 910   }
 911 }
 912 
 913 bool Metaspace::contains(const void* ptr) {
 914   if (MetaspaceShared::is_in_shared_metaspace(ptr)) {
 915     return true;
 916   }
 917   return contains_non_shared(ptr);
 918 }
 919 
 920 bool Metaspace::contains_non_shared(const void* ptr) {
<span class="changed"> 921   if (using_class_space() &amp;&amp; VirtualSpaceList::vslist_class()-&gt;contains((MetaWord*)ptr)) {</span>
 922      return true;
 923   }
 924 
<span class="changed"> 925   return VirtualSpaceList::vslist_nonclass()-&gt;contains((MetaWord*)ptr);</span>













































































































































































































 926 }
</pre></td>
</tr></table>
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
