<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60818">60818</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_RUNTIME_GLOBALS_HPP
  26 #define SHARE_RUNTIME_GLOBALS_HPP
  27 
  28 #include "compiler/compiler_globals.hpp"
  29 #include "gc/shared/gc_globals.hpp"
  30 #include "runtime/globals_shared.hpp"
  31 #include "utilities/align.hpp"
  32 #include "utilities/globalDefinitions.hpp"
  33 #include "utilities/macros.hpp"
  34 #include CPU_HEADER(globals)
  35 #include OS_HEADER(globals)
  36 #include OS_CPU_HEADER(globals)
  37 
  38 // develop flags are settable / visible only during development and are constant in the PRODUCT version
  39 // product flags are always settable / visible
  40 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
  41 
  42 // A flag must be declared with one of the following types:
  43 // bool, int, uint, intx, uintx, size_t, ccstr, ccstrlist, double, or uint64_t.
  44 // The type "ccstr" and "ccstrlist" are an alias for "const char*" and is used
  45 // only in this file, because the macrology requires single-token type names.
  46 
  47 // Note: Diagnostic options not meant for VM tuning or for product modes.
  48 // They are to be used for VM quality assurance or field diagnosis
  49 // of VM bugs.  They are hidden so that users will not be encouraged to
  50 // try them as if they were VM ordinary execution options.  However, they
  51 // are available in the product version of the VM.  Under instruction
  52 // from support engineers, VM customers can turn them on to collect
  53 // diagnostic information about VM problems.  To use a VM diagnostic
  54 // option, you must first specify +UnlockDiagnosticVMOptions.
  55 // (This master switch also affects the behavior of -Xprintflags.)
  56 //
  57 // experimental flags are in support of features that are not
  58 //    part of the officially supported product, but are available
  59 //    for experimenting with. They could, for example, be performance
  60 //    features that may not have undergone full or rigorous QA, but which may
  61 //    help performance in some cases and released for experimentation
  62 //    by the community of users and developers. This flag also allows one to
  63 //    be able to build a fully supported product that nonetheless also
  64 //    ships with some unsupported, lightly tested, experimental features.
  65 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
  66 //    UnlockExperimentalVMOptions flag, which allows the control and
  67 //    modification of the experimental flags.
  68 //
  69 // Nota bene: neither diagnostic nor experimental options should be used casually,
  70 //    and they are not supported on production loads, except under explicit
  71 //    direction from support engineers.
  72 //
  73 // manageable flags are writeable external product flags.
  74 //    They are dynamically writeable through the JDK management interface
  75 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
  76 //    These flags are external exported interface (see CCC).  The list of
  77 //    manageable flags can be queried programmatically through the management
  78 //    interface.
  79 //
  80 //    A flag can be made as "manageable" only if
  81 //    - the flag is defined in a CCC as an external exported interface.
  82 //    - the VM implementation supports dynamic setting of the flag.
  83 //      This implies that the VM must *always* query the flag variable
  84 //      and not reuse state related to the flag state at any given time.
  85 //    - you want the flag to be queried programmatically by the customers.
  86 //
  87 // product_rw flags are writeable internal product flags.
  88 //    They are like "manageable" flags but for internal/private use.
  89 //    The list of product_rw flags are internal/private flags which
  90 //    may be changed/removed in a future release.  It can be set
  91 //    through the management interface to get/set value
  92 //    when the name of flag is supplied.
  93 //
  94 //    A flag can be made as "product_rw" only if
  95 //    - the VM implementation supports dynamic setting of the flag.
  96 //      This implies that the VM must *always* query the flag variable
  97 //      and not reuse state related to the flag state at any given time.
  98 //
  99 // Note that when there is a need to support develop flags to be writeable,
 100 // it can be done in the same way as product_rw.
 101 //
 102 // range is a macro that will expand to min and max arguments for range
 103 //    checking code if provided - see jvmFlagRangeList.hpp
 104 //
 105 // constraint is a macro that will expand to custom function call
 106 //    for constraint checking if provided - see jvmFlagConstraintList.hpp
 107 
 108 // Default and minimum StringTable and SymbolTable size values
 109 // Must be powers of 2
 110 const size_t defaultStringTableSize = NOT_LP64(1024) LP64_ONLY(65536);
 111 const size_t minimumStringTableSize = 128;
 112 const size_t defaultSymbolTableSize = 32768; // 2^15
 113 const size_t minimumSymbolTableSize = 1024;
 114 
 115 #define RUNTIME_FLAGS(develop, \
 116                       develop_pd, \
 117                       product, \
 118                       product_pd, \
 119                       diagnostic, \
 120                       diagnostic_pd, \
 121                       experimental, \
 122                       notproduct, \
 123                       manageable, \
 124                       product_rw, \
 125                       lp64_product, \
 126                       range, \
 127                       constraint) \
 128                                                                             \
 129   lp64_product(bool, UseCompressedOops, false,                              \
 130           "Use 32-bit object references in 64-bit VM. "                     \
 131           "lp64_product means flag is always constant in 32 bit VM")        \
 132                                                                             \
 133   lp64_product(bool, UseCompressedClassPointers, false,                     \
 134           "Use 32-bit class pointers in 64-bit VM. "                        \
 135           "lp64_product means flag is always constant in 32 bit VM")        \
 136                                                                             \
 137   notproduct(bool, CheckCompressedOops, true,                               \
 138           "Generate checks in encoding/decoding code in debug VM")          \
 139                                                                             \
 140   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 141           "Heap allocation steps through preferred address regions to find" \
 142           " where it can allocate the heap. Number of steps to take per "   \
 143           "region.")                                                        \
 144           range(1, max_uintx)                                               \
 145                                                                             \
 146   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 147           "Default object alignment in bytes, 8 is minimum")                \
 148           range(8, 256)                                                     \
 149           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 150                                                                             \
 151   develop(bool, CleanChunkPoolAsync, true,                                  \
 152           "Clean the chunk pool asynchronously")                            \
 153                                                                             \
 154   diagnostic(uint, HandshakeTimeout, 0,                                     \
 155           "If nonzero set a timeout in milliseconds for handshakes")        \
 156                                                                             \
 157   experimental(bool, AlwaysSafeConstructors, false,                         \
 158           "Force safe construction, as if all fields are final.")           \
 159                                                                             \
 160   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 161           "Enable normal processing of flags relating to field diagnostics")\
 162                                                                             \
 163   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 164           "Enable normal processing of flags relating to experimental "     \
 165           "features")                                                       \
 166                                                                             \
 167   product(bool, JavaMonitorsInStackTrace, true,                             \
 168           "Print information about Java monitor locks when the stacks are"  \
 169           "dumped")                                                         \
 170                                                                             \
 171   product_pd(bool, UseLargePages,                                           \
 172           "Use large page memory")                                          \
 173                                                                             \
 174   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 175           "Allocate large pages individually for better affinity")          \
 176                                                                             \
 177   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 178           "Fail large pages individual allocation")                         \
 179                                                                             \
 180   product(bool, UseLargePagesInMetaspace, false,                            \
 181           "(Deprecated) Use large page memory in metaspace. "               \
 182           "Only used if UseLargePages is enabled.")                         \
 183                                                                             \
 184   product(bool, UseNUMA, false,                                             \
 185           "Use NUMA if available")                                          \
 186                                                                             \
 187   product(bool, UseNUMAInterleaving, false,                                 \
 188           "Interleave memory across NUMA nodes if available")               \
 189                                                                             \
 190   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 191           "Granularity to use for NUMA interleaving on Windows OS")         \
 192           range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \
 193                                                                             \
 194   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 195           "Percentage (0-100) used to weight the current sample when "      \
 196           "computing exponentially decaying average for "                   \
 197           "AdaptiveNUMAChunkSizing")                                        \
 198           range(0, 100)                                                     \
 199                                                                             \
 200   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 201           "Do not reallocate more than this amount per collection")         \
 202           range(0, max_uintx)                                               \
 203                                                                             \
 204   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 205           "Enable adaptive chunk sizing for NUMA")                          \
 206                                                                             \
 207   product(bool, NUMAStats, false,                                           \
 208           "Print NUMA stats in detailed heap information")                  \
 209                                                                             \
 210   product(uintx, NUMAPageScanRate, 256,                                     \
 211           "Maximum number of pages to include in the page scan procedure")  \
 212           range(0, max_uintx)                                               \
 213                                                                             \
 214   product(bool, UseAES, false,                                              \
 215           "Control whether AES instructions are used when available")       \
 216                                                                             \
 217   product(bool, UseFMA, false,                                              \
 218           "Control whether FMA instructions are used when available")       \
 219                                                                             \
 220   product(bool, UseSHA, false,                                              \
 221           "Control whether SHA instructions are used when available")       \
 222                                                                             \
 223   diagnostic(bool, UseGHASHIntrinsics, false,                               \
 224           "Use intrinsics for GHASH versions of crypto")                    \
 225                                                                             \
 226   product(bool, UseBASE64Intrinsics, false,                                 \
 227           "Use intrinsics for java.util.Base64")                            \
 228                                                                             \
 229   product(size_t, LargePageSizeInBytes, 0,                                  \
 230           "Large page size (0 to let VM choose the page size)")             \
 231           range(0, max_uintx)                                               \
 232                                                                             \
 233   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 234           "Use large pages if maximum heap is at least this big")           \
 235           range(0, max_uintx)                                               \
 236                                                                             \
 237   product(bool, ForceTimeHighResolution, false,                             \
 238           "Using high time resolution (for Win32 only)")                    \
 239                                                                             \
 240   develop(bool, TracePcPatching, false,                                     \
 241           "Trace usage of frame::patch_pc")                                 \
 242                                                                             \
 243   develop(bool, TraceRelocator, false,                                      \
 244           "Trace the bytecode relocator")                                   \
 245                                                                             \
 246   develop(bool, TraceLongCompiles, false,                                   \
 247           "Print out every time compilation is longer than "                \
 248           "a given threshold")                                              \
 249                                                                             \
 250   diagnostic(bool, SafepointALot, false,                                    \
 251           "Generate a lot of safepoints. This works with "                  \
 252           "GuaranteedSafepointInterval")                                    \
 253                                                                             \
 254   diagnostic(bool, HandshakeALot, false,                                    \
 255           "Generate a lot of handshakes. This works with "                  \
 256           "GuaranteedSafepointInterval")                                    \
 257                                                                             \
 258   product_pd(bool, BackgroundCompilation,                                   \
 259           "A thread requesting compilation is not blocked during "          \
 260           "compilation")                                                    \
 261                                                                             \
 262   product(bool, MethodFlushing, true,                                       \
 263           "Reclamation of zombie and not-entrant methods")                  \
 264                                                                             \
 265   develop(bool, VerifyStack, false,                                         \
 266           "Verify stack of each thread when it is entering a runtime call") \
 267                                                                             \
 268   diagnostic(bool, ForceUnreachable, false,                                 \
 269           "Make all non code cache addresses to be unreachable by "         \
 270           "forcing use of 64bit literal fixups")                            \
 271                                                                             \
 272   notproduct(bool, StressDerivedPointers, false,                            \
 273           "Force scavenge when a derived pointer is detected on stack "     \
 274           "after rtm call")                                                 \
 275                                                                             \
 276   develop(bool, TraceDerivedPointers, false,                                \
 277           "Trace traversal of derived pointers on stack")                   \
 278                                                                             \
 279   notproduct(bool, TraceCodeBlobStacks, false,                              \
 280           "Trace stack-walk of codeblobs")                                  \
 281                                                                             \
 282   notproduct(bool, PrintRewrites, false,                                    \
 283           "Print methods that are being rewritten")                         \
 284                                                                             \
 285   product(bool, UseInlineCaches, true,                                      \
 286           "Use Inline Caches for virtual calls ")                           \
 287                                                                             \
 288   diagnostic(bool, InlineArrayCopy, true,                                   \
 289           "Inline arraycopy native that is known to be part of "            \
 290           "base library DLL")                                               \
 291                                                                             \
 292   diagnostic(bool, InlineObjectHash, true,                                  \
 293           "Inline Object::hashCode() native that is known to be part "      \
 294           "of base library DLL")                                            \
 295                                                                             \
 296   diagnostic(bool, InlineNatives, true,                                     \
 297           "Inline natives that are known to be part of base library DLL")   \
 298                                                                             \
 299   diagnostic(bool, InlineMathNatives, true,                                 \
 300           "Inline SinD, CosD, etc.")                                        \
 301                                                                             \
 302   diagnostic(bool, InlineClassNatives, true,                                \
 303           "Inline Class.isInstance, etc")                                   \
 304                                                                             \
 305   diagnostic(bool, InlineThreadNatives, true,                               \
 306           "Inline Thread.currentThread, etc")                               \
 307                                                                             \
 308   diagnostic(bool, InlineUnsafeOps, true,                                   \
 309           "Inline memory ops (native methods) from Unsafe")                 \
 310                                                                             \
 311   product(bool, CriticalJNINatives, true,                                   \
 312           "Check for critical JNI entry points")                            \
 313                                                                             \
 314   notproduct(bool, StressCriticalJNINatives, false,                         \
 315           "Exercise register saving code in critical natives")              \
 316                                                                             \
 317   diagnostic(bool, UseAESIntrinsics, false,                                 \
 318           "Use intrinsics for AES versions of crypto")                      \
 319                                                                             \
 320   diagnostic(bool, UseAESCTRIntrinsics, false,                              \
 321           "Use intrinsics for the paralleled version of AES/CTR crypto")    \
 322                                                                             \
 323   diagnostic(bool, UseMD5Intrinsics, false,                                 \
 324           "Use intrinsics for MD5 crypto hash function")                    \
 325                                                                             \
 326   diagnostic(bool, UseSHA1Intrinsics, false,                                \
 327           "Use intrinsics for SHA-1 crypto hash function. "                 \
 328           "Requires that UseSHA is enabled.")                               \
 329                                                                             \
 330   diagnostic(bool, UseSHA256Intrinsics, false,                              \
 331           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions. "  \
 332           "Requires that UseSHA is enabled.")                               \
 333                                                                             \
 334   diagnostic(bool, UseSHA512Intrinsics, false,                              \
 335           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions. "  \
 336           "Requires that UseSHA is enabled.")                               \
 337                                                                             \
 338   diagnostic(bool, UseCRC32Intrinsics, false,                               \
 339           "use intrinsics for java.util.zip.CRC32")                         \
 340                                                                             \
 341   diagnostic(bool, UseCRC32CIntrinsics, false,                              \
 342           "use intrinsics for java.util.zip.CRC32C")                        \
 343                                                                             \
 344   diagnostic(bool, UseAdler32Intrinsics, false,                             \
 345           "use intrinsics for java.util.zip.Adler32")                       \
 346                                                                             \
 347   diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \
 348           "Enables intrinsification of ArraysSupport.vectorizedMismatch()") \
 349                                                                             \
 350   diagnostic(bool, UseCopySignIntrinsic, false,                             \
 351           "Enables intrinsification of Math.copySign")                      \
 352                                                                             \
 353   diagnostic(bool, UseSignumIntrinsic, false,                               \
 354           "Enables intrinsification of Math.signum")                        \
 355                                                                             \
 356   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
 357          "do not expand intrinsics whose (internal) names appear here")     \
 358                                                                             \
 359   diagnostic(ccstrlist, ControlIntrinsic, "",                               \
 360          "Control intrinsics using a list of +/- (internal) names, "        \
 361          "separated by commas")                                             \
 362                                                                             \
 363   develop(bool, TraceCallFixup, false,                                      \
 364           "Trace all call fixups")                                          \
 365                                                                             \
 366   develop(bool, DeoptimizeALot, false,                                      \
 367           "Deoptimize at every exit from the runtime system")               \
 368                                                                             \
 369   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 370           "A comma separated list of bcis to deoptimize at")                \
 371                                                                             \
 372   develop(bool, DeoptimizeRandom, false,                                    \
 373           "Deoptimize random frames on random exit from the runtime system")\
 374                                                                             \
 375   notproduct(bool, ZombieALot, false,                                       \
 376           "Create zombies (non-entrant) at exit from the runtime system")   \
 377                                                                             \
 378   notproduct(bool, WalkStackALot, false,                                    \
 379           "Trace stack (no print) at every exit from the runtime system")   \
 380                                                                             \
 381   product(bool, Debugging, false,                                           \
 382           "Set when executing debug methods in debug.cpp "                  \
 383           "(to prevent triggering assertions)")                             \
 384                                                                             \
 385   notproduct(bool, VerifyLastFrame, false,                                  \
 386           "Verify oops on last frame on entry to VM")                       \
 387                                                                             \
 388   product(bool, SafepointTimeout, false,                                    \
 389           "Time out and warn or fail after SafepointTimeoutDelay "          \
 390           "milliseconds if failed to reach safepoint")                      \
 391                                                                             \
 392   diagnostic(bool, AbortVMOnSafepointTimeout, false,                        \
 393           "Abort upon failure to reach safepoint (see SafepointTimeout)")   \
 394                                                                             \
 395   diagnostic(bool, AbortVMOnVMOperationTimeout, false,                      \
 396           "Abort upon failure to complete VM operation promptly")           \
 397                                                                             \
 398   diagnostic(intx, AbortVMOnVMOperationTimeoutDelay, 1000,                  \
 399           "Delay in milliseconds for option AbortVMOnVMOperationTimeout")   \
 400           range(0, max_intx)                                                \
 401                                                                             \
 402   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 403   /* typically, at most a few retries are needed                    */      \
 404   product(intx, SuspendRetryCount, 50,                                      \
 405           "Maximum retry count for an external suspend request")            \
 406           range(0, max_intx)                                                \
 407                                                                             \
 408   product(intx, SuspendRetryDelay, 5,                                       \
 409           "Milliseconds to delay per retry (* current_retry_count)")        \
 410           range(0, max_intx)                                                \
 411                                                                             \
 412   product(bool, AssertOnSuspendWaitFailure, false,                          \
 413           "Assert/Guarantee on external suspend wait failure")              \
 414                                                                             \
 415   product(bool, TraceSuspendWaitFailures, false,                            \
 416           "Trace external suspend wait failures")                           \
 417                                                                             \
 418   product(bool, MaxFDLimit, true,                                           \
 419           "Bump the number of file descriptors to maximum (Unix only)")     \
 420                                                                             \
 421   diagnostic(bool, LogEvents, true,                                         \
 422           "Enable the various ring buffer event logs")                      \
 423                                                                             \
 424   diagnostic(uintx, LogEventsBufferEntries, 20,                             \
 425           "Number of ring buffer event logs")                               \
 426           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 427                                                                             \
 428   diagnostic(bool, BytecodeVerificationRemote, true,                        \
 429           "Enable the Java bytecode verifier for remote classes")           \
 430                                                                             \
 431   diagnostic(bool, BytecodeVerificationLocal, false,                        \
 432           "Enable the Java bytecode verifier for local classes")            \
 433                                                                             \
 434   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 435           "Force exceptions on FP stack under/overflow")                    \
 436                                                                             \
 437   develop(bool, VerifyStackAtCalls, false,                                  \
 438           "Verify that the stack pointer is unchanged after calls")         \
 439                                                                             \
 440   develop(bool, TraceJavaAssertions, false,                                 \
 441           "Trace java language assertions")                                 \
 442                                                                             \
 443   notproduct(bool, VerifyCodeCache, false,                                  \
 444           "Verify code cache on memory allocation/deallocation")            \
 445                                                                             \
 446   develop(bool, UseMallocOnly, false,                                       \
 447           "Use only malloc/free for allocation (no resource area/arena)")   \
 448                                                                             \
 449   develop(bool, ZapResourceArea, trueInDebug,                               \
 450           "Zap freed resource/arena space with 0xABABABAB")                 \
 451                                                                             \
 452   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 453           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 454                                                                             \
 455   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 456           "Zap allocated/freed stack segments with 0xFADFADED")             \
 457                                                                             \
 458   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 459           "Zap unused heap space with 0xBAADBABE")                          \
 460                                                                             \
 461   develop(bool, CheckZapUnusedHeapArea, false,                              \
 462           "Check zapping of unused heap space")                             \
 463                                                                             \
 464   develop(bool, ZapFillerObjects, trueInDebug,                              \
 465           "Zap filler objects with 0xDEAFBABE")                             \
 466                                                                             \
 467   develop(bool, PrintVMMessages, true,                                      \
 468           "Print VM messages on console")                                   \
 469                                                                             \
 470   notproduct(uintx, ErrorHandlerTest, 0,                                    \
 471           "If &gt; 0, provokes an error after VM initialization; the value "   \
 472           "determines which error to provoke. See test_error_handler() "    \
 473           "in vmError.cpp.")                                                \
 474                                                                             \
 475   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
 476           "If &gt; 0, provokes an error inside VM error handler (a secondary " \
 477           "crash). see test_error_handler() in vmError.cpp")                \
 478                                                                             \
 479   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
 480           "If true, tests SafeFetch inside error handler.")                 \
 481                                                                             \
 482   notproduct(bool, TestUnresponsiveErrorHandler, false,                     \
 483           "If true, simulates an unresponsive error handler.")              \
 484                                                                             \
 485   develop(bool, Verbose, false,                                             \
 486           "Print additional debugging information from other modes")        \
 487                                                                             \
 488   develop(bool, PrintMiscellaneous, false,                                  \
 489           "Print uncategorized debugging information (requires +Verbose)")  \
 490                                                                             \
 491   develop(bool, WizardMode, false,                                          \
 492           "Print much more debugging information")                          \
 493                                                                             \
 494   product(bool, ShowMessageBoxOnError, false,                               \
 495           "Keep process alive on VM fatal error")                           \
 496                                                                             \
 497   product(bool, CreateCoredumpOnCrash, true,                                \
 498           "Create core/mini dump on VM fatal error")                        \
 499                                                                             \
 500   product(uint64_t, ErrorLogTimeout, 2 * 60,                                \
 501           "Timeout, in seconds, to limit the time spent on writing an "     \
 502           "error log in case of a crash.")                                  \
 503           range(0, (uint64_t)max_jlong/1000)                                \
 504                                                                             \
 505   product_pd(bool, UseOSErrorReporting,                                     \
 506           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
 507                                                                             \
 508   product(bool, SuppressFatalErrorMessage, false,                           \
 509           "Report NO fatal error message (avoid deadlock)")                 \
 510                                                                             \
 511   product(ccstrlist, OnError, "",                                           \
 512           "Run user-defined commands on fatal error; see VMError.cpp "      \
 513           "for examples")                                                   \
 514                                                                             \
 515   product(ccstrlist, OnOutOfMemoryError, "",                                \
 516           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
 517                                                                             \
 518   manageable(bool, HeapDumpBeforeFullGC, false,                             \
 519           "Dump heap to file before any major stop-the-world GC")           \
 520                                                                             \
 521   manageable(bool, HeapDumpAfterFullGC, false,                              \
 522           "Dump heap to file after any major stop-the-world GC")            \
 523                                                                             \
 524   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
 525           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
 526                                                                             \
 527   manageable(ccstr, HeapDumpPath, NULL,                                     \
 528           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
 529           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
 530           "in the working directory)")                                      \
 531                                                                             \
 532   develop(bool, BreakAtWarning, false,                                      \
 533           "Execute breakpoint upon encountering VM warning")                \
 534                                                                             \
 535   product(ccstr, NativeMemoryTracking, "off",                               \
 536           "Native memory tracking options")                                 \
 537                                                                             \
 538   diagnostic(bool, PrintNMTStatistics, false,                               \
 539           "Print native memory tracking summary data if it is on")          \
 540                                                                             \
 541   diagnostic(bool, LogCompilation, false,                                   \
 542           "Log compilation activity in detail to LogFile")                  \
 543                                                                             \
 544   product(bool, PrintCompilation, false,                                    \
 545           "Print compilations")                                             \
 546                                                                             \
 547   diagnostic(intx, RepeatCompilation, 0,                                    \
 548           "Repeat compilation without installing code (number of times)")   \
 549           range(0, max_jint)                                                 \
 550                                                                             \
 551   product(bool, PrintExtendedThreadInfo, false,                             \
 552           "Print more information in thread dump")                          \
 553                                                                             \
 554   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
 555           "0: do not allow scavengable oops in the code cache; "            \
 556           "1: allow scavenging from the code cache; "                       \
 557           "2: emit as many constants as the compiler can see")              \
 558           range(0, 2)                                                       \
 559                                                                             \
 560   product(bool, AlwaysRestoreFPU, false,                                    \
 561           "Restore the FPU control word after every JNI call (expensive)")  \
 562                                                                             \
 563   diagnostic(bool, PrintCompilation2, false,                                \
 564           "Print additional statistics per compilation")                    \
 565                                                                             \
 566   diagnostic(bool, PrintAdapterHandlers, false,                             \
 567           "Print code generated for i2c/c2i adapters")                      \
 568                                                                             \
 569   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
 570           "Verify that i2c/c2i adapters are called properly")               \
 571                                                                             \
 572   develop(bool, VerifyAdapterSharing, false,                                \
 573           "Verify that the code for shared adapters is the equivalent")     \
 574                                                                             \
 575   diagnostic(bool, PrintAssembly, false,                                    \
 576           "Print assembly code (using external disassembler.so)")           \
 577                                                                             \
 578   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
 579           "Print options string passed to disassembler.so")                 \
 580                                                                             \
 581   notproduct(bool, PrintNMethodStatistics, false,                           \
 582           "Print a summary statistic for the generated nmethods")           \
 583                                                                             \
 584   diagnostic(bool, PrintNMethods, false,                                    \
 585           "Print assembly code for nmethods when generated")                \
 586                                                                             \
 587   diagnostic(bool, PrintNativeNMethods, false,                              \
 588           "Print assembly code for native nmethods when generated")         \
 589                                                                             \
 590   develop(bool, PrintDebugInfo, false,                                      \
 591           "Print debug information for all nmethods when generated")        \
 592                                                                             \
 593   develop(bool, PrintRelocations, false,                                    \
 594           "Print relocation information for all nmethods when generated")   \
 595                                                                             \
 596   develop(bool, PrintDependencies, false,                                   \
 597           "Print dependency information for all nmethods when generated")   \
 598                                                                             \
 599   develop(bool, PrintExceptionHandlers, false,                              \
 600           "Print exception handler tables for all nmethods when generated") \
 601                                                                             \
 602   develop(bool, StressCompiledExceptionHandlers, false,                     \
 603           "Exercise compiled exception handlers")                           \
 604                                                                             \
 605   develop(bool, InterceptOSException, false,                                \
 606           "Start debugger when an implicit OS (e.g. NULL) "                 \
 607           "exception happens")                                              \
 608                                                                             \
 609   product(bool, PrintCodeCache, false,                                      \
 610           "Print the code cache memory usage when exiting")                 \
 611                                                                             \
 612   develop(bool, PrintCodeCache2, false,                                     \
 613           "Print detailed usage information on the code cache when exiting")\
 614                                                                             \
 615   product(bool, PrintCodeCacheOnCompilation, false,                         \
 616           "Print the code cache memory usage each time a method is "        \
 617           "compiled")                                                       \
 618                                                                             \
 619   diagnostic(bool, PrintCodeHeapAnalytics, false,                           \
 620           "Print code heap usage statistics on exit and on full condition") \
 621                                                                             \
 622   diagnostic(bool, PrintStubCode, false,                                    \
 623           "Print generated stub code")                                      \
 624                                                                             \
 625   product(bool, StackTraceInThrowable, true,                                \
 626           "Collect backtrace in throwable when exception happens")          \
 627                                                                             \
 628   product(bool, OmitStackTraceInFastThrow, true,                            \
 629           "Omit backtraces for some 'hot' exceptions in optimized code")    \
 630                                                                             \
 631   manageable(bool, ShowCodeDetailsInExceptionMessages, true,                \
 632           "Show exception messages from RuntimeExceptions that contain "    \
 633           "snippets of the failing code. Disable this to improve privacy.") \
 634                                                                             \
 635   product(bool, PrintWarnings, true,                                        \
 636           "Print JVM warnings to output stream")                            \
 637                                                                             \
 638   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
 639           "Print warnings for stalled SpinLocks")                           \
 640                                                                             \
 641   product(bool, RegisterFinalizersAtInit, true,                             \
 642           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
 643           "after allocation")                                               \
 644                                                                             \
 645   develop(bool, RegisterReferences, true,                                   \
 646           "Tell whether the VM should register soft/weak/final/phantom "    \
 647           "references")                                                     \
 648                                                                             \
 649   develop(bool, IgnoreRewrites, false,                                      \
 650           "Suppress rewrites of bytecodes in the oopmap generator. "        \
 651           "This is unsafe!")                                                \
 652                                                                             \
 653   develop(bool, PrintCodeCacheExtension, false,                             \
 654           "Print extension of code cache")                                  \
 655                                                                             \
 656   develop(bool, UsePrivilegedStack, true,                                   \
 657           "Enable the security JVM functions")                              \
 658                                                                             \
 659   develop(bool, ProtectionDomainVerification, true,                         \
 660           "Verify protection domain before resolution in system dictionary")\
 661                                                                             \
 662   product(bool, ClassUnloading, true,                                       \
 663           "Do unloading of classes")                                        \
 664                                                                             \
 665   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
 666           "Do unloading of classes with a concurrent marking cycle")        \
 667                                                                             \
 668   develop(bool, DisableStartThread, false,                                  \
 669           "Disable starting of additional Java threads "                    \
 670           "(for debugging only)")                                           \
 671                                                                             \
 672   develop(bool, MemProfiling, false,                                        \
 673           "Write memory usage profiling to log file")                       \
 674                                                                             \
 675   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
 676           "Print the system dictionary at exit")                            \
 677                                                                             \
 678   diagnostic(bool, DynamicallyResizeSystemDictionaries, true,               \
 679           "Dynamically resize system dictionaries as needed")               \
 680                                                                             \
 681   product(bool, AlwaysLockClassLoader, false,                               \
 682           "Require the VM to acquire the class loader lock before calling " \
 683           "loadClass() even for class loaders registering "                 \
 684           "as parallel capable")                                            \
 685                                                                             \
 686   product(bool, AllowParallelDefineClass, false,                            \
 687           "Allow parallel defineClass requests for class loaders "          \
 688           "registering as parallel capable")                                \
 689                                                                             \
 690   product_pd(bool, DontYieldALot,                                           \
 691           "Throw away obvious excess yield calls")                          \
 692                                                                             \
 693   experimental(bool, DisablePrimordialThreadGuardPages, false,              \
 694                "Disable the use of stack guard pages if the JVM is loaded " \
 695                "on the primordial process thread")                          \
 696                                                                             \
 697   /* notice: the max range value here is max_jint, not max_intx  */         \
 698   /* because of overflow issue                                   */         \
 699   diagnostic(intx, AsyncDeflationInterval, 250,                             \
 700           "Async deflate idle monitors every so many milliseconds when "    \
 701           "MonitorUsedDeflationThreshold is exceeded (0 is off).")          \
 702           range(0, max_jint)                                                \
 703                                                                             \
 704   experimental(intx, MonitorUsedDeflationThreshold, 90,                     \
 705           "Percentage of used monitors before triggering deflation (0 is "  \
 706           "off). The check is performed on GuaranteedSafepointInterval "    \
 707           "or AsyncDeflationInterval.")                                     \
 708           range(0, 100)                                                     \
 709                                                                             \
 710   experimental(intx, hashCode, 5,                                           \
 711                "(Unstable) select hashCode generation algorithm")           \
 712                                                                             \
 713   product(bool, FilterSpuriousWakeups, true,                                \
 714           "When true prevents OS-level spurious, or premature, wakeups "    \
 715           "from Object.wait (Ignored for Windows)")                         \
 716                                                                             \
 717   product(bool, ReduceSignalUsage, false,                                   \
 718           "Reduce the use of OS signals in Java and/or the VM")             \
 719                                                                             \
 720   develop(bool, LoadLineNumberTables, true,                                 \
 721           "Tell whether the class file parser loads line number tables")    \
 722                                                                             \
 723   develop(bool, LoadLocalVariableTables, true,                              \
 724           "Tell whether the class file parser loads local variable tables") \
 725                                                                             \
 726   develop(bool, LoadLocalVariableTypeTables, true,                          \
 727           "Tell whether the class file parser loads local variable type"    \
 728           "tables")                                                         \
 729                                                                             \
 730   product(bool, AllowUserSignalHandlers, false,                             \
 731           "Do not complain if the application installs signal handlers "    \
 732           "(Unix only)")                                                    \
 733                                                                             \
 734   product(bool, UseSignalChaining, true,                                    \
 735           "Use signal-chaining to invoke signal handlers installed "        \
 736           "by the application (Unix only)")                                 \
 737                                                                             \
 738   product(bool, RestoreMXCSROnJNICalls, false,                              \
 739           "Restore MXCSR when returning from JNI calls")                    \
 740                                                                             \
 741   product(bool, CheckJNICalls, false,                                       \
 742           "Verify all arguments to JNI calls")                              \
 743                                                                             \
 744   product(bool, UseFastJNIAccessors, true,                                  \
 745           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
 746                                                                             \
 747   product(intx, MaxJNILocalCapacity, 65536,                                 \
 748           "Maximum allowable local JNI handle capacity to "                 \
 749           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
 750           "where &lt;= 0 is unlimited, default: 65536")                        \
 751           range(min_intx, max_intx)                                         \
 752                                                                             \
 753   product(bool, EagerXrunInit, false,                                       \
 754           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
 755           "but not all -Xrun libraries may support the state of the VM "    \
 756           "at this time")                                                   \
 757                                                                             \
 758   product(bool, PreserveAllAnnotations, false,                              \
 759           "Preserve RuntimeInvisibleAnnotations as well "                   \
 760           "as RuntimeVisibleAnnotations")                                   \
 761                                                                             \
 762   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
 763           "Number of OutOfMemoryErrors preallocated with backtrace")        \
 764                                                                             \
 765   product(bool, UseXMMForArrayCopy, false,                                  \
 766           "Use SSE2 MOVQ instruction for Arraycopy")                        \
 767                                                                             \
 768   notproduct(bool, PrintFieldLayout, false,                                 \
 769           "Print field layout for each class")                              \
 770                                                                             \
 771   /* Need to limit the extent of the padding to reasonable size.          */\
 772   /* 8K is well beyond the reasonable HW cache line size, even with       */\
 773   /* aggressive prefetching, while still leaving the room for segregating */\
 774   /* among the distinct pages.                                            */\
 775   product(intx, ContendedPaddingWidth, 128,                                 \
 776           "How many bytes to pad the fields/classes marked @Contended with")\
 777           range(0, 8192)                                                    \
 778           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
 779                                                                             \
 780   product(bool, EnableContended, true,                                      \
 781           "Enable @Contended annotation support")                           \
 782                                                                             \
 783   product(bool, RestrictContended, true,                                    \
 784           "Restrict @Contended to trusted classes")                         \
 785                                                                             \
 786   product(bool, UseBiasedLocking, false,                                    \
 787           "(Deprecated) Enable biased locking in JVM")                      \
 788                                                                             \
 789   product(intx, BiasedLockingStartupDelay, 0,                               \
 790           "(Deprecated) Number of milliseconds to wait before enabling "    \
 791           "biased locking")                                                 \
 792           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
 793           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
 794                                                                             \
 795   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
 796           "(Deprecated) Print statistics of biased locking in JVM")         \
 797                                                                             \
 798   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
 799           "(Deprecated) Threshold of number of revocations per type to "    \
 800           "try to rebias all objects in the heap of that type")             \
 801           range(0, max_intx)                                                \
 802           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
 803                                                                             \
 804   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
 805           "(Deprecated) Threshold of number of revocations per type to "    \
 806           "permanently revoke biases of all objects in the heap of that "   \
 807           "type")                                                           \
 808           range(0, max_intx)                                                \
 809           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
 810                                                                             \
 811   product(intx, BiasedLockingDecayTime, 25000,                              \
 812           "(Deprecated) Decay time (in milliseconds) to re-enable bulk "    \
 813           "rebiasing of a type after previous bulk rebias")                 \
 814           range(500, max_intx)                                              \
 815           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
 816                                                                             \
 817   diagnostic(intx, DiagnoseSyncOnPrimitiveWrappers, 0,                      \
 818              "Detect and take action upon identifying synchronization on "  \
 819              "primitive wrappers. Modes: "                                  \
 820              "0: off; "                                                     \
 821              "1: exit with fatal error; "                                   \
 822              "2: log message to stdout. Output file can be specified with " \
 823              "   -Xlog:primitivewrappers. If JFR is running it will "       \
 824              "   also generate JFR events.")                                \
 825              range(0, 2)                                                    \
 826                                                                             \
 827   product(bool, ExitOnOutOfMemoryError, false,                              \
 828           "JVM exits on the first occurrence of an out-of-memory error")    \
 829                                                                             \
 830   product(bool, CrashOnOutOfMemoryError, false,                             \
 831           "JVM aborts, producing an error log and core/mini dump, on the "  \
 832           "first occurrence of an out-of-memory error")                     \
 833                                                                             \
 834   /* tracing */                                                             \
 835                                                                             \
 836   develop(bool, StressRewriter, false,                                      \
 837           "Stress linktime bytecode rewriting")                             \
 838                                                                             \
 839   product(ccstr, TraceJVMTI, NULL,                                          \
 840           "Trace flags for JVMTI functions and events")                     \
 841                                                                             \
 842   /* This option can change an EMCP method into an obsolete method. */      \
 843   /* This can affect tests that except specific methods to be EMCP. */      \
 844   /* This option should be used with caution.                       */      \
 845   product(bool, StressLdcRewrite, false,                                    \
 846           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
 847                                                                             \
 848   /* change to false by default sometime after Mustang */                   \
 849   product(bool, VerifyMergedCPBytecodes, true,                              \
 850           "Verify bytecodes after RedefineClasses constant pool merging")   \
 851                                                                             \
 852   product(bool, AllowRedefinitionToAddDeleteMethods, false,                 \
 853           "(Deprecated) Allow redefinition to add and delete private "      \
 854           "static or final methods for compatibility with old releases")    \
 855                                                                             \
 856   develop(bool, TraceBytecodes, false,                                      \
 857           "Trace bytecode execution")                                       \
 858                                                                             \
 859   develop(bool, TraceICs, false,                                            \
 860           "Trace inline cache changes")                                     \
 861                                                                             \
 862   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
 863           "Trace method invocation counter overflow")                       \
 864                                                                             \
 865   develop(bool, TraceInlineCacheClearing, false,                            \
 866           "Trace clearing of inline caches in nmethods")                    \
 867                                                                             \
 868   develop(bool, TraceDependencies, false,                                   \
 869           "Trace dependencies")                                             \
 870                                                                             \
 871   develop(bool, VerifyDependencies, trueInDebug,                            \
 872           "Exercise and verify the compilation dependency mechanism")       \
 873                                                                             \
 874   develop(bool, TraceNewOopMapGeneration, false,                            \
 875           "Trace OopMapGeneration")                                         \
 876                                                                             \
 877   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
 878           "Trace OopMapGeneration: print detailed cell states")             \
 879                                                                             \
 880   develop(bool, TimeOopMap, false,                                          \
 881           "Time calls to GenerateOopMap::compute_map() in sum")             \
 882                                                                             \
 883   develop(bool, TimeOopMap2, false,                                         \
 884           "Time calls to GenerateOopMap::compute_map() individually")       \
 885                                                                             \
 886   develop(bool, TraceOopMapRewrites, false,                                 \
 887           "Trace rewriting of methods during oop map generation")           \
 888                                                                             \
 889   develop(bool, TraceICBuffer, false,                                       \
 890           "Trace usage of IC buffer")                                       \
 891                                                                             \
 892   develop(bool, TraceCompiledIC, false,                                     \
 893           "Trace changes of compiled IC")                                   \
 894                                                                             \
 895   develop(bool, FLSVerifyDictionary, false,                                 \
 896           "Do lots of (expensive) FLS dictionary verification")             \
 897                                                                             \
 898                                                                             \
 899   notproduct(bool, CheckMemoryInitialization, false,                        \
 900           "Check memory initialization")                                    \
 901                                                                             \
 902   product(uintx, ProcessDistributionStride, 4,                              \
 903           "Stride through processors when distributing processes")          \
 904           range(0, max_juint)                                               \
 905                                                                             \
 906   develop(bool, TraceFinalizerRegistration, false,                          \
 907           "Trace registration of final references")                         \
 908                                                                             \
 909   product(bool, IgnoreEmptyClassPaths, false,                               \
 910           "Ignore empty path elements in -classpath")                       \
 911                                                                             \
 912   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
 913           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
 914           "(Deprecated) Initial size of the boot class loader data metaspace") \
 915           range(30*K, max_uintx/BytesPerWord)                               \
<a name="1" id="anc1"></a>
 916                                                                             \
 917   product(bool, PrintHeapAtSIGBREAK, true,                                  \
 918           "Print heap layout in response to SIGBREAK")                      \
 919                                                                             \
 920   manageable(bool, PrintClassHistogram, false,                              \
 921           "Print a histogram of class instances")                           \
 922                                                                             \
 923   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
 924           "The percentage of the used heap that the instances of a class "  \
 925           "must occupy for the class to generate a trace event")            \
 926           range(0.0, 100.0)                                                 \
 927                                                                             \
 928   /* JVMTI heap profiling */                                                \
 929                                                                             \
 930   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
 931           "Trace JVMTI object tagging calls")                               \
 932                                                                             \
 933   diagnostic(bool, VerifyBeforeIteration, false,                            \
 934           "Verify memory system before JVMTI iteration")                    \
 935                                                                             \
 936   /* compiler interface */                                                  \
 937                                                                             \
 938   develop(bool, CIPrintCompilerName, false,                                 \
 939           "when CIPrint is active, print the name of the active compiler")  \
 940                                                                             \
 941   diagnostic(bool, CIPrintCompileQueue, false,                              \
 942           "display the contents of the compile queue whenever a "           \
 943           "compilation is enqueued")                                        \
 944                                                                             \
 945   develop(bool, CIPrintRequests, false,                                     \
 946           "display every request for compilation")                          \
 947                                                                             \
 948   product(bool, CITime, false,                                              \
 949           "collect timing information for compilation")                     \
 950                                                                             \
 951   develop(bool, CITimeVerbose, false,                                       \
 952           "be more verbose in compilation timings")                         \
 953                                                                             \
 954   develop(bool, CITimeEach, false,                                          \
 955           "display timing information after each successful compilation")   \
 956                                                                             \
 957   develop(bool, CICountOSR, false,                                          \
 958           "use a separate counter when assigning ids to osr compilations")  \
 959                                                                             \
 960   develop(bool, CICompileNatives, true,                                     \
 961           "compile native methods if supported by the compiler")            \
 962                                                                             \
 963   develop_pd(bool, CICompileOSR,                                            \
 964           "compile on stack replacement methods if supported by the "       \
 965           "compiler")                                                       \
 966                                                                             \
 967   develop(bool, CIPrintMethodCodes, false,                                  \
 968           "print method bytecodes of the compiled code")                    \
 969                                                                             \
 970   develop(bool, CIPrintTypeFlow, false,                                     \
 971           "print the results of ciTypeFlow analysis")                       \
 972                                                                             \
 973   develop(bool, CITraceTypeFlow, false,                                     \
 974           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
 975                                                                             \
 976   develop(intx, OSROnlyBCI, -1,                                             \
 977           "OSR only at this bci.  Negative values mean exclude that bci")   \
 978                                                                             \
 979   /* compiler */                                                            \
 980                                                                             \
 981   /* notice: the max range value here is max_jint, not max_intx  */         \
 982   /* because of overflow issue                                   */         \
 983   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
 984           "Number of compiler threads to run")                              \
 985           range(0, max_jint)                                                \
 986           constraint(CICompilerCountConstraintFunc, AfterErgo)              \
 987                                                                             \
 988   product(bool, UseDynamicNumberOfCompilerThreads, true,                    \
 989           "Dynamically choose the number of parallel compiler threads")     \
 990                                                                             \
 991   diagnostic(bool, ReduceNumberOfCompilerThreads, true,                     \
 992              "Reduce the number of parallel compiler threads when they "    \
 993              "are not used")                                                \
 994                                                                             \
 995   diagnostic(bool, TraceCompilerThreads, false,                             \
 996              "Trace creation and removal of compiler threads")              \
 997                                                                             \
 998   develop(bool, InjectCompilerCreationFailure, false,                       \
 999           "Inject thread creation failures for "                            \
1000           "UseDynamicNumberOfCompilerThreads")                              \
1001                                                                             \
1002   develop(bool, UseStackBanging, true,                                      \
1003           "use stack banging for stack overflow checks (required for "      \
1004           "proper StackOverflow handling; disable only to measure cost "    \
1005           "of stackbanging)")                                               \
1006                                                                             \
1007   develop(bool, GenerateSynchronizationCode, true,                          \
1008           "generate locking/unlocking code for synchronized methods and "   \
1009           "monitors")                                                       \
1010                                                                             \
1011   develop(bool, GenerateRangeChecks, true,                                  \
1012           "Generate range checks for array accesses")                       \
1013                                                                             \
1014   diagnostic_pd(bool, ImplicitNullChecks,                                   \
1015           "Generate code for implicit null checks")                         \
1016                                                                             \
1017   product_pd(bool, TrapBasedNullChecks,                                     \
1018           "Generate code for null checks that uses a cmp and trap "         \
1019           "instruction raising SIGTRAP.  This is only used if an access to" \
1020           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
1021           "ImplicitNullChecks don't work (PPC64).")                         \
1022                                                                             \
1023   diagnostic(bool, EnableThreadSMRExtraValidityChecks, true,                \
1024              "Enable Thread SMR extra validity checks")                     \
1025                                                                             \
1026   diagnostic(bool, EnableThreadSMRStatistics, trueInDebug,                  \
1027              "Enable Thread SMR Statistics")                                \
1028                                                                             \
1029   product(bool, UseNotificationThread, true,                                \
1030           "Use Notification Thread")                                        \
1031                                                                             \
1032   product(bool, Inline, true,                                               \
1033           "Enable inlining")                                                \
1034                                                                             \
1035   product(bool, ClipInlining, true,                                         \
1036           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
1037                                                                             \
1038   develop(bool, UseCHA, true,                                               \
1039           "Enable CHA")                                                     \
1040                                                                             \
1041   product(bool, UseTypeProfile, true,                                       \
1042           "Check interpreter profile for historically monomorphic calls")   \
1043                                                                             \
1044   diagnostic(bool, PrintInlining, false,                                    \
1045           "Print inlining optimizations")                                   \
1046                                                                             \
1047   product(bool, UsePopCountInstruction, false,                              \
1048           "Use population count instruction")                               \
1049                                                                             \
1050   develop(bool, EagerInitialization, false,                                 \
1051           "Eagerly initialize classes if possible")                         \
1052                                                                             \
1053   diagnostic(bool, LogTouchedMethods, false,                                \
1054           "Log methods which have been ever touched in runtime")            \
1055                                                                             \
1056   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
1057           "Print all methods that have been ever touched in runtime")       \
1058                                                                             \
1059   develop(bool, TraceMethodReplacement, false,                              \
1060           "Print when methods are replaced do to recompilation")            \
1061                                                                             \
1062   develop(bool, PrintMethodFlushing, false,                                 \
1063           "Print the nmethods being flushed")                               \
1064                                                                             \
1065   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
1066           "print statistics about method flushing")                         \
1067                                                                             \
1068   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
1069           "Number of compiled code invocations after which "                \
1070           "the method is considered as hot by the flusher")                 \
1071           range(1, max_jint)                                                \
1072                                                                             \
1073   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
1074           "Minimum number of sweeper passes before an nmethod "             \
1075           "can be flushed")                                                 \
1076           range(0, max_intx)                                                \
1077                                                                             \
1078   product(bool, UseCodeAging, true,                                         \
1079           "Insert counter to detect warm methods")                          \
1080                                                                             \
1081   diagnostic(bool, StressCodeAging, false,                                  \
1082           "Start with counters compiled in")                                \
1083                                                                             \
1084   develop(bool, StressCodeBuffers, false,                                   \
1085           "Exercise code buffer expansion and other rare state changes")    \
1086                                                                             \
1087   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
1088           "Generate extra debugging information for non-safepoints in "     \
1089           "nmethods")                                                       \
1090                                                                             \
1091   product(bool, PrintVMOptions, false,                                      \
1092           "Print flags that appeared on the command line")                  \
1093                                                                             \
1094   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
1095           "Ignore unrecognized VM options")                                 \
1096                                                                             \
1097   product(bool, PrintCommandLineFlags, false,                               \
1098           "Print flags specified on command line or set by ergonomics")     \
1099                                                                             \
1100   product(bool, PrintFlagsInitial, false,                                   \
1101           "Print all VM flags before argument processing and exit VM")      \
1102                                                                             \
1103   product(bool, PrintFlagsFinal, false,                                     \
1104           "Print all VM flags after argument and ergonomic processing")     \
1105                                                                             \
1106   notproduct(bool, PrintFlagsWithComments, false,                           \
1107           "Print all VM flags with default values and descriptions and "    \
1108           "exit")                                                           \
1109                                                                             \
1110   product(bool, PrintFlagsRanges, false,                                    \
1111           "Print VM flags and their ranges")                                \
1112                                                                             \
1113   diagnostic(bool, SerializeVMOutput, true,                                 \
1114           "Use a mutex to serialize output to tty and LogFile")             \
1115                                                                             \
1116   diagnostic(bool, DisplayVMOutput, true,                                   \
1117           "Display all VM output on the tty, independently of LogVMOutput") \
1118                                                                             \
1119   diagnostic(bool, LogVMOutput, false,                                      \
1120           "Save VM output to LogFile")                                      \
1121                                                                             \
1122   diagnostic(ccstr, LogFile, NULL,                                          \
1123           "If LogVMOutput or LogCompilation is on, save VM output to "      \
1124           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
1125                                                                             \
1126   product(ccstr, ErrorFile, NULL,                                           \
1127           "If an error occurs, save the error data to this file "           \
1128           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
1129                                                                             \
1130   product(bool, ExtensiveErrorReports,                                      \
1131           PRODUCT_ONLY(false) NOT_PRODUCT(true),                            \
1132           "Error reports are more extensive.")                              \
1133                                                                             \
1134   product(bool, DisplayVMOutputToStderr, false,                             \
1135           "If DisplayVMOutput is true, display all VM output to stderr")    \
1136                                                                             \
1137   product(bool, DisplayVMOutputToStdout, false,                             \
1138           "If DisplayVMOutput is true, display all VM output to stdout")    \
1139                                                                             \
1140   product(bool, ErrorFileToStderr, false,                                   \
1141           "If true, error data is printed to stderr instead of a file")     \
1142                                                                             \
1143   product(bool, ErrorFileToStdout, false,                                   \
1144           "If true, error data is printed to stdout instead of a file")     \
1145                                                                             \
1146   product(bool, UseHeavyMonitors, false,                                    \
1147           "use heavyweight instead of lightweight Java monitors")           \
1148                                                                             \
1149   product(bool, PrintStringTableStatistics, false,                          \
1150           "print statistics about the StringTable and SymbolTable")         \
1151                                                                             \
1152   diagnostic(bool, VerifyStringTableAtExit, false,                          \
1153           "verify StringTable contents at exit")                            \
1154                                                                             \
1155   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
1156           "print histogram of the symbol table")                            \
1157                                                                             \
1158   notproduct(bool, ExitVMOnVerifyError, false,                              \
1159           "standard exit from VM if bytecode verify error "                 \
1160           "(only in debug mode)")                                           \
1161                                                                             \
1162   diagnostic(ccstr, AbortVMOnException, NULL,                               \
1163           "Call fatal if this exception is thrown.  Example: "              \
1164           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
1165                                                                             \
1166   diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \
1167           "Call fatal if the exception pointed by AbortVMOnException "      \
1168           "has this message")                                               \
1169                                                                             \
1170   develop(bool, DebugVtables, false,                                        \
1171           "add debugging code to vtable dispatch")                          \
1172                                                                             \
1173   notproduct(bool, PrintVtableStats, false,                                 \
1174           "print vtables stats at end of run")                              \
1175                                                                             \
1176   develop(bool, TraceCreateZombies, false,                                  \
1177           "trace creation of zombie nmethods")                              \
1178                                                                             \
1179   product(bool, RangeCheckElimination, true,                                \
1180           "Eliminate range checks")                                         \
1181                                                                             \
1182   develop_pd(bool, UncommonNullCast,                                        \
1183           "track occurrences of null in casts; adjust compiler tactics")    \
1184                                                                             \
1185   develop(bool, TypeProfileCasts,  true,                                    \
1186           "treat casts like calls for purposes of type profiling")          \
1187                                                                             \
1188   develop(bool, TraceLivenessGen, false,                                    \
1189           "Trace the generation of liveness analysis information")          \
1190                                                                             \
1191   notproduct(bool, TraceLivenessQuery, false,                               \
1192           "Trace queries of liveness analysis information")                 \
1193                                                                             \
1194   notproduct(bool, CollectIndexSetStatistics, false,                        \
1195           "Collect information about IndexSets")                            \
1196                                                                             \
1197   develop(bool, UseLoopSafepoints, true,                                    \
1198           "Generate Safepoint nodes in every loop")                         \
1199                                                                             \
1200   develop(intx, FastAllocateSizeLimit, 128*K,                               \
1201           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
1202           "Inline allocations larger than this in doublewords must go slow")\
1203                                                                             \
1204   product_pd(bool, CompactStrings,                                          \
1205           "Enable Strings to use single byte chars in backing store")       \
1206                                                                             \
1207   product_pd(uintx, TypeProfileLevel,                                       \
1208           "=XYZ, with Z: Type profiling of arguments at call; "             \
1209                      "Y: Type profiling of return value at call; "          \
1210                      "X: Type profiling of parameters to methods; "         \
1211           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
1212           constraint(TypeProfileLevelConstraintFunc, AfterErgo)             \
1213                                                                             \
1214   product(intx, TypeProfileArgsLimit,     2,                                \
1215           "max number of call arguments to consider for type profiling")    \
1216           range(0, 16)                                                      \
1217                                                                             \
1218   product(intx, TypeProfileParmsLimit,    2,                                \
1219           "max number of incoming parameters to consider for type profiling"\
1220           ", -1 for all")                                                   \
1221           range(-1, 64)                                                     \
1222                                                                             \
1223   /* statistics */                                                          \
1224   develop(bool, CountCompiledCalls, false,                                  \
1225           "Count method invocations")                                       \
1226                                                                             \
1227   notproduct(bool, CountRuntimeCalls, false,                                \
1228           "Count VM runtime calls")                                         \
1229                                                                             \
1230   develop(bool, CountJNICalls, false,                                       \
1231           "Count jni method invocations")                                   \
1232                                                                             \
1233   notproduct(bool, CountJVMCalls, false,                                    \
1234           "Count jvm method invocations")                                   \
1235                                                                             \
1236   notproduct(bool, CountRemovableExceptions, false,                         \
1237           "Count exceptions that could be replaced by branches due to "     \
1238           "inlining")                                                       \
1239                                                                             \
1240   notproduct(bool, ICMissHistogram, false,                                  \
1241           "Produce histogram of IC misses")                                 \
1242                                                                             \
1243   /* interpreter */                                                         \
1244   product_pd(bool, RewriteBytecodes,                                        \
1245           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
1246                                                                             \
1247   product_pd(bool, RewriteFrequentPairs,                                    \
1248           "Rewrite frequently used bytecode pairs into a single bytecode")  \
1249                                                                             \
1250   diagnostic(bool, PrintInterpreter, false,                                 \
1251           "Print the generated interpreter code")                           \
1252                                                                             \
1253   product(bool, UseInterpreter, true,                                       \
1254           "Use interpreter for non-compiled methods")                       \
1255                                                                             \
1256   develop(bool, UseFastSignatureHandlers, true,                             \
1257           "Use fast signature handlers for native calls")                   \
1258                                                                             \
1259   product(bool, UseLoopCounter, true,                                       \
1260           "Increment invocation counter on backward branch")                \
1261                                                                             \
1262   product_pd(bool, UseOnStackReplacement,                                   \
1263           "Use on stack replacement, calls runtime if invoc. counter "      \
1264           "overflows in loop")                                              \
1265                                                                             \
1266   notproduct(bool, TraceOnStackReplacement, false,                          \
1267           "Trace on stack replacement")                                     \
1268                                                                             \
1269   product_pd(bool, PreferInterpreterNativeStubs,                            \
1270           "Use always interpreter stubs for native methods invoked via "    \
1271           "interpreter")                                                    \
1272                                                                             \
1273   develop(bool, CountBytecodes, false,                                      \
1274           "Count number of bytecodes executed")                             \
1275                                                                             \
1276   develop(bool, PrintBytecodeHistogram, false,                              \
1277           "Print histogram of the executed bytecodes")                      \
1278                                                                             \
1279   develop(bool, PrintBytecodePairHistogram, false,                          \
1280           "Print histogram of the executed bytecode pairs")                 \
1281                                                                             \
1282   diagnostic(bool, PrintSignatureHandlers, false,                           \
1283           "Print code generated for native method signature handlers")      \
1284                                                                             \
1285   develop(bool, VerifyOops, false,                                          \
1286           "Do plausibility checks for oops")                                \
1287                                                                             \
1288   develop(bool, CheckUnhandledOops, false,                                  \
1289           "Check for unhandled oops in VM code")                            \
1290                                                                             \
1291   develop(bool, VerifyJNIFields, trueInDebug,                               \
1292           "Verify jfieldIDs for instance fields")                           \
1293                                                                             \
1294   notproduct(bool, VerifyJNIEnvThread, false,                               \
1295           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
1296           "from JNI")                                                       \
1297                                                                             \
1298   develop(bool, VerifyFPU, false,                                           \
1299           "Verify FPU state (check for NaN's, etc.)")                       \
1300                                                                             \
1301   develop(bool, VerifyThread, false,                                        \
1302           "Watch the thread register for corruption (SPARC only)")          \
1303                                                                             \
1304   develop(bool, VerifyActivationFrameSize, false,                           \
1305           "Verify that activation frame didn't become smaller than its "    \
1306           "minimal size")                                                   \
1307                                                                             \
1308   develop(bool, TraceFrequencyInlining, false,                              \
1309           "Trace frequency based inlining")                                 \
1310                                                                             \
1311   develop_pd(bool, InlineIntrinsics,                                        \
1312           "Inline intrinsics that can be statically resolved")              \
1313                                                                             \
1314   product_pd(bool, ProfileInterpreter,                                      \
1315           "Profile at the bytecode level during interpretation")            \
1316                                                                             \
1317   develop(bool, TraceProfileInterpreter, false,                             \
1318           "Trace profiling at the bytecode level during interpretation. "   \
1319           "This outputs the profiling information collected to improve "    \
1320           "jit compilation.")                                               \
1321                                                                             \
1322   develop_pd(bool, ProfileTraps,                                            \
1323           "Profile deoptimization traps at the bytecode level")             \
1324                                                                             \
1325   product(intx, ProfileMaturityPercentage, 20,                              \
1326           "number of method invocations/branches (expressed as % of "       \
1327           "CompileThreshold) before using the method's profile")            \
1328           range(0, 100)                                                     \
1329                                                                             \
1330   diagnostic(bool, PrintMethodData, false,                                  \
1331           "Print the results of +ProfileInterpreter at end of run")         \
1332                                                                             \
1333   develop(bool, VerifyDataPointer, trueInDebug,                             \
1334           "Verify the method data pointer during interpreter profiling")    \
1335                                                                             \
1336   develop(bool, VerifyCompiledCode, false,                                  \
1337           "Include miscellaneous runtime verifications in nmethod code; "   \
1338           "default off because it disturbs nmethod size heuristics")        \
1339                                                                             \
1340   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
1341           "Manually make GC thread crash then dump java stack trace;  "     \
1342           "Test only")                                                      \
1343                                                                             \
1344   /* compilation */                                                         \
1345   product(bool, UseCompiler, true,                                          \
1346           "Use Just-In-Time compilation")                                   \
1347                                                                             \
1348   product(bool, UseCounterDecay, true,                                      \
1349           "Adjust recompilation counters")                                  \
1350                                                                             \
1351   develop(intx, CounterHalfLifeTime,    30,                                 \
1352           "Half-life time of invocation counters (in seconds)")             \
1353                                                                             \
1354   develop(intx, CounterDecayMinIntervalLength,   500,                       \
1355           "The minimum interval (in milliseconds) between invocation of "   \
1356           "CounterDecay")                                                   \
1357                                                                             \
1358   product(bool, AlwaysCompileLoopMethods, false,                            \
1359           "When using recompilation, never interpret methods "              \
1360           "containing loops")                                               \
1361                                                                             \
1362   product(bool, DontCompileHugeMethods, true,                               \
1363           "Do not compile methods &gt; HugeMethodLimit")                       \
1364                                                                             \
1365   /* Bytecode escape analysis estimation. */                                \
1366   product(bool, EstimateArgEscape, true,                                    \
1367           "Analyze bytecodes to estimate escape state of arguments")        \
1368                                                                             \
1369   product(intx, BCEATraceLevel, 0,                                          \
1370           "How much tracing to do of bytecode escape analysis estimates "   \
1371           "(0-3)")                                                          \
1372           range(0, 3)                                                       \
1373                                                                             \
1374   product(intx, MaxBCEAEstimateLevel, 5,                                    \
1375           "Maximum number of nested calls that are analyzed by BC EA")      \
1376           range(0, max_jint)                                                \
1377                                                                             \
1378   product(intx, MaxBCEAEstimateSize, 150,                                   \
1379           "Maximum bytecode size of a method to be analyzed by BC EA")      \
1380           range(0, max_jint)                                                \
1381                                                                             \
1382   product(intx,  AllocatePrefetchStyle, 1,                                  \
1383           "0 = no prefetch, "                                               \
1384           "1 = generate prefetch instructions for each allocation, "        \
1385           "2 = use TLAB watermark to gate allocation prefetch, "            \
1386           "3 = generate one prefetch instruction per cache line")           \
1387           range(0, 3)                                                       \
1388                                                                             \
1389   product(intx,  AllocatePrefetchDistance, -1,                              \
1390           "Distance to prefetch ahead of allocation pointer. "              \
1391           "-1: use system-specific value (automatically determined")        \
1392           constraint(AllocatePrefetchDistanceConstraintFunc,AfterMemoryInit)\
1393                                                                             \
1394   product(intx,  AllocatePrefetchLines, 3,                                  \
1395           "Number of lines to prefetch ahead of array allocation pointer")  \
1396           range(1, 64)                                                      \
1397                                                                             \
1398   product(intx,  AllocateInstancePrefetchLines, 1,                          \
1399           "Number of lines to prefetch ahead of instance allocation "       \
1400           "pointer")                                                        \
1401           range(1, 64)                                                      \
1402                                                                             \
1403   product(intx,  AllocatePrefetchStepSize, 16,                              \
1404           "Step size in bytes of sequential prefetch instructions")         \
1405           range(1, 512)                                                     \
1406           constraint(AllocatePrefetchStepSizeConstraintFunc,AfterMemoryInit)\
1407                                                                             \
1408   product(intx,  AllocatePrefetchInstr, 0,                                  \
1409           "Select instruction to prefetch ahead of allocation pointer")     \
1410           constraint(AllocatePrefetchInstrConstraintFunc, AfterMemoryInit)  \
1411                                                                             \
1412   /* deoptimization */                                                      \
1413   develop(bool, TraceDeoptimization, false,                                 \
1414           "Trace deoptimization")                                           \
1415                                                                             \
1416   develop(bool, PrintDeoptimizationDetails, false,                          \
1417           "Print more information about deoptimization")                    \
1418                                                                             \
1419   develop(bool, DebugDeoptimization, false,                                 \
1420           "Tracing various information while debugging deoptimization")     \
1421                                                                             \
1422   product(intx, SelfDestructTimer, 0,                                       \
1423           "Will cause VM to terminate after a given time (in minutes) "     \
1424           "(0 means off)")                                                  \
1425           range(0, max_intx)                                                \
1426                                                                             \
1427   product(intx, MaxJavaStackTraceDepth, 1024,                               \
1428           "The maximum number of lines in the stack trace for Java "        \
1429           "exceptions (0 means all)")                                       \
1430           range(0, max_jint/2)                                              \
1431                                                                             \
1432   /* notice: the max range value here is max_jint, not max_intx  */         \
1433   /* because of overflow issue                                   */         \
1434   diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \
1435           "Guarantee a safepoint (at least) every so many milliseconds "    \
1436           "(0 means none)")                                                 \
1437           range(0, max_jint)                                                \
1438                                                                             \
1439   product(intx, SafepointTimeoutDelay, 10000,                               \
1440           "Delay in milliseconds for option SafepointTimeout")              \
1441   LP64_ONLY(range(0, max_intx/MICROUNITS))                                  \
1442   NOT_LP64(range(0, max_intx))                                              \
1443                                                                             \
1444   product(intx, NmethodSweepActivity, 10,                                   \
1445           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
1446           "result in more aggressive sweeping")                             \
1447           range(0, 2000)                                                    \
1448                                                                             \
1449   notproduct(bool, LogSweeper, false,                                       \
1450           "Keep a ring buffer of sweeper activity")                         \
1451                                                                             \
1452   notproduct(intx, SweeperLogEntries, 1024,                                 \
1453           "Number of records in the ring buffer of sweeper activity")       \
1454                                                                             \
1455   notproduct(intx, MemProfilingInterval, 500,                               \
1456           "Time between each invocation of the MemProfiler")                \
1457                                                                             \
1458   develop(intx, MallocCatchPtr, -1,                                         \
1459           "Hit breakpoint when mallocing/freeing this pointer")             \
1460                                                                             \
1461   notproduct(ccstrlist, SuppressErrorAt, "",                                \
1462           "List of assertions (file:line) to muzzle")                       \
1463                                                                             \
1464   develop(intx, StackPrintLimit, 100,                                       \
1465           "number of stack frames to print in VM-level stack dump")         \
1466                                                                             \
1467   notproduct(intx, MaxElementPrintSize, 256,                                \
1468           "maximum number of elements to print")                            \
1469                                                                             \
1470   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
1471           "maximum number of subklasses to print when printing klass")      \
1472                                                                             \
1473   develop(intx, MaxForceInlineLevel, 100,                                   \
1474           "maximum number of nested calls that are forced for inlining "    \
1475           "(using CompileCommand or marked w/ @ForceInline)")               \
1476           range(0, max_jint)                                                \
1477                                                                             \
1478   product(intx, MinInliningThreshold, 250,                                  \
1479           "The minimum invocation count a method needs to have to be "      \
1480           "inlined")                                                        \
1481           range(0, max_jint)                                                \
1482                                                                             \
1483   develop(intx, MethodHistogramCutoff, 100,                                 \
1484           "The cutoff value for method invocation histogram (+CountCalls)") \
1485                                                                             \
1486   develop(intx, DontYieldALotInterval,    10,                               \
1487           "Interval between which yields will be dropped (milliseconds)")   \
1488                                                                             \
1489   notproduct(intx, DeoptimizeALotInterval,     5,                           \
1490           "Number of exits until DeoptimizeALot kicks in")                  \
1491                                                                             \
1492   notproduct(intx, ZombieALotInterval,     5,                               \
1493           "Number of exits until ZombieALot kicks in")                      \
1494                                                                             \
1495   diagnostic(uintx, MallocMaxTestWords,     0,                              \
1496           "If non-zero, maximum number of words that malloc/realloc can "   \
1497           "allocate (for testing only)")                                    \
1498           range(0, max_uintx)                                               \
1499                                                                             \
1500   product(intx, TypeProfileWidth, 2,                                        \
1501           "Number of receiver types to record in call/cast profile")        \
1502           range(0, 8)                                                       \
1503                                                                             \
1504   develop(intx, BciProfileWidth,      2,                                    \
1505           "Number of return bci's to record in ret profile")                \
1506                                                                             \
1507   product(intx, PerMethodRecompilationCutoff, 400,                          \
1508           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
1509           range(-1, max_intx)                                               \
1510                                                                             \
1511   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
1512           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
1513           range(-1, max_intx)                                               \
1514                                                                             \
1515   product(intx, PerMethodTrapLimit,  100,                                   \
1516           "Limit on traps (of one kind) in a method (includes inlines)")    \
1517           range(0, max_jint)                                                \
1518                                                                             \
1519   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
1520           "Limit on speculative traps (of one kind) in a method "           \
1521           "(includes inlines)")                                             \
1522           range(0, max_jint)                                                \
1523                                                                             \
1524   product(intx, PerBytecodeTrapLimit,  4,                                   \
1525           "Limit on traps (of one kind) at a particular BCI")               \
1526           range(0, max_jint)                                                \
1527                                                                             \
1528   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
1529           "Extra method data trap entries for speculation")                 \
1530                                                                             \
1531   develop(intx, InlineFrequencyRatio,    20,                                \
1532           "Ratio of call site execution to caller method invocation")       \
1533           range(0, max_jint)                                                \
1534                                                                             \
1535   diagnostic_pd(intx, InlineFrequencyCount,                                 \
1536           "Count of call site execution necessary to trigger frequent "     \
1537           "inlining")                                                       \
1538           range(0, max_jint)                                                \
1539                                                                             \
1540   develop(intx, InlineThrowCount,    50,                                    \
1541           "Force inlining of interpreted methods that throw this often")    \
1542           range(0, max_jint)                                                \
1543                                                                             \
1544   develop(intx, InlineThrowMaxSize,   200,                                  \
1545           "Force inlining of throwing methods smaller than this")           \
1546           range(0, max_jint)                                                \
1547                                                                             \
1548   develop(intx, ProfilerNodeSize,  1024,                                    \
1549           "Size in K to allocate for the Profile Nodes of each thread")     \
1550           range(0, 1024)                                                    \
1551                                                                             \
1552   product_pd(size_t, MetaspaceSize,                                         \
1553           "Initial threshold (in bytes) at which a garbage collection "     \
1554           "is done to reduce Metaspace usage")                              \
1555           constraint(MetaspaceSizeConstraintFunc,AfterErgo)                 \
1556                                                                             \
1557   product(size_t, MaxMetaspaceSize, max_uintx,                              \
1558           "Maximum size of Metaspaces (in bytes)")                          \
1559           constraint(MaxMetaspaceSizeConstraintFunc,AfterErgo)              \
1560                                                                             \
1561   product(size_t, CompressedClassSpaceSize, 1*G,                            \
1562           "Maximum size of class area in Metaspace when compressed "        \
1563           "class pointers are used")                                        \
1564           range(1*M, 3*G)                                                   \
<a name="2" id="anc2"></a><span class="new">1565                                                                             \</span>
<span class="new">1566   experimental(uintx, ForceCompressedClassSpaceStartAddress, 0,             \</span>
<span class="new">1567           "Force class space start address to a given value.")              \</span>
<span class="new">1568                                                                             \</span>
<span class="new">1569   product(ccstr, MetaspaceReclaimPolicy, "balanced",                        \</span>
<span class="new">1570           "options: balanced, aggressive, none")                            \</span>
<span class="new">1571                                                                             \</span>
<span class="new">1572   develop(bool, MetaspaceGuardAllocations, false,                           \</span>
<span class="new">1573           "Metapace allocations are guarded.")                              \</span>
<span class="new">1574                                                                             \</span>
<span class="new">1575   develop(bool, MetaspaceHandleDeallocations, true,                         \</span>
<span class="new">1576           "Switch off Metapace deallocation handling.")                     \</span>
1577                                                                             \
1578   manageable(uintx, MinHeapFreeRatio, 40,                                   \
1579           "The minimum percentage of heap free after GC to avoid expansion."\
1580           " For most GCs this applies to the old generation. In G1 and"     \
1581           " ParallelGC it applies to the whole heap.")                      \
1582           range(0, 100)                                                     \
1583           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
1584                                                                             \
1585   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
1586           "The maximum percentage of heap free after GC to avoid shrinking."\
1587           " For most GCs this applies to the old generation. In G1 and"     \
1588           " ParallelGC it applies to the whole heap.")                      \
1589           range(0, 100)                                                     \
1590           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
1591                                                                             \
1592   product(bool, ShrinkHeapInSteps, true,                                    \
1593           "When disabled, informs the GC to shrink the java heap directly"  \
1594           " to the target size at the next full GC rather than requiring"   \
1595           " smaller steps during multiple full GCs.")                       \
1596                                                                             \
1597   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
1598           "Number of milliseconds per MB of free space in the heap")        \
1599           range(0, max_intx)                                                \
1600           constraint(SoftRefLRUPolicyMSPerMBConstraintFunc,AfterMemoryInit) \
1601                                                                             \
1602   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
1603           "The minimum change in heap space due to GC (in bytes)")          \
1604           range(0, max_uintx)                                               \
1605                                                                             \
1606   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
1607           "The minimum expansion of Metaspace (in bytes)")                  \
1608           range(0, max_uintx)                                               \
1609                                                                             \
1610   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
1611           "The maximum percentage of Metaspace free after GC to avoid "     \
1612           "shrinking")                                                      \
1613           range(0, 100)                                                     \
1614           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
1615                                                                             \
1616   product(uintx, MinMetaspaceFreeRatio,    40,                              \
1617           "The minimum percentage of Metaspace free after GC to avoid "     \
1618           "expansion")                                                      \
1619           range(0, 99)                                                      \
1620           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
1621                                                                             \
1622   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
1623           "The maximum expansion of Metaspace without full GC (in bytes)")  \
1624           range(0, max_uintx)                                               \
1625                                                                             \
1626   /* stack parameters */                                                    \
1627   product_pd(intx, StackYellowPages,                                        \
1628           "Number of yellow zone (recoverable overflows) pages of size "    \
1629           "4KB. If pages are bigger yellow zone is aligned up.")            \
1630           range(MIN_STACK_YELLOW_PAGES, (DEFAULT_STACK_YELLOW_PAGES+5))     \
1631                                                                             \
1632   product_pd(intx, StackRedPages,                                           \
1633           "Number of red zone (unrecoverable overflows) pages of size "     \
1634           "4KB. If pages are bigger red zone is aligned up.")               \
1635           range(MIN_STACK_RED_PAGES, (DEFAULT_STACK_RED_PAGES+2))           \
1636                                                                             \
1637   product_pd(intx, StackReservedPages,                                      \
1638           "Number of reserved zone (reserved to annotated methods) pages"   \
1639           " of size 4KB. If pages are bigger reserved zone is aligned up.") \
1640           range(MIN_STACK_RESERVED_PAGES, (DEFAULT_STACK_RESERVED_PAGES+10))\
1641                                                                             \
1642   product(bool, RestrictReservedStack, true,                                \
1643           "Restrict @ReservedStackAccess to trusted classes")               \
1644                                                                             \
1645   /* greater stack shadow pages can't generate instruction to bang stack */ \
1646   product_pd(intx, StackShadowPages,                                        \
1647           "Number of shadow zone (for overflow checking) pages of size "    \
1648           "4KB. If pages are bigger shadow zone is aligned up. "            \
1649           "This should exceed the depth of the VM and native call stack.")  \
1650           range(MIN_STACK_SHADOW_PAGES, (DEFAULT_STACK_SHADOW_PAGES+30))    \
1651                                                                             \
1652   product_pd(intx, ThreadStackSize,                                         \
1653           "Thread Stack Size (in Kbytes)")                                  \
1654           range(0, 1 * M)                                                   \
1655                                                                             \
1656   product_pd(intx, VMThreadStackSize,                                       \
1657           "Non-Java Thread Stack Size (in Kbytes)")                         \
1658           range(0, max_intx/(1 * K))                                        \
1659                                                                             \
1660   product_pd(intx, CompilerThreadStackSize,                                 \
1661           "Compiler Thread Stack Size (in Kbytes)")                         \
1662           range(0, max_intx/(1 * K))                                        \
1663                                                                             \
1664   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
1665           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
1666                                                                             \
1667   /* code cache parameters                                    */            \
1668   develop_pd(uintx, CodeCacheSegmentSize,                                   \
1669           "Code cache segment size (in bytes) - smallest unit of "          \
1670           "allocation")                                                     \
1671           range(1, 1024)                                                    \
1672           constraint(CodeCacheSegmentSizeConstraintFunc, AfterErgo)         \
1673                                                                             \
1674   develop_pd(intx, CodeEntryAlignment,                                      \
1675           "Code entry alignment for generated code (in bytes)")             \
1676           constraint(CodeEntryAlignmentConstraintFunc, AfterErgo)           \
1677                                                                             \
1678   product_pd(intx, OptoLoopAlignment,                                       \
1679           "Align inner loops to zero relative to this modulus")             \
1680           range(1, 16)                                                      \
1681           constraint(OptoLoopAlignmentConstraintFunc, AfterErgo)            \
1682                                                                             \
1683   product_pd(uintx, InitialCodeCacheSize,                                   \
1684           "Initial code cache size (in bytes)")                             \
1685           range(os::vm_page_size(), max_uintx)                              \
1686                                                                             \
1687   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
1688           "Minimum code cache size (in bytes) required to start VM.")       \
1689           range(0, max_uintx)                                               \
1690                                                                             \
1691   product(bool, SegmentedCodeCache, false,                                  \
1692           "Use a segmented code cache")                                     \
1693                                                                             \
1694   product_pd(uintx, ReservedCodeCacheSize,                                  \
1695           "Reserved code cache size (in bytes) - maximum code cache size")  \
1696           range(os::vm_page_size(), max_uintx)                              \
1697                                                                             \
1698   product_pd(uintx, NonProfiledCodeHeapSize,                                \
1699           "Size of code heap with non-profiled methods (in bytes)")         \
1700           range(0, max_uintx)                                               \
1701                                                                             \
1702   product_pd(uintx, ProfiledCodeHeapSize,                                   \
1703           "Size of code heap with profiled methods (in bytes)")             \
1704           range(0, max_uintx)                                               \
1705                                                                             \
1706   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
1707           "Size of code heap with non-nmethods (in bytes)")                 \
1708           range(os::vm_page_size(), max_uintx)                              \
1709                                                                             \
1710   product_pd(uintx, CodeCacheExpansionSize,                                 \
1711           "Code cache expansion size (in bytes)")                           \
1712           range(32*K, max_uintx)                                            \
1713                                                                             \
1714   diagnostic_pd(uintx, CodeCacheMinBlockLength,                             \
1715           "Minimum number of segments in a code cache block")               \
1716           range(1, 100)                                                     \
1717                                                                             \
1718   notproduct(bool, ExitOnFullCodeCache, false,                              \
1719           "Exit the VM if we fill the code cache")                          \
1720                                                                             \
1721   product(bool, UseCodeCacheFlushing, true,                                 \
1722           "Remove cold/old nmethods from the code cache")                   \
1723                                                                             \
1724   product(double, SweeperThreshold, 0.5,                                    \
1725           "Threshold controlling when code cache sweeper is invoked."       \
1726           "Value is percentage of ReservedCodeCacheSize.")                  \
1727           range(0.0, 100.0)                                                 \
1728                                                                             \
1729   product(uintx, StartAggressiveSweepingAt, 10,                             \
1730           "Start aggressive sweeping if X[%] of the code cache is free."    \
1731           "Segmented code cache: X[%] of the non-profiled heap."            \
1732           "Non-segmented code cache: X[%] of the total code cache")         \
1733           range(0, 100)                                                     \
1734                                                                             \
1735   /* AOT parameters */                                                      \
1736   experimental(bool, UseAOT, false,                                         \
1737           "Use AOT compiled files")                                         \
1738                                                                             \
1739   experimental(ccstrlist, AOTLibrary, NULL,                                 \
1740           "AOT library")                                                    \
1741                                                                             \
1742   experimental(bool, PrintAOT, false,                                       \
1743           "Print used AOT klasses and methods")                             \
1744                                                                             \
1745   notproduct(bool, PrintAOTStatistics, false,                               \
1746           "Print AOT statistics")                                           \
1747                                                                             \
1748   diagnostic(bool, UseAOTStrictLoading, false,                              \
1749           "Exit the VM if any of the AOT libraries has invalid config")     \
1750                                                                             \
1751   product(bool, CalculateClassFingerprint, false,                           \
1752           "Calculate class fingerprint")                                    \
1753                                                                             \
1754   /* interpreter debugging */                                               \
1755   develop(intx, BinarySwitchThreshold, 5,                                   \
1756           "Minimal number of lookupswitch entries for rewriting to binary " \
1757           "switch")                                                         \
1758                                                                             \
1759   develop(intx, StopInterpreterAt, 0,                                       \
1760           "Stop interpreter execution at specified bytecode number")        \
1761                                                                             \
1762   develop(intx, TraceBytecodesAt, 0,                                        \
1763           "Trace bytecodes starting with specified bytecode number")        \
1764                                                                             \
1765   /* compiler interface */                                                  \
1766   develop(intx, CIStart, 0,                                                 \
1767           "The id of the first compilation to permit")                      \
1768                                                                             \
1769   develop(intx, CIStop, max_jint,                                           \
1770           "The id of the last compilation to permit")                       \
1771                                                                             \
1772   develop(intx, CIStartOSR, 0,                                              \
1773           "The id of the first osr compilation to permit "                  \
1774           "(CICountOSR must be on)")                                        \
1775                                                                             \
1776   develop(intx, CIStopOSR, max_jint,                                        \
1777           "The id of the last osr compilation to permit "                   \
1778           "(CICountOSR must be on)")                                        \
1779                                                                             \
1780   develop(intx, CIBreakAtOSR, -1,                                           \
1781           "The id of osr compilation to break at")                          \
1782                                                                             \
1783   develop(intx, CIBreakAt, -1,                                              \
1784           "The id of compilation to break at")                              \
1785                                                                             \
1786   product(ccstrlist, CompileOnly, "",                                       \
1787           "List of methods (pkg/class.name) to restrict compilation to")    \
1788                                                                             \
1789   product(ccstr, CompileCommandFile, NULL,                                  \
1790           "Read compiler commands from this file [.hotspot_compiler]")      \
1791                                                                             \
1792   diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \
1793           "Read compiler directives from this file")                        \
1794                                                                             \
1795   product(ccstrlist, CompileCommand, "",                                    \
1796           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
1797                                                                             \
1798   develop(bool, ReplayCompiles, false,                                      \
1799           "Enable replay of compilations from ReplayDataFile")              \
1800                                                                             \
1801   product(ccstr, ReplayDataFile, NULL,                                      \
1802           "File containing compilation replay information"                  \
1803           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
1804                                                                             \
1805    product(ccstr, InlineDataFile, NULL,                                     \
1806           "File containing inlining replay information"                     \
1807           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
1808                                                                             \
1809   develop(intx, ReplaySuppressInitializers, 2,                              \
1810           "Control handling of class initialization during replay: "        \
1811           "0 - don't do anything special; "                                 \
1812           "1 - treat all class initializers as empty; "                     \
1813           "2 - treat class initializers for application classes as empty; " \
1814           "3 - allow all class initializers to run during bootstrap but "   \
1815           "    pretend they are empty after starting replay")               \
1816           range(0, 3)                                                       \
1817                                                                             \
1818   develop(bool, ReplayIgnoreInitErrors, false,                              \
1819           "Ignore exceptions thrown during initialization for replay")      \
1820                                                                             \
1821   product(bool, DumpReplayDataOnError, true,                                \
1822           "Record replay data for crashing compiler threads")               \
1823                                                                             \
1824   product(bool, CICompilerCountPerCPU, false,                               \
1825           "1 compiler thread for log(N CPUs)")                              \
1826                                                                             \
1827   notproduct(intx, CICrashAt, -1,                                           \
1828           "id of compilation to trigger assert in compiler thread for "     \
1829           "the purpose of testing, e.g. generation of replay data")         \
1830   notproduct(bool, CIObjectFactoryVerify, false,                            \
1831           "enable potentially expensive verification in ciObjectFactory")   \
1832                                                                             \
1833   diagnostic(bool, AbortVMOnCompilationFailure, false,                      \
1834           "Abort VM when method had failed to compile.")                    \
1835                                                                             \
1836   /* Priorities */                                                          \
1837   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
1838                                                                             \
1839   product(intx, ThreadPriorityPolicy, 0,                                    \
1840           "0 : Normal.                                                     "\
1841           "    VM chooses priorities that are appropriate for normal       "\
1842           "    applications.                                               "\
1843           "    On Windows applications are allowed to use higher native    "\
1844           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
1845           "    not use the highest possible native priority,               "\
1846           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
1847           "    system threads. On Linux thread priorities are ignored      "\
1848           "    because the OS does not support static priority in          "\
1849           "    SCHED_OTHER scheduling class which is the only choice for   "\
1850           "    non-root, non-realtime applications.                        "\
1851           "1 : Aggressive.                                                 "\
1852           "    Java thread priorities map over to the entire range of      "\
1853           "    native thread priorities. Higher Java thread priorities map "\
1854           "    to higher native thread priorities. This policy should be   "\
1855           "    used with care, as sometimes it can cause performance       "\
1856           "    degradation in the application and/or the entire system. On "\
1857           "    Linux/BSD/macOS this policy requires root privilege or an   "\
1858           "    extended capability.")                                       \
1859           range(0, 1)                                                       \
1860                                                                             \
1861   product(bool, ThreadPriorityVerbose, false,                               \
1862           "Print priority changes")                                         \
1863                                                                             \
1864   product(intx, CompilerThreadPriority, -1,                                 \
1865           "The native priority at which compiler threads should run "       \
1866           "(-1 means no change)")                                           \
1867           range(min_jint, max_jint)                                         \
1868                                                                             \
1869   product(intx, VMThreadPriority, -1,                                       \
1870           "The native priority at which the VM thread should run "          \
1871           "(-1 means no change)")                                           \
1872           range(-1, 127)                                                    \
1873                                                                             \
1874   product(intx, JavaPriority1_To_OSPriority, -1,                            \
1875           "Map Java priorities to OS priorities")                           \
1876           range(-1, 127)                                                    \
1877                                                                             \
1878   product(intx, JavaPriority2_To_OSPriority, -1,                            \
1879           "Map Java priorities to OS priorities")                           \
1880           range(-1, 127)                                                    \
1881                                                                             \
1882   product(intx, JavaPriority3_To_OSPriority, -1,                            \
1883           "Map Java priorities to OS priorities")                           \
1884           range(-1, 127)                                                    \
1885                                                                             \
1886   product(intx, JavaPriority4_To_OSPriority, -1,                            \
1887           "Map Java priorities to OS priorities")                           \
1888           range(-1, 127)                                                    \
1889                                                                             \
1890   product(intx, JavaPriority5_To_OSPriority, -1,                            \
1891           "Map Java priorities to OS priorities")                           \
1892           range(-1, 127)                                                    \
1893                                                                             \
1894   product(intx, JavaPriority6_To_OSPriority, -1,                            \
1895           "Map Java priorities to OS priorities")                           \
1896           range(-1, 127)                                                    \
1897                                                                             \
1898   product(intx, JavaPriority7_To_OSPriority, -1,                            \
1899           "Map Java priorities to OS priorities")                           \
1900           range(-1, 127)                                                    \
1901                                                                             \
1902   product(intx, JavaPriority8_To_OSPriority, -1,                            \
1903           "Map Java priorities to OS priorities")                           \
1904           range(-1, 127)                                                    \
1905                                                                             \
1906   product(intx, JavaPriority9_To_OSPriority, -1,                            \
1907           "Map Java priorities to OS priorities")                           \
1908           range(-1, 127)                                                    \
1909                                                                             \
1910   product(intx, JavaPriority10_To_OSPriority,-1,                            \
1911           "Map Java priorities to OS priorities")                           \
1912           range(-1, 127)                                                    \
1913                                                                             \
1914   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
1915           "Java thread priority 10 maps to critical scheduling priority")   \
1916                                                                             \
1917   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
1918           "Compiler thread(s) run at critical scheduling priority")         \
1919                                                                             \
1920   develop(intx, NewCodeParameter,      0,                                   \
1921           "Testing Only: Create a dedicated integer parameter before "      \
1922           "putback")                                                        \
1923                                                                             \
1924   /* new oopmap storage allocation */                                       \
1925   develop(intx, MinOopMapAllocation,     8,                                 \
1926           "Minimum number of OopMap entries in an OopMapSet")               \
1927                                                                             \
1928   /* Background Compilation */                                              \
1929   develop(intx, LongCompileThreshold,     50,                               \
1930           "Used with +TraceLongCompiles")                                   \
1931                                                                             \
1932   /* recompilation */                                                       \
1933   product_pd(intx, CompileThreshold,                                        \
1934           "number of interpreted method invocations before (re-)compiling") \
1935           constraint(CompileThresholdConstraintFunc, AfterErgo)             \
1936                                                                             \
1937   product(double, CompileThresholdScaling, 1.0,                             \
1938           "Factor to control when first compilation happens "               \
1939           "(both with and without tiered compilation): "                    \
1940           "values greater than 1.0 delay counter overflow, "                \
1941           "values between 0 and 1.0 rush counter overflow, "                \
1942           "value of 1.0 leaves compilation thresholds unchanged "           \
1943           "value of 0.0 is equivalent to -Xint. "                           \
1944           ""                                                                \
1945           "Flag can be set as per-method option. "                          \
1946           "If a value is specified for a method, compilation thresholds "   \
1947           "for that method are scaled by both the value of the global flag "\
1948           "and the value of the per-method flag.")                          \
1949           range(0.0, DBL_MAX)                                               \
1950                                                                             \
1951   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
1952           "Interpreter (tier 0) invocation notification frequency")         \
1953           range(0, 30)                                                      \
1954                                                                             \
1955   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
1956           "C1 without MDO (tier 2) invocation notification frequency")      \
1957           range(0, 30)                                                      \
1958                                                                             \
1959   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
1960           "C1 with MDO profiling (tier 3) invocation notification "         \
1961           "frequency")                                                      \
1962           range(0, 30)                                                      \
1963                                                                             \
1964   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
1965           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
1966           range(0, 30)                                                      \
1967                                                                             \
1968   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
1969           "Interpreter (tier 0) invocation notification frequency")         \
1970           range(0, 30)                                                      \
1971                                                                             \
1972   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
1973           "C1 without MDO (tier 2) invocation notification frequency")      \
1974           range(0, 30)                                                      \
1975                                                                             \
1976   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
1977           "C1 with MDO profiling (tier 3) invocation notification "         \
1978           "frequency")                                                      \
1979           range(0, 30)                                                      \
1980                                                                             \
1981   product(intx, Tier2CompileThreshold, 0,                                   \
1982           "threshold at which tier 2 compilation is invoked")               \
1983           range(0, max_jint)                                                \
1984                                                                             \
1985   product(intx, Tier2BackEdgeThreshold, 0,                                  \
1986           "Back edge threshold at which tier 2 compilation is invoked")     \
1987           range(0, max_jint)                                                \
1988                                                                             \
1989   product(intx, Tier3InvocationThreshold, 200,                              \
1990           "Compile if number of method invocations crosses this "           \
1991           "threshold")                                                      \
1992           range(0, max_jint)                                                \
1993                                                                             \
1994   product(intx, Tier3MinInvocationThreshold, 100,                           \
1995           "Minimum invocation to compile at tier 3")                        \
1996           range(0, max_jint)                                                \
1997                                                                             \
1998   product(intx, Tier3CompileThreshold, 2000,                                \
1999           "Threshold at which tier 3 compilation is invoked (invocation "   \
2000           "minimum must be satisfied)")                                     \
2001           range(0, max_jint)                                                \
2002                                                                             \
2003   product(intx, Tier3BackEdgeThreshold,  60000,                             \
2004           "Back edge threshold at which tier 3 OSR compilation is invoked") \
2005           range(0, max_jint)                                                \
2006                                                                             \
2007   product(intx, Tier3AOTInvocationThreshold, 10000,                         \
2008           "Compile if number of method invocations crosses this "           \
2009           "threshold if coming from AOT")                                   \
2010           range(0, max_jint)                                                \
2011                                                                             \
2012   product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \
2013           "Minimum invocation to compile at tier 3 if coming from AOT")     \
2014           range(0, max_jint)                                                \
2015                                                                             \
2016   product(intx, Tier3AOTCompileThreshold, 15000,                            \
2017           "Threshold at which tier 3 compilation is invoked (invocation "   \
2018           "minimum must be satisfied) if coming from AOT")                  \
2019           range(0, max_jint)                                                \
2020                                                                             \
2021   product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \
2022           "Back edge threshold at which tier 3 OSR compilation is invoked " \
2023           "if coming from AOT")                                             \
2024           range(0, max_jint)                                                \
2025                                                                             \
2026   diagnostic(intx, Tier0AOTInvocationThreshold, 200,                        \
2027           "Switch to interpreter to profile if the number of method "       \
2028           "invocations crosses this threshold if coming from AOT "          \
2029           "(applicable only with "                                          \
2030           "CompilationMode=high-only|high-only-quick-internal)")            \
2031           range(0, max_jint)                                                \
2032                                                                             \
2033   diagnostic(intx, Tier0AOTMinInvocationThreshold, 100,                     \
2034           "Minimum number of invocations to switch to interpreter "         \
2035           "to profile if coming from AOT "                                  \
2036           "(applicable only with "                                          \
2037           "CompilationMode=high-only|high-only-quick-internal)")            \
2038           range(0, max_jint)                                                \
2039                                                                             \
2040   diagnostic(intx, Tier0AOTCompileThreshold, 2000,                          \
2041           "Threshold at which to switch to interpreter to profile "         \
2042           "if coming from AOT "                                             \
2043           "(invocation minimum must be satisfied, "                         \
2044           "applicable only with "                                           \
2045           "CompilationMode=high-only|high-only-quick-internal)")            \
2046           range(0, max_jint)                                                \
2047                                                                             \
2048   diagnostic(intx, Tier0AOTBackEdgeThreshold,  60000,                       \
2049           "Back edge threshold at which to switch to interpreter "          \
2050           "to profile if coming from AOT "                                  \
2051           "(applicable only with "                                          \
2052           "CompilationMode=high-only|high-only-quick-internal)")            \
2053           range(0, max_jint)                                                \
2054                                                                             \
2055   product(intx, Tier4InvocationThreshold, 5000,                             \
2056           "Compile if number of method invocations crosses this "           \
2057           "threshold")                                                      \
2058           range(0, max_jint)                                                \
2059                                                                             \
2060   product(intx, Tier4MinInvocationThreshold, 600,                           \
2061           "Minimum invocation to compile at tier 4")                        \
2062           range(0, max_jint)                                                \
2063                                                                             \
2064   product(intx, Tier4CompileThreshold, 15000,                               \
2065           "Threshold at which tier 4 compilation is invoked (invocation "   \
2066           "minimum must be satisfied)")                                     \
2067           range(0, max_jint)                                                \
2068                                                                             \
2069   product(intx, Tier4BackEdgeThreshold, 40000,                              \
2070           "Back edge threshold at which tier 4 OSR compilation is invoked") \
2071           range(0, max_jint)                                                \
2072                                                                             \
2073   diagnostic(intx, Tier40InvocationThreshold, 5000,                         \
2074           "Compile if number of method invocations crosses this "           \
2075           "threshold (applicable only with "                                \
2076           "CompilationMode=high-only|high-only-quick-internal)")            \
2077           range(0, max_jint)                                                \
2078                                                                             \
2079   diagnostic(intx, Tier40MinInvocationThreshold, 600,                       \
2080           "Minimum number of invocations to compile at tier 4 "             \
2081           "(applicable only with "                                          \
2082           "CompilationMode=high-only|high-only-quick-internal)")            \
2083           range(0, max_jint)                                                \
2084                                                                             \
2085   diagnostic(intx, Tier40CompileThreshold, 10000,                           \
2086           "Threshold at which tier 4 compilation is invoked (invocation "   \
2087           "minimum must be satisfied, applicable only with "                \
2088           "CompilationMode=high-only|high-only-quick-internal)")            \
2089           range(0, max_jint)                                                \
2090                                                                             \
2091   diagnostic(intx, Tier40BackEdgeThreshold, 15000,                          \
2092           "Back edge threshold at which tier 4 OSR compilation is invoked " \
2093           "(applicable only with "                                          \
2094           "CompilationMode=high-only|high-only-quick-internal)")            \
2095           range(0, max_jint)                                                \
2096                                                                             \
2097   diagnostic(intx, Tier0Delay, 5,                                           \
2098           "If C2 queue size grows over this amount per compiler thread "    \
2099           "do not start profiling in the interpreter "                      \
2100           "(applicable only with "                                          \
2101           "CompilationMode=high-only|high-only-quick-internal)")            \
2102           range(0, max_jint)                                                \
2103                                                                             \
2104   product(intx, Tier3DelayOn, 5,                                            \
2105           "If C2 queue size grows over this amount per compiler thread "    \
2106           "stop compiling at tier 3 and start compiling at tier 2")         \
2107           range(0, max_jint)                                                \
2108                                                                             \
2109   product(intx, Tier3DelayOff, 2,                                           \
2110           "If C2 queue size is less than this amount per compiler thread "  \
2111           "allow methods compiled at tier 2 transition to tier 3")          \
2112           range(0, max_jint)                                                \
2113                                                                             \
2114   product(intx, Tier3LoadFeedback, 5,                                       \
2115           "Tier 3 thresholds will increase twofold when C1 queue size "     \
2116           "reaches this amount per compiler thread")                        \
2117           range(0, max_jint)                                                \
2118                                                                             \
2119   product(intx, Tier4LoadFeedback, 3,                                       \
2120           "Tier 4 thresholds will increase twofold when C2 queue size "     \
2121           "reaches this amount per compiler thread")                        \
2122           range(0, max_jint)                                                \
2123                                                                             \
2124   product(intx, TieredCompileTaskTimeout, 50,                               \
2125           "Kill compile task if method was not used within "                \
2126           "given timeout in milliseconds")                                  \
2127           range(0, max_intx)                                                \
2128                                                                             \
2129   product(intx, TieredStopAtLevel, 4,                                       \
2130           "Stop at given compilation level")                                \
2131           range(0, 4)                                                       \
2132                                                                             \
2133   product(intx, Tier0ProfilingStartPercentage, 200,                         \
2134           "Start profiling in interpreter if the counters exceed tier 3 "   \
2135           "thresholds (tier 4 thresholds with "                             \
2136           "CompilationMode=high-only|high-only-quick-internal)"             \
2137           "by the specified percentage")                                    \
2138           range(0, max_jint)                                                \
2139                                                                             \
2140   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
2141           "Increase the compile threshold for C1 compilation if the code "  \
2142           "cache is filled by the specified percentage")                    \
2143           range(0, 99)                                                      \
2144                                                                             \
2145   product(intx, TieredRateUpdateMinTime, 1,                                 \
2146           "Minimum rate sampling interval (in milliseconds)")               \
2147           range(0, max_intx)                                                \
2148                                                                             \
2149   product(intx, TieredRateUpdateMaxTime, 25,                                \
2150           "Maximum rate sampling interval (in milliseconds)")               \
2151           range(0, max_intx)                                                \
2152                                                                             \
2153   product(ccstr, CompilationMode, "default",                                \
2154           "Compilation modes: "                                             \
2155           "default: normal tiered compilation; "                            \
2156           "quick-only: C1-only mode; "                                      \
2157           "high-only: C2/JVMCI-only mode; "                                 \
2158           "high-only-quick-internal: C2/JVMCI-only mode, "                  \
2159           "with JVMCI compiler compiled with C1.")                          \
2160                                                                             \
2161   product_pd(bool, TieredCompilation,                                       \
2162           "Enable tiered compilation")                                      \
2163                                                                             \
2164   product(bool, PrintTieredEvents, false,                                   \
2165           "Print tiered events notifications")                              \
2166                                                                             \
2167   product_pd(intx, OnStackReplacePercentage,                                \
2168           "NON_TIERED number of method invocations/branches (expressed as " \
2169           "% of CompileThreshold) before (re-)compiling OSR code")          \
2170           constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \
2171                                                                             \
2172   product(intx, InterpreterProfilePercentage, 33,                           \
2173           "NON_TIERED number of method invocations/branches (expressed as " \
2174           "% of CompileThreshold) before profiling in the interpreter")     \
2175           range(0, 100)                                                     \
2176                                                                             \
2177   develop(intx, DesiredMethodLimit,  8000,                                  \
2178           "The desired maximum method size (in bytecodes) after inlining")  \
2179                                                                             \
2180   develop(intx, HugeMethodLimit,  8000,                                     \
2181           "Don't compile methods larger than this if "                      \
2182           "+DontCompileHugeMethods")                                        \
2183                                                                             \
2184   /* Properties for Java libraries  */                                      \
2185                                                                             \
2186   product(uint64_t, MaxDirectMemorySize, 0,                                 \
2187           "Maximum total size of NIO direct-buffer allocations")            \
2188           range(0, max_jlong)                                               \
2189                                                                             \
2190   /* Flags used for temporary code during development  */                   \
2191                                                                             \
2192   diagnostic(bool, UseNewCode, false,                                       \
2193           "Testing Only: Use the new version while testing")                \
2194                                                                             \
2195   diagnostic(bool, UseNewCode2, false,                                      \
2196           "Testing Only: Use the new version while testing")                \
2197                                                                             \
2198   diagnostic(bool, UseNewCode3, false,                                      \
2199           "Testing Only: Use the new version while testing")                \
2200                                                                             \
2201   /* flags for performance data collection */                               \
2202                                                                             \
2203   product(bool, UsePerfData, true,                                          \
2204           "Flag to disable jvmstat instrumentation for performance testing "\
2205           "and problem isolation purposes")                                 \
2206                                                                             \
2207   product(bool, PerfDataSaveToFile, false,                                  \
2208           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
2209                                                                             \
2210   product(ccstr, PerfDataSaveFile, NULL,                                    \
2211           "Save PerfData memory to the specified absolute pathname. "       \
2212           "The string %p in the file name (if present) "                    \
2213           "will be replaced by pid")                                        \
2214                                                                             \
2215   product(intx, PerfDataSamplingInterval, 50,                               \
2216           "Data sampling interval (in milliseconds)")                       \
2217           range(PeriodicTask::min_interval, max_jint)                       \
2218           constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \
2219                                                                             \
2220   product(bool, PerfDisableSharedMem, false,                                \
2221           "Store performance data in standard memory")                      \
2222                                                                             \
2223   product(intx, PerfDataMemorySize, 32*K,                                   \
2224           "Size of performance data memory region. Will be rounded "        \
2225           "up to a multiple of the native os page size.")                   \
2226           range(128, 32*64*K)                                               \
2227                                                                             \
2228   product(intx, PerfMaxStringConstLength, 1024,                             \
2229           "Maximum PerfStringConstant string length before truncation")     \
2230           range(32, 32*K)                                                   \
2231                                                                             \
2232   product(bool, PerfAllowAtExitRegistration, false,                         \
2233           "Allow registration of atexit() methods")                         \
2234                                                                             \
2235   product(bool, PerfBypassFileSystemCheck, false,                           \
2236           "Bypass Win32 file system criteria checks (Windows Only)")        \
2237                                                                             \
2238   product(intx, UnguardOnExecutionViolation, 0,                             \
2239           "Unguard page and retry on no-execute fault (Win32 only) "        \
2240           "0=off, 1=conservative, 2=aggressive")                            \
2241           range(0, 2)                                                       \
2242                                                                             \
2243   /* Serviceability Support */                                              \
2244                                                                             \
2245   product(bool, ManagementServer, false,                                    \
2246           "Create JMX Management Server")                                   \
2247                                                                             \
2248   product(bool, DisableAttachMechanism, false,                              \
2249           "Disable mechanism that allows tools to attach to this VM")       \
2250                                                                             \
2251   product(bool, StartAttachListener, false,                                 \
2252           "Always start Attach Listener at VM startup")                     \
2253                                                                             \
2254   product(bool, EnableDynamicAgentLoading, true,                            \
2255           "Allow tools to load agents with the attach mechanism")           \
2256                                                                             \
2257   manageable(bool, PrintConcurrentLocks, false,                             \
2258           "Print java.util.concurrent locks in thread dump")                \
2259                                                                             \
2260   /* Shared spaces */                                                       \
2261                                                                             \
2262   product(bool, UseSharedSpaces, true,                                      \
2263           "Use shared spaces for metadata")                                 \
2264                                                                             \
2265   product(bool, VerifySharedSpaces, false,                                  \
2266           "Verify integrity of shared spaces")                              \
2267                                                                             \
2268   product(bool, RequireSharedSpaces, false,                                 \
2269           "Require shared spaces for metadata")                             \
2270                                                                             \
2271   product(bool, DumpSharedSpaces, false,                                    \
2272           "Special mode: JVM reads a class list, loads classes, builds "    \
2273           "shared spaces, and dumps the shared spaces to a file to be "     \
2274           "used in future JVM runs")                                        \
2275                                                                             \
2276   product(bool, DynamicDumpSharedSpaces, false,                             \
2277           "Dynamic archive")                                                \
2278                                                                             \
2279   product(bool, PrintSharedArchiveAndExit, false,                           \
2280           "Print shared archive file contents")                             \
2281                                                                             \
2282   product(bool, PrintSharedDictionary, false,                               \
2283           "If PrintSharedArchiveAndExit is true, also print the shared "    \
2284           "dictionary")                                                     \
2285                                                                             \
2286   product(size_t, SharedBaseAddress, LP64_ONLY(32*G)                        \
2287           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
2288           "Address to allocate shared memory region for class data")        \
2289           range(0, SIZE_MAX)                                                \
2290                                                                             \
2291   product(ccstr, SharedArchiveConfigFile, NULL,                             \
2292           "Data to add to the CDS archive file")                            \
2293                                                                             \
2294   product(uintx, SharedSymbolTableBucketSize, 4,                            \
2295           "Average number of symbols per bucket in shared table")           \
2296           range(2, 246)                                                     \
2297                                                                             \
2298   diagnostic(bool, AllowArchivingWithJavaAgent, false,                      \
2299           "Allow Java agent to be run with CDS dumping")                    \
2300                                                                             \
2301   diagnostic(bool, PrintMethodHandleStubs, false,                           \
2302           "Print generated stub code for method handles")                   \
2303                                                                             \
2304   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
2305           "perform extra checks when constructing method handles")          \
2306                                                                             \
2307   diagnostic(bool, ShowHiddenFrames, false,                                 \
2308           "show method handle implementation frames (usually hidden)")      \
2309                                                                             \
2310   experimental(bool, TrustFinalNonStaticFields, false,                      \
2311           "trust final non-static declarations for constant folding")       \
2312                                                                             \
2313   diagnostic(bool, FoldStableValues, true,                                  \
2314           "Optimize loads from stable fields (marked w/ @Stable)")          \
2315                                                                             \
2316   diagnostic(int, UseBootstrapCallInfo, 1,                                  \
2317           "0: when resolving InDy or ConDy, force all BSM arguments to be " \
2318           "resolved before the bootstrap method is called; 1: when a BSM "  \
2319           "that may accept a BootstrapCallInfo is detected, use that API "  \
2320           "to pass BSM arguments, which allows the BSM to delay their "     \
2321           "resolution; 2+: stress test the BCI API by calling more BSMs "   \
2322           "via that API, instead of with the eagerly-resolved array.")      \
2323                                                                             \
2324   diagnostic(bool, PauseAtStartup,      false,                              \
2325           "Causes the VM to pause at startup time and wait for the pause "  \
2326           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
2327                                                                             \
2328   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
2329           "The file to create and for whose removal to await when pausing " \
2330           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
2331                                                                             \
2332   diagnostic(bool, PauseAtExit, false,                                      \
2333           "Pause and wait for keypress on exit if a debugger is attached")  \
2334                                                                             \
2335   product(bool, ExtendedDTraceProbes,    false,                             \
2336           "Enable performance-impacting dtrace probes")                     \
2337                                                                             \
2338   product(bool, DTraceMethodProbes, false,                                  \
2339           "Enable dtrace probes for method-entry and method-exit")          \
2340                                                                             \
2341   product(bool, DTraceAllocProbes, false,                                   \
2342           "Enable dtrace probes for object allocation")                     \
2343                                                                             \
2344   product(bool, DTraceMonitorProbes, false,                                 \
2345           "Enable dtrace probes for monitor events")                        \
2346                                                                             \
2347   product(bool, RelaxAccessControlCheck, false,                             \
2348           "Relax the access control checks in the verifier")                \
2349                                                                             \
2350   product(uintx, StringTableSize, defaultStringTableSize,                   \
2351           "Number of buckets in the interned String table "                 \
2352           "(will be rounded to nearest higher power of 2)")                 \
2353           range(minimumStringTableSize, 16777216ul /* 2^24 */)              \
2354                                                                             \
2355   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
2356           "Number of buckets in the JVM internal Symbol table")             \
2357           range(minimumSymbolTableSize, 16777216ul /* 2^24 */)              \
2358                                                                             \
2359   product(bool, UseStringDeduplication, false,                              \
2360           "Use string deduplication")                                       \
2361                                                                             \
2362   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
2363           "A string must reach this age (or be promoted to an old region) " \
2364           "to be considered for deduplication")                             \
2365           range(1, markWord::max_age)                                       \
2366                                                                             \
2367   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
2368           "Force table resize every time the table is scanned")             \
2369                                                                             \
2370   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
2371           "Force table rehash every time the table is scanned")             \
2372                                                                             \
2373   diagnostic(bool, WhiteBoxAPI, false,                                      \
2374           "Enable internal testing APIs")                                   \
2375                                                                             \
2376   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
2377            "Default survivor space alignment in bytes")                     \
2378            range(8, 256)                                                    \
2379            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
2380                                                                             \
2381   product(ccstr, DumpLoadedClassList, NULL,                                 \
2382           "Dump the names all loaded classes, that could be stored into "   \
2383           "the CDS archive, in the specified file")                         \
2384                                                                             \
2385   product(ccstr, SharedClassListFile, NULL,                                 \
2386           "Override the default CDS class list")                            \
2387                                                                             \
2388   product(ccstr, SharedArchiveFile, NULL,                                   \
2389           "Override the default location of the CDS archive file")          \
2390                                                                             \
2391   product(ccstr, ArchiveClassesAtExit, NULL,                                \
2392           "The path and name of the dynamic archive file")                  \
2393                                                                             \
2394   product(ccstr, ExtraSharedClassListFile, NULL,                            \
2395           "Extra classlist for building the CDS archive file")              \
2396                                                                             \
2397   diagnostic(intx, ArchiveRelocationMode, 0,                                \
2398            "(0) first map at preferred address, and if "                    \
2399            "unsuccessful, map at alternative address (default); "           \
2400            "(1) always map at alternative address; "                        \
2401            "(2) always map at preferred address, and if unsuccessful, "     \
2402            "do not map the archive")                                        \
2403            range(0, 2)                                                      \
2404                                                                             \
2405   experimental(size_t, ArrayAllocatorMallocLimit, (size_t)-1,               \
2406           "Allocation less than this value will be allocated "              \
2407           "using malloc. Larger allocations will use mmap.")                \
2408                                                                             \
2409   experimental(bool, AlwaysAtomicAccesses, false,                           \
2410           "Accesses to all variables should always be atomic")              \
2411                                                                             \
2412   diagnostic(bool, UseUnalignedAccesses, false,                             \
2413           "Use unaligned memory accesses in Unsafe")                        \
2414                                                                             \
2415   product_pd(bool, PreserveFramePointer,                                    \
2416              "Use the FP register for holding the frame pointer "           \
2417              "and not as a general purpose register.")                      \
2418                                                                             \
2419   diagnostic(bool, CheckIntrinsics, true,                                   \
2420              "When a class C is loaded, check that "                        \
2421              "(1) all intrinsics defined by the VM for class C are present "\
2422              "in the loaded class file and are marked with the "            \
2423              "@HotSpotIntrinsicCandidate annotation, that "                 \
2424              "(2) there is an intrinsic registered for all loaded methods " \
2425              "that are annotated with the @HotSpotIntrinsicCandidate "      \
2426              "annotation, and that "                                        \
2427              "(3) no orphan methods exist for class C (i.e., methods for "  \
2428              "which the VM declares an intrinsic but that are not declared "\
2429              "in the loaded class C. "                                      \
2430              "Check (3) is available only in debug builds.")                \
2431                                                                             \
2432   diagnostic_pd(intx, InitArrayShortSize,                                   \
2433           "Threshold small size (in bytes) for clearing arrays. "           \
2434           "Anything this size or smaller may get converted to discrete "    \
2435           "scalar stores.")                                                 \
2436           range(0, max_intx)                                                \
2437           constraint(InitArrayShortSizeConstraintFunc, AfterErgo)           \
2438                                                                             \
2439   diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \
2440              "Disable backwards compatibility for compile commands.")       \
2441                                                                             \
2442   diagnostic(bool, CompilerDirectivesPrint, false,                          \
2443              "Print compiler directives on installation.")                  \
2444   diagnostic(int,  CompilerDirectivesLimit, 50,                             \
2445              "Limit on number of compiler directives.")                     \
2446                                                                             \
2447   product(ccstr, AllocateHeapAt, NULL,                                      \
2448           "Path to the directoy where a temporary file will be created "    \
2449           "to use as the backing store for Java Heap.")                     \
2450                                                                             \
2451   experimental(ccstr, AllocateOldGenAt, NULL,                               \
2452           "Path to the directoy where a temporary file will be "            \
2453           "created to use as the backing store for old generation."         \
2454           "File of size Xmx is pre-allocated for performance reason, so"    \
2455           "we need that much space available")                              \
2456                                                                             \
2457   develop(int, VerifyMetaspaceInterval, DEBUG_ONLY(500) NOT_DEBUG(0),       \
2458                "Run periodic metaspace verifications (0 - none, "           \
2459                "1 - always, &gt;1 every nth interval)")                        \
2460                                                                             \
2461   diagnostic(bool, ShowRegistersOnAssert, true,                             \
2462           "On internal errors, include registers in error report.")         \
2463                                                                             \
2464   diagnostic(bool, UseSwitchProfiling, true,                                \
2465           "leverage profiling for table/lookup switch")                     \
2466                                                                             \
2467   develop(bool, TraceMemoryWriteback, false,                                \
2468           "Trace memory writeback operations")                              \
2469                                                                             \
2470   JFR_ONLY(product(bool, FlightRecorder, false,                             \
2471           "(Deprecated) Enable Flight Recorder"))                           \
2472                                                                             \
2473   JFR_ONLY(product(ccstr, FlightRecorderOptions, NULL,                      \
2474           "Flight Recorder options"))                                       \
2475                                                                             \
2476   JFR_ONLY(product(ccstr, StartFlightRecording, NULL,                       \
2477           "Start flight recording with options"))                           \
2478                                                                             \
2479   experimental(bool, UseFastUnorderedTimeStamps, false,                     \
2480           "Use platform unstable time where supported for timestamps only") \
2481                                                                             \
2482   product(bool, UseEmptySlotsInSupers, true,                                \
2483                 "Allow allocating fields in empty slots of super-classes")  \
2484                                                                             \
2485   diagnostic(bool, DeoptimizeNMethodBarriersALot, false,                    \
2486                 "Make nmethod barriers deoptimise a lot.")                  \
2487 
2488 // Interface macros
2489 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
2490 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
2491 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
2492 #define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern "C" type name;
2493 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
2494 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
2495 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
2496 #ifdef PRODUCT
2497 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;
2498 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;
2499 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;
2500 #else
2501 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
2502 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
2503 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
2504 #endif // PRODUCT
2505 // Special LP64 flags, product only needed for now.
2506 #ifdef _LP64
2507 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
2508 #else
2509 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
2510 #endif // _LP64
2511 
2512 ALL_FLAGS(DECLARE_DEVELOPER_FLAG,     \
2513           DECLARE_PD_DEVELOPER_FLAG,  \
2514           DECLARE_PRODUCT_FLAG,       \
2515           DECLARE_PD_PRODUCT_FLAG,    \
2516           DECLARE_DIAGNOSTIC_FLAG,    \
2517           DECLARE_PD_DIAGNOSTIC_FLAG, \
2518           DECLARE_EXPERIMENTAL_FLAG,  \
2519           DECLARE_NOTPRODUCT_FLAG,    \
2520           DECLARE_MANAGEABLE_FLAG,    \
2521           DECLARE_PRODUCT_RW_FLAG,    \
2522           DECLARE_LP64_PRODUCT_FLAG,  \
2523           IGNORE_RANGE,               \
2524           IGNORE_CONSTRAINT)
2525 
2526 #endif // SHARE_RUNTIME_GLOBALS_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="3" type="hidden" /></form></body></html>
