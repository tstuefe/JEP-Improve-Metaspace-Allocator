<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60800">60800</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1  /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // A ClassLoaderData identifies the full set of class types that a class
  26 // loader's name resolution strategy produces for a given configuration of the
  27 // class loader.
  28 // Class types in the ClassLoaderData may be defined by from class file binaries
  29 // provided by the class loader, or from other class loader it interacts with
  30 // according to its name resolution strategy.
  31 //
  32 // Class loaders that implement a deterministic name resolution strategy
  33 // (including with respect to their delegation behavior), such as the boot, the
  34 // platform, and the system loaders of the JDK's built-in class loader
  35 // hierarchy, always produce the same linkset for a given configuration.
  36 //
  37 // ClassLoaderData carries information related to a linkset (e.g.,
  38 // metaspace holding its klass definitions).
  39 // The System Dictionary and related data structures (e.g., placeholder table,
  40 // loader constraints table) as well as the runtime representation of classes
  41 // only reference ClassLoaderData.
  42 //
  43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
  44 // that represent the loader's "linking domain" in the JVM.
  45 //
  46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
  47 // the singleton class the_null_class_loader_data().
  48 
  49 #include "precompiled.hpp"
  50 #include "classfile/classLoaderData.inline.hpp"
  51 #include "classfile/classLoaderDataGraph.inline.hpp"
  52 #include "classfile/dictionary.hpp"
  53 #include "classfile/javaClasses.hpp"
  54 #include "classfile/moduleEntry.hpp"
  55 #include "classfile/packageEntry.hpp"
  56 #include "classfile/symbolTable.hpp"
  57 #include "classfile/systemDictionary.hpp"
  58 #include "logging/log.hpp"
  59 #include "logging/logStream.hpp"
  60 #include "memory/allocation.inline.hpp"
  61 #include "memory/metadataFactory.hpp"
<a name="1" id="anc1"></a>
  62 #include "memory/resourceArea.hpp"
  63 #include "memory/universe.hpp"
  64 #include "oops/access.inline.hpp"
  65 #include "oops/oop.inline.hpp"
  66 #include "oops/oopHandle.inline.hpp"
  67 #include "oops/weakHandle.inline.hpp"
  68 #include "runtime/arguments.hpp"
  69 #include "runtime/atomic.hpp"
  70 #include "runtime/handles.inline.hpp"
  71 #include "runtime/mutex.hpp"
  72 #include "runtime/safepoint.hpp"
  73 #include "utilities/growableArray.hpp"
  74 #include "utilities/macros.hpp"
  75 #include "utilities/ostream.hpp"
  76 
  77 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
  78 
  79 void ClassLoaderData::init_null_class_loader_data() {
  80   assert(_the_null_class_loader_data == NULL, "cannot initialize twice");
  81   assert(ClassLoaderDataGraph::_head == NULL, "cannot initialize twice");
  82 
  83   _the_null_class_loader_data = new ClassLoaderData(Handle(), false);
  84   ClassLoaderDataGraph::_head = _the_null_class_loader_data;
  85   assert(_the_null_class_loader_data-&gt;is_the_null_class_loader_data(), "Must be");
  86 
  87   LogTarget(Trace, class, loader, data) lt;
  88   if (lt.is_enabled()) {
  89     ResourceMark rm;
  90     LogStream ls(lt);
  91     ls.print("create ");
  92     _the_null_class_loader_data-&gt;print_value_on(&amp;ls);
  93     ls.cr();
  94   }
  95 }
  96 
  97 // Obtain and set the class loader's name within the ClassLoaderData so
  98 // it will be available for error messages, logging, JFR, etc.  The name
  99 // and klass are available after the class_loader oop is no longer alive,
 100 // during unloading.
 101 void ClassLoaderData::initialize_name(Handle class_loader) {
 102   Thread* THREAD = Thread::current();
 103   ResourceMark rm(THREAD);
 104 
 105   // Obtain the class loader's name.  If the class loader's name was not
 106   // explicitly set during construction, the CLD's _name field will be null.
 107   oop cl_name = java_lang_ClassLoader::name(class_loader());
 108   if (cl_name != NULL) {
 109     const char* cl_instance_name = java_lang_String::as_utf8_string(cl_name);
 110 
 111     if (cl_instance_name != NULL &amp;&amp; cl_instance_name[0] != '\0') {
 112       _name = SymbolTable::new_symbol(cl_instance_name);
 113     }
 114   }
 115 
 116   // Obtain the class loader's name and identity hash.  If the class loader's
 117   // name was not explicitly set during construction, the class loader's name and id
 118   // will be set to the qualified class name of the class loader along with its
 119   // identity hash.
 120   // If for some reason the ClassLoader's constructor has not been run, instead of
 121   // leaving the _name_and_id field null, fall back to the external qualified class
 122   // name.  Thus CLD's _name_and_id field should never have a null value.
 123   oop cl_name_and_id = java_lang_ClassLoader::nameAndId(class_loader());
 124   const char* cl_instance_name_and_id =
 125                   (cl_name_and_id == NULL) ? _class_loader_klass-&gt;external_name() :
 126                                              java_lang_String::as_utf8_string(cl_name_and_id);
 127   assert(cl_instance_name_and_id != NULL &amp;&amp; cl_instance_name_and_id[0] != '\0', "class loader has no name and id");
 128   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
 129 }
 130 
 131 ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder) :
 132   _metaspace(NULL),
 133   _metaspace_lock(new Mutex(Mutex::leaf+1, "Metaspace allocation lock", true,
 134                             Mutex::_safepoint_check_never)),
 135   _unloading(false), _has_class_mirror_holder(has_class_mirror_holder),
 136   _modified_oops(true), _accumulated_modified_oops(false),
 137   // An unsafe anonymous class loader data doesn't have anything to keep
 138   // it from being unloaded during parsing of the unsafe anonymous class.
 139   // The null-class-loader should always be kept alive.
 140   _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),
 141   _claim(0),
 142   _handles(),
 143   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
 144   _jmethod_ids(NULL),
 145   _deallocate_list(NULL),
 146   _next(NULL),
 147   _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {
 148 
 149   if (!h_class_loader.is_null()) {
 150     _class_loader = _handles.add(h_class_loader());
 151     _class_loader_klass = h_class_loader-&gt;klass();
 152     initialize_name(h_class_loader);
 153   }
 154 
 155   if (!has_class_mirror_holder) {
 156     // The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,
 157     // and before calling anything that call class_loader().
 158     initialize_holder(h_class_loader);
 159 
 160     // A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should
 161     // never have a ModuleEntryTable or PackageEntryTable created for it. The defining package
 162     // and module for an unsafe anonymous class will be found in its host class.
 163     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
 164     if (h_class_loader.is_null()) {
 165       // Create unnamed module for boot loader
 166       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
 167     } else {
 168       // Create unnamed module for all other loaders
 169       _unnamed_module = ModuleEntry::create_unnamed_module(this);
 170     }
 171     _dictionary = create_dictionary();
 172   }
 173 
 174   NOT_PRODUCT(_dependency_count = 0); // number of class loader dependencies
 175 
 176   JFR_ONLY(INIT_ID(this);)
 177 }
 178 
 179 ClassLoaderData::ChunkedHandleList::~ChunkedHandleList() {
 180   Chunk* c = _head;
 181   while (c != NULL) {
 182     Chunk* next = c-&gt;_next;
 183     delete c;
 184     c = next;
 185   }
 186 }
 187 
 188 OopHandle ClassLoaderData::ChunkedHandleList::add(oop o) {
 189   if (_head == NULL || _head-&gt;_size == Chunk::CAPACITY) {
 190     Chunk* next = new Chunk(_head);
 191     Atomic::release_store(&amp;_head, next);
 192   }
 193   oop* handle = &amp;_head-&gt;_data[_head-&gt;_size];
 194   NativeAccess&lt;IS_DEST_UNINITIALIZED&gt;::oop_store(handle, o);
 195   Atomic::release_store(&amp;_head-&gt;_size, _head-&gt;_size + 1);
 196   return OopHandle(handle);
 197 }
 198 
 199 int ClassLoaderData::ChunkedHandleList::count() const {
 200   int count = 0;
 201   Chunk* chunk = _head;
 202   while (chunk != NULL) {
 203     count += chunk-&gt;_size;
 204     chunk = chunk-&gt;_next;
 205   }
 206   return count;
 207 }
 208 
 209 inline void ClassLoaderData::ChunkedHandleList::oops_do_chunk(OopClosure* f, Chunk* c, const juint size) {
 210   for (juint i = 0; i &lt; size; i++) {
 211     if (c-&gt;_data[i] != NULL) {
 212       f-&gt;do_oop(&amp;c-&gt;_data[i]);
 213     }
 214   }
 215 }
 216 
 217 void ClassLoaderData::ChunkedHandleList::oops_do(OopClosure* f) {
 218   Chunk* head = Atomic::load_acquire(&amp;_head);
 219   if (head != NULL) {
 220     // Must be careful when reading size of head
 221     oops_do_chunk(f, head, Atomic::load_acquire(&amp;head-&gt;_size));
 222     for (Chunk* c = head-&gt;_next; c != NULL; c = c-&gt;_next) {
 223       oops_do_chunk(f, c, c-&gt;_size);
 224     }
 225   }
 226 }
 227 
 228 class VerifyContainsOopClosure : public OopClosure {
 229   oop  _target;
 230   bool _found;
 231 
 232  public:
 233   VerifyContainsOopClosure(oop target) : _target(target), _found(false) {}
 234 
 235   void do_oop(oop* p) {
 236     if (p != NULL &amp;&amp; NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(p) == _target) {
 237       _found = true;
 238     }
 239   }
 240 
 241   void do_oop(narrowOop* p) {
 242     // The ChunkedHandleList should not contain any narrowOop
 243     ShouldNotReachHere();
 244   }
 245 
 246   bool found() const {
 247     return _found;
 248   }
 249 };
 250 
 251 bool ClassLoaderData::ChunkedHandleList::contains(oop p) {
 252   VerifyContainsOopClosure cl(p);
 253   oops_do(&amp;cl);
 254   return cl.found();
 255 }
 256 
 257 #ifndef PRODUCT
 258 bool ClassLoaderData::ChunkedHandleList::owner_of(oop* oop_handle) {
 259   Chunk* chunk = _head;
 260   while (chunk != NULL) {
 261     if (&amp;(chunk-&gt;_data[0]) &lt;= oop_handle &amp;&amp; oop_handle &lt; &amp;(chunk-&gt;_data[chunk-&gt;_size])) {
 262       return true;
 263     }
 264     chunk = chunk-&gt;_next;
 265   }
 266   return false;
 267 }
 268 #endif // PRODUCT
 269 
 270 void ClassLoaderData::clear_claim(int claim) {
 271   for (;;) {
 272     int old_claim = Atomic::load(&amp;_claim);
 273     if ((old_claim &amp; claim) == 0) {
 274       return;
 275     }
 276     int new_claim = old_claim &amp; ~claim;
 277     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
 278       return;
 279     }
 280   }
 281 }
 282 
 283 bool ClassLoaderData::try_claim(int claim) {
 284   for (;;) {
 285     int old_claim = Atomic::load(&amp;_claim);
 286     if ((old_claim &amp; claim) == claim) {
 287       return false;
 288     }
 289     int new_claim = old_claim | claim;
 290     if (Atomic::cmpxchg(&amp;_claim, old_claim, new_claim) == old_claim) {
 291       return true;
 292     }
 293   }
 294 }
 295 
 296 // Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
 297 // while the class is being parsed, and if the class appears on the module fixup list.
 298 // Due to the uniqueness that no other class shares the hidden or unsafe anonymous class' name or
 299 // ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while
 300 // it is being defined, therefore _keep_alive is not volatile or atomic.
 301 void ClassLoaderData::inc_keep_alive() {
 302   if (has_class_mirror_holder()) {
 303     if (!Arguments::is_dumping_archive()) {
 304       assert(_keep_alive &gt; 0, "Invalid keep alive increment count");
 305     }
 306     _keep_alive++;
 307   }
 308 }
 309 
 310 void ClassLoaderData::dec_keep_alive() {
 311   if (has_class_mirror_holder()) {
 312     assert(_keep_alive &gt; 0, "Invalid keep alive decrement count");
 313     _keep_alive--;
 314   }
 315 }
 316 
 317 void ClassLoaderData::oops_do(OopClosure* f, int claim_value, bool clear_mod_oops) {
 318   if (claim_value != ClassLoaderData::_claim_none &amp;&amp; !try_claim(claim_value)) {
 319     return;
 320   }
 321 
 322   // Only clear modified_oops after the ClassLoaderData is claimed.
 323   if (clear_mod_oops) {
 324     clear_modified_oops();
 325   }
 326 
 327   _handles.oops_do(f);
 328 }
 329 
 330 void ClassLoaderData::classes_do(KlassClosure* klass_closure) {
 331   // Lock-free access requires load_acquire
 332   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 333     klass_closure-&gt;do_klass(k);
 334     assert(k != k-&gt;next_link(), "no loops!");
 335   }
 336 }
 337 
 338 void ClassLoaderData::classes_do(void f(Klass * const)) {
 339   // Lock-free access requires load_acquire
 340   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 341     f(k);
 342     assert(k != k-&gt;next_link(), "no loops!");
 343   }
 344 }
 345 
 346 void ClassLoaderData::methods_do(void f(Method*)) {
 347   // Lock-free access requires load_acquire
 348   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 349     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded()) {
 350       InstanceKlass::cast(k)-&gt;methods_do(f);
 351     }
 352   }
 353 }
 354 
 355 void ClassLoaderData::loaded_classes_do(KlassClosure* klass_closure) {
 356   // Lock-free access requires load_acquire
 357   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 358     // Do not filter ArrayKlass oops here...
 359     if (k-&gt;is_array_klass() || (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;is_loaded())) {
 360 #ifdef ASSERT
 361       oop m = k-&gt;java_mirror();
 362       assert(m != NULL, "NULL mirror");
 363       assert(m-&gt;is_a(SystemDictionary::Class_klass()), "invalid mirror");
 364 #endif
 365       klass_closure-&gt;do_klass(k);
 366     }
 367   }
 368 }
 369 
 370 void ClassLoaderData::classes_do(void f(InstanceKlass*)) {
 371   // Lock-free access requires load_acquire
 372   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 373     if (k-&gt;is_instance_klass()) {
 374       f(InstanceKlass::cast(k));
 375     }
 376     assert(k != k-&gt;next_link(), "no loops!");
 377   }
 378 }
 379 
 380 void ClassLoaderData::modules_do(void f(ModuleEntry*)) {
 381   assert_locked_or_safepoint(Module_lock);
 382   if (_unnamed_module != NULL) {
 383     f(_unnamed_module);
 384   }
 385   if (_modules != NULL) {
 386     for (int i = 0; i &lt; _modules-&gt;table_size(); i++) {
 387       for (ModuleEntry* entry = _modules-&gt;bucket(i);
 388            entry != NULL;
 389            entry = entry-&gt;next()) {
 390         f(entry);
 391       }
 392     }
 393   }
 394 }
 395 
 396 void ClassLoaderData::packages_do(void f(PackageEntry*)) {
 397   assert_locked_or_safepoint(Module_lock);
 398   if (_packages != NULL) {
 399     for (int i = 0; i &lt; _packages-&gt;table_size(); i++) {
 400       for (PackageEntry* entry = _packages-&gt;bucket(i);
 401            entry != NULL;
 402            entry = entry-&gt;next()) {
 403         f(entry);
 404       }
 405     }
 406   }
 407 }
 408 
 409 void ClassLoaderData::record_dependency(const Klass* k) {
 410   assert(k != NULL, "invariant");
 411 
 412   ClassLoaderData * const from_cld = this;
 413   ClassLoaderData * const to_cld = k-&gt;class_loader_data();
 414 
 415   // Do not need to record dependency if the dependency is to a class whose
 416   // class loader data is never freed.  (i.e. the dependency's class loader
 417   // is one of the three builtin class loaders and the dependency's class
 418   // loader data has a ClassLoader holder, not a Class holder.)
 419   if (to_cld-&gt;is_permanent_class_loader_data()) {
 420     return;
 421   }
 422 
 423   oop to;
 424   if (to_cld-&gt;has_class_mirror_holder()) {
 425     // Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency
 426     // to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class
 427     // loader data.)
 428     if (to_cld == from_cld) {
 429       return;
 430     }
 431     // Hidden and unsafe anonymous class dependencies are through the mirror.
 432     to = k-&gt;java_mirror();
 433   } else {
 434     to = to_cld-&gt;class_loader();
 435     oop from = from_cld-&gt;class_loader();
 436 
 437     // Just return if this dependency is to a class with the same or a parent
 438     // class_loader.
 439     if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {
 440       return; // this class loader is in the parent list, no need to add it.
 441     }
 442   }
 443 
 444   // It's a dependency we won't find through GC, add it.
 445   if (!_handles.contains(to)) {
 446     NOT_PRODUCT(Atomic::inc(&amp;_dependency_count));
 447     LogTarget(Trace, class, loader, data) lt;
 448     if (lt.is_enabled()) {
 449       ResourceMark rm;
 450       LogStream ls(lt);
 451       ls.print("adding dependency from ");
 452       print_value_on(&amp;ls);
 453       ls.print(" to ");
 454       to_cld-&gt;print_value_on(&amp;ls);
 455       ls.cr();
 456     }
 457     Handle dependency(Thread::current(), to);
 458     add_handle(dependency);
 459     // Added a potentially young gen oop to the ClassLoaderData
 460     record_modified_oops();
 461   }
 462 }
 463 
 464 void ClassLoaderData::add_class(Klass* k, bool publicize /* true */) {
 465   {
 466     MutexLocker ml(metaspace_lock(), Mutex::_no_safepoint_check_flag);
 467     Klass* old_value = _klasses;
 468     k-&gt;set_next_link(old_value);
 469     // Link the new item into the list, making sure the linked class is stable
 470     // since the list can be walked without a lock
 471     Atomic::release_store(&amp;_klasses, k);
 472     if (k-&gt;is_array_klass()) {
 473       ClassLoaderDataGraph::inc_array_classes(1);
 474     } else {
 475       ClassLoaderDataGraph::inc_instance_classes(1);
 476     }
 477   }
 478 
 479   if (publicize) {
 480     LogTarget(Trace, class, loader, data) lt;
 481     if (lt.is_enabled()) {
 482       ResourceMark rm;
 483       LogStream ls(lt);
 484       ls.print("Adding k: " PTR_FORMAT " %s to ", p2i(k), k-&gt;external_name());
 485       print_value_on(&amp;ls);
 486       ls.cr();
 487     }
 488   }
 489 }
 490 
 491 void ClassLoaderData::initialize_holder(Handle loader_or_mirror) {
 492   if (loader_or_mirror() != NULL) {
 493     assert(_holder.is_null(), "never replace holders");
 494     _holder = WeakHandle(Universe::vm_weak(), loader_or_mirror);
 495   }
 496 }
 497 
 498 // Remove a klass from the _klasses list for scratch_class during redefinition
 499 // or parsed class in the case of an error.
 500 void ClassLoaderData::remove_class(Klass* scratch_class) {
 501   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
 502 
 503   // Adjust global class iterator.
 504   ClassLoaderDataGraph::adjust_saved_class(scratch_class);
 505 
 506   Klass* prev = NULL;
 507   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 508     if (k == scratch_class) {
 509       if (prev == NULL) {
 510         _klasses = k-&gt;next_link();
 511       } else {
 512         Klass* next = k-&gt;next_link();
 513         prev-&gt;set_next_link(next);
 514       }
 515 
 516       if (k-&gt;is_array_klass()) {
 517         ClassLoaderDataGraph::dec_array_classes(1);
 518       } else {
 519         ClassLoaderDataGraph::dec_instance_classes(1);
 520       }
 521 
 522       return;
 523     }
 524     prev = k;
 525     assert(k != k-&gt;next_link(), "no loops!");
 526   }
 527   ShouldNotReachHere();   // should have found this class!!
 528 }
 529 
 530 void ClassLoaderData::unload() {
 531   _unloading = true;
 532 
 533   LogTarget(Trace, class, loader, data) lt;
 534   if (lt.is_enabled()) {
 535     ResourceMark rm;
 536     LogStream ls(lt);
 537     ls.print("unload");
 538     print_value_on(&amp;ls);
 539     ls.cr();
 540   }
 541 
 542   // Some items on the _deallocate_list need to free their C heap structures
 543   // if they are not already on the _klasses list.
 544   free_deallocate_list_C_heap_structures();
 545 
 546   // Clean up class dependencies and tell serviceability tools
 547   // these classes are unloading.  Must be called
 548   // after erroneous classes are released.
 549   classes_do(InstanceKlass::unload_class);
 550 
 551   // Clean up global class iterator for compiler
 552   ClassLoaderDataGraph::adjust_saved_class(this);
 553 }
 554 
 555 ModuleEntryTable* ClassLoaderData::modules() {
 556   // Lazily create the module entry table at first request.
 557   // Lock-free access requires load_acquire.
 558   ModuleEntryTable* modules = Atomic::load_acquire(&amp;_modules);
 559   if (modules == NULL) {
 560     MutexLocker m1(Module_lock);
 561     // Check if _modules got allocated while we were waiting for this lock.
 562     if ((modules = _modules) == NULL) {
 563       modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);
 564 
 565       {
 566         MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);
 567         // Ensure _modules is stable, since it is examined without a lock
 568         Atomic::release_store(&amp;_modules, modules);
 569       }
 570     }
 571   }
 572   return modules;
 573 }
 574 
 575 const int _boot_loader_dictionary_size    = 1009;
 576 const int _default_loader_dictionary_size = 107;
 577 
 578 Dictionary* ClassLoaderData::create_dictionary() {
 579   assert(!has_class_mirror_holder(), "class mirror holder cld does not have a dictionary");
 580   int size;
 581   bool resizable = false;
 582   if (_the_null_class_loader_data == NULL) {
 583     size = _boot_loader_dictionary_size;
 584     resizable = true;
 585   } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
 586     size = 1;  // there's only one class in relection class loader and no initiated classes
 587   } else if (is_system_class_loader_data()) {
 588     size = _boot_loader_dictionary_size;
 589     resizable = true;
 590   } else {
 591     size = _default_loader_dictionary_size;
 592     resizable = true;
 593   }
 594   if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {
 595     resizable = false;
 596   }
 597   return new Dictionary(this, size, resizable);
 598 }
 599 
 600 // Tell the GC to keep this klass alive while iterating ClassLoaderDataGraph
 601 oop ClassLoaderData::holder_phantom() const {
 602   // A klass that was previously considered dead can be looked up in the
 603   // CLD/SD, and its _java_mirror or _class_loader can be stored in a root
 604   // or a reachable object making it alive again. The SATB part of G1 needs
 605   // to get notified about this potential resurrection, otherwise the marking
 606   // might not find the object.
 607   if (!_holder.is_null()) {  // NULL class_loader
 608     return _holder.resolve();
 609   } else {
 610     return NULL;
 611   }
 612 }
 613 
 614 // Let the GC read the holder without keeping it alive.
 615 oop ClassLoaderData::holder_no_keepalive() const {
 616   if (!_holder.is_null()) {  // NULL class_loader
 617     return _holder.peek();
 618   } else {
 619     return NULL;
 620   }
 621 }
 622 
 623 // Unloading support
 624 bool ClassLoaderData::is_alive() const {
 625   bool alive = keep_alive()         // null class loader and incomplete non-strong hidden class or unsafe anonymous class.
 626       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
 627 
 628   return alive;
 629 }
 630 
 631 class ReleaseKlassClosure: public KlassClosure {
 632 private:
 633   size_t  _instance_class_released;
 634   size_t  _array_class_released;
 635 public:
 636   ReleaseKlassClosure() : _instance_class_released(0), _array_class_released(0) { }
 637 
 638   size_t instance_class_released() const { return _instance_class_released; }
 639   size_t array_class_released()    const { return _array_class_released;    }
 640 
 641   void do_klass(Klass* k) {
 642     if (k-&gt;is_array_klass()) {
 643       _array_class_released ++;
 644     } else {
 645       assert(k-&gt;is_instance_klass(), "Must be");
 646       _instance_class_released ++;
 647     }
 648     k-&gt;release_C_heap_structures();
 649   }
 650 };
 651 
 652 ClassLoaderData::~ClassLoaderData() {
 653   // Release C heap structures for all the classes.
 654   ReleaseKlassClosure cl;
 655   classes_do(&amp;cl);
 656 
 657   ClassLoaderDataGraph::dec_array_classes(cl.array_class_released());
 658   ClassLoaderDataGraph::dec_instance_classes(cl.instance_class_released());
 659 
 660   // Release the WeakHandle
 661   _holder.release(Universe::vm_weak());
 662 
 663   // Release C heap allocated hashtable for all the packages.
 664   if (_packages != NULL) {
 665     // Destroy the table itself
 666     delete _packages;
 667     _packages = NULL;
 668   }
 669 
 670   // Release C heap allocated hashtable for all the modules.
 671   if (_modules != NULL) {
 672     // Destroy the table itself
 673     delete _modules;
 674     _modules = NULL;
 675   }
 676 
 677   // Release C heap allocated hashtable for the dictionary
 678   if (_dictionary != NULL) {
 679     // Destroy the table itself
 680     delete _dictionary;
 681     _dictionary = NULL;
 682   }
 683 
 684   if (_unnamed_module != NULL) {
 685     _unnamed_module-&gt;delete_unnamed_module();
 686     _unnamed_module = NULL;
 687   }
 688 
 689   // release the metaspace
 690   ClassLoaderMetaspace *m = _metaspace;
 691   if (m != NULL) {
 692     _metaspace = NULL;
 693     delete m;
 694   }
 695   // Clear all the JNI handles for methods
 696   // These aren't deallocated and are going to look like a leak, but that's
 697   // needed because we can't really get rid of jmethodIDs because we don't
 698   // know when native code is going to stop using them.  The spec says that
 699   // they're "invalid" but existing programs likely rely on their being
 700   // NULL after class unloading.
 701   if (_jmethod_ids != NULL) {
 702     Method::clear_jmethod_ids(this);
 703   }
 704   // Delete lock
 705   delete _metaspace_lock;
 706 
 707   // Delete free list
 708   if (_deallocate_list != NULL) {
 709     delete _deallocate_list;
 710   }
 711 
 712   // Decrement refcounts of Symbols if created.
 713   if (_name != NULL) {
 714     _name-&gt;decrement_refcount();
 715   }
 716   if (_name_and_id != NULL) {
 717     _name_and_id-&gt;decrement_refcount();
 718   }
 719 }
 720 
 721 // Returns true if this class loader data is for the app class loader
 722 // or a user defined system class loader.  (Note that the class loader
 723 // data may have a Class holder.)
 724 bool ClassLoaderData::is_system_class_loader_data() const {
 725   return SystemDictionary::is_system_class_loader(class_loader());
 726 }
 727 
 728 // Returns true if this class loader data is for the platform class loader.
 729 // (Note that the class loader data may have a Class holder.)
 730 bool ClassLoaderData::is_platform_class_loader_data() const {
 731   return SystemDictionary::is_platform_class_loader(class_loader());
 732 }
 733 
 734 // Returns true if the class loader for this class loader data is one of
 735 // the 3 builtin (boot application/system or platform) class loaders,
 736 // including a user-defined system class loader.  Note that if the class
 737 // loader data is for a non-strong hidden class or unsafe anonymous class then it may
 738 // get freed by a GC even if its class loader is one of these loaders.
 739 bool ClassLoaderData::is_builtin_class_loader_data() const {
 740   return (is_boot_class_loader_data() ||
 741           SystemDictionary::is_system_class_loader(class_loader()) ||
 742           SystemDictionary::is_platform_class_loader(class_loader()));
 743 }
 744 
 745 // Returns true if this class loader data is a class loader data
 746 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
 747 // class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
 748 bool ClassLoaderData::is_permanent_class_loader_data() const {
 749   return is_builtin_class_loader_data() &amp;&amp; !has_class_mirror_holder();
 750 }
 751 
 752 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
 753   // If the metaspace has not been allocated, create a new one.  Might want
 754   // to create smaller arena for Reflection class loaders also.
 755   // The reason for the delayed allocation is because some class loaders are
 756   // simply for delegating with no metadata of their own.
 757   // Lock-free access requires load_acquire.
 758   ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&amp;_metaspace);
 759   if (metaspace == NULL) {
 760     MutexLocker ml(_metaspace_lock,  Mutex::_no_safepoint_check_flag);
 761     // Check if _metaspace got allocated while we were waiting for this lock.
 762     if ((metaspace = _metaspace) == NULL) {
 763       if (this == the_null_class_loader_data()) {
 764         assert (class_loader() == NULL, "Must be");
 765         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
 766       } else if (has_class_mirror_holder()) {
 767         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);
 768       } else if (class_loader()-&gt;is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
 769         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
 770       } else {
 771         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
 772       }
 773       // Ensure _metaspace is stable, since it is examined without a lock
 774       Atomic::release_store(&amp;_metaspace, metaspace);
 775     }
 776   }
 777   return metaspace;
 778 }
 779 
 780 OopHandle ClassLoaderData::add_handle(Handle h) {
 781   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
 782   record_modified_oops();
 783   return _handles.add(h());
 784 }
 785 
 786 void ClassLoaderData::remove_handle(OopHandle h) {
 787   assert(!is_unloading(), "Do not remove a handle for a CLD that is unloading");
 788   oop* ptr = h.ptr_raw();
 789   if (ptr != NULL) {
 790     assert(_handles.owner_of(ptr), "Got unexpected handle " PTR_FORMAT, p2i(ptr));
 791     NativeAccess&lt;&gt;::oop_store(ptr, oop(NULL));
 792   }
 793 }
 794 
 795 void ClassLoaderData::init_handle_locked(OopHandle&amp; dest, Handle h) {
 796   MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
 797   if (dest.resolve() != NULL) {
 798     return;
 799   } else {
 800     dest = _handles.add(h());
 801   }
 802 }
 803 
 804 // Add this metadata pointer to be freed when it's safe.  This is only during
 805 // a safepoint which checks if handles point to this metadata field.
 806 void ClassLoaderData::add_to_deallocate_list(Metadata* m) {
 807   // Metadata in shared region isn't deleted.
 808   if (!m-&gt;is_shared()) {
 809     MutexLocker ml(metaspace_lock(),  Mutex::_no_safepoint_check_flag);
 810     if (_deallocate_list == NULL) {
 811       _deallocate_list = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Metadata*&gt;(100, mtClass);
 812     }
 813     _deallocate_list-&gt;append_if_missing(m);
 814     log_debug(class, loader, data)("deallocate added for %s", m-&gt;print_value_string());
 815     ClassLoaderDataGraph::set_should_clean_deallocate_lists();
 816   }
 817 }
 818 
 819 // Deallocate free metadata on the free list.  How useful the PermGen was!
 820 void ClassLoaderData::free_deallocate_list() {
 821   // This must be called at a safepoint because it depends on metadata walking at
 822   // safepoint cleanup time.
 823   assert(SafepointSynchronize::is_at_safepoint(), "only called at safepoint");
 824   assert(!is_unloading(), "only called for ClassLoaderData that are not unloading");
 825   if (_deallocate_list == NULL) {
 826     return;
 827   }
 828   // Go backwards because this removes entries that are freed.
 829   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
 830     Metadata* m = _deallocate_list-&gt;at(i);
 831     if (!m-&gt;on_stack()) {
 832       _deallocate_list-&gt;remove_at(i);
 833       // There are only three types of metadata that we deallocate directly.
 834       // Cast them so they can be used by the template function.
 835       if (m-&gt;is_method()) {
 836         MetadataFactory::free_metadata(this, (Method*)m);
 837       } else if (m-&gt;is_constantPool()) {
 838         MetadataFactory::free_metadata(this, (ConstantPool*)m);
 839       } else if (m-&gt;is_klass()) {
 840         MetadataFactory::free_metadata(this, (InstanceKlass*)m);
 841       } else {
 842         ShouldNotReachHere();
 843       }
 844     } else {
 845       // Metadata is alive.
 846       // If scratch_class is on stack then it shouldn't be on this list!
 847       assert(!m-&gt;is_klass() || !((InstanceKlass*)m)-&gt;is_scratch_class(),
 848              "scratch classes on this list should be dead");
 849       // Also should assert that other metadata on the list was found in handles.
 850       // Some cleaning remains.
 851       ClassLoaderDataGraph::set_should_clean_deallocate_lists();
 852     }
 853   }
 854 }
 855 
 856 // This is distinct from free_deallocate_list.  For class loader data that are
 857 // unloading, this frees the C heap memory for items on the list, and unlinks
 858 // scratch or error classes so that unloading events aren't triggered for these
 859 // classes. The metadata is removed with the unloading metaspace.
 860 // There isn't C heap memory allocated for methods, so nothing is done for them.
 861 void ClassLoaderData::free_deallocate_list_C_heap_structures() {
 862   assert_locked_or_safepoint(ClassLoaderDataGraph_lock);
 863   assert(is_unloading(), "only called for ClassLoaderData that are unloading");
 864   if (_deallocate_list == NULL) {
 865     return;
 866   }
 867   // Go backwards because this removes entries that are freed.
 868   for (int i = _deallocate_list-&gt;length() - 1; i &gt;= 0; i--) {
 869     Metadata* m = _deallocate_list-&gt;at(i);
 870     _deallocate_list-&gt;remove_at(i);
 871     if (m-&gt;is_constantPool()) {
 872       ((ConstantPool*)m)-&gt;release_C_heap_structures();
 873     } else if (m-&gt;is_klass()) {
 874       InstanceKlass* ik = (InstanceKlass*)m;
 875       // also releases ik-&gt;constants() C heap memory
 876       ik-&gt;release_C_heap_structures();
 877       // Remove the class so unloading events aren't triggered for
 878       // this class (scratch or error class) in do_unloading().
 879       remove_class(ik);
 880     }
 881   }
 882 }
 883 
 884 // Caller needs ResourceMark
 885 // If the class loader's _name has not been explicitly set, the class loader's
 886 // qualified class name is returned.
 887 const char* ClassLoaderData::loader_name() const {
 888    if (_class_loader_klass == NULL) {
 889      return BOOTSTRAP_LOADER_NAME;
 890    } else if (_name != NULL) {
 891      return _name-&gt;as_C_string();
 892    } else {
 893      return _class_loader_klass-&gt;external_name();
 894    }
 895 }
 896 
 897 // Caller needs ResourceMark
 898 // Format of the _name_and_id is as follows:
 899 //   If the defining loader has a name explicitly set then '&lt;loader-name&gt;' @&lt;id&gt;
 900 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
 901 //   If built-in loader, then omit '@&lt;id&gt;' as there is only one instance.
 902 const char* ClassLoaderData::loader_name_and_id() const {
 903   if (_class_loader_klass == NULL) {
 904     return "'" BOOTSTRAP_LOADER_NAME "'";
 905   } else if (_name_and_id != NULL) {
 906     return _name_and_id-&gt;as_C_string();
 907   } else {
 908     // May be called in a race before _name_and_id is initialized.
 909     return _class_loader_klass-&gt;external_name();
 910   }
 911 }
 912 
 913 void ClassLoaderData::print_value_on(outputStream* out) const {
 914   if (!is_unloading() &amp;&amp; class_loader() != NULL) {
 915     out-&gt;print("loader data: " INTPTR_FORMAT " for instance ", p2i(this));
 916     class_loader()-&gt;print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
 917   } else {
 918     // loader data: 0xsomeaddr of 'bootstrap'
 919     out-&gt;print("loader data: " INTPTR_FORMAT " of %s", p2i(this), loader_name_and_id());
 920   }
 921   if (_has_class_mirror_holder) {
 922     out-&gt;print(" has a class holder");
 923   }
 924 }
 925 
 926 void ClassLoaderData::print_value() const { print_value_on(tty); }
 927 
 928 #ifndef PRODUCT
 929 void ClassLoaderData::print_on(outputStream* out) const {
 930   out-&gt;print("ClassLoaderData CLD: " PTR_FORMAT ", loader: " PTR_FORMAT ", loader_klass: %s {",
 931               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
 932   if (has_class_mirror_holder()) out-&gt;print(" has a class holder");
 933   if (claimed()) out-&gt;print(" claimed");
 934   if (is_unloading()) out-&gt;print(" unloading");
 935   out-&gt;print(" metaspace: " INTPTR_FORMAT, p2i(metaspace_or_null()));
 936 
 937   if (_jmethod_ids != NULL) {
 938     Method::print_jmethod_ids(this, out);
 939   }
 940   out-&gt;print(" handles count %d", _handles.count());
 941   out-&gt;print(" dependencies %d", _dependency_count);
 942   out-&gt;print_cr("}");
 943 }
 944 #endif // PRODUCT
 945 
 946 void ClassLoaderData::print() const { print_on(tty); }
 947 
 948 void ClassLoaderData::verify() {
 949   assert_locked_or_safepoint(_metaspace_lock);
 950   oop cl = class_loader();
 951 
 952   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
 953   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 954 
 955   // Verify the integrity of the allocated space.
<a name="2" id="anc2"></a>
 956   if (metaspace_or_null() != NULL) {
 957     metaspace_or_null()-&gt;verify();
 958   }
<a name="3" id="anc3"></a>
 959 
 960   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 961     guarantee(k-&gt;class_loader_data() == this, "Must be the same");
 962     k-&gt;verify();
 963     assert(k != k-&gt;next_link(), "no loops!");
 964   }
 965 }
 966 
 967 bool ClassLoaderData::contains_klass(Klass* klass) {
 968   // Lock-free access requires load_acquire
 969   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 970     if (k == klass) return true;
 971   }
 972   return false;
 973 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="4" type="hidden" /></form></body></html>
