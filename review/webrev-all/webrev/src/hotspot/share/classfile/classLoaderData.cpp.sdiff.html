<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/classfile </title>
</head><body id="SUNWwebrev">
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderData.hpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/classfile/classLoaderData.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60538">60538</a> : imported patch jep387-all.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
  42 //
  43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
  44 // that represent the loader's "linking domain" in the JVM.
  45 //
  46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
  47 // the singleton class the_null_class_loader_data().
  48 
  49 #include "precompiled.hpp"
  50 #include "classfile/classLoaderData.inline.hpp"
  51 #include "classfile/classLoaderDataGraph.inline.hpp"
  52 #include "classfile/dictionary.hpp"
  53 #include "classfile/javaClasses.hpp"
  54 #include "classfile/moduleEntry.hpp"
  55 #include "classfile/packageEntry.hpp"
  56 #include "classfile/symbolTable.hpp"
  57 #include "classfile/systemDictionary.hpp"
  58 #include "logging/log.hpp"
  59 #include "logging/logStream.hpp"
  60 #include "memory/allocation.inline.hpp"
  61 #include "memory/metadataFactory.hpp"

  62 #include "memory/resourceArea.hpp"
  63 #include "memory/universe.hpp"
  64 #include "oops/access.inline.hpp"
  65 #include "oops/oop.inline.hpp"
  66 #include "oops/oopHandle.inline.hpp"
  67 #include "oops/weakHandle.inline.hpp"
  68 #include "runtime/atomic.hpp"
  69 #include "runtime/handles.inline.hpp"
  70 #include "runtime/mutex.hpp"
  71 #include "runtime/safepoint.hpp"
  72 #include "utilities/growableArray.hpp"
  73 #include "utilities/macros.hpp"
  74 #include "utilities/ostream.hpp"
  75 
  76 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
  77 
  78 void ClassLoaderData::init_null_class_loader_data() {
  79   assert(_the_null_class_loader_data == NULL, "cannot initialize twice");
  80   assert(ClassLoaderDataGraph::_head == NULL, "cannot initialize twice");
  81 

</pre><hr></hr><pre>
 933 
 934   if (_jmethod_ids != NULL) {
 935     Method::print_jmethod_ids(this, out);
 936   }
 937   out-&gt;print(" handles count %d", _handles.count());
 938   out-&gt;print(" dependencies %d", _dependency_count);
 939   out-&gt;print_cr("}");
 940 }
 941 #endif // PRODUCT
 942 
 943 void ClassLoaderData::print() const { print_on(tty); }
 944 
 945 void ClassLoaderData::verify() {
 946   assert_locked_or_safepoint(_metaspace_lock);
 947   oop cl = class_loader();
 948 
 949   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
 950   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 951 
 952   // Verify the integrity of the allocated space.

 953   if (metaspace_or_null() != NULL) {
 954     metaspace_or_null()-&gt;verify();
 955   }

 956 
 957   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 958     guarantee(k-&gt;class_loader_data() == this, "Must be the same");
 959     k-&gt;verify();
 960     assert(k != k-&gt;next_link(), "no loops!");
 961   }
 962 }
 963 
 964 bool ClassLoaderData::contains_klass(Klass* klass) {
 965   // Lock-free access requires load_acquire
 966   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 967     if (k == klass) return true;
 968   }
 969   return false;
 970 }
</pre></td><td><pre>

</pre><hr></hr><pre>
  42 //
  43 // Instances of java.lang.ClassLoader holds a pointer to a ClassLoaderData that
  44 // that represent the loader's "linking domain" in the JVM.
  45 //
  46 // The bootstrap loader (represented by NULL) also has a ClassLoaderData,
  47 // the singleton class the_null_class_loader_data().
  48 
  49 #include "precompiled.hpp"
  50 #include "classfile/classLoaderData.inline.hpp"
  51 #include "classfile/classLoaderDataGraph.inline.hpp"
  52 #include "classfile/dictionary.hpp"
  53 #include "classfile/javaClasses.hpp"
  54 #include "classfile/moduleEntry.hpp"
  55 #include "classfile/packageEntry.hpp"
  56 #include "classfile/symbolTable.hpp"
  57 #include "classfile/systemDictionary.hpp"
  58 #include "logging/log.hpp"
  59 #include "logging/logStream.hpp"
  60 #include "memory/allocation.inline.hpp"
  61 #include "memory/metadataFactory.hpp"
<span class="new">  62 #include "memory/metaspace.hpp"</span>
  63 #include "memory/resourceArea.hpp"
  64 #include "memory/universe.hpp"
  65 #include "oops/access.inline.hpp"
  66 #include "oops/oop.inline.hpp"
  67 #include "oops/oopHandle.inline.hpp"
  68 #include "oops/weakHandle.inline.hpp"
  69 #include "runtime/atomic.hpp"
  70 #include "runtime/handles.inline.hpp"
  71 #include "runtime/mutex.hpp"
  72 #include "runtime/safepoint.hpp"
  73 #include "utilities/growableArray.hpp"
  74 #include "utilities/macros.hpp"
  75 #include "utilities/ostream.hpp"
  76 
  77 ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;
  78 
  79 void ClassLoaderData::init_null_class_loader_data() {
  80   assert(_the_null_class_loader_data == NULL, "cannot initialize twice");
  81   assert(ClassLoaderDataGraph::_head == NULL, "cannot initialize twice");
  82 

</pre><hr></hr><pre>
 934 
 935   if (_jmethod_ids != NULL) {
 936     Method::print_jmethod_ids(this, out);
 937   }
 938   out-&gt;print(" handles count %d", _handles.count());
 939   out-&gt;print(" dependencies %d", _dependency_count);
 940   out-&gt;print_cr("}");
 941 }
 942 #endif // PRODUCT
 943 
 944 void ClassLoaderData::print() const { print_on(tty); }
 945 
 946 void ClassLoaderData::verify() {
 947   assert_locked_or_safepoint(_metaspace_lock);
 948   oop cl = class_loader();
 949 
 950   guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
 951   guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 952 
 953   // Verify the integrity of the allocated space.
<span class="new"> 954 #ifdef ASSERT</span>
 955   if (metaspace_or_null() != NULL) {
 956     metaspace_or_null()-&gt;verify();
 957   }
<span class="new"> 958 #endif</span>
 959 
 960   for (Klass* k = _klasses; k != NULL; k = k-&gt;next_link()) {
 961     guarantee(k-&gt;class_loader_data() == this, "Must be the same");
 962     k-&gt;verify();
 963     assert(k != k-&gt;next_link(), "no loops!");
 964   }
 965 }
 966 
 967 bool ClassLoaderData::contains_klass(Klass* klass) {
 968   // Lock-free access requires load_acquire
 969   for (Klass* k = Atomic::load_acquire(&amp;_klasses); k != NULL; k = k-&gt;next_link()) {
 970     if (k == klass) return true;
 971   }
 972   return false;
 973 }
</pre></td>
</tr></table>
<center>&lt prev <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/classfile/classLoaderData.hpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
