<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace.hpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/memory/metaspace.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace/chunkManager.cpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace.hpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60538">60538</a> : imported patch jep387-all.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 26,102 ****</span>
  
  #include "memory/allocation.hpp"
  #include "memory/memRegion.hpp"
  #include "memory/metaspaceChunkFreeListSummary.hpp"
  #include "memory/virtualspace.hpp"
<span class="removed">- #include "memory/metaspace/metaspaceSizesSnapshot.hpp"</span>
  #include "runtime/globals.hpp"
  #include "utilities/exceptions.hpp"
<span class="changed">! </span>
<span class="changed">! // Metaspace</span>
<span class="changed">! //</span>
<span class="changed">! // Metaspaces are Arenas for the VM's metadata.</span>
<span class="changed">! // They are allocated one per class loader object, and one for the null</span>
<span class="changed">! // bootstrap class loader</span>
<span class="changed">! //</span>
<span class="changed">! //    block X ---+       +-------------------+</span>
<span class="changed">! //               |       |  Virtualspace     |</span>
<span class="changed">! //               |       |                   |</span>
<span class="changed">! //               |       |                   |</span>
<span class="changed">! //               |       |-------------------|</span>
<span class="changed">! //               |       || Chunk            |</span>
<span class="changed">! //               |       ||                  |</span>
<span class="changed">! //               |       ||----------        |</span>
<span class="changed">! //               +------&gt;||| block 0 |       |</span>
<span class="changed">! //                       ||----------        |</span>
<span class="changed">! //                       ||| block 1 |       |</span>
<span class="changed">! //                       ||----------        |</span>
<span class="changed">! //                       ||                  |</span>
<span class="changed">! //                       |-------------------|</span>
<span class="changed">! //                       |                   |</span>
<span class="changed">! //                       |                   |</span>
<span class="changed">! //                       +-------------------+</span>
<span class="changed">! //</span>
  
  class ClassLoaderData;
  class MetaspaceTracer;
  class Mutex;
  class outputStream;
  
<span class="removed">- class CollectedHeap;</span>
<span class="removed">- </span>
  namespace metaspace {
<span class="changed">!   class ChunkManager;</span>
<span class="changed">!   class ClassLoaderMetaspaceStatistics;</span>
<span class="changed">!   class Metablock;</span>
<span class="changed">!   class Metachunk;</span>
<span class="changed">!   class PrintCLDMetaspaceInfoClosure;</span>
<span class="changed">!   class SpaceManager;</span>
<span class="changed">!   class VirtualSpaceList;</span>
<span class="changed">!   class VirtualSpaceNode;</span>
  }
  
<span class="changed">! // Metaspaces each have a  SpaceManager and allocations</span>
<span class="changed">! // are done by the SpaceManager.  Allocations are done</span>
<span class="changed">! // out of the current Metachunk.  When the current Metachunk</span>
<span class="changed">! // is exhausted, the SpaceManager gets a new one from</span>
<span class="changed">! // the current VirtualSpace.  When the VirtualSpace is exhausted</span>
<span class="changed">! // the SpaceManager gets a new one.  The SpaceManager</span>
<span class="changed">! // also manages freelists of available Chunks.</span>
<span class="changed">! //</span>
<span class="changed">! // Currently the space manager maintains the list of</span>
<span class="changed">! // virtual spaces and the list of chunks in use.  Its</span>
<span class="changed">! // allocate() method returns a block for use as a</span>
<span class="changed">! // quantum of metadata.</span>
  
  // Namespace for important central static functions
  // (auxiliary stuff goes into MetaspaceUtils)
  class Metaspace : public AllStatic {
  
    friend class MetaspaceShared;
  
<span class="changed">!  public:</span>
    enum MetadataType {
      ClassType,
      NonClassType,
      MetadataTypeCount
    };
<span class="newmarker">--- 26,60 ----</span>
  
  #include "memory/allocation.hpp"
  #include "memory/memRegion.hpp"
  #include "memory/metaspaceChunkFreeListSummary.hpp"
  #include "memory/virtualspace.hpp"
  #include "runtime/globals.hpp"
  #include "utilities/exceptions.hpp"
<span class="changed">! #include "utilities/globalDefinitions.hpp"</span>
  
  class ClassLoaderData;
<span class="new">+ class MetaspaceShared;</span>
  class MetaspaceTracer;
  class Mutex;
  class outputStream;
  
  namespace metaspace {
<span class="changed">!   class MetaspaceArena;</span>
<span class="changed">!   class MetaspaceSizesSnapshot;</span>
<span class="changed">!   struct clms_stats_t;</span>
  }
  
<span class="changed">! ////////////////// Metaspace ///////////////////////</span>
  
  // Namespace for important central static functions
  // (auxiliary stuff goes into MetaspaceUtils)
  class Metaspace : public AllStatic {
  
    friend class MetaspaceShared;
  
<span class="changed">! public:</span>
    enum MetadataType {
      ClassType,
      NonClassType,
      MetadataTypeCount
    };
<hr /><span class="oldmarker">*** 107,169 ****</span>
      ClassMirrorHolderMetaspaceType = BootMetaspaceType + 1,
      ReflectionMetaspaceType = ClassMirrorHolderMetaspaceType + 1,
      MetaspaceTypeCount
    };
  
<span class="changed">!  private:</span>
<span class="changed">! </span>
<span class="changed">!   // Align up the word size to the allocation word size</span>
<span class="changed">!   static size_t align_word_size_up(size_t);</span>
<span class="changed">! </span>
<span class="changed">!   // Aligned size of the metaspace.</span>
<span class="changed">!   static size_t _compressed_class_space_size;</span>
<span class="changed">! </span>
<span class="changed">!   static size_t compressed_class_space_size() {</span>
<span class="changed">!     return _compressed_class_space_size;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   static void set_compressed_class_space_size(size_t size) {</span>
<span class="changed">!     _compressed_class_space_size = size;</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   static size_t _first_chunk_word_size;</span>
<span class="changed">!   static size_t _first_class_chunk_word_size;</span>
  
<span class="removed">-   static size_t _commit_alignment;</span>
<span class="removed">-   static size_t _reserve_alignment;</span>
    DEBUG_ONLY(static bool   _frozen;)
  
<span class="removed">-   // Virtual Space lists for both classes and other metadata</span>
<span class="removed">-   static metaspace::VirtualSpaceList* _space_list;</span>
<span class="removed">-   static metaspace::VirtualSpaceList* _class_space_list;</span>
<span class="removed">- </span>
<span class="removed">-   static metaspace::ChunkManager* _chunk_manager_metadata;</span>
<span class="removed">-   static metaspace::ChunkManager* _chunk_manager_class;</span>
<span class="removed">- </span>
    static const MetaspaceTracer* _tracer;
  
    static bool _initialized;
  
<span class="changed">!  public:</span>
<span class="changed">!   static metaspace::VirtualSpaceList* space_list()       { return _space_list; }</span>
<span class="changed">!   static metaspace::VirtualSpaceList* class_space_list() { return _class_space_list; }</span>
<span class="changed">!   static metaspace::VirtualSpaceList* get_space_list(MetadataType mdtype) {</span>
<span class="changed">!     assert(mdtype != MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");</span>
<span class="changed">!     return mdtype == ClassType ? class_space_list() : space_list();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   static metaspace::ChunkManager* chunk_manager_metadata() { return _chunk_manager_metadata; }</span>
<span class="changed">!   static metaspace::ChunkManager* chunk_manager_class()    { return _chunk_manager_class; }</span>
<span class="changed">!   static metaspace::ChunkManager* get_chunk_manager(MetadataType mdtype) {</span>
<span class="changed">!     assert(mdtype != MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");</span>
<span class="changed">!     return mdtype == ClassType ? chunk_manager_class() : chunk_manager_metadata();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   // convenience function</span>
<span class="changed">!   static metaspace::ChunkManager* get_chunk_manager(bool is_class) {</span>
<span class="changed">!     return is_class ? chunk_manager_class() : chunk_manager_metadata();</span>
<span class="changed">!   }</span>
  
    static const MetaspaceTracer* tracer() { return _tracer; }
    static void freeze() {
      assert(DumpSharedSpaces, "sanity");
      DEBUG_ONLY(_frozen = true;)
<span class="newmarker">--- 65,83 ----</span>
      ClassMirrorHolderMetaspaceType = BootMetaspaceType + 1,
      ReflectionMetaspaceType = ClassMirrorHolderMetaspaceType + 1,
      MetaspaceTypeCount
    };
  
<span class="changed">! private:</span>
  
    DEBUG_ONLY(static bool   _frozen;)
  
    static const MetaspaceTracer* _tracer;
  
    static bool _initialized;
  
<span class="changed">! public:</span>
  
    static const MetaspaceTracer* tracer() { return _tracer; }
    static void freeze() {
      assert(DumpSharedSpaces, "sanity");
      DEBUG_ONLY(_frozen = true;)
<hr /><span class="oldmarker">*** 186,447 ****</span>
  
    // Given a prereserved space, use that to set up the compressed class space list.
    static void initialize_class_space(ReservedSpace rs);
  
    // Returns true if class space has been setup (initialize_class_space).
<span class="changed">!   static bool class_space_is_initialized() { return _class_space_list != NULL; }</span>
  
  #endif
  
   public:
  
    static void ergo_initialize();
    static void global_initialize();
    static void post_initialize();
  
<span class="changed">!   static void verify_global_initialization();</span>
<span class="changed">! </span>
<span class="changed">!   static size_t first_chunk_word_size() { return _first_chunk_word_size; }</span>
<span class="changed">!   static size_t first_class_chunk_word_size() { return _first_class_chunk_word_size; }</span>
  
<span class="changed">!   static size_t reserve_alignment()       { return _reserve_alignment; }</span>
<span class="changed">!   static size_t reserve_alignment_words() { return _reserve_alignment / BytesPerWord; }</span>
<span class="changed">!   static size_t commit_alignment()        { return _commit_alignment; }</span>
<span class="changed">!   static size_t commit_alignment_words()  { return _commit_alignment / BytesPerWord; }</span>
  
    static MetaWord* allocate(ClassLoaderData* loader_data, size_t word_size,
                              MetaspaceObj::Type type, TRAPS);
  
    static bool contains(const void* ptr);
    static bool contains_non_shared(const void* ptr);
  
    // Free empty virtualspaces
<span class="removed">-   static void purge(MetadataType mdtype);</span>
    static void purge();
  
    static void report_metadata_oome(ClassLoaderData* loader_data, size_t word_size,
<span class="changed">!                                    MetaspaceObj::Type type, MetadataType mdtype, TRAPS);</span>
<span class="changed">! </span>
<span class="changed">!   static const char* metadata_type_name(Metaspace::MetadataType mdtype);</span>
  
    static void print_compressed_class_space(outputStream* st) NOT_LP64({});
  
    // Return TRUE only if UseCompressedClassPointers is True.
    static bool using_class_space() {
      return NOT_LP64(false) LP64_ONLY(UseCompressedClassPointers);
    }
  
<span class="changed">!   static bool is_class_space_allocation(MetadataType mdType) {</span>
<span class="changed">!     return mdType == ClassType &amp;&amp; using_class_space();</span>
<span class="changed">!   }</span>
<span class="changed">! </span>
<span class="changed">!   static bool initialized() { return _initialized; }</span>
  
  };
  
<span class="changed">! // Manages the metaspace portion belonging to a class loader</span>
  class ClassLoaderMetaspace : public CHeapObj&lt;mtClass&gt; {
<span class="removed">-   friend class CollectedHeap; // For expand_and_allocate()</span>
<span class="removed">-   friend class ZCollectedHeap; // For expand_and_allocate()</span>
<span class="removed">-   friend class ShenandoahHeap; // For expand_and_allocate()</span>
<span class="removed">-   friend class Metaspace;</span>
<span class="removed">-   friend class MetaspaceUtils;</span>
<span class="removed">-   friend class metaspace::PrintCLDMetaspaceInfoClosure;</span>
<span class="removed">-   friend class VM_CollectForMetadataAllocation; // For expand_and_allocate()</span>
  
<span class="changed">!  private:</span>
<span class="changed">! </span>
<span class="changed">!   void initialize(Mutex* lock, Metaspace::MetaspaceType type);</span>
<span class="changed">! </span>
<span class="changed">!   // Initialize the first chunk for a Metaspace.  Used for</span>
<span class="changed">!   // special cases such as the boot class loader, reflection</span>
<span class="changed">!   // class loader and hidden class loader.</span>
<span class="changed">!   void initialize_first_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype);</span>
<span class="changed">!   metaspace::Metachunk* get_initialization_chunk(Metaspace::MetaspaceType type, Metaspace::MetadataType mdtype);</span>
  
    const Metaspace::MetaspaceType _space_type;
<span class="removed">-   Mutex* const  _lock;</span>
<span class="removed">-   metaspace::SpaceManager* _vsm;</span>
<span class="removed">-   metaspace::SpaceManager* _class_vsm;</span>
  
<span class="changed">!   metaspace::SpaceManager* vsm() const { return _vsm; }</span>
<span class="changed">!   metaspace::SpaceManager* class_vsm() const { return _class_vsm; }</span>
<span class="changed">!   metaspace::SpaceManager* get_space_manager(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!     assert(mdtype != Metaspace::MetadataTypeCount, "MetadaTypeCount can't be used as mdtype");</span>
<span class="changed">!     return mdtype == Metaspace::ClassType ? class_vsm() : vsm();</span>
<span class="changed">!   }</span>
  
    Mutex* lock() const { return _lock; }
  
<span class="changed">!   MetaWord* expand_and_allocate(size_t size, Metaspace::MetadataType mdtype);</span>
<span class="changed">! </span>
<span class="changed">!   size_t class_chunk_size(size_t word_size);</span>
  
<span class="changed">!   // Adds to the given statistic object. Must be locked with CLD metaspace lock.</span>
<span class="changed">!   void add_to_statistics_locked(metaspace::ClassLoaderMetaspaceStatistics* out) const;</span>
  
<span class="changed">!   Metaspace::MetaspaceType space_type() const { return _space_type; }</span>
  
<span class="removed">-  public:</span>
<span class="removed">- </span>
<span class="removed">-   ClassLoaderMetaspace(Mutex* lock, Metaspace::MetaspaceType type);</span>
    ~ClassLoaderMetaspace();
  
<span class="changed">!   // Allocate space for metadata of type mdtype. This is space</span>
<span class="changed">!   // within a Metachunk and is used by</span>
<span class="changed">!   //   allocate(ClassLoaderData*, size_t, bool, MetadataType, TRAPS)</span>
<span class="changed">!   MetaWord* allocate(size_t word_size, Metaspace::MetadataType mdtype);</span>
<span class="changed">! </span>
<span class="changed">!   size_t allocated_blocks_bytes() const;</span>
<span class="changed">!   size_t allocated_chunks_bytes() const;</span>
<span class="changed">! </span>
<span class="changed">!   void deallocate(MetaWord* ptr, size_t byte_size, bool is_class);</span>
<span class="changed">! </span>
<span class="changed">!   void print_on(outputStream* st) const;</span>
<span class="changed">!   // Debugging support</span>
<span class="changed">!   void verify();</span>
<span class="changed">! </span>
<span class="changed">!   // Adds to the given statistic object. Will lock with CLD metaspace lock.</span>
<span class="changed">!   void add_to_statistics(metaspace::ClassLoaderMetaspaceStatistics* out) const;</span>
<span class="changed">! </span>
<span class="changed">! }; // ClassLoaderMetaspace</span>
<span class="changed">! </span>
<span class="changed">! class MetaspaceUtils : AllStatic {</span>
  
<span class="changed">!   // Spacemanager updates running counters.</span>
<span class="changed">!   friend class metaspace::SpaceManager;</span>
  
<span class="changed">!   // Special access for error reporting (checks without locks).</span>
<span class="changed">!   friend class oopDesc;</span>
<span class="changed">!   friend class Klass;</span>
<span class="changed">! </span>
<span class="changed">!   // Running counters for statistics concerning in-use chunks.</span>
<span class="changed">!   // Note: capacity = used + free + waste + overhead. Note that we do not</span>
<span class="changed">!   // count free and waste. Their sum can be deduces from the three other values.</span>
<span class="changed">!   // For more details, one should call print_report() from within a safe point.</span>
<span class="changed">!   static size_t _capacity_words [Metaspace:: MetadataTypeCount];</span>
<span class="changed">!   static size_t _overhead_words [Metaspace:: MetadataTypeCount];</span>
<span class="changed">!   static volatile size_t _used_words [Metaspace:: MetadataTypeCount];</span>
<span class="changed">! </span>
<span class="changed">!   // Atomically decrement or increment in-use statistic counters</span>
<span class="changed">!   static void dec_capacity(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">!   static void inc_capacity(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">!   static void dec_used(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">!   static void inc_used(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">!   static void dec_overhead(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">!   static void inc_overhead(Metaspace::MetadataType mdtype, size_t words);</span>
<span class="changed">! </span>
<span class="changed">! </span>
<span class="changed">!   // Getters for the in-use counters.</span>
<span class="changed">!   static size_t capacity_words(Metaspace::MetadataType mdtype)        { return _capacity_words[mdtype]; }</span>
<span class="changed">!   static size_t used_words(Metaspace::MetadataType mdtype)            { return _used_words[mdtype]; }</span>
<span class="changed">!   static size_t overhead_words(Metaspace::MetadataType mdtype)        { return _overhead_words[mdtype]; }</span>
  
<span class="changed">!   static size_t free_chunks_total_words(Metaspace::MetadataType mdtype);</span>
  
<span class="changed">!   // Helper for print_xx_report.</span>
<span class="changed">!   static void print_vs(outputStream* out, size_t scale);</span>
  
<span class="changed">! public:</span>
  
<span class="changed">!   // Collect used metaspace statistics. This involves walking the CLDG. The resulting</span>
<span class="changed">!   // output will be the accumulated values for all live metaspaces.</span>
<span class="changed">!   // Note: method does not do any locking.</span>
<span class="changed">!   static void collect_statistics(metaspace::ClassLoaderMetaspaceStatistics* out);</span>
<span class="changed">! </span>
<span class="changed">!   // Used by MetaspaceCounters</span>
<span class="changed">!   static size_t free_chunks_total_words();</span>
<span class="changed">!   static size_t free_chunks_total_bytes();</span>
<span class="changed">!   static size_t free_chunks_total_bytes(Metaspace::MetadataType mdtype);</span>
<span class="changed">! </span>
<span class="changed">!   static size_t capacity_words() {</span>
<span class="changed">!     return capacity_words(Metaspace::NonClassType) +</span>
<span class="changed">!            capacity_words(Metaspace::ClassType);</span>
<span class="changed">!   }</span>
<span class="changed">!   static size_t capacity_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!     return capacity_words(mdtype) * BytesPerWord;</span>
<span class="changed">!   }</span>
<span class="changed">!   static size_t capacity_bytes() {</span>
<span class="changed">!     return capacity_words() * BytesPerWord;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   static size_t used_words() {</span>
<span class="changed">!     return used_words(Metaspace::NonClassType) +</span>
<span class="changed">!            used_words(Metaspace::ClassType);</span>
<span class="changed">!   }</span>
<span class="changed">!   static size_t used_bytes(Metaspace::MetadataType mdtype) {</span>
<span class="changed">!     return used_words(mdtype) * BytesPerWord;</span>
<span class="changed">!   }</span>
<span class="changed">!   static size_t used_bytes() {</span>
<span class="changed">!     return used_words() * BytesPerWord;</span>
<span class="changed">!   }</span>
  
<span class="removed">-   // Space committed but yet unclaimed by any class loader.</span>
<span class="removed">-   static size_t free_in_vs_bytes();</span>
<span class="removed">-   static size_t free_in_vs_bytes(Metaspace::MetadataType mdtype);</span>
<span class="removed">- </span>
<span class="removed">-   static size_t reserved_bytes(Metaspace::MetadataType mdtype);</span>
<span class="removed">-   static size_t reserved_bytes() {</span>
<span class="removed">-     return reserved_bytes(Metaspace::ClassType) +</span>
<span class="removed">-            reserved_bytes(Metaspace::NonClassType);</span>
<span class="removed">-   }</span>
  
<span class="changed">!   static size_t committed_bytes(Metaspace::MetadataType mdtype);</span>
<span class="changed">!   static size_t committed_bytes() {</span>
<span class="changed">!     return committed_bytes(Metaspace::ClassType) +</span>
<span class="changed">!            committed_bytes(Metaspace::NonClassType);</span>
<span class="changed">!   }</span>
  
<span class="changed">!   static size_t min_chunk_size_words();</span>
  
<span class="changed">!   // Flags for print_report().</span>
<span class="changed">!   enum ReportFlag {</span>
<span class="changed">!     // Show usage by class loader.</span>
<span class="changed">!     rf_show_loaders                 = (1 &lt;&lt; 0),</span>
<span class="changed">!     // Breaks report down by chunk type (small, medium, ...).</span>
<span class="changed">!     rf_break_down_by_chunktype      = (1 &lt;&lt; 1),</span>
<span class="changed">!     // Breaks report down by space type (hidden, reflection, ...).</span>
<span class="changed">!     rf_break_down_by_spacetype      = (1 &lt;&lt; 2),</span>
<span class="changed">!     // Print details about the underlying virtual spaces.</span>
<span class="changed">!     rf_show_vslist                  = (1 &lt;&lt; 3),</span>
<span class="changed">!     // Print metaspace map.</span>
<span class="changed">!     rf_show_vsmap                   = (1 &lt;&lt; 4),</span>
<span class="changed">!     // If show_loaders: show loaded classes for each loader.</span>
<span class="changed">!     rf_show_classes                 = (1 &lt;&lt; 5)</span>
    };
  
<span class="changed">!   // This will print out a basic metaspace usage report but</span>
<span class="changed">!   // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="changed">!   static void print_basic_report(outputStream* st, size_t scale);</span>
<span class="changed">! </span>
<span class="changed">!   // Prints a report about the current metaspace state.</span>
<span class="changed">!   // Optional parts can be enabled via flags.</span>
<span class="changed">!   // Function will walk the CLDG and will lock the expand lock; if that is not</span>
<span class="changed">!   // convenient, use print_basic_report() instead.</span>
<span class="changed">!   static void print_report(outputStream* out, size_t scale = 0, int flags = 0);</span>
<span class="changed">! </span>
<span class="changed">!   static bool has_chunk_free_list(Metaspace::MetadataType mdtype);</span>
<span class="changed">!   static MetaspaceChunkFreeListSummary chunk_free_list_summary(Metaspace::MetadataType mdtype);</span>
<span class="changed">! </span>
<span class="changed">!   // Log change in used metadata.</span>
<span class="changed">!   static void print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values);</span>
<span class="changed">!   static void print_on(outputStream * out);</span>
<span class="changed">! </span>
<span class="changed">!   // Prints an ASCII representation of the given space.</span>
<span class="changed">!   static void print_metaspace_map(outputStream* out, Metaspace::MetadataType mdtype);</span>
<span class="changed">! </span>
<span class="changed">!   static void dump(outputStream* out);</span>
<span class="changed">!   static void verify_free_chunks();</span>
<span class="changed">!   // Check internal counters (capacity, used).</span>
<span class="changed">!   static void verify_metrics();</span>
  };
  
<span class="changed">! // Metaspace are deallocated when their class loader are GC'ed.</span>
<span class="changed">! // This class implements a policy for inducing GC's to recover</span>
<span class="changed">! // Metaspaces.</span>
<span class="changed">! </span>
<span class="changed">! class MetaspaceGC : AllStatic {</span>
  
    // The current high-water-mark for inducing a GC.
    // When committed memory of all metaspaces reaches this value,
    // a GC is induced and the value is increased. Size is in bytes.
    static volatile size_t _capacity_until_GC;
<span class="newmarker">--- 100,261 ----</span>
  
    // Given a prereserved space, use that to set up the compressed class space list.
    static void initialize_class_space(ReservedSpace rs);
  
    // Returns true if class space has been setup (initialize_class_space).
<span class="changed">!   static bool class_space_is_initialized();</span>
  
  #endif
  
   public:
  
    static void ergo_initialize();
    static void global_initialize();
    static void post_initialize();
  
<span class="changed">!   // Alignment, in bytes, of metaspace mappings</span>
<span class="changed">!   static size_t reserve_alignment()       { return reserve_alignment_words() * BytesPerWord; }</span>
<span class="changed">!   // Alignment, in words, of metaspace mappings</span>
<span class="changed">!   static size_t reserve_alignment_words();</span>
<span class="changed">! </span>
<span class="changed">!   // The granularity at which Metaspace is committed and uncommitted.</span>
<span class="changed">!   // (Todo: Why does this have to be exposed?)</span>
<span class="changed">!   static size_t commit_alignment()        { return commit_alignment_words() * BytesPerWord; }</span>
<span class="changed">!   static size_t commit_alignment_words();</span>
  
<span class="changed">!   // The largest possible single allocation</span>
<span class="changed">!   static size_t max_allocation_word_size();</span>
  
    static MetaWord* allocate(ClassLoaderData* loader_data, size_t word_size,
                              MetaspaceObj::Type type, TRAPS);
  
    static bool contains(const void* ptr);
    static bool contains_non_shared(const void* ptr);
  
    // Free empty virtualspaces
    static void purge();
  
    static void report_metadata_oome(ClassLoaderData* loader_data, size_t word_size,
<span class="changed">!                                    MetaspaceObj::Type type, Metaspace::MetadataType mdtype, TRAPS);</span>
  
    static void print_compressed_class_space(outputStream* st) NOT_LP64({});
  
    // Return TRUE only if UseCompressedClassPointers is True.
    static bool using_class_space() {
      return NOT_LP64(false) LP64_ONLY(UseCompressedClassPointers);
    }
  
<span class="changed">!   static bool initialized();</span>
  
  };
  
<span class="changed">! // ClassLoaderMetaspace is an inbetween-object between a CLD and its MetaspaceArena(s).</span>
<span class="changed">! //</span>
<span class="changed">! // A CLD owns one MetaspaceArena if compressed class space is off, two if its one</span>
<span class="changed">! // (one for allocations of Klass* structures from class space, one for the rest from</span>
<span class="changed">! //  non-class space).</span>
<span class="changed">! //</span>
<span class="changed">! // ClassLoaderMetaspace only exists to hide this logic from upper layers:</span>
<span class="changed">! //</span>
<span class="changed">! // +------+       +----------------------+       +-------------------+</span>
<span class="changed">! // | CLD  | ---&gt;  | ClassLoaderMetaspace | ----&gt; | (non class) Arena |</span>
<span class="changed">! // +------+       +----------------------+  |    +-------------------+     allocation top</span>
<span class="changed">! //                                          |       |                        v</span>
<span class="changed">! //                                          |       + chunk -- chunk ... -- chunk</span>
<span class="changed">! //                                          |</span>
<span class="changed">! //                                          |    +-------------------+</span>
<span class="changed">! //                                          +--&gt; | (class) Arena     |</span>
<span class="changed">! //                                               +-------------------+</span>
<span class="changed">! //                                                  |</span>
<span class="changed">! //                                                  + chunk ... chunk</span>
<span class="changed">! //                                                               ^</span>
<span class="changed">! //                                                               alloc top</span>
<span class="changed">! //</span>
  class ClassLoaderMetaspace : public CHeapObj&lt;mtClass&gt; {
  
<span class="changed">!   // A reference to an outside lock, held by the CLD.</span>
<span class="changed">!   Mutex* const _lock;</span>
  
    const Metaspace::MetaspaceType _space_type;
  
<span class="changed">!   // Arena for allocations from non-class  metaspace</span>
<span class="changed">!   //  (resp. for all allocations if -XX:-UseCompressedClassPointers).</span>
<span class="changed">!   metaspace::MetaspaceArena* _non_class_space_arena;</span>
<span class="changed">! </span>
<span class="changed">!   // Arena for allocations from class space</span>
<span class="changed">!   //  (NULL if -XX:-UseCompressedClassPointers).</span>
<span class="changed">!   metaspace::MetaspaceArena* _class_space_arena;</span>
  
    Mutex* lock() const                             { return _lock; }
<span class="new">+   metaspace::MetaspaceArena* non_class_space_arena() const   { return _non_class_space_arena; }</span>
<span class="new">+   metaspace::MetaspaceArena* class_space_arena() const       { return _class_space_arena; }</span>
  
<span class="changed">!   metaspace::MetaspaceArena* get_arena(bool is_class) {</span>
<span class="changed">!     return is_class ? class_space_arena() : non_class_space_arena();</span>
<span class="changed">!   }</span>
  
<span class="changed">! public:</span>
  
<span class="changed">!   ClassLoaderMetaspace(Mutex* lock, Metaspace::MetaspaceType space_type);</span>
  
    ~ClassLoaderMetaspace();
  
<span class="changed">!   Metaspace::MetaspaceType space_type() const { return _space_type; }</span>
  
<span class="changed">!   // Allocate word_size words from Metaspace.</span>
<span class="changed">!   MetaWord* allocate(size_t word_size, Metaspace::MetadataType mdType);</span>
  
<span class="changed">!   // Attempt to expand the GC threshold to be good for at least another word_size words</span>
<span class="changed">!   // and allocate. Returns NULL if failure. Used during Metaspace GC.</span>
<span class="changed">!   MetaWord* expand_and_allocate(size_t word_size, Metaspace::MetadataType mdType);</span>
  
<span class="changed">!   // Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="changed">!   // because it is not needed anymore.</span>
<span class="changed">!   void deallocate(MetaWord* ptr, size_t word_size, bool is_class);</span>
  
<span class="changed">!   // Update statistics. This walks all in-use chunks.</span>
<span class="changed">!   void add_to_statistics(metaspace::clms_stats_t* out) const;</span>
  
<span class="changed">!   DEBUG_ONLY(void verify() const;)</span>
  
<span class="changed">!   // This only exists for JFR and jcmd VM.classloader_stats. We may want to</span>
<span class="changed">!   //  change this. Capacity as a stat is of questionable use since it may</span>
<span class="changed">!   //  contain committed and uncommitted areas. For now we do this to maintain</span>
<span class="changed">!   //  backward compatibility with JFR.</span>
<span class="changed">!   void calculate_jfr_stats(size_t* p_used_bytes, size_t* p_capacity_bytes) const;</span>
  
<span class="changed">! }; // end: ClassLoaderMetaspace</span>
  
  
<span class="changed">! ////////////////// MetaspaceGC ///////////////////////</span>
  
<span class="changed">! // Metaspace are deallocated when their class loader are GC'ed.</span>
<span class="changed">! // This class implements a policy for inducing GC's to recover</span>
<span class="changed">! // Metaspaces.</span>
  
<span class="changed">! class MetaspaceGCThresholdUpdater : public AllStatic {</span>
<span class="changed">!  public:</span>
<span class="changed">!   enum Type {</span>
<span class="changed">!     ComputeNewSize,</span>
<span class="changed">!     ExpandAndAllocate,</span>
<span class="changed">!     Last</span>
    };
  
<span class="changed">!   static const char* to_string(MetaspaceGCThresholdUpdater::Type updater) {</span>
<span class="changed">!     switch (updater) {</span>
<span class="changed">!       case ComputeNewSize:</span>
<span class="changed">!         return "compute_new_size";</span>
<span class="changed">!       case ExpandAndAllocate:</span>
<span class="changed">!         return "expand_and_allocate";</span>
<span class="changed">!       default:</span>
<span class="changed">!         assert(false, "Got bad updater: %d", (int) updater);</span>
<span class="changed">!         return NULL;</span>
<span class="changed">!     };</span>
<span class="changed">!   }</span>
  };
  
<span class="changed">! class MetaspaceGC : public AllStatic {</span>
  
    // The current high-water-mark for inducing a GC.
    // When committed memory of all metaspaces reaches this value,
    // a GC is induced and the value is increased. Size is in bytes.
    static volatile size_t _capacity_until_GC;
<hr /><span class="oldmarker">*** 475,480 ****</span>
<span class="newmarker">--- 289,343 ----</span>
    // Calculate the new high-water mark at which to induce
    // a GC.
    static void compute_new_size();
  };
  
<span class="new">+ </span>
<span class="new">+ </span>
<span class="new">+ </span>
<span class="new">+ class MetaspaceUtils : AllStatic {</span>
<span class="new">+ public:</span>
<span class="new">+ </span>
<span class="new">+   // Committed space actually in use by Metadata</span>
<span class="new">+   static size_t used_words();</span>
<span class="new">+   static size_t used_words(Metaspace::MetadataType mdtype);</span>
<span class="new">+ </span>
<span class="new">+   // Space committed for Metaspace</span>
<span class="new">+   static size_t committed_words();</span>
<span class="new">+   static size_t committed_words(Metaspace::MetadataType mdtype);</span>
<span class="new">+ </span>
<span class="new">+   // Space reserved for Metaspace</span>
<span class="new">+   static size_t reserved_words();</span>
<span class="new">+   static size_t reserved_words(Metaspace::MetadataType mdtype);</span>
<span class="new">+ </span>
<span class="new">+   // _bytes() variants for convenience...</span>
<span class="new">+   static size_t used_bytes()                                    { return used_words() * BytesPerWord; }</span>
<span class="new">+   static size_t used_bytes(Metaspace::MetadataType mdtype)      { return used_words(mdtype) * BytesPerWord; }</span>
<span class="new">+   static size_t committed_bytes()                               { return committed_words() * BytesPerWord; }</span>
<span class="new">+   static size_t committed_bytes(Metaspace::MetadataType mdtype) { return committed_words(mdtype) * BytesPerWord; }</span>
<span class="new">+   static size_t reserved_bytes()                                { return reserved_words() * BytesPerWord; }</span>
<span class="new">+   static size_t reserved_bytes(Metaspace::MetadataType mdtype)  { return reserved_words(mdtype) * BytesPerWord; }</span>
<span class="new">+ </span>
<span class="new">+   // (See JDK-8251342). Implement or Consolidate.</span>
<span class="new">+   static MetaspaceChunkFreeListSummary chunk_free_list_summary(Metaspace::MetadataType mdtype) {</span>
<span class="new">+     return MetaspaceChunkFreeListSummary(0,0,0,0,0,0,0,0);</span>
<span class="new">+   }</span>
<span class="new">+ </span>
<span class="new">+   // Log change in used metadata.</span>
<span class="new">+   static void print_metaspace_change(const metaspace::MetaspaceSizesSnapshot&amp; pre_meta_values);</span>
<span class="new">+ </span>
<span class="new">+   // This will print out a basic metaspace usage report but</span>
<span class="new">+   // unlike print_report() is guaranteed not to lock or to walk the CLDG.</span>
<span class="new">+   static void print_basic_report(outputStream* st, size_t scale = 0);</span>
<span class="new">+ </span>
<span class="new">+   // Prints a report about the current metaspace state.</span>
<span class="new">+   // Function will walk the CLDG and will lock the expand lock; if that is not</span>
<span class="new">+   // convenient, use print_basic_report() instead.</span>
<span class="new">+   static void print_report(outputStream* out, size_t scale = 0);</span>
<span class="new">+ </span>
<span class="new">+   static void print_on(outputStream * out);</span>
<span class="new">+ </span>
<span class="new">+   DEBUG_ONLY(static void verify(bool slow);)</span>
<span class="new">+ </span>
<span class="new">+ };</span>
<span class="new">+ </span>
  #endif // SHARE_MEMORY_METASPACE_HPP
</pre>
<center><a href='../../../../src/hotspot/share/memory/metaspace.cpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/memory/metaspace/chunkManager.cpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

