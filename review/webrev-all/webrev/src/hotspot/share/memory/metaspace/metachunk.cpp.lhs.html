<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
<a name="2" id="anc2"></a><span class="changed">  26 #include "memory/allocation.hpp"</span>


  27 #include "memory/metaspace/metachunk.hpp"
<a name="3" id="anc3"></a><span class="changed">  28 #include "memory/metaspace/occupancyMap.hpp"</span>

  29 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="4" id="anc4"></a>

  30 #include "utilities/align.hpp"
  31 #include "utilities/copy.hpp"
  32 #include "utilities/debug.hpp"
  33 
  34 namespace metaspace {
  35 
<a name="5" id="anc5"></a><span class="changed">  36 size_t Metachunk::object_alignment() {</span>
<span class="changed">  37   // Must align pointers and sizes to 8,</span>
<span class="changed">  38   // so that 64 bit types get correctly aligned.</span>
<span class="changed">  39   const size_t alignment = 8;</span>
<span class="changed">  40 </span>
<span class="changed">  41   // Make sure that the Klass alignment also agree.</span>
<span class="changed">  42   STATIC_ASSERT(alignment == (size_t)KlassAlignmentInBytes);</span>
<span class="changed">  43 </span>
<span class="changed">  44   return alignment;</span>
<span class="changed">  45 }</span>
<span class="changed">  46 </span>
<span class="changed">  47 size_t Metachunk::overhead() {</span>
<span class="changed">  48   return align_up(sizeof(Metachunk), object_alignment()) / BytesPerWord;</span>
<span class="changed">  49 }</span>
<span class="changed">  50 </span>
<span class="changed">  51 // Metachunk methods</span>
<span class="changed">  52 </span>
<span class="changed">  53 Metachunk::Metachunk(ChunkIndex chunktype, bool is_class, size_t word_size,</span>
<span class="changed">  54                      VirtualSpaceNode* container)</span>
<span class="changed">  55     : Metabase&lt;Metachunk&gt;(word_size),</span>
<span class="changed">  56     _container(container),</span>
<span class="changed">  57     _top(NULL),</span>
<span class="changed">  58     _sentinel(CHUNK_SENTINEL),</span>
<span class="changed">  59     _chunk_type(chunktype),</span>
<span class="changed">  60     _is_class(is_class),</span>
<span class="changed">  61     _origin(origin_normal),</span>
<span class="changed">  62     _use_count(0)</span>
<span class="changed">  63 {</span>
<span class="changed">  64   _top = initial_top();</span>
<span class="changed">  65   set_is_tagged_free(false);</span>
  66 #ifdef ASSERT
<a name="6" id="anc6"></a><span class="changed">  67   mangle(uninitMetaWordVal);</span>
<span class="changed">  68   verify();</span>
<span class="changed">  69 #endif</span>
  70 }
<a name="7" id="anc7"></a>
















































  71 
<a name="8" id="anc8"></a><span class="changed">  72 MetaWord* Metachunk::allocate(size_t word_size) {</span>
<span class="changed">  73   MetaWord* result = NULL;</span>
<span class="changed">  74   // If available, bump the pointer to allocate.</span>
<span class="changed">  75   if (free_word_size() &gt;= word_size) {</span>
<span class="changed">  76     result = _top;</span>
<span class="changed">  77     _top = _top + word_size;</span>

  78   }
<a name="9" id="anc9"></a><span class="changed">  79   return result;</span>








  80 }
  81 
<a name="10" id="anc10"></a><span class="changed">  82 // _bottom points to the start of the chunk including the overhead.</span>
<span class="changed">  83 size_t Metachunk::used_word_size() const {</span>
<span class="changed">  84   return pointer_delta(_top, bottom(), sizeof(MetaWord));</span>











  85 }
  86 
<a name="11" id="anc11"></a><span class="changed">  87 size_t Metachunk::free_word_size() const {</span>
<span class="changed">  88   return pointer_delta(end(), _top, sizeof(MetaWord));</span>











  89 }
  90 
<a name="12" id="anc12"></a><span class="changed">  91 void Metachunk::print_on(outputStream* st) const {</span>
<span class="changed">  92   st-&gt;print_cr("Metachunk:"</span>
<span class="changed">  93                " bottom " PTR_FORMAT " top " PTR_FORMAT</span>
<span class="changed">  94                " end " PTR_FORMAT " size " SIZE_FORMAT " (%s)",</span>
<span class="changed">  95                p2i(bottom()), p2i(_top), p2i(end()), word_size(),</span>
<span class="changed">  96                chunk_size_name(get_chunk_type()));</span>
<span class="changed">  97   if (Verbose) {</span>
<span class="changed">  98     st-&gt;print_cr("    used " SIZE_FORMAT " free " SIZE_FORMAT,</span>
<span class="changed">  99                  used_word_size(), free_word_size());</span>








 100   }
 101 }
<a name="13" id="anc13"></a>






























 102 
 103 #ifdef ASSERT
<a name="14" id="anc14"></a><span class="changed"> 104 void Metachunk::mangle(juint word_value) {</span>
<span class="changed"> 105   // Overwrite the payload of the chunk and not the links that</span>
<span class="changed"> 106   // maintain list of chunks.</span>
<span class="changed"> 107   HeapWord* start = (HeapWord*)initial_top();</span>
<span class="changed"> 108   size_t size = word_size() - overhead();</span>
<span class="changed"> 109   Copy::fill_to_words(start, size, word_value);</span>
<span class="changed"> 110 }</span>
<span class="changed"> 111 </span>
<span class="changed"> 112 void Metachunk::verify() const {</span>
<span class="changed"> 113   assert(is_valid_sentinel(), "Chunk " PTR_FORMAT ": sentinel invalid", p2i(this));</span>
<span class="changed"> 114   const ChunkIndex chunk_type = get_chunk_type();</span>
<span class="changed"> 115   assert(is_valid_chunktype(chunk_type), "Chunk " PTR_FORMAT ": Invalid chunk type.", p2i(this));</span>
<span class="changed"> 116   if (chunk_type != HumongousIndex) {</span>
<span class="changed"> 117     assert(word_size() == get_size_for_nonhumongous_chunktype(chunk_type, is_class()),</span>
<span class="changed"> 118            "Chunk " PTR_FORMAT ": wordsize " SIZE_FORMAT " does not fit chunk type %s.",</span>
<span class="changed"> 119            p2i(this), word_size(), chunk_size_name(chunk_type));</span>
<span class="changed"> 120   }</span>
<span class="changed"> 121   assert(is_valid_chunkorigin(get_origin()), "Chunk " PTR_FORMAT ": Invalid chunk origin.", p2i(this));</span>
<span class="changed"> 122   assert(bottom() &lt;= _top &amp;&amp; _top &lt;= (MetaWord*)end(),</span>
<span class="changed"> 123          "Chunk " PTR_FORMAT ": Chunk top out of chunk bounds.", p2i(this));</span>
<span class="changed"> 124 </span>
<span class="changed"> 125   // For non-humongous chunks, starting address shall be aligned</span>
<span class="changed"> 126   // to its chunk size. Humongous chunks start address is</span>
<span class="changed"> 127   // aligned to specialized chunk size.</span>
<span class="changed"> 128   const size_t required_alignment =</span>
<span class="changed"> 129     (chunk_type != HumongousIndex ? word_size() : get_size_for_nonhumongous_chunktype(SpecializedIndex, is_class())) * sizeof(MetaWord);</span>
<span class="changed"> 130   assert(is_aligned((address)this, required_alignment),</span>
<span class="changed"> 131          "Chunk " PTR_FORMAT ": (size " SIZE_FORMAT ") not aligned to " SIZE_FORMAT ".",</span>
<span class="changed"> 132          p2i(this), word_size() * sizeof(MetaWord), required_alignment);</span>
 133 }
 134 
<a name="15" id="anc15"></a><span class="changed"> 135 #endif // ASSERT</span>











































































































































 136 
<a name="16" id="anc16"></a><span class="removed"> 137 // Helper, returns a descriptive name for the given index.</span>
<span class="removed"> 138 const char* chunk_size_name(ChunkIndex index) {</span>
<span class="removed"> 139   switch (index) {</span>
<span class="removed"> 140     case SpecializedIndex:</span>
<span class="removed"> 141       return "specialized";</span>
<span class="removed"> 142     case SmallIndex:</span>
<span class="removed"> 143       return "small";</span>
<span class="removed"> 144     case MediumIndex:</span>
<span class="removed"> 145       return "medium";</span>
<span class="removed"> 146     case HumongousIndex:</span>
<span class="removed"> 147       return "humongous";</span>
<span class="removed"> 148     default:</span>
<span class="removed"> 149       return "Invalid index";</span>
 150   }
 151 }
 152 
<a name="17" id="anc17"></a><span class="changed"> 153 #ifdef ASSERT</span>
<span class="changed"> 154 void do_verify_chunk(Metachunk* chunk) {</span>
<span class="changed"> 155   guarantee(chunk != NULL, "Sanity");</span>
<span class="changed"> 156   // Verify chunk itself; then verify that it is consistent with the</span>
<span class="changed"> 157   // occupany map of its containing node.</span>
<span class="changed"> 158   chunk-&gt;verify();</span>
<span class="changed"> 159   VirtualSpaceNode* const vsn = chunk-&gt;container();</span>
<span class="changed"> 160   OccupancyMap* const ocmap = vsn-&gt;occupancy_map();</span>
<span class="changed"> 161   ocmap-&gt;verify_for_chunk(chunk);</span>












































































 162 }
<a name="18" id="anc18"></a><span class="removed"> 163 #endif</span>
 164 
<a name="19" id="anc19"></a><span class="changed"> 165 void do_update_in_use_info_for_chunk(Metachunk* chunk, bool inuse) {</span>
<span class="changed"> 166   chunk-&gt;set_is_tagged_free(!inuse);</span>
<span class="changed"> 167   OccupancyMap* const ocmap = chunk-&gt;container()-&gt;occupancy_map();</span>
<span class="changed"> 168   ocmap-&gt;set_region_in_use((MetaWord*)chunk, chunk-&gt;word_size(), inuse);</span>























































 169 }
 170 
 171 } // namespace metaspace
 172 
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="20" type="hidden" /></form></body></html>
