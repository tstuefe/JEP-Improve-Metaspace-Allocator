<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Cdiff src/hotspot/share/memory/metaspace/chunkManager.cpp</title>
</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace.hpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.cdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/chunkManager.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-all.patch</pre>
        <pre>
<hr /><span class="oldmarker">*** 1,7 ****</span>
  /*
<span class="changed">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="newmarker">--- 1,8 ----</span>
  /*
<span class="changed">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">!  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<hr /><span class="oldmarker">*** 19,642 ****</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   *
   */
  #include "precompiled.hpp"
  
  #include "logging/log.hpp"
  #include "logging/logStream.hpp"
<span class="changed">! #include "memory/binaryTreeDictionary.inline.hpp"</span>
<span class="changed">! #include "memory/freeList.inline.hpp"</span>
  #include "memory/metaspace/chunkManager.hpp"
  #include "memory/metaspace/metachunk.hpp"
<span class="removed">- #include "memory/metaspace/metaDebug.hpp"</span>
  #include "memory/metaspace/metaspaceCommon.hpp"
  #include "memory/metaspace/metaspaceStatistics.hpp"
<span class="changed">! #include "memory/metaspace/occupancyMap.hpp"</span>
  #include "memory/metaspace/virtualSpaceNode.hpp"
  #include "runtime/mutexLocker.hpp"
  #include "utilities/debug.hpp"
  #include "utilities/globalDefinitions.hpp"
<span class="removed">- #include "utilities/ostream.hpp"</span>
  
  namespace metaspace {
  
<span class="changed">! ChunkManager::ChunkManager(bool is_class)</span>
<span class="changed">!       : _is_class(is_class), _free_chunks_total(0), _free_chunks_count(0) {</span>
<span class="changed">!   _free_chunks[SpecializedIndex].set_size(get_size_for_nonhumongous_chunktype(SpecializedIndex, is_class));</span>
<span class="changed">!   _free_chunks[SmallIndex].set_size(get_size_for_nonhumongous_chunktype(SmallIndex, is_class));</span>
<span class="changed">!   _free_chunks[MediumIndex].set_size(get_size_for_nonhumongous_chunktype(MediumIndex, is_class));</span>
<span class="changed">! }</span>
  
<span class="changed">! void ChunkManager::remove_chunk(Metachunk* chunk) {</span>
<span class="changed">!   size_t word_size = chunk-&gt;word_size();</span>
<span class="changed">!   ChunkIndex index = list_index(word_size);</span>
<span class="changed">!   if (index != HumongousIndex) {</span>
<span class="changed">!     free_chunks(index)-&gt;remove_chunk(chunk);</span>
<span class="changed">!   } else {</span>
<span class="changed">!     humongous_dictionary()-&gt;remove_chunk(chunk);</span>
<span class="changed">!   }</span>
  
<span class="removed">-   // Chunk has been removed from the chunks free list, update counters.</span>
<span class="removed">-   account_for_removed_chunk(chunk);</span>
  }
  
<span class="changed">! bool ChunkManager::attempt_to_coalesce_around_chunk(Metachunk* chunk, ChunkIndex target_chunk_type) {</span>
    assert_lock_strong(MetaspaceExpand_lock);
<span class="removed">-   assert(chunk != NULL, "invalid chunk pointer");</span>
<span class="removed">-   // Check for valid merge combinations.</span>
<span class="removed">-   assert((chunk-&gt;get_chunk_type() == SpecializedIndex &amp;&amp;</span>
<span class="removed">-           (target_chunk_type == SmallIndex || target_chunk_type == MediumIndex)) ||</span>
<span class="removed">-          (chunk-&gt;get_chunk_type() == SmallIndex &amp;&amp; target_chunk_type == MediumIndex),</span>
<span class="removed">-         "Invalid chunk merge combination.");</span>
<span class="removed">- </span>
<span class="removed">-   const size_t target_chunk_word_size =</span>
<span class="removed">-     get_size_for_nonhumongous_chunktype(target_chunk_type, this-&gt;is_class());</span>
<span class="removed">- </span>
<span class="removed">-   // [ prospective merge region )</span>
<span class="removed">-   MetaWord* const p_merge_region_start =</span>
<span class="removed">-     (MetaWord*) align_down(chunk, target_chunk_word_size * sizeof(MetaWord));</span>
<span class="removed">-   MetaWord* const p_merge_region_end =</span>
<span class="removed">-     p_merge_region_start + target_chunk_word_size;</span>
<span class="removed">- </span>
<span class="removed">-   // We need the VirtualSpaceNode containing this chunk and its occupancy map.</span>
<span class="removed">-   VirtualSpaceNode* const vsn = chunk-&gt;container();</span>
<span class="removed">-   OccupancyMap* const ocmap = vsn-&gt;occupancy_map();</span>
<span class="removed">- </span>
<span class="removed">-   // The prospective chunk merge range must be completely contained by the</span>
<span class="removed">-   // committed range of the virtual space node.</span>
<span class="removed">-   if (p_merge_region_start &lt; vsn-&gt;bottom() || p_merge_region_end &gt; vsn-&gt;top()) {</span>
<span class="removed">-     return false;</span>
<span class="removed">-   }</span>
<span class="removed">- </span>
<span class="removed">-   // Only attempt to merge this range if at its start a chunk starts and at its end</span>
<span class="removed">-   // a chunk ends. If a chunk (can only be humongous) straddles either start or end</span>
<span class="removed">-   // of that range, we cannot merge.</span>
<span class="removed">-   if (!ocmap-&gt;chunk_starts_at_address(p_merge_region_start)) {</span>
<span class="removed">-     return false;</span>
<span class="removed">-   }</span>
<span class="removed">-   if (p_merge_region_end &lt; vsn-&gt;top() &amp;&amp;</span>
<span class="removed">-       !ocmap-&gt;chunk_starts_at_address(p_merge_region_end)) {</span>
<span class="removed">-     return false;</span>
<span class="removed">-   }</span>
<span class="removed">- </span>
<span class="removed">-   // Now check if the prospective merge area contains live chunks. If it does we cannot merge.</span>
<span class="removed">-   if (ocmap-&gt;is_region_in_use(p_merge_region_start, target_chunk_word_size)) {</span>
<span class="removed">-     return false;</span>
<span class="removed">-   }</span>
<span class="removed">- </span>
<span class="removed">-   // Success! Remove all chunks in this region...</span>
<span class="removed">-   log_trace(gc, metaspace, freelist)("%s: coalescing chunks in area [%p-%p)...",</span>
<span class="removed">-     (is_class() ? "class space" : "metaspace"),</span>
<span class="removed">-     p_merge_region_start, p_merge_region_end);</span>
<span class="removed">- </span>
<span class="removed">-   const int num_chunks_removed =</span>
<span class="removed">-     remove_chunks_in_area(p_merge_region_start, target_chunk_word_size);</span>
<span class="removed">- </span>
<span class="removed">-   // ... and create a single new bigger chunk.</span>
<span class="removed">-   Metachunk* const p_new_chunk =</span>
<span class="removed">-       ::new (p_merge_region_start) Metachunk(target_chunk_type, is_class(), target_chunk_word_size, vsn);</span>
<span class="removed">-   assert(p_new_chunk == (Metachunk*)p_merge_region_start, "Sanity");</span>
<span class="removed">-   p_new_chunk-&gt;set_origin(origin_merge);</span>
<span class="removed">- </span>
<span class="removed">-   log_trace(gc, metaspace, freelist)("%s: created coalesced chunk at %p, size " SIZE_FORMAT_HEX ".",</span>
<span class="removed">-     (is_class() ? "class space" : "metaspace"),</span>
<span class="removed">-     p_new_chunk, p_new_chunk-&gt;word_size() * sizeof(MetaWord));</span>
<span class="removed">- </span>
<span class="removed">-   // Fix occupancy map: remove old start bits of the small chunks and set new start bit.</span>
<span class="removed">-   ocmap-&gt;wipe_chunk_start_bits_in_region(p_merge_region_start, target_chunk_word_size);</span>
<span class="removed">-   ocmap-&gt;set_chunk_starts_at_address(p_merge_region_start, true);</span>
<span class="removed">- </span>
<span class="removed">-   // Mark chunk as free. Note: it is not necessary to update the occupancy</span>
<span class="removed">-   // map in-use map, because the old chunks were also free, so nothing</span>
<span class="removed">-   // should have changed.</span>
<span class="removed">-   p_new_chunk-&gt;set_is_tagged_free(true);</span>
<span class="removed">- </span>
<span class="removed">-   // Add new chunk to its freelist.</span>
<span class="removed">-   ChunkList* const list = free_chunks(target_chunk_type);</span>
<span class="removed">-   list-&gt;return_chunk_at_head(p_new_chunk);</span>
<span class="removed">- </span>
<span class="removed">-   // And adjust ChunkManager:: _free_chunks_count (_free_chunks_total</span>
<span class="removed">-   // should not have changed, because the size of the space should be the same)</span>
<span class="removed">-   _free_chunks_count -= num_chunks_removed;</span>
<span class="removed">-   _free_chunks_count ++;</span>
<span class="removed">- </span>
<span class="removed">-   // VirtualSpaceNode::chunk_count does not have to be modified:</span>
<span class="removed">-   // it means "number of active (non-free) chunks", so merging free chunks</span>
<span class="removed">-   // should not affect that count.</span>
  
<span class="changed">!   // At the end of a chunk merge, run verification tests.</span>
<span class="changed">! #ifdef ASSERT</span>
  
<span class="changed">!   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed">!     locked_verify(true);</span>
<span class="changed">!     vsn-&gt;verify(true);</span>
<span class="changed">!   END_EVERY_NTH</span>
  
<span class="changed">!   g_internal_statistics.num_chunk_merges ++;</span>
  
<span class="changed">! #endif</span>
  
<span class="changed">!   return true;</span>
<span class="changed">! }</span>
  
<span class="changed">! // Remove all chunks in the given area - the chunks are supposed to be free -</span>
<span class="changed">! // from their corresponding freelists. Mark them as invalid.</span>
<span class="changed">! // - This does not correct the occupancy map.</span>
<span class="changed">! // - This does not adjust the counters in ChunkManager.</span>
<span class="changed">! // - Does not adjust container count counter in containing VirtualSpaceNode</span>
<span class="changed">! // Returns number of chunks removed.</span>
<span class="changed">! int ChunkManager::remove_chunks_in_area(MetaWord* p, size_t word_size) {</span>
<span class="changed">!   assert(p != NULL &amp;&amp; word_size &gt; 0, "Invalid range.");</span>
<span class="changed">!   const size_t smallest_chunk_size = get_size_for_nonhumongous_chunktype(SpecializedIndex, is_class());</span>
<span class="changed">!   assert_is_aligned(word_size, smallest_chunk_size);</span>
<span class="changed">! </span>
<span class="changed">!   Metachunk* const start = (Metachunk*) p;</span>
<span class="changed">!   const Metachunk* const end = (Metachunk*)(p + word_size);</span>
<span class="changed">!   Metachunk* cur = start;</span>
<span class="changed">!   int num_removed = 0;</span>
<span class="changed">!   while (cur &lt; end) {</span>
<span class="changed">!     Metachunk* next = (Metachunk*)(((MetaWord*)cur) + cur-&gt;word_size());</span>
<span class="changed">!     DEBUG_ONLY(do_verify_chunk(cur));</span>
<span class="changed">!     assert(cur-&gt;get_chunk_type() != HumongousIndex, "Unexpected humongous chunk found at %p.", cur);</span>
<span class="changed">!     assert(cur-&gt;is_tagged_free(), "Chunk expected to be free (%p)", cur);</span>
<span class="changed">!     log_trace(gc, metaspace, freelist)("%s: removing chunk %p, size " SIZE_FORMAT_HEX ".",</span>
<span class="changed">!       (is_class() ? "class space" : "metaspace"),</span>
<span class="changed">!       cur, cur-&gt;word_size() * sizeof(MetaWord));</span>
<span class="changed">!     cur-&gt;remove_sentinel();</span>
<span class="changed">!     // Note: cannot call ChunkManager::remove_chunk, because that</span>
<span class="changed">!     // modifies the counters in ChunkManager, which we do not want. So</span>
<span class="changed">!     // we call remove_chunk on the freelist directly (see also the</span>
<span class="changed">!     // splitting function which does the same).</span>
<span class="changed">!     ChunkList* const list = free_chunks(list_index(cur-&gt;word_size()));</span>
<span class="changed">!     list-&gt;remove_chunk(cur);</span>
<span class="changed">!     num_removed ++;</span>
<span class="changed">!     cur = next;</span>
    }
<span class="changed">!   return num_removed;</span>
<span class="changed">! }</span>
  
<span class="changed">! // Update internal accounting after a chunk was added</span>
<span class="changed">! void ChunkManager::account_for_added_chunk(const Metachunk* c) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   _free_chunks_count ++;</span>
<span class="changed">!   _free_chunks_total += c-&gt;word_size();</span>
<span class="changed">! }</span>
  
<span class="changed">! // Update internal accounting after a chunk was removed</span>
<span class="changed">! void ChunkManager::account_for_removed_chunk(const Metachunk* c) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   assert(_free_chunks_count &gt;= 1,</span>
<span class="changed">!     "ChunkManager::_free_chunks_count: about to go negative (" SIZE_FORMAT ").", _free_chunks_count);</span>
<span class="changed">!   assert(_free_chunks_total &gt;= c-&gt;word_size(),</span>
<span class="changed">!     "ChunkManager::_free_chunks_total: about to go negative"</span>
<span class="changed">!      "(now: " SIZE_FORMAT ", decrement value: " SIZE_FORMAT ").", _free_chunks_total, c-&gt;word_size());</span>
<span class="changed">!   _free_chunks_count --;</span>
<span class="changed">!   _free_chunks_total -= c-&gt;word_size();</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! ChunkIndex ChunkManager::list_index(size_t size) {</span>
<span class="changed">!   return get_chunk_type_by_size(size, is_class());</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! size_t ChunkManager::size_by_index(ChunkIndex index) const {</span>
<span class="changed">!   index_bounds_check(index);</span>
<span class="changed">!   assert(index != HumongousIndex, "Do not call for humongous chunks.");</span>
<span class="changed">!   return get_size_for_nonhumongous_chunktype(index, is_class());</span>
<span class="changed">! }</span>
  
<span class="removed">- #ifdef ASSERT</span>
<span class="removed">- void ChunkManager::verify(bool slow) const {</span>
<span class="removed">-   MutexLocker cl(MetaspaceExpand_lock,</span>
<span class="removed">-                      Mutex::_no_safepoint_check_flag);</span>
<span class="removed">-   locked_verify(slow);</span>
  }
  
<span class="changed">! void ChunkManager::locked_verify(bool slow) const {</span>
<span class="changed">!   log_trace(gc, metaspace, freelist)("verifying %s chunkmanager (%s).",</span>
<span class="changed">!     (is_class() ? "class space" : "metaspace"), (slow ? "slow" : "quick"));</span>
  
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   size_t chunks_counted = 0;</span>
<span class="changed">!   size_t wordsize_chunks_counted = 0;</span>
<span class="changed">!   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfFreeLists; i = next_chunk_index(i)) {</span>
<span class="changed">!     const ChunkList* list = _free_chunks + i;</span>
<span class="changed">!     if (list != NULL) {</span>
<span class="changed">!       Metachunk* chunk = list-&gt;head();</span>
<span class="changed">!       while (chunk) {</span>
<span class="changed">!         if (slow) {</span>
<span class="changed">!           do_verify_chunk(chunk);</span>
<span class="changed">!         }</span>
<span class="changed">!         assert(chunk-&gt;is_tagged_free(), "Chunk should be tagged as free.");</span>
<span class="changed">!         chunks_counted ++;</span>
<span class="changed">!         wordsize_chunks_counted += chunk-&gt;size();</span>
<span class="changed">!         chunk = chunk-&gt;next();</span>
        }
      }
    }
  
<span class="changed">!   chunks_counted += humongous_dictionary()-&gt;total_free_blocks();</span>
<span class="changed">!   wordsize_chunks_counted += humongous_dictionary()-&gt;total_size();</span>
<span class="changed">! </span>
<span class="changed">!   assert(chunks_counted == _free_chunks_count &amp;&amp; wordsize_chunks_counted == _free_chunks_total,</span>
<span class="changed">!          "freelist accounting mismatch: "</span>
<span class="changed">!          "we think: " SIZE_FORMAT " chunks, total " SIZE_FORMAT " words, "</span>
<span class="changed">!          "reality: " SIZE_FORMAT " chunks, total " SIZE_FORMAT " words.",</span>
<span class="changed">!          _free_chunks_count, _free_chunks_total,</span>
<span class="changed">!          chunks_counted, wordsize_chunks_counted);</span>
<span class="changed">! }</span>
<span class="changed">! #endif // ASSERT</span>
  
<span class="changed">! void ChunkManager::locked_print_free_chunks(outputStream* st) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   st-&gt;print_cr("Free chunk total " SIZE_FORMAT "  count " SIZE_FORMAT,</span>
<span class="changed">!                 _free_chunks_total, _free_chunks_count);</span>
<span class="changed">! }</span>
  
<span class="changed">! ChunkList* ChunkManager::free_chunks(ChunkIndex index) {</span>
<span class="changed">!   assert(index == SpecializedIndex || index == SmallIndex || index == MediumIndex,</span>
<span class="changed">!          "Bad index: %d", (int)index);</span>
<span class="changed">!   return &amp;_free_chunks[index];</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! ChunkList* ChunkManager::find_free_chunks_list(size_t word_size) {</span>
<span class="changed">!   ChunkIndex index = list_index(word_size);</span>
<span class="changed">!   assert(index &lt; HumongousIndex, "No humongous list");</span>
<span class="changed">!   return free_chunks(index);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Helper for chunk splitting: given a target chunk size and a larger free chunk,</span>
<span class="changed">! // split up the larger chunk into n smaller chunks, at least one of which should be</span>
<span class="changed">! // the target chunk of target chunk size. The smaller chunks, including the target</span>
<span class="changed">! // chunk, are returned to the freelist. The pointer to the target chunk is returned.</span>
<span class="changed">! // Note that this chunk is supposed to be removed from the freelist right away.</span>
<span class="changed">! Metachunk* ChunkManager::split_chunk(size_t target_chunk_word_size, Metachunk* larger_chunk) {</span>
<span class="changed">!   assert(larger_chunk-&gt;word_size() &gt; target_chunk_word_size, "Sanity");</span>
<span class="changed">! </span>
<span class="changed">!   const ChunkIndex larger_chunk_index = larger_chunk-&gt;get_chunk_type();</span>
<span class="changed">!   const ChunkIndex target_chunk_index = get_chunk_type_by_size(target_chunk_word_size, is_class());</span>
<span class="changed">! </span>
<span class="changed">!   MetaWord* const region_start = (MetaWord*)larger_chunk;</span>
<span class="changed">!   const size_t region_word_len = larger_chunk-&gt;word_size();</span>
<span class="changed">!   MetaWord* const region_end = region_start + region_word_len;</span>
<span class="changed">!   VirtualSpaceNode* const vsn = larger_chunk-&gt;container();</span>
<span class="changed">!   OccupancyMap* const ocmap = vsn-&gt;occupancy_map();</span>
<span class="changed">! </span>
<span class="changed">!   // Any larger non-humongous chunk size is a multiple of any smaller chunk size.</span>
<span class="changed">!   // Since non-humongous chunks are aligned to their chunk size, the larger chunk should start</span>
<span class="changed">!   // at an address suitable to place the smaller target chunk.</span>
<span class="changed">!   assert_is_aligned(region_start, target_chunk_word_size);</span>
<span class="changed">! </span>
<span class="changed">!   // Remove old chunk.</span>
<span class="changed">!   free_chunks(larger_chunk_index)-&gt;remove_chunk(larger_chunk);</span>
<span class="changed">!   larger_chunk-&gt;remove_sentinel();</span>
<span class="changed">! </span>
<span class="changed">!   // Prevent access to the old chunk from here on.</span>
<span class="changed">!   larger_chunk = NULL;</span>
<span class="changed">!   // ... and wipe it.</span>
<span class="changed">!   DEBUG_ONLY(memset(region_start, 0xfe, region_word_len * BytesPerWord));</span>
<span class="changed">! </span>
<span class="changed">!   // In its place create first the target chunk...</span>
<span class="changed">!   MetaWord* p = region_start;</span>
<span class="changed">!   Metachunk* target_chunk = ::new (p) Metachunk(target_chunk_index, is_class(), target_chunk_word_size, vsn);</span>
<span class="changed">!   assert(target_chunk == (Metachunk*)p, "Sanity");</span>
<span class="changed">!   target_chunk-&gt;set_origin(origin_split);</span>
<span class="changed">! </span>
<span class="changed">!   // Note: we do not need to mark its start in the occupancy map</span>
<span class="changed">!   // because it coincides with the old chunk start.</span>
<span class="changed">! </span>
<span class="changed">!   // Mark chunk as free and return to the freelist.</span>
<span class="changed">!   do_update_in_use_info_for_chunk(target_chunk, false);</span>
<span class="changed">!   free_chunks(target_chunk_index)-&gt;return_chunk_at_head(target_chunk);</span>
<span class="changed">! </span>
<span class="changed">!   // This chunk should now be valid and can be verified.</span>
<span class="changed">!   DEBUG_ONLY(do_verify_chunk(target_chunk));</span>
<span class="changed">! </span>
<span class="changed">!   // In the remaining space create the remainder chunks.</span>
<span class="changed">!   p += target_chunk-&gt;word_size();</span>
<span class="changed">!   assert(p &lt; region_end, "Sanity");</span>
<span class="changed">! </span>
<span class="changed">!   while (p &lt; region_end) {</span>
<span class="changed">! </span>
<span class="changed">!     // Find the largest chunk size which fits the alignment requirements at address p.</span>
<span class="changed">!     ChunkIndex this_chunk_index = prev_chunk_index(larger_chunk_index);</span>
<span class="changed">!     size_t this_chunk_word_size = 0;</span>
<span class="changed">!     for(;;) {</span>
<span class="changed">!       this_chunk_word_size = get_size_for_nonhumongous_chunktype(this_chunk_index, is_class());</span>
<span class="changed">!       if (is_aligned(p, this_chunk_word_size * BytesPerWord)) {</span>
<span class="changed">!         break;</span>
        } else {
<span class="changed">!         this_chunk_index = prev_chunk_index(this_chunk_index);</span>
<span class="changed">!         assert(this_chunk_index &gt;= target_chunk_index, "Sanity");</span>
        }
      }
  
<span class="changed">!     assert(this_chunk_word_size &gt;= target_chunk_word_size, "Sanity");</span>
<span class="changed">!     assert(is_aligned(p, this_chunk_word_size * BytesPerWord), "Sanity");</span>
<span class="changed">!     assert(p + this_chunk_word_size &lt;= region_end, "Sanity");</span>
  
<span class="changed">!     // Create splitting chunk.</span>
<span class="changed">!     Metachunk* this_chunk = ::new (p) Metachunk(this_chunk_index, is_class(), this_chunk_word_size, vsn);</span>
<span class="changed">!     assert(this_chunk == (Metachunk*)p, "Sanity");</span>
<span class="changed">!     this_chunk-&gt;set_origin(origin_split);</span>
<span class="changed">!     ocmap-&gt;set_chunk_starts_at_address(p, true);</span>
<span class="changed">!     do_update_in_use_info_for_chunk(this_chunk, false);</span>
  
<span class="changed">!     // This chunk should be valid and can be verified.</span>
<span class="changed">!     DEBUG_ONLY(do_verify_chunk(this_chunk));</span>
  
<span class="changed">!     // Return this chunk to freelist and correct counter.</span>
<span class="changed">!     free_chunks(this_chunk_index)-&gt;return_chunk_at_head(this_chunk);</span>
<span class="changed">!     _free_chunks_count ++;</span>
  
<span class="changed">!     log_trace(gc, metaspace, freelist)("Created chunk at " PTR_FORMAT ", word size "</span>
<span class="changed">!       SIZE_FORMAT_HEX " (%s), in split region [" PTR_FORMAT "..." PTR_FORMAT ").",</span>
<span class="changed">!       p2i(this_chunk), this_chunk-&gt;word_size(), chunk_size_name(this_chunk_index),</span>
<span class="changed">!       p2i(region_start), p2i(region_end));</span>
  
<span class="changed">!     p += this_chunk_word_size;</span>
  
<span class="changed">!   }</span>
  
<span class="changed">!   // Note: at this point, the VirtualSpaceNode is invalid since we split a chunk and</span>
<span class="changed">!   // did not yet hand out part of that split; so, vsn-&gt;verify_free_chunks_are_ideally_merged()</span>
<span class="changed">!   // would assert. Instead, do all verifications in the caller.</span>
  
<span class="changed">!   DEBUG_ONLY(g_internal_statistics.num_chunk_splits ++);</span>
  
<span class="changed">!   return target_chunk;</span>
<span class="changed">! }</span>
  
<span class="changed">! Metachunk* ChunkManager::free_chunks_get(size_t word_size) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   Metachunk* chunk = NULL;</span>
<span class="changed">!   bool we_did_split_a_chunk = false;</span>
  
<span class="changed">!   if (list_index(word_size) != HumongousIndex) {</span>
  
<span class="changed">!     ChunkList* free_list = find_free_chunks_list(word_size);</span>
<span class="changed">!     assert(free_list != NULL, "Sanity check");</span>
  
<span class="changed">!     chunk = free_list-&gt;head();</span>
  
<span class="removed">-     if (chunk == NULL) {</span>
<span class="removed">-       // Split large chunks into smaller chunks if there are no smaller chunks, just large chunks.</span>
<span class="removed">-       // This is the counterpart of the coalescing-upon-chunk-return.</span>
  
<span class="changed">!       ChunkIndex target_chunk_index = get_chunk_type_by_size(word_size, is_class());</span>
  
<span class="changed">!       // Is there a larger chunk we could split?</span>
<span class="changed">!       Metachunk* larger_chunk = NULL;</span>
<span class="changed">!       ChunkIndex larger_chunk_index = next_chunk_index(target_chunk_index);</span>
<span class="changed">!       while (larger_chunk == NULL &amp;&amp; larger_chunk_index &lt; NumberOfFreeLists) {</span>
<span class="changed">!         larger_chunk = free_chunks(larger_chunk_index)-&gt;head();</span>
<span class="changed">!         if (larger_chunk == NULL) {</span>
<span class="changed">!           larger_chunk_index = next_chunk_index(larger_chunk_index);</span>
<span class="changed">!         }</span>
<span class="changed">!       }</span>
  
<span class="changed">!       if (larger_chunk != NULL) {</span>
<span class="changed">!         assert(larger_chunk-&gt;word_size() &gt; word_size, "Sanity");</span>
<span class="changed">!         assert(larger_chunk-&gt;get_chunk_type() == larger_chunk_index, "Sanity");</span>
  
<span class="changed">!         // We found a larger chunk. Lets split it up:</span>
<span class="changed">!         // - remove old chunk</span>
<span class="changed">!         // - in its place, create new smaller chunks, with at least one chunk</span>
<span class="changed">!         //   being of target size, the others sized as large as possible. This</span>
<span class="changed">!         //   is to make sure the resulting chunks are "as coalesced as possible"</span>
<span class="changed">!         //   (similar to VirtualSpaceNode::retire()).</span>
<span class="changed">!         // Note: during this operation both ChunkManager and VirtualSpaceNode</span>
<span class="changed">!         //  are temporarily invalid, so be careful with asserts.</span>
  
<span class="changed">!         log_trace(gc, metaspace, freelist)("%s: splitting chunk " PTR_FORMAT</span>
<span class="changed">!            ", word size " SIZE_FORMAT_HEX " (%s), to get a chunk of word size " SIZE_FORMAT_HEX " (%s)...",</span>
<span class="changed">!           (is_class() ? "class space" : "metaspace"), p2i(larger_chunk), larger_chunk-&gt;word_size(),</span>
<span class="changed">!           chunk_size_name(larger_chunk_index), word_size, chunk_size_name(target_chunk_index));</span>
  
<span class="changed">!         chunk = split_chunk(word_size, larger_chunk);</span>
  
<span class="changed">!         // This should have worked.</span>
<span class="changed">!         assert(chunk != NULL, "Sanity");</span>
<span class="changed">!         assert(chunk-&gt;word_size() == word_size, "Sanity");</span>
<span class="changed">!         assert(chunk-&gt;is_tagged_free(), "Sanity");</span>
  
<span class="changed">!         we_did_split_a_chunk = true;</span>
  
<span class="changed">!       }</span>
      }
  
<span class="changed">!     if (chunk == NULL) {</span>
<span class="changed">!       return NULL;</span>
<span class="changed">!     }</span>
  
<span class="changed">!     // Remove the chunk as the head of the list.</span>
<span class="changed">!     free_list-&gt;remove_chunk(chunk);</span>
  
<span class="changed">!     log_trace(gc, metaspace, freelist)("ChunkManager::free_chunks_get: free_list: " PTR_FORMAT " chunks left: " SSIZE_FORMAT ".",</span>
<span class="changed">!                                        p2i(free_list), free_list-&gt;count());</span>
  
<span class="changed">!   } else {</span>
<span class="changed">!     chunk = humongous_dictionary()-&gt;get_chunk(word_size);</span>
  
<span class="removed">-     if (chunk == NULL) {</span>
<span class="removed">-       return NULL;</span>
      }
  
<span class="changed">!     log_trace(gc, metaspace, alloc)("Free list allocate humongous chunk size " SIZE_FORMAT " for requested size " SIZE_FORMAT " waste " SIZE_FORMAT,</span>
<span class="changed">!                                     chunk-&gt;word_size(), word_size, chunk-&gt;word_size() - word_size);</span>
    }
  
<span class="changed">!   // Chunk has been removed from the chunk manager; update counters.</span>
<span class="changed">!   account_for_removed_chunk(chunk);</span>
<span class="changed">!   do_update_in_use_info_for_chunk(chunk, true);</span>
<span class="changed">!   chunk-&gt;container()-&gt;inc_container_count();</span>
<span class="changed">!   chunk-&gt;inc_use_count();</span>
  
<span class="changed">!   // Remove it from the links to this freelist</span>
<span class="changed">!   chunk-&gt;set_next(NULL);</span>
<span class="changed">!   chunk-&gt;set_prev(NULL);</span>
  
<span class="changed">!   // Run some verifications (some more if we did a chunk split)</span>
<span class="changed">! #ifdef ASSERT</span>
  
<span class="changed">!   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed">!     // Be extra verify-y when chunk split happened.</span>
<span class="changed">!     locked_verify(true);</span>
<span class="changed">!     VirtualSpaceNode* const vsn = chunk-&gt;container();</span>
<span class="changed">!     vsn-&gt;verify(true);</span>
<span class="changed">!     if (we_did_split_a_chunk) {</span>
<span class="changed">!       vsn-&gt;verify_free_chunks_are_ideally_merged();</span>
      }
<span class="changed">!   END_EVERY_NTH</span>
  
<span class="changed">!   g_internal_statistics.num_chunks_removed_from_freelist ++;</span>
  
<span class="changed">! #endif</span>
  
<span class="changed">!   return chunk;</span>
<span class="changed">! }</span>
  
<span class="changed">! Metachunk* ChunkManager::chunk_freelist_allocate(size_t word_size) {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   // Take from the beginning of the list</span>
<span class="changed">!   Metachunk* chunk = free_chunks_get(word_size);</span>
<span class="changed">!   if (chunk == NULL) {</span>
<span class="changed">!     return NULL;</span>
    }
  
<span class="changed">!   assert((word_size &lt;= chunk-&gt;word_size()) ||</span>
<span class="changed">!          (list_index(chunk-&gt;word_size()) == HumongousIndex),</span>
<span class="changed">!          "Non-humongous variable sized chunk");</span>
<span class="changed">!   LogTarget(Trace, gc, metaspace, freelist) lt;</span>
<span class="changed">!   if (lt.is_enabled()) {</span>
<span class="changed">!     size_t list_count;</span>
<span class="changed">!     if (list_index(word_size) &lt; HumongousIndex) {</span>
<span class="changed">!       ChunkList* list = find_free_chunks_list(word_size);</span>
<span class="changed">!       list_count = list-&gt;count();</span>
      } else {
<span class="changed">!       list_count = humongous_dictionary()-&gt;total_count();</span>
<span class="changed">!     }</span>
      LogStream ls(lt);
<span class="changed">!     ls.print("ChunkManager::chunk_freelist_allocate: " PTR_FORMAT " chunk " PTR_FORMAT "  size " SIZE_FORMAT " count " SIZE_FORMAT " ",</span>
<span class="changed">!              p2i(this), p2i(chunk), chunk-&gt;word_size(), list_count);</span>
<span class="changed">!     ResourceMark rm;</span>
<span class="changed">!     locked_print_free_chunks(&amp;ls);</span>
    }
  
<span class="removed">-   return chunk;</span>
  }
  
<span class="changed">! void ChunkManager::return_single_chunk(Metachunk* chunk) {</span>
  
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="changed">!     this-&gt;locked_verify(false);</span>
<span class="changed">!     do_verify_chunk(chunk);</span>
<span class="changed">!   END_EVERY_NTH</span>
<span class="changed">! #endif</span>
  
<span class="changed">!   const ChunkIndex index = chunk-&gt;get_chunk_type();</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   DEBUG_ONLY(g_internal_statistics.num_chunks_added_to_freelist ++;)</span>
<span class="changed">!   assert(chunk != NULL, "Expected chunk.");</span>
<span class="changed">!   assert(chunk-&gt;container() != NULL, "Container should have been set.");</span>
<span class="changed">!   assert(chunk-&gt;is_tagged_free() == false, "Chunk should be in use.");</span>
<span class="changed">!   index_bounds_check(index);</span>
<span class="changed">! </span>
<span class="changed">!   // Note: mangle *before* returning the chunk to the freelist or dictionary. It does not</span>
<span class="changed">!   // matter for the freelist (non-humongous chunks), but the humongous chunk dictionary</span>
<span class="changed">!   // keeps tree node pointers in the chunk payload area which mangle will overwrite.</span>
<span class="changed">!   DEBUG_ONLY(chunk-&gt;mangle(badMetaWordVal);)</span>
<span class="changed">! </span>
<span class="changed">!   // may need node for verification later after chunk may have been merged away.</span>
<span class="changed">!   DEBUG_ONLY(VirtualSpaceNode* vsn = chunk-&gt;container(); )</span>
<span class="changed">! </span>
<span class="changed">!   if (index != HumongousIndex) {</span>
<span class="changed">!     // Return non-humongous chunk to freelist.</span>
<span class="changed">!     ChunkList* list = free_chunks(index);</span>
<span class="changed">!     assert(list-&gt;size() == chunk-&gt;word_size(), "Wrong chunk type.");</span>
<span class="changed">!     list-&gt;return_chunk_at_head(chunk);</span>
<span class="changed">!     log_trace(gc, metaspace, freelist)("returned one %s chunk at " PTR_FORMAT " to freelist.",</span>
<span class="changed">!         chunk_size_name(index), p2i(chunk));</span>
<span class="changed">!   } else {</span>
<span class="changed">!     // Return humongous chunk to dictionary.</span>
<span class="changed">!     assert(chunk-&gt;word_size() &gt; free_chunks(MediumIndex)-&gt;size(), "Wrong chunk type.");</span>
<span class="changed">!     assert(chunk-&gt;word_size() % free_chunks(SpecializedIndex)-&gt;size() == 0,</span>
<span class="changed">!            "Humongous chunk has wrong alignment.");</span>
<span class="changed">!     _humongous_dictionary.return_chunk(chunk);</span>
<span class="changed">!     log_trace(gc, metaspace, freelist)("returned one %s chunk at " PTR_FORMAT " (word size " SIZE_FORMAT ") to freelist.",</span>
<span class="changed">!         chunk_size_name(index), p2i(chunk), chunk-&gt;word_size());</span>
<span class="changed">!   }</span>
<span class="changed">!   chunk-&gt;container()-&gt;dec_container_count();</span>
<span class="changed">!   do_update_in_use_info_for_chunk(chunk, false);</span>
  
<span class="changed">!   // Chunk has been added; update counters.</span>
<span class="changed">!   account_for_added_chunk(chunk);</span>
  
<span class="changed">!   // Attempt coalesce returned chunks with its neighboring chunks:</span>
<span class="changed">!   // if this chunk is small or special, attempt to coalesce to a medium chunk.</span>
<span class="changed">!   if (index == SmallIndex || index == SpecializedIndex) {</span>
<span class="changed">!     if (!attempt_to_coalesce_around_chunk(chunk, MediumIndex)) {</span>
<span class="changed">!       // This did not work. But if this chunk is special, we still may form a small chunk?</span>
<span class="changed">!       if (index == SpecializedIndex) {</span>
<span class="changed">!         if (!attempt_to_coalesce_around_chunk(chunk, SmallIndex)) {</span>
<span class="changed">!           // give up.</span>
<span class="changed">!         }</span>
<span class="changed">!       }</span>
<span class="changed">!     }</span>
    }
  
<span class="changed">!   // From here on do not access chunk anymore, it may have been merged with another chunk.</span>
  
  #ifdef ASSERT
<span class="removed">-   EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="removed">-     this-&gt;locked_verify(true);</span>
<span class="removed">-     vsn-&gt;verify(true);</span>
<span class="removed">-     vsn-&gt;verify_free_chunks_are_ideally_merged();</span>
<span class="removed">-   END_EVERY_NTH</span>
<span class="removed">- #endif</span>
  
  }
  
<span class="changed">! void ChunkManager::return_chunk_list(Metachunk* chunks) {</span>
<span class="changed">!   if (chunks == NULL) {</span>
<span class="changed">!     return;</span>
<span class="changed">!   }</span>
<span class="changed">!   LogTarget(Trace, gc, metaspace, freelist) log;</span>
<span class="changed">!   if (log.is_enabled()) { // tracing</span>
<span class="changed">!     log.print("returning list of chunks...");</span>
<span class="changed">!   }</span>
<span class="changed">!   unsigned num_chunks_returned = 0;</span>
<span class="changed">!   size_t size_chunks_returned = 0;</span>
<span class="changed">!   Metachunk* cur = chunks;</span>
<span class="changed">!   while (cur != NULL) {</span>
<span class="changed">!     // Capture the next link before it is changed</span>
<span class="changed">!     // by the call to return_chunk_at_head();</span>
<span class="changed">!     Metachunk* next = cur-&gt;next();</span>
<span class="changed">!     if (log.is_enabled()) { // tracing</span>
<span class="changed">!       num_chunks_returned ++;</span>
<span class="changed">!       size_chunks_returned += cur-&gt;word_size();</span>
<span class="changed">!     }</span>
<span class="changed">!     return_single_chunk(cur);</span>
<span class="changed">!     cur = next;</span>
<span class="changed">!   }</span>
<span class="changed">!   if (log.is_enabled()) { // tracing</span>
<span class="changed">!     log.print("returned %u chunks to freelist, total word size " SIZE_FORMAT ".",</span>
<span class="changed">!         num_chunks_returned, size_chunks_returned);</span>
<span class="changed">!   }</span>
  }
  
<span class="changed">! void ChunkManager::collect_statistics(ChunkManagerStatistics* out) const {</span>
<span class="changed">!   MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {</span>
<span class="changed">!     out-&gt;chunk_stats(i).add(num_free_chunks(i), size_free_chunks_in_bytes(i) / sizeof(MetaWord));</span>
<span class="changed">!   }</span>
  }
  
<span class="changed">! } // namespace metaspace</span>
  
  
  
<span class="newmarker">--- 20,479 ----</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   *
   */
<span class="new">+ </span>
  #include "precompiled.hpp"
  
<span class="new">+ </span>
  #include "logging/log.hpp"
  #include "logging/logStream.hpp"
<span class="changed">! #include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="changed">! #include "memory/metaspace/chunkLevel.hpp"</span>
  #include "memory/metaspace/chunkManager.hpp"
<span class="new">+ #include "memory/metaspace/internStat.hpp"</span>
  #include "memory/metaspace/metachunk.hpp"
  #include "memory/metaspace/metaspaceCommon.hpp"
<span class="new">+ #include "memory/metaspace/metaspaceContext.hpp"</span>
  #include "memory/metaspace/metaspaceStatistics.hpp"
<span class="changed">! #include "memory/metaspace/settings.hpp"</span>
  #include "memory/metaspace/virtualSpaceNode.hpp"
<span class="new">+ #include "memory/metaspace/virtualSpaceList.hpp"</span>
  #include "runtime/mutexLocker.hpp"
  #include "utilities/debug.hpp"
  #include "utilities/globalDefinitions.hpp"
  
  namespace metaspace {
  
<span class="changed">! #define LOGFMT         "ChkMgr @" PTR_FORMAT " (%s)"</span>
<span class="changed">! #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>
  
<span class="changed">! // Return a single chunk to the freelist and adjust accounting. No merge is attempted.</span>
<span class="changed">! void ChunkManager::return_chunk_simple_locked(Metachunk* c) {</span>
<span class="changed">! </span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(c-&gt;verify(false));</span>
<span class="changed">! </span>
<span class="changed">!   const chunklevel_t lvl = c-&gt;level();</span>
<span class="changed">!   _chunks.add(c);</span>
<span class="changed">!   c-&gt;reset_used_words();</span>
<span class="changed">! </span>
<span class="changed">!   // Tracing</span>
<span class="changed">!   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",</span>
<span class="changed">!                        _name, METACHUNK_FORMAT_ARGS(c));</span>
  
  }
  
<span class="changed">! // Creates a chunk manager with a given name (which is for debug purposes only)</span>
<span class="changed">! // and an associated space list which will be used to request new chunks from</span>
<span class="changed">! // (see get_chunk())</span>
<span class="changed">! ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)</span>
<span class="changed">!   : _vslist(space_list),</span>
<span class="changed">!     _name(name),</span>
<span class="changed">!     _chunks()</span>
<span class="changed">! {</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! // Given a chunk, split it into a target chunk of a smaller size (higher target level)</span>
<span class="changed">! //  and at least one, possible several splinter chunks.</span>
<span class="changed">! // The original chunk must be outside of the freelist and its state must be free.</span>
<span class="changed">! // The splinter chunks are added to the freelist.</span>
<span class="changed">! // The resulting target chunk will be located at the same address as the original</span>
<span class="changed">! //  chunk, but it will of course be smaller (of a higher level).</span>
<span class="changed">! // The committed areas within the original chunk carry over to the resulting</span>
<span class="changed">! //  chunks.</span>
<span class="changed">! void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {</span>
<span class="changed">! </span>
    assert_lock_strong(MetaspaceExpand_lock);
  
<span class="changed">!   assert(c-&gt;is_free(), "chunk to be split must be free.");</span>
<span class="changed">!   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");</span>
<span class="changed">!   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");</span>
  
<span class="changed">!   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)</span>
<span class="changed">!   DEBUG_ONLY(c-&gt;verify(true);)</span>
  
<span class="changed">!   UL2(debug, "splitting chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",</span>
<span class="changed">!       METACHUNK_FORMAT_ARGS(c), target_level);</span>
  
<span class="changed">!   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)</span>
  
<span class="changed">!   const chunklevel_t orig_level = c-&gt;level();</span>
<span class="changed">!   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);</span>
<span class="changed">! </span>
<span class="changed">!   // Splitting should never fail.</span>
<span class="changed">!   assert(c-&gt;level() == target_level, "Sanity");</span>
  
<span class="changed">!   // The size of the committed portion should not change (subject to the reduced chunk size of course)</span>
<span class="changed">! #ifdef ASSERT</span>
<span class="changed">!   if (committed_words_before &gt; c-&gt;word_size()) {</span>
<span class="changed">!     assert(c-&gt;is_fully_committed(), "Sanity");</span>
<span class="changed">!   } else {</span>
<span class="changed">!     assert(c-&gt;committed_words() == committed_words_before, "Sanity");</span>
    }
<span class="changed">! #endif</span>
  
<span class="changed">!   DEBUG_ONLY(c-&gt;verify(false));</span>
  
<span class="changed">!   DEBUG_ONLY(verify_locked(true);)</span>
<span class="changed">! </span>
<span class="changed">!   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>
<span class="changed">! </span>
<span class="changed">!   InternalStats::inc_num_chunk_splits();</span>
  
  }
  
<span class="changed">! // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.</span>
<span class="changed">! //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.</span>
<span class="changed">! // On error, will return NULL.</span>
<span class="changed">! //</span>
<span class="changed">! // This function may fail for two reasons:</span>
<span class="changed">! // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList</span>
<span class="changed">! //   is non-expandable but needs expanding - aka out of compressed class space).</span>
<span class="changed">! // - Or, if the necessary space cannot be committed because we hit a commit limit.</span>
<span class="changed">! //   This may be either the GC threshold or MaxMetaspaceSize.</span>
<span class="changed">! Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {</span>
  
<span class="changed">!   assert(preferred_level &lt;= max_level, "Sanity");</span>
<span class="changed">!   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");</span>
<span class="changed">! </span>
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="changed">!   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed">! </span>
<span class="changed">!   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)</span>
<span class="changed">!   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)</span>
<span class="changed">!   assert(max_level &gt;= preferred_level, "invalid level.");</span>
<span class="changed">! </span>
<span class="changed">!   UL2(debug, "requested chunk: pref_level: " CHKLVL_FORMAT</span>
<span class="changed">!      ", max_level: " CHKLVL_FORMAT ", min committed size: " SIZE_FORMAT ".",</span>
<span class="changed">!      preferred_level, max_level, min_committed_words);</span>
<span class="changed">! </span>
<span class="changed">!   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.</span>
<span class="changed">! </span>
<span class="changed">!   // 1) Search best or smaller committed chunks (first attempt):</span>
<span class="changed">!   //    Start at the preferred chunk size and work your way down (level up).</span>
<span class="changed">!   //    But for now, only consider chunks larger than a certain threshold -</span>
<span class="changed">!   //    this is to prevent large loaders (eg boot) from unnecessarily gobbling up</span>
<span class="changed">!   //    all the tiny splinter chunks lambdas leave around.</span>
<span class="changed">!   Metachunk* c = NULL;</span>
<span class="changed">!   c = _chunks.search_chunk_ascending(preferred_level, MIN2((chunklevel_t)(preferred_level + 2), max_level), min_committed_words);</span>
<span class="changed">! </span>
<span class="changed">!   // 2) Search larger committed chunks:</span>
<span class="changed">!   //    If that did not yield anything, look at larger chunks, which may be committed. We would have to split</span>
<span class="changed">!   //    them first, of course.</span>
<span class="changed">!   if (c == NULL) {</span>
<span class="changed">!     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);</span>
    }
<span class="new">+ </span>
<span class="new">+   // 3) Search best or smaller committed chunks (second attempt):</span>
<span class="new">+   //    Repeat (1) but now consider even the tiniest chunks as long as they are large enough to hold the</span>
<span class="new">+   //    committed min size.</span>
<span class="new">+   if (c == NULL) {</span>
<span class="new">+     c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);</span>
    }
<span class="new">+ </span>
<span class="new">+   // if we did not get anything yet, there are no free chunks commmitted enough. Repeat search but look for uncommitted chunks too:</span>
<span class="new">+ </span>
<span class="new">+   // 4) Search best or smaller chunks, can be uncommitted:</span>
<span class="new">+   if (c == NULL) {</span>
<span class="new">+     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);</span>
    }
  
<span class="changed">!   // 5) Search a larger uncommitted chunk:</span>
<span class="changed">!   if (c == NULL) {</span>
<span class="changed">!     c = _chunks.search_chunk_descending(preferred_level, 0);</span>
<span class="changed">!   }</span>
  
<span class="changed">!   if (c != NULL) {</span>
<span class="changed">!     UL(trace, "taken from freelist.");</span>
<span class="changed">!   }</span>
  
<span class="changed">!   // Failing all that, allocate a new root chunk from the connected virtual space.</span>
<span class="changed">!   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)</span>
<span class="changed">!   if (c == NULL) {</span>
<span class="changed">!     c = _vslist-&gt;allocate_root_chunk();</span>
<span class="changed">!     if (c == NULL) {</span>
<span class="changed">!       UL(info, "failed to get new root chunk.");</span>
      } else {
<span class="changed">!       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");</span>
<span class="changed">!       UL(debug, "allocated new root chunk.");</span>
      }
    }
  
<span class="changed">!   if (c == NULL) {</span>
<span class="changed">!     // If we end up here, we found no match in the freelists and were unable to get a new</span>
<span class="changed">!     // root chunk (so we used up all address space, e.g. out of CompressedClassSpace).</span>
<span class="changed">!     UL2(info, "failed to get chunk (preferred level: " CHKLVL_FORMAT</span>
<span class="changed">!        ", max level " CHKLVL_FORMAT ".", preferred_level, max_level);</span>
<span class="changed">!     c = NULL;</span>
<span class="changed">!   }</span>
  
<span class="changed">!   if (c != NULL) {</span>
  
<span class="changed">!     // Now we have a chunk.</span>
<span class="changed">!     //  It may be larger than what the caller wanted, so we may want to split it. This should</span>
<span class="changed">!     //  always work.</span>
<span class="changed">!     if (c-&gt;level() &lt; preferred_level) {</span>
<span class="changed">!       split_chunk_and_add_splinters(c, preferred_level);</span>
<span class="changed">!       assert(c-&gt;level() == preferred_level, "split failed?");</span>
<span class="changed">!     }</span>
  
<span class="changed">!     // Attempt to commit the chunk (depending on settings, we either fully commit it or just</span>
<span class="changed">!     //  commit enough to get the caller going). That may fail if we hit a commit limit. In</span>
<span class="changed">!     //  that case put the chunk back to the freelist (re-merging it with its neighbors if we</span>
<span class="changed">!     //  did split it) and return NULL.</span>
<span class="changed">!     const size_t to_commit = Settings::new_chunks_are_fully_committed() ? c-&gt;word_size() : min_committed_words;</span>
<span class="changed">!     if (c-&gt;committed_words() &lt; to_commit) {</span>
<span class="changed">!       if (c-&gt;ensure_committed_locked(to_commit) == false) {</span>
<span class="changed">!         UL2(info, "failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",</span>
<span class="changed">!             to_commit,  METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed">!         c-&gt;set_in_use(); // gets asserted in return_chunk().</span>
<span class="changed">!         return_chunk_locked(c);</span>
<span class="changed">!         c = NULL;</span>
<span class="changed">!       }</span>
<span class="changed">!     }</span>
  
<span class="changed">!     if (c != NULL) {</span>
  
<span class="changed">!       // Still here? We have now a good chunk, all is well.</span>
<span class="changed">!       assert(c-&gt;committed_words() &gt;= min_committed_words, "Sanity");</span>
  
<span class="changed">!       // Any chunk returned from ChunkManager shall be marked as in use.</span>
<span class="changed">!       c-&gt;set_in_use();</span>
  
<span class="changed">!       UL2(debug, "handing out chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
  
<span class="changed">!       InternalStats::inc_num_chunks_taken_from_freelist();</span>
  
<span class="changed">!       SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>
  
<span class="changed">!     }</span>
  
<span class="changed">!   }</span>
  
<span class="changed">!   DEBUG_ONLY(verify_locked(false);)</span>
  
<span class="changed">!   return c;</span>
  
<span class="changed">! }</span>
  
  
<span class="changed">! // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk</span>
<span class="changed">! //  with neighbors.</span>
<span class="changed">! // As a side effect this removes the chunk from whatever list it has been in previously.</span>
<span class="changed">! // Happens after a Classloader was unloaded and releases its metaspace chunks.</span>
<span class="changed">! // !! Note: this may invalidate the chunk. Do not access the chunk after</span>
<span class="changed">! //    this function returns !!</span>
<span class="changed">! void ChunkManager::return_chunk(Metachunk* c) {</span>
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   return_chunk_locked(c);</span>
<span class="changed">! }</span>
  
<span class="changed">! // See return_chunk().</span>
<span class="changed">! void ChunkManager::return_chunk_locked(Metachunk* c) {</span>
  
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
  
<span class="changed">!   UL2(debug, ": returning chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
  
<span class="changed">!   DEBUG_ONLY(c-&gt;verify(true);)</span>
  
<span class="changed">!   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");</span>
  
<span class="changed">!   assert(c-&gt;is_in_use(), "Unexpected chunk state");</span>
<span class="changed">!   assert(!c-&gt;in_list(), "Remove from list first");</span>
<span class="changed">!   c-&gt;set_free();</span>
<span class="changed">!   c-&gt;reset_used_words();</span>
  
<span class="changed">!   const chunklevel_t orig_lvl = c-&gt;level();</span>
  
<span class="changed">!   Metachunk* merged = NULL;</span>
<span class="changed">!   if (!c-&gt;is_root_chunk()) {</span>
<span class="changed">!     // Only attempt merging if we are not of the lowest level already.</span>
<span class="changed">!     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);</span>
    }
  
<span class="changed">!   if (merged != NULL) {</span>
  
<span class="changed">!     InternalStats::inc_num_chunk_merges();</span>
  
<span class="changed">!     DEBUG_ONLY(merged-&gt;verify(false));</span>
  
<span class="changed">!     // We did merge our chunk into a different chunk.</span>
<span class="changed">! </span>
<span class="changed">!     // We did merge chunks and now have a bigger chunk.</span>
<span class="changed">!     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");</span>
<span class="changed">! </span>
<span class="changed">!     UL2(debug, "merged into chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(merged));</span>
<span class="changed">! </span>
<span class="changed">!     c = merged;</span>
  
    }
  
<span class="changed">!   if (Settings::uncommit_free_chunks() &amp;&amp;</span>
<span class="changed">!       c-&gt;word_size() &gt;= Settings::commit_granule_words())</span>
<span class="changed">!   {</span>
<span class="changed">!     UL2(debug, "uncommitting free chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed">!     c-&gt;uncommit_locked();</span>
    }
  
<span class="changed">!   return_chunk_simple_locked(c);</span>
  
<span class="changed">!   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed">!   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>
  
<span class="changed">!   InternalStats::inc_num_chunks_returned_to_freelist();</span>
<span class="changed">! </span>
<span class="changed">! }</span>
  
<span class="changed">! // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to</span>
<span class="changed">! // enlarge it in place by claiming its trailing buddy.</span>
<span class="changed">! //</span>
<span class="changed">! // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="changed">! //</span>
<span class="changed">! // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="changed">! // double in size (level decreased by one).</span>
<span class="changed">! //</span>
<span class="changed">! // On success, true is returned, false otherwise.</span>
<span class="changed">! bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {</span>
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed">!   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);</span>
<span class="changed">! }</span>
<span class="changed">! </span>
<span class="changed">! static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {</span>
<span class="changed">!   if (word_size_1 == word_size_2) {</span>
<span class="changed">!     print_scaled_words(st, word_size_1);</span>
<span class="changed">!     st-&gt;print (" (no change)");</span>
<span class="changed">!   } else {</span>
<span class="changed">!     print_scaled_words(st, word_size_1);</span>
<span class="changed">!     st-&gt;print("-&gt;");</span>
<span class="changed">!     print_scaled_words(st, word_size_2);</span>
<span class="changed">!     st-&gt;print(" (");</span>
<span class="changed">!     if (word_size_2 &lt;= word_size_1) {</span>
<span class="changed">!       st-&gt;print("-");</span>
<span class="changed">!       print_scaled_words(st, word_size_1 - word_size_2);</span>
<span class="changed">!     } else {</span>
<span class="changed">!       st-&gt;print("+");</span>
<span class="changed">!       print_scaled_words(st, word_size_2 - word_size_1);</span>
      }
<span class="changed">!     st-&gt;print(")");</span>
<span class="changed">!   }</span>
<span class="changed">! }</span>
  
<span class="changed">! void ChunkManager::purge() {</span>
  
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="changed">!   UL(info, ": reclaiming memory...");</span>
  
<span class="changed">!   const size_t reserved_before = _vslist-&gt;reserved_words();</span>
<span class="changed">!   const size_t committed_before = _vslist-&gt;committed_words();</span>
<span class="changed">!   int num_nodes_purged = 0;</span>
<span class="changed">! </span>
<span class="changed">!   // 1) purge virtual space list</span>
<span class="changed">!   num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);</span>
<span class="changed">!   InternalStats::inc_num_purges();</span>
  
<span class="changed">!   // 2) uncommit free chunks</span>
<span class="changed">!   if (Settings::uncommit_free_chunks()) {</span>
<span class="changed">!     const chunklevel_t max_level =</span>
<span class="changed">!         chunklevel::level_fitting_word_size(Settings::commit_granule_words());</span>
<span class="changed">!     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;</span>
<span class="changed">!          l &lt;= max_level;</span>
<span class="changed">!          l ++)</span>
<span class="changed">!     {</span>
<span class="changed">!       // Since we uncommit all chunks at this level, we do not break the "committed chunks are</span>
<span class="changed">!       //  at the front of the list" condition.</span>
<span class="changed">!       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {</span>
<span class="changed">!         c-&gt;uncommit_locked();</span>
<span class="changed">!       }</span>
<span class="changed">!     }</span>
    }
  
<span class="changed">!   const size_t reserved_after = _vslist-&gt;reserved_words();</span>
<span class="changed">!   const size_t committed_after = _vslist-&gt;committed_words();</span>
<span class="changed">! </span>
<span class="changed">!   // Print a nice report.</span>
<span class="changed">!   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {</span>
<span class="changed">!     UL(info, "nothing reclaimed.");</span>
    } else {
<span class="changed">!     LogTarget(Info, metaspace) lt;</span>
<span class="changed">!     if (lt.is_enabled()) {</span>
        LogStream ls(lt);
<span class="changed">!       ls.print_cr(LOGFMT ": finished reclaiming memory: ", LOGFMT_ARGS);</span>
<span class="changed">! </span>
<span class="changed">!       ls.print("reserved: ");</span>
<span class="changed">!       print_word_size_delta(&amp;ls, reserved_before, reserved_after);</span>
<span class="changed">!       ls.cr();</span>
<span class="changed">! </span>
<span class="changed">!       ls.print("committed: ");</span>
<span class="changed">!       print_word_size_delta(&amp;ls, committed_before, committed_after);</span>
<span class="changed">!       ls.cr();</span>
<span class="changed">! </span>
<span class="changed">!       ls.print_cr("full nodes purged: %d", num_nodes_purged);</span>
      }
<span class="new">+   }</span>
<span class="new">+ </span>
<span class="new">+   DEBUG_ONLY(_vslist-&gt;verify_locked(true));</span>
<span class="new">+   DEBUG_ONLY(verify_locked(true));</span>
  
  }
  
<span class="changed">! // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed">! //  and non-class chunkmanager, respectively.</span>
<span class="changed">! ChunkManager* ChunkManager::chunkmanager_class() {</span>
<span class="changed">!   return MetaspaceContext::context_class() == NULL ? NULL : MetaspaceContext::context_class()-&gt;cm();</span>
<span class="changed">! }</span>
  
<span class="changed">! ChunkManager* ChunkManager::chunkmanager_nonclass() {</span>
<span class="changed">!   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;cm();</span>
<span class="changed">! }</span>
  
<span class="changed">! // Update statistics.</span>
<span class="changed">! void ChunkManager::add_to_statistics(cm_stats_t* out) const {</span>
  
<span class="changed">!   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
  
<span class="changed">!   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {</span>
<span class="changed">!     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);</span>
<span class="changed">!     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);</span>
    }
  
<span class="changed">!   DEBUG_ONLY(out-&gt;verify();)</span>
<span class="changed">! </span>
<span class="changed">! }</span>
  
  #ifdef ASSERT
  
<span class="new">+ void ChunkManager::verify(bool slow) const {</span>
<span class="new">+   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+   verify_locked(slow);</span>
  }
  
<span class="changed">! void ChunkManager::verify_locked(bool slow) const {</span>
<span class="changed">!   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">!   assert(_vslist != NULL, "No vslist");</span>
<span class="changed">!   _chunks.verify();</span>
  }
  
<span class="changed">! bool ChunkManager::contains_chunk(Metachunk* c) const {</span>
<span class="changed">!   return _chunks.contains(c);</span>
  }
  
<span class="changed">! #endif // ASSERT</span>
  
<span class="new">+ void ChunkManager::print_on(outputStream* st) const {</span>
<span class="new">+   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+   print_on_locked(st);</span>
<span class="new">+ }</span>
  
<span class="new">+ void ChunkManager::print_on_locked(outputStream* st) const {</span>
<span class="new">+   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="new">+                total_num_chunks(), total_word_size(), _chunks.committed_word_size());</span>
<span class="new">+   _chunks.print_on(st);</span>
<span class="new">+ }</span>
  
<span class="new">+ } // namespace metaspace</span>
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace.hpp.cdiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/chunkManager.hpp.cdiff.html' target='_top'>next &gt</a></center>
</body></html>

