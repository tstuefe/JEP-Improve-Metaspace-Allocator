<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60538">60538</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
<a name="2" id="anc2"></a><span class="new">  25 </span>
  26 #include "precompiled.hpp"
  27 
<a name="3" id="anc3"></a><span class="new">  28 </span>
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
<a name="4" id="anc4"></a><span class="changed">  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/chunkLevel.hpp"</span>
  33 #include "memory/metaspace/chunkManager.hpp"
<a name="5" id="anc5"></a><span class="new">  34 #include "memory/metaspace/internStat.hpp"</span>
  35 #include "memory/metaspace/metachunk.hpp"
<a name="6" id="anc6"></a>
  36 #include "memory/metaspace/metaspaceCommon.hpp"
<a name="7" id="anc7"></a><span class="new">  37 #include "memory/metaspace/metaspaceContext.hpp"</span>
  38 #include "memory/metaspace/metaspaceStatistics.hpp"
<a name="8" id="anc8"></a><span class="changed">  39 #include "memory/metaspace/settings.hpp"</span>
  40 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="9" id="anc9"></a><span class="new">  41 #include "memory/metaspace/virtualSpaceList.hpp"</span>
  42 #include "runtime/mutexLocker.hpp"
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
<a name="10" id="anc10"></a>
  45 
  46 namespace metaspace {
  47 
<a name="11" id="anc11"></a><span class="changed">  48 #define LOGFMT         "ChkMgr @" PTR_FORMAT " (%s)"</span>
<span class="changed">  49 #define LOGFMT_ARGS    p2i(this), this-&gt;_name</span>




  50 
<a name="12" id="anc12"></a><span class="changed">  51 // Return a single chunk to the freelist and adjust accounting. No merge is attempted.</span>
<span class="changed">  52 void ChunkManager::return_chunk_simple_locked(Metachunk* c) {</span>
<span class="changed">  53 </span>
<span class="changed">  54   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed">  55 </span>
<span class="changed">  56   DEBUG_ONLY(c-&gt;verify(false));</span>
<span class="changed">  57 </span>
<span class="changed">  58   const chunklevel_t lvl = c-&gt;level();</span>
<span class="changed">  59   _chunks.add(c);</span>
<span class="changed">  60   c-&gt;reset_used_words();</span>
<span class="changed">  61 </span>
<span class="changed">  62   // Tracing</span>
<span class="changed">  63   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",</span>
<span class="changed">  64                        _name, METACHUNK_FORMAT_ARGS(c));</span>
  65 
<a name="13" id="anc13"></a>

  66 }
  67 
<a name="14" id="anc14"></a><span class="changed">  68 // Creates a chunk manager with a given name (which is for debug purposes only)</span>
<span class="changed">  69 // and an associated space list which will be used to request new chunks from</span>
<span class="changed">  70 // (see get_chunk())</span>
<span class="changed">  71 ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)</span>
<span class="changed">  72   : _vslist(space_list),</span>
<span class="changed">  73     _name(name),</span>
<span class="changed">  74     _chunks()</span>
<span class="changed">  75 {</span>
<span class="changed">  76 }</span>
<span class="changed">  77 </span>
<span class="changed">  78 // Given a chunk, split it into a target chunk of a smaller size (higher target level)</span>
<span class="changed">  79 //  and at least one, possible several splinter chunks.</span>
<span class="changed">  80 // The original chunk must be outside of the freelist and its state must be free.</span>
<span class="changed">  81 // The splinter chunks are added to the freelist.</span>
<span class="changed">  82 // The resulting target chunk will be located at the same address as the original</span>
<span class="changed">  83 //  chunk, but it will of course be smaller (of a higher level).</span>
<span class="changed">  84 // The committed areas within the original chunk carry over to the resulting</span>
<span class="changed">  85 //  chunks.</span>
<span class="changed">  86 void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {</span>
<span class="changed">  87 </span>
  88   assert_lock_strong(MetaspaceExpand_lock);
<a name="15" id="anc15"></a>
















































































  89 
<a name="16" id="anc16"></a><span class="changed">  90   assert(c-&gt;is_free(), "chunk to be split must be free.");</span>
<span class="changed">  91   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");</span>
<span class="changed">  92   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");</span>
  93 
<a name="17" id="anc17"></a><span class="changed">  94   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)</span>
<span class="changed">  95   DEBUG_ONLY(c-&gt;verify(true);)</span>


  96 
<a name="18" id="anc18"></a><span class="changed">  97   UL2(debug, "splitting chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",</span>
<span class="changed">  98       METACHUNK_FORMAT_ARGS(c), target_level);</span>
  99 
<a name="19" id="anc19"></a><span class="changed"> 100   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)</span>
 101 
<a name="20" id="anc20"></a><span class="changed"> 102   const chunklevel_t orig_level = c-&gt;level();</span>
<span class="changed"> 103   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);</span>
<span class="changed"> 104 </span>
<span class="changed"> 105   // Splitting should never fail.</span>
<span class="changed"> 106   assert(c-&gt;level() == target_level, "Sanity");</span>
 107 
<a name="21" id="anc21"></a><span class="changed"> 108   // The size of the committed portion should not change (subject to the reduced chunk size of course)</span>
<span class="changed"> 109 #ifdef ASSERT</span>
<span class="changed"> 110   if (committed_words_before &gt; c-&gt;word_size()) {</span>
<span class="changed"> 111     assert(c-&gt;is_fully_committed(), "Sanity");</span>
<span class="changed"> 112   } else {</span>
<span class="changed"> 113     assert(c-&gt;committed_words() == committed_words_before, "Sanity");</span>


























 114   }
<a name="22" id="anc22"></a><span class="changed"> 115 #endif</span>

 116 
<a name="23" id="anc23"></a><span class="changed"> 117   DEBUG_ONLY(c-&gt;verify(false));</span>





 118 
<a name="24" id="anc24"></a><span class="changed"> 119   DEBUG_ONLY(verify_locked(true);)</span>
<span class="changed"> 120 </span>
<span class="changed"> 121   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>
<span class="changed"> 122 </span>
<span class="changed"> 123   InternalStats::inc_num_chunk_splits();</span>
















 124 
<a name="25" id="anc25"></a>




 125 }
 126 
<a name="26" id="anc26"></a><span class="changed"> 127 // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.</span>
<span class="changed"> 128 //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.</span>
<span class="changed"> 129 // On error, will return NULL.</span>
<span class="changed"> 130 //</span>
<span class="changed"> 131 // This function may fail for two reasons:</span>
<span class="changed"> 132 // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList</span>
<span class="changed"> 133 //   is non-expandable but needs expanding - aka out of compressed class space).</span>
<span class="changed"> 134 // - Or, if the necessary space cannot be committed because we hit a commit limit.</span>
<span class="changed"> 135 //   This may be either the GC threshold or MaxMetaspaceSize.</span>
<span class="changed"> 136 Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {</span>
 137 
<a name="27" id="anc27"></a><span class="changed"> 138   assert(preferred_level &lt;= max_level, "Sanity");</span>
<span class="changed"> 139   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");</span>
<span class="changed"> 140 </span>
<span class="changed"> 141   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
 142 
<a name="28" id="anc28"></a><span class="changed"> 143   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed"> 144 </span>
<span class="changed"> 145   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)</span>
<span class="changed"> 146   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)</span>
<span class="changed"> 147   assert(max_level &gt;= preferred_level, "invalid level.");</span>
<span class="changed"> 148 </span>
<span class="changed"> 149   UL2(debug, "requested chunk: pref_level: " CHKLVL_FORMAT</span>
<span class="changed"> 150      ", max_level: " CHKLVL_FORMAT ", min committed size: " SIZE_FORMAT ".",</span>
<span class="changed"> 151      preferred_level, max_level, min_committed_words);</span>
<span class="changed"> 152 </span>
<span class="changed"> 153   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.</span>
<span class="changed"> 154 </span>
<span class="changed"> 155   // 1) Search best or smaller committed chunks (first attempt):</span>
<span class="changed"> 156   //    Start at the preferred chunk size and work your way down (level up).</span>
<span class="changed"> 157   //    But for now, only consider chunks larger than a certain threshold -</span>
<span class="changed"> 158   //    this is to prevent large loaders (eg boot) from unnecessarily gobbling up</span>
<span class="changed"> 159   //    all the tiny splinter chunks lambdas leave around.</span>
<span class="changed"> 160   Metachunk* c = NULL;</span>
<span class="changed"> 161   c = _chunks.search_chunk_ascending(preferred_level, MIN2((chunklevel_t)(preferred_level + 2), max_level), min_committed_words);</span>
<span class="changed"> 162 </span>
<span class="changed"> 163   // 2) Search larger committed chunks:</span>
<span class="changed"> 164   //    If that did not yield anything, look at larger chunks, which may be committed. We would have to split</span>
<span class="changed"> 165   //    them first, of course.</span>
<span class="changed"> 166   if (c == NULL) {</span>
<span class="changed"> 167     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);</span>
 168   }
<a name="29" id="anc29"></a><span class="new"> 169 </span>
<span class="new"> 170   // 3) Search best or smaller committed chunks (second attempt):</span>
<span class="new"> 171   //    Repeat (1) but now consider even the tiniest chunks as long as they are large enough to hold the</span>
<span class="new"> 172   //    committed min size.</span>
<span class="new"> 173   if (c == NULL) {</span>
<span class="new"> 174     c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);</span>
 175   }
<a name="30" id="anc30"></a><span class="new"> 176 </span>
<span class="new"> 177   // if we did not get anything yet, there are no free chunks commmitted enough. Repeat search but look for uncommitted chunks too:</span>
<span class="new"> 178 </span>
<span class="new"> 179   // 4) Search best or smaller chunks, can be uncommitted:</span>
<span class="new"> 180   if (c == NULL) {</span>
<span class="new"> 181     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);</span>
 182   }
 183 
<a name="31" id="anc31"></a><span class="changed"> 184   // 5) Search a larger uncommitted chunk:</span>
<span class="changed"> 185   if (c == NULL) {</span>
<span class="changed"> 186     c = _chunks.search_chunk_descending(preferred_level, 0);</span>
<span class="changed"> 187   }</span>







 188 
<a name="32" id="anc32"></a><span class="changed"> 189   if (c != NULL) {</span>
<span class="changed"> 190     UL(trace, "taken from freelist.");</span>
<span class="changed"> 191   }</span>


 192 
<a name="33" id="anc33"></a><span class="changed"> 193   // Failing all that, allocate a new root chunk from the connected virtual space.</span>
<span class="changed"> 194   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)</span>
<span class="changed"> 195   if (c == NULL) {</span>
<span class="changed"> 196     c = _vslist-&gt;allocate_root_chunk();</span>
<span class="changed"> 197     if (c == NULL) {</span>
<span class="changed"> 198       UL(info, "failed to get new root chunk.");</span>


































































 199     } else {
<a name="34" id="anc34"></a><span class="changed"> 200       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");</span>
<span class="changed"> 201       UL(debug, "allocated new root chunk.");</span>
 202     }
 203   }
 204 
<a name="35" id="anc35"></a><span class="changed"> 205   if (c == NULL) {</span>
<span class="changed"> 206     // If we end up here, we found no match in the freelists and were unable to get a new</span>
<span class="changed"> 207     // root chunk (so we used up all address space, e.g. out of CompressedClassSpace).</span>
<span class="changed"> 208     UL2(info, "failed to get chunk (preferred level: " CHKLVL_FORMAT</span>
<span class="changed"> 209        ", max level " CHKLVL_FORMAT ".", preferred_level, max_level);</span>
<span class="changed"> 210     c = NULL;</span>
<span class="changed"> 211   }</span>
 212 
<a name="36" id="anc36"></a><span class="changed"> 213   if (c != NULL) {</span>





 214 
<a name="37" id="anc37"></a><span class="changed"> 215     // Now we have a chunk.</span>
<span class="changed"> 216     //  It may be larger than what the caller wanted, so we may want to split it. This should</span>
<span class="changed"> 217     //  always work.</span>
<span class="changed"> 218     if (c-&gt;level() &lt; preferred_level) {</span>
<span class="changed"> 219       split_chunk_and_add_splinters(c, preferred_level);</span>
<span class="changed"> 220       assert(c-&gt;level() == preferred_level, "split failed?");</span>
<span class="changed"> 221     }</span>
 222 
<a name="38" id="anc38"></a><span class="changed"> 223     // Attempt to commit the chunk (depending on settings, we either fully commit it or just</span>
<span class="changed"> 224     //  commit enough to get the caller going). That may fail if we hit a commit limit. In</span>
<span class="changed"> 225     //  that case put the chunk back to the freelist (re-merging it with its neighbors if we</span>
<span class="changed"> 226     //  did split it) and return NULL.</span>
<span class="changed"> 227     const size_t to_commit = Settings::new_chunks_are_fully_committed() ? c-&gt;word_size() : min_committed_words;</span>
<span class="changed"> 228     if (c-&gt;committed_words() &lt; to_commit) {</span>
<span class="changed"> 229       if (c-&gt;ensure_committed_locked(to_commit) == false) {</span>
<span class="changed"> 230         UL2(info, "failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",</span>
<span class="changed"> 231             to_commit,  METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 232         c-&gt;set_in_use(); // gets asserted in return_chunk().</span>
<span class="changed"> 233         return_chunk_locked(c);</span>
<span class="changed"> 234         c = NULL;</span>
<span class="changed"> 235       }</span>
<span class="changed"> 236     }</span>
 237 
<a name="39" id="anc39"></a><span class="changed"> 238     if (c != NULL) {</span>



 239 
<a name="40" id="anc40"></a><span class="changed"> 240       // Still here? We have now a good chunk, all is well.</span>
<span class="changed"> 241       assert(c-&gt;committed_words() &gt;= min_committed_words, "Sanity");</span>
 242 
<a name="41" id="anc41"></a><span class="changed"> 243       // Any chunk returned from ChunkManager shall be marked as in use.</span>
<span class="changed"> 244       c-&gt;set_in_use();</span>
 245 
<a name="42" id="anc42"></a><span class="changed"> 246       UL2(debug, "handing out chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>


 247 
<a name="43" id="anc43"></a><span class="changed"> 248       InternalStats::inc_num_chunks_taken_from_freelist();</span>
 249 
<a name="44" id="anc44"></a><span class="changed"> 250       SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>

 251 
<a name="45" id="anc45"></a><span class="changed"> 252     }</span>

 253 
<a name="46" id="anc46"></a><span class="changed"> 254   }</span>

 255 
<a name="47" id="anc47"></a><span class="changed"> 256   DEBUG_ONLY(verify_locked(false);)</span>
 257 
<a name="48" id="anc48"></a><span class="changed"> 258   return c;</span>

 259 
<a name="49" id="anc49"></a><span class="changed"> 260 }</span>
 261 
<a name="50" id="anc50"></a>


 262 
<a name="51" id="anc51"></a><span class="changed"> 263 // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk</span>
<span class="changed"> 264 //  with neighbors.</span>
<span class="changed"> 265 // As a side effect this removes the chunk from whatever list it has been in previously.</span>
<span class="changed"> 266 // Happens after a Classloader was unloaded and releases its metaspace chunks.</span>
<span class="changed"> 267 // !! Note: this may invalidate the chunk. Do not access the chunk after</span>
<span class="changed"> 268 //    this function returns !!</span>
<span class="changed"> 269 void ChunkManager::return_chunk(Metachunk* c) {</span>
<span class="changed"> 270   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 271   return_chunk_locked(c);</span>
<span class="changed"> 272 }</span>
 273 
<a name="52" id="anc52"></a><span class="changed"> 274 // See return_chunk().</span>
<span class="changed"> 275 void ChunkManager::return_chunk_locked(Metachunk* c) {</span>







 276 
<a name="53" id="anc53"></a><span class="changed"> 277   assert_lock_strong(MetaspaceExpand_lock);</span>


 278 
<a name="54" id="anc54"></a><span class="changed"> 279   UL2(debug, ": returning chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>







 280 
<a name="55" id="anc55"></a><span class="changed"> 281   DEBUG_ONLY(c-&gt;verify(true);)</span>



 282 
<a name="56" id="anc56"></a><span class="changed"> 283   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");</span>
 284 
<a name="57" id="anc57"></a><span class="changed"> 285   assert(c-&gt;is_in_use(), "Unexpected chunk state");</span>
<span class="changed"> 286   assert(!c-&gt;in_list(), "Remove from list first");</span>
<span class="changed"> 287   c-&gt;set_free();</span>
<span class="changed"> 288   c-&gt;reset_used_words();</span>
 289 
<a name="58" id="anc58"></a><span class="changed"> 290   const chunklevel_t orig_lvl = c-&gt;level();</span>
 291 
<a name="59" id="anc59"></a><span class="changed"> 292   Metachunk* merged = NULL;</span>
<span class="changed"> 293   if (!c-&gt;is_root_chunk()) {</span>
<span class="changed"> 294     // Only attempt merging if we are not of the lowest level already.</span>
<span class="changed"> 295     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);</span>
 296   }
 297 
<a name="60" id="anc60"></a><span class="changed"> 298   if (merged != NULL) {</span>


 299 
<a name="61" id="anc61"></a><span class="changed"> 300     InternalStats::inc_num_chunk_merges();</span>

 301 
<a name="62" id="anc62"></a><span class="changed"> 302     DEBUG_ONLY(merged-&gt;verify(false));</span>

 303 
<a name="63" id="anc63"></a><span class="changed"> 304     // We did merge our chunk into a different chunk.</span>
<span class="changed"> 305 </span>
<span class="changed"> 306     // We did merge chunks and now have a bigger chunk.</span>
<span class="changed"> 307     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");</span>
<span class="changed"> 308 </span>
<span class="changed"> 309     UL2(debug, "merged into chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(merged));</span>
<span class="changed"> 310 </span>
<span class="changed"> 311     c = merged;</span>
 312 
<a name="64" id="anc64"></a>

 313   }
 314 
<a name="65" id="anc65"></a><span class="changed"> 315   if (Settings::uncommit_free_chunks() &amp;&amp;</span>
<span class="changed"> 316       c-&gt;word_size() &gt;= Settings::commit_granule_words())</span>
<span class="changed"> 317   {</span>
<span class="changed"> 318     UL2(debug, "uncommitting free chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));</span>
<span class="changed"> 319     c-&gt;uncommit_locked();</span>
 320   }
 321 
<a name="66" id="anc66"></a><span class="changed"> 322   return_chunk_simple_locked(c);</span>




 323 
<a name="67" id="anc67"></a><span class="changed"> 324   DEBUG_ONLY(verify_locked(false);)</span>
<span class="changed"> 325   SOMETIMES(c-&gt;vsnode()-&gt;verify_locked(true);)</span>

 326 
<a name="68" id="anc68"></a><span class="changed"> 327   InternalStats::inc_num_chunks_returned_to_freelist();</span>
<span class="changed"> 328 </span>
<span class="changed"> 329 }</span>
 330 
<a name="69" id="anc69"></a><span class="changed"> 331 // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to</span>
<span class="changed"> 332 // enlarge it in place by claiming its trailing buddy.</span>
<span class="changed"> 333 //</span>
<span class="changed"> 334 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="changed"> 335 //</span>
<span class="changed"> 336 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="changed"> 337 // double in size (level decreased by one).</span>
<span class="changed"> 338 //</span>
<span class="changed"> 339 // On success, true is returned, false otherwise.</span>
<span class="changed"> 340 bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {</span>
<span class="changed"> 341   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 342   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);</span>
<span class="changed"> 343 }</span>
<span class="changed"> 344 </span>
<span class="changed"> 345 static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {</span>
<span class="changed"> 346   if (word_size_1 == word_size_2) {</span>
<span class="changed"> 347     print_scaled_words(st, word_size_1);</span>
<span class="changed"> 348     st-&gt;print (" (no change)");</span>
<span class="changed"> 349   } else {</span>
<span class="changed"> 350     print_scaled_words(st, word_size_1);</span>
<span class="changed"> 351     st-&gt;print("-&gt;");</span>
<span class="changed"> 352     print_scaled_words(st, word_size_2);</span>
<span class="changed"> 353     st-&gt;print(" (");</span>
<span class="changed"> 354     if (word_size_2 &lt;= word_size_1) {</span>
<span class="changed"> 355       st-&gt;print("-");</span>
<span class="changed"> 356       print_scaled_words(st, word_size_1 - word_size_2);</span>
<span class="changed"> 357     } else {</span>
<span class="changed"> 358       st-&gt;print("+");</span>
<span class="changed"> 359       print_scaled_words(st, word_size_2 - word_size_1);</span>
 360     }
<a name="70" id="anc70"></a><span class="changed"> 361     st-&gt;print(")");</span>
<span class="changed"> 362   }</span>
<span class="changed"> 363 }</span>
 364 
<a name="71" id="anc71"></a><span class="changed"> 365 void ChunkManager::purge() {</span>
 366 
<a name="72" id="anc72"></a><span class="changed"> 367   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
 368 
<a name="73" id="anc73"></a><span class="changed"> 369   UL(info, ": reclaiming memory...");</span>

 370 
<a name="74" id="anc74"></a><span class="changed"> 371   const size_t reserved_before = _vslist-&gt;reserved_words();</span>
<span class="changed"> 372   const size_t committed_before = _vslist-&gt;committed_words();</span>
<span class="changed"> 373   int num_nodes_purged = 0;</span>
<span class="changed"> 374 </span>
<span class="changed"> 375   // 1) purge virtual space list</span>
<span class="changed"> 376   num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);</span>
<span class="changed"> 377   InternalStats::inc_num_purges();</span>
 378 
<a name="75" id="anc75"></a><span class="changed"> 379   // 2) uncommit free chunks</span>
<span class="changed"> 380   if (Settings::uncommit_free_chunks()) {</span>
<span class="changed"> 381     const chunklevel_t max_level =</span>
<span class="changed"> 382         chunklevel::level_fitting_word_size(Settings::commit_granule_words());</span>
<span class="changed"> 383     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;</span>
<span class="changed"> 384          l &lt;= max_level;</span>
<span class="changed"> 385          l ++)</span>
<span class="changed"> 386     {</span>
<span class="changed"> 387       // Since we uncommit all chunks at this level, we do not break the "committed chunks are</span>
<span class="changed"> 388       //  at the front of the list" condition.</span>
<span class="changed"> 389       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 390         c-&gt;uncommit_locked();</span>
<span class="changed"> 391       }</span>
<span class="changed"> 392     }</span>
 393   }
 394 
<a name="76" id="anc76"></a><span class="changed"> 395   const size_t reserved_after = _vslist-&gt;reserved_words();</span>
<span class="changed"> 396   const size_t committed_after = _vslist-&gt;committed_words();</span>
<span class="changed"> 397 </span>
<span class="changed"> 398   // Print a nice report.</span>
<span class="changed"> 399   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {</span>
<span class="changed"> 400     UL(info, "nothing reclaimed.");</span>



 401   } else {
<a name="77" id="anc77"></a><span class="changed"> 402     LogTarget(Info, metaspace) lt;</span>
<span class="changed"> 403     if (lt.is_enabled()) {</span>
 404       LogStream ls(lt);
<a name="78" id="anc78"></a><span class="changed"> 405       ls.print_cr(LOGFMT ": finished reclaiming memory: ", LOGFMT_ARGS);</span>
<span class="changed"> 406 </span>
<span class="changed"> 407       ls.print("reserved: ");</span>
<span class="changed"> 408       print_word_size_delta(&amp;ls, reserved_before, reserved_after);</span>
<span class="changed"> 409       ls.cr();</span>
<span class="changed"> 410 </span>
<span class="changed"> 411       ls.print("committed: ");</span>
<span class="changed"> 412       print_word_size_delta(&amp;ls, committed_before, committed_after);</span>
<span class="changed"> 413       ls.cr();</span>
<span class="changed"> 414 </span>
<span class="changed"> 415       ls.print_cr("full nodes purged: %d", num_nodes_purged);</span>
 416     }
<a name="79" id="anc79"></a><span class="new"> 417   }</span>
<span class="new"> 418 </span>
<span class="new"> 419   DEBUG_ONLY(_vslist-&gt;verify_locked(true));</span>
<span class="new"> 420   DEBUG_ONLY(verify_locked(true));</span>
 421 
<a name="80" id="anc80"></a>
 422 }
 423 
<a name="81" id="anc81"></a><span class="changed"> 424 // Convenience methods to return the global class-space chunkmanager</span>
<span class="changed"> 425 //  and non-class chunkmanager, respectively.</span>
<span class="changed"> 426 ChunkManager* ChunkManager::chunkmanager_class() {</span>
<span class="changed"> 427   return MetaspaceContext::context_class() == NULL ? NULL : MetaspaceContext::context_class()-&gt;cm();</span>
<span class="changed"> 428 }</span>
 429 
<a name="82" id="anc82"></a><span class="changed"> 430 ChunkManager* ChunkManager::chunkmanager_nonclass() {</span>
<span class="changed"> 431   return MetaspaceContext::context_nonclass() == NULL ? NULL : MetaspaceContext::context_nonclass()-&gt;cm();</span>
<span class="changed"> 432 }</span>



 433 
<a name="83" id="anc83"></a><span class="changed"> 434 // Update statistics.</span>
<span class="changed"> 435 void ChunkManager::add_to_statistics(cm_stats_t* out) const {</span>
































 436 
<a name="84" id="anc84"></a><span class="changed"> 437   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>

 438 
<a name="85" id="anc85"></a><span class="changed"> 439   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {</span>
<span class="changed"> 440     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);</span>
<span class="changed"> 441     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);</span>








 442   }
 443 
<a name="86" id="anc86"></a><span class="changed"> 444   DEBUG_ONLY(out-&gt;verify();)</span>
<span class="changed"> 445 </span>
<span class="changed"> 446 }</span>
 447 
 448 #ifdef ASSERT
<a name="87" id="anc87"></a>





 449 
<a name="88" id="anc88"></a><span class="new"> 450 void ChunkManager::verify(bool slow) const {</span>
<span class="new"> 451   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new"> 452   verify_locked(slow);</span>
 453 }
 454 
<a name="89" id="anc89"></a><span class="changed"> 455 void ChunkManager::verify_locked(bool slow) const {</span>
<span class="changed"> 456   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="changed"> 457   assert(_vslist != NULL, "No vslist");</span>
<span class="changed"> 458   _chunks.verify();</span>






















 459 }
 460 
<a name="90" id="anc90"></a><span class="changed"> 461 bool ChunkManager::contains_chunk(Metachunk* c) const {</span>
<span class="changed"> 462   return _chunks.contains(c);</span>



 463 }
 464 
<a name="91" id="anc91"></a><span class="changed"> 465 #endif // ASSERT</span>
 466 
<a name="92" id="anc92"></a><span class="new"> 467 void ChunkManager::print_on(outputStream* st) const {</span>
<span class="new"> 468   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new"> 469   print_on_locked(st);</span>
<span class="new"> 470 }</span>
 471 
<a name="93" id="anc93"></a><span class="new"> 472 void ChunkManager::print_on_locked(outputStream* st) const {</span>
<span class="new"> 473   assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new"> 474   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="new"> 475                total_num_chunks(), total_word_size(), _chunks.committed_word_size());</span>
<span class="new"> 476   _chunks.print_on(st);</span>
<span class="new"> 477 }</span>
 478 
<a name="94" id="anc94"></a><span class="new"> 479 } // namespace metaspace</span>
<a name="95" id="anc95"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="95" type="hidden" /></form></body></html>
