<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Udiff src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspaceChunkFreeListSummary.hpp.udiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60529">60529</a> : imported patch jep387-all.patch</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -1,7 +1,8 @@</span>
 /*
<span class="removed">- * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="new">+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="new">+ * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
</pre><hr /><pre>
<span class="newmarker">@@ -23,141 +24,270 @@</span>
  */
 
 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
 
<span class="removed">-#include "memory/virtualspace.hpp"</span>
<span class="new">+</span>
<span class="new">+#include "memory/allocation.hpp"</span>
<span class="new">+#include "memory/metaspace/counter.hpp"</span>
<span class="new">+#include "memory/metaspace/commitMask.hpp"</span>
<span class="new">+#include "memory/metaspace/rootChunkArea.hpp"</span>
<span class="new">+#include "memory/metaspace/settings.hpp"</span>
 #include "memory/memRegion.hpp"
<span class="new">+#include "memory/virtualspace.hpp"</span>
 #include "utilities/debug.hpp"
<span class="new">+#include "utilities/bitMap.hpp"</span>
 #include "utilities/globalDefinitions.hpp"
 
<span class="new">+</span>
 class outputStream;
 
 namespace metaspace {
 
<span class="removed">-class Metachunk;</span>
<span class="removed">-class ChunkManager;</span>
<span class="removed">-class OccupancyMap;</span>
<span class="new">+class CommitLimiter;</span>
<span class="new">+class FreeChunkListVector;</span>
<span class="new">+</span>
<span class="new">+// VirtualSpaceNode manages a single contiguous address range of metaspace. Logically that memory</span>
<span class="new">+//  region is split up into a sequence of "root chunk areas", each one containing one root chunk</span>
<span class="new">+//  or splinters of a root chunk.</span>
<span class="new">+//</span>
<span class="new">+// The underlying memory is also logically divided into a number of "commit granules", units of memory</span>
<span class="new">+//  which may be committed or uncommitted independently from each other.</span>
<span class="new">+//</span>
<span class="new">+// (Both root chunk areas and commit granules have not much to do with each other - one is a way to</span>
<span class="new">+//   reserve memory for the upper regions, see ChunkManager. One is a way to manage commited memory.)</span>
<span class="new">+//</span>
<span class="new">+// VirtualSpaceNode:</span>
<span class="new">+//  - exposes a function to allocate a new root chunk (see VirtualSpaceNode::allocate_root_chunk()).</span>
<span class="new">+//</span>
<span class="new">+//  - knows about the commit state of the memory region - which commit granule are committed, which</span>
<span class="new">+//    are not. It exposes functions to commit and uncommit regions (without actively committing</span>
<span class="new">+//    itself)</span>
<span class="new">+//</span>
<span class="new">+//  - It has a reference to a "CommitLimiter", an interface to query whether committing is</span>
<span class="new">+//    possible. That interface hides the various ways committing may be limited (GC threshold,</span>
<span class="new">+//    MaxMetaspaceSize, ...)</span>
<span class="new">+//</span>
<span class="new">+//  - It uses ReservedSpace to reserve its memory. It either owns the ReservedSpace or that</span>
<span class="new">+//    space got handed in from outside (ccs).</span>
<span class="new">+//</span>
<span class="new">+//</span>
<span class="new">+//</span>
<span class="new">+//</span>
<span class="new">+// | root chunk area               | root chunk area               | root chunk area               | &lt;-- root chunk areas</span>
<span class="new">+//</span>
<span class="new">+// +-----------------------------------------------------------------------------------------------+</span>
<span class="new">+// |                                                                                               |</span>
<span class="new">+// |                                   `VirtualSpaceNode` memory                                   |</span>
<span class="new">+// |                                                                                               |</span>
<span class="new">+// +-----------------------------------------------------------------------------------------------+</span>
<span class="new">+//</span>
<span class="new">+// |x| |x|x|x| | | | |x|x|x| | | |x|x| | | |x|x|x|x| | | | | | | | |x| | | |x|x|x|x| | | |x| | | |x| &lt;-- commit granules</span>
<span class="new">+//</span>
<span class="new">+// (x = committed)</span>
<span class="new">+//</span>
 
<span class="removed">-// A VirtualSpaceList node.</span>
 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
<span class="removed">-  friend class VirtualSpaceList;</span>
 
   // Link to next VirtualSpaceNode
   VirtualSpaceNode* _next;
 
<span class="removed">-  // Whether this node is contained in class or metaspace.</span>
<span class="removed">-  const bool _is_class;</span>
<span class="removed">-</span>
<span class="removed">-  // total in the VirtualSpace</span>
<span class="new">+  // The underlying space. This has been either created by this node</span>
<span class="new">+  //  and is owned by it, or has been handed in from outside (e.g. in</span>
<span class="new">+  //  case of CompressedClassSpace).</span>
   ReservedSpace _rs;
<span class="removed">-  VirtualSpace _virtual_space;</span>
<span class="removed">-  MetaWord* _top;</span>
<span class="removed">-  // count of chunks contained in this VirtualSpace</span>
<span class="removed">-  uintx _container_count;</span>
<span class="removed">-</span>
<span class="removed">-  OccupancyMap* _occupancy_map;</span>
<span class="removed">-</span>
<span class="removed">-  // Convenience functions to access the _virtual_space</span>
<span class="removed">-  char* low()  const { return virtual_space()-&gt;low(); }</span>
<span class="removed">-  char* high() const { return virtual_space()-&gt;high(); }</span>
<span class="removed">-  char* low_boundary()  const { return virtual_space()-&gt;low_boundary(); }</span>
<span class="removed">-  char* high_boundary() const { return virtual_space()-&gt;high_boundary(); }</span>
<span class="removed">-</span>
<span class="removed">-  // The first Metachunk will be allocated at the bottom of the</span>
<span class="removed">-  // VirtualSpace</span>
<span class="removed">-  Metachunk* first_chunk() { return (Metachunk*) bottom(); }</span>
<span class="removed">-</span>
<span class="removed">-  // Committed but unused space in the virtual space</span>
<span class="removed">-  size_t free_words_in_vs() const;</span>
<span class="removed">-</span>
<span class="removed">-  // True if this node belongs to class metaspace.</span>
<span class="removed">-  bool is_class() const { return _is_class; }</span>
<span class="removed">-</span>
<span class="removed">-  // Helper function for take_from_committed: allocate padding chunks</span>
<span class="removed">-  // until top is at the given address.</span>
<span class="removed">-  void allocate_padding_chunks_until_top_is_at(MetaWord* target_top);</span>
<span class="removed">-</span>
<span class="removed">- public:</span>
<span class="removed">-</span>
<span class="removed">-  VirtualSpaceNode(bool is_class, size_t byte_size);</span>
<span class="removed">-  VirtualSpaceNode(bool is_class, ReservedSpace rs) :</span>
<span class="removed">-    _next(NULL), _is_class(is_class), _rs(rs), _top(NULL), _container_count(0), _occupancy_map(NULL) {}</span>
<span class="removed">-  ~VirtualSpaceNode();</span>
<span class="removed">-</span>
<span class="removed">-  // Convenience functions for logical bottom and (committed) end</span>
<span class="removed">-  MetaWord* bottom() const { return (MetaWord*) _virtual_space.low(); }</span>
<span class="removed">-  MetaWord* end() const { return (MetaWord*) _virtual_space.high(); }</span>
<span class="removed">-</span>
<span class="removed">-  const OccupancyMap* occupancy_map() const { return _occupancy_map; }</span>
<span class="removed">-  OccupancyMap* occupancy_map() { return _occupancy_map; }</span>
<span class="removed">-</span>
<span class="removed">-  bool contains(const void* ptr) { return ptr &gt;= low() &amp;&amp; ptr &lt; high(); }</span>
 
<span class="removed">-  size_t reserved_words() const  { return _virtual_space.reserved_size() / BytesPerWord; }</span>
<span class="removed">-  size_t committed_words() const { return _virtual_space.actual_committed_size() / BytesPerWord; }</span>
<span class="new">+  // True if the node owns the reserved space, false if not.</span>
<span class="new">+  const bool _owns_rs;</span>
 
<span class="removed">-  bool is_pre_committed() const { return _virtual_space.special(); }</span>
<span class="new">+  // Start pointer of the area.</span>
<span class="new">+  MetaWord* const _base;</span>
 
<span class="removed">-  // address of next available space in _virtual_space;</span>
<span class="removed">-  // Accessors</span>
<span class="removed">-  VirtualSpaceNode* next() { return _next; }</span>
<span class="removed">-  void set_next(VirtualSpaceNode* v) { _next = v; }</span>
<span class="new">+  // Size, in words, of the whole node</span>
<span class="new">+  const size_t _word_size;</span>
 
<span class="removed">-  void set_top(MetaWord* v) { _top = v; }</span>
<span class="new">+  // Size, in words, of the range of this node which has been handed out in</span>
<span class="new">+  // the form of root chunks.</span>
<span class="new">+  size_t _used_words;</span>
<span class="new">+</span>
<span class="new">+  // The bitmap describing the commit state of the region:</span>
<span class="new">+  // Each bit covers a region of 64K (see constants::commit_granule_size).</span>
<span class="new">+  CommitMask _commit_mask;</span>
<span class="new">+</span>
<span class="new">+  // An array/lookup table of RootChunkArea objects. Each one describes a root chunk area.</span>
<span class="new">+  RootChunkAreaLUT _root_chunk_area_lut;</span>
<span class="new">+</span>
<span class="new">+  // Limiter object to ask before expanding the committed size of this node.</span>
<span class="new">+  CommitLimiter* const _commit_limiter;</span>
<span class="new">+</span>
<span class="new">+  // Points to outside size counters which we are to increase/decrease when we commit/uncommit</span>
<span class="new">+  // space from this node.</span>
<span class="new">+  SizeCounter* const _total_reserved_words_counter;</span>
<span class="new">+  SizeCounter* const _total_committed_words_counter;</span>
<span class="new">+</span>
<span class="new">+  /// committing, uncommitting ///</span>
<span class="new">+</span>
<span class="new">+  // Given a pointer into this node, calculate the start of the commit granule</span>
<span class="new">+  // the pointer points into.</span>
<span class="new">+  MetaWord* calc_start_of_granule(MetaWord* p) const {</span>
<span class="new">+    DEBUG_ONLY(check_pointer(p));</span>
<span class="new">+    return align_down(p, Settings::commit_granule_bytes());</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+  // Given an address range, ensure it is committed.</span>
<span class="new">+  //</span>
<span class="new">+  // The range has to be aligned to granule size.</span>
<span class="new">+  //</span>
<span class="new">+  // Function will:</span>
<span class="new">+  // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="new">+  //    returns true immediately.</span>
<span class="new">+  // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="new">+  //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="new">+  // - commit the memory.</span>
<span class="new">+  // - mark the range as committed in the commit mask</span>
<span class="new">+  //</span>
<span class="new">+  // Returns true if success, false if it did hit a commit limit.</span>
<span class="new">+  bool commit_range(MetaWord* p, size_t word_size);</span>
<span class="new">+</span>
<span class="new">+  //// creation ////</span>
<span class="new">+</span>
<span class="new">+  // Create a new empty node spanning the given given reserved space.</span>
<span class="new">+  VirtualSpaceNode(ReservedSpace rs, bool owns_rs, CommitLimiter* limiter,</span>
<span class="new">+                   SizeCounter* reserve_counter, SizeCounter* commit_counter);</span>
<span class="new">+</span>
<span class="new">+public:</span>
<span class="new">+</span>
<span class="new">+  // Create a node of a given size (it will create its own space).</span>
<span class="new">+  static VirtualSpaceNode* create_node(size_t word_size, CommitLimiter* limiter, SizeCounter* reserve_words_counter,</span>
<span class="new">+                                       SizeCounter* commit_words_counter);</span>
<span class="new">+</span>
<span class="new">+  // Create a node over an existing space</span>
<span class="new">+  static VirtualSpaceNode* create_node(ReservedSpace rs, CommitLimiter* limiter, SizeCounter* reserve_words_counter,</span>
<span class="new">+                                       SizeCounter* commit_words_counter);</span>
 
<span class="removed">-  // Accessors</span>
<span class="removed">-  VirtualSpace* virtual_space() const { return (VirtualSpace*) &amp;_virtual_space; }</span>
<span class="removed">-</span>
<span class="removed">-  // Returns true if "word_size" is available in the VirtualSpace</span>
<span class="removed">-  bool is_available(size_t word_size) { return word_size &lt;= pointer_delta(end(), _top, sizeof(MetaWord)); }</span>
<span class="removed">-</span>
<span class="removed">-  MetaWord* top() const { return _top; }</span>
<span class="removed">-  void inc_top(size_t word_size) { _top += word_size; }</span>
<span class="removed">-</span>
<span class="removed">-  uintx container_count() { return _container_count; }</span>
<span class="removed">-  void inc_container_count();</span>
<span class="removed">-  void dec_container_count();</span>
<span class="removed">-</span>
<span class="removed">-  // used and capacity in this single entry in the list</span>
<span class="removed">-  size_t used_words_in_vs() const;</span>
<span class="removed">-  size_t capacity_words_in_vs() const;</span>
<span class="removed">-</span>
<span class="removed">-  bool initialize();</span>
<span class="removed">-</span>
<span class="removed">-  // get space from the virtual space</span>
<span class="removed">-  Metachunk* take_from_committed(size_t chunk_word_size);</span>
<span class="removed">-</span>
<span class="removed">-  // Allocate a chunk from the virtual space and return it.</span>
<span class="removed">-  Metachunk* get_chunk_vs(size_t chunk_word_size);</span>
<span class="removed">-</span>
<span class="removed">-  // Expands the committed space by at least min_words words.</span>
<span class="removed">-  bool expand_by(size_t min_words, size_t preferred_words);</span>
<span class="new">+  ~VirtualSpaceNode();</span>
 
<span class="removed">-  // In preparation for deleting this node, remove all the chunks</span>
<span class="removed">-  // in the node from any freelist.</span>
<span class="removed">-  void purge(ChunkManager* chunk_manager);</span>
<span class="new">+  // Note: public for gtests only, could be private.</span>
<span class="new">+  MetaWord* base() const        { return _base; }</span>
 
<span class="removed">-  // If an allocation doesn't fit in the current node a new node is created.</span>
<span class="removed">-  // Allocate chunks out of the remaining committed space in this node</span>
<span class="removed">-  // to avoid wasting that memory.</span>
<span class="removed">-  // This always adds up because all the chunk sizes are multiples of</span>
<span class="removed">-  // the smallest chunk size.</span>
<span class="removed">-  void retire(ChunkManager* chunk_manager);</span>
<span class="new">+  // Reserved size of the whole node.</span>
<span class="new">+  size_t word_size() const      { return _word_size; }</span>
 
<span class="removed">-  void print_on(outputStream* st) const                 { print_on(st, K); }</span>
<span class="removed">-  void print_on(outputStream* st, size_t scale) const;</span>
<span class="removed">-  void print_map(outputStream* st, bool is_class) const;</span>
<span class="new">+  //// Chunk allocation, splitting, merging /////</span>
 
<span class="removed">-  // Debug support</span>
<span class="removed">-  DEBUG_ONLY(void mangle();)</span>
<span class="removed">-  // Verify counters and basic structure. Slow mode: verify all chunks in depth and occupancy map.</span>
<span class="removed">-  DEBUG_ONLY(void verify(bool slow);)</span>
<span class="removed">-  // Verify that all free chunks in this node are ideally merged</span>
<span class="removed">-  // (there should not be multiple small chunks where a large chunk could exist.)</span>
<span class="removed">-  DEBUG_ONLY(void verify_free_chunks_are_ideally_merged();)</span>
<span class="new">+  // Allocate a root chunk from this node. Will fail and return NULL if the node is full</span>
<span class="new">+  //  - if we used up the whole address space of this node's memory region.</span>
<span class="new">+  //    (in case this node backs compressed class space, this is how we hit</span>
<span class="new">+  //     CompressedClassSpaceSize).</span>
<span class="new">+  // Note that this just returns reserved memory; caller must take care of committing this</span>
<span class="new">+  //  chunk before using it.</span>
<span class="new">+  Metachunk* allocate_root_chunk();</span>
<span class="new">+</span>
<span class="new">+  // Given a chunk c, split it recursively until you get a chunk of the given target_level.</span>
<span class="new">+  //</span>
<span class="new">+  // The resulting target chunk resides at the same address as the original chunk.</span>
<span class="new">+  // The resulting splinters are added to freelists.</span>
<span class="new">+  void split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="new">+</span>
<span class="new">+  // Given a chunk, attempt to merge it recursively with its neighboring chunks.</span>
<span class="new">+  //</span>
<span class="new">+  // If successful (merged at least once), returns address of</span>
<span class="new">+  // the merged chunk; NULL otherwise.</span>
<span class="new">+  //</span>
<span class="new">+  // The merged chunks are removed from the freelists.</span>
<span class="new">+  //</span>
<span class="new">+  // !!! Please note that if this method returns a non-NULL value, the</span>
<span class="new">+  // original chunk will be invalid and should not be accessed anymore! !!!</span>
<span class="new">+  Metachunk* merge(Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="new">+</span>
<span class="new">+  // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to</span>
<span class="new">+  // enlarge it in place by claiming its trailing buddy.</span>
<span class="new">+  //</span>
<span class="new">+  // This will only work if c is the leader of the buddy pair and the trailing buddy is free.</span>
<span class="new">+  //</span>
<span class="new">+  // If successful, the follower chunk will be removed from the freelists, the leader chunk c will</span>
<span class="new">+  // double in size (level decreased by one).</span>
<span class="new">+  //</span>
<span class="new">+  // On success, true is returned, false otherwise.</span>
<span class="new">+  bool attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists);</span>
<span class="new">+</span>
<span class="new">+  // Attempts to purge the node:</span>
<span class="new">+  //</span>
<span class="new">+  // If all chunks living in this node are free, they will all be removed from</span>
<span class="new">+  //  the freelist they currently reside in. Then, the node will be deleted.</span>
<span class="new">+  //</span>
<span class="new">+  // Returns true if the node has been deleted, false if not.</span>
<span class="new">+  // !! If this returns true, do not access the node from this point on. !!</span>
<span class="new">+  bool attempt_purge(FreeChunkListVector* freelists);</span>
<span class="new">+</span>
<span class="new">+  // Attempts to uncommit free areas according to the rules set in settings.</span>
<span class="new">+  // Returns number of words uncommitted.</span>
<span class="new">+  size_t uncommit_free_areas();</span>
<span class="new">+</span>
<span class="new">+  /// misc /////</span>
<span class="new">+</span>
<span class="new">+  // Returns size, in words, of the used space in this node alone.</span>
<span class="new">+  // (Notes:</span>
<span class="new">+  //  - This is the space handed out to the ChunkManager, so it is "used" from the viewpoint of this node,</span>
<span class="new">+  //    but not necessarily used for Metadata.</span>
<span class="new">+  //  - This may or may not be committed memory.</span>
<span class="new">+  size_t used_words() const             { return _used_words; }</span>
<span class="new">+</span>
<span class="new">+  // Returns size, in words, of how much space is left in this node alone.</span>
<span class="new">+  size_t free_words() const             { return _word_size - _used_words; }</span>
<span class="new">+</span>
<span class="new">+  // Returns size, in words, of committed space in this node alone.</span>
<span class="new">+  // Note: iterates over commit mask and hence may be a tad expensive on large nodes.</span>
<span class="new">+  size_t committed_words() const;</span>
<span class="new">+</span>
<span class="new">+  //// Committing/uncommitting memory /////</span>
<span class="new">+</span>
<span class="new">+  // Given an address range, ensure it is committed.</span>
<span class="new">+  //</span>
<span class="new">+  // The range does not have to be aligned to granule size. However, the function will always commit</span>
<span class="new">+  // whole granules.</span>
<span class="new">+  //</span>
<span class="new">+  // Function will:</span>
<span class="new">+  // - check how many granules in that region are uncommitted; If all are committed, it</span>
<span class="new">+  //    returns true immediately.</span>
<span class="new">+  // - check if committing those uncommitted granules would bring us over the commit limit</span>
<span class="new">+  //    (GC threshold, MaxMetaspaceSize). If true, it returns false.</span>
<span class="new">+  // - commit the memory.</span>
<span class="new">+  // - mark the range as committed in the commit mask</span>
<span class="new">+  //</span>
<span class="new">+  // Returns true if success, false if it did hit a commit limit.</span>
<span class="new">+  bool ensure_range_is_committed(MetaWord* p, size_t word_size);</span>
<span class="new">+</span>
<span class="new">+  // Given an address range (which has to be aligned to commit granule size):</span>
<span class="new">+  //  - uncommit it</span>
<span class="new">+  //  - mark it as uncommitted in the commit mask</span>
<span class="new">+  void uncommit_range(MetaWord* p, size_t word_size);</span>
<span class="new">+</span>
<span class="new">+  //// List stuff ////</span>
<span class="new">+  VirtualSpaceNode* next() const        { return _next; }</span>
<span class="new">+  void set_next(VirtualSpaceNode* vsn)  { _next = vsn; }</span>
<span class="new">+</span>
<span class="new">+</span>
<span class="new">+  /// Debug stuff ////</span>
<span class="new">+</span>
<span class="new">+  // Print a description about this node.</span>
<span class="new">+  void print_on(outputStream* st) const;</span>
<span class="new">+</span>
<span class="new">+  // Verify counters and basic structure. Slow mode: verify all chunks in depth</span>
<span class="new">+  bool contains(const MetaWord* p) const {</span>
<span class="new">+    return p &gt;= _base &amp;&amp; p &lt; _base + _used_words;</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+#ifdef ASSERT</span>
<span class="new">+  void check_pointer(const MetaWord* p) const {</span>
<span class="new">+    assert(contains(p), "invalid pointer");</span>
<span class="new">+  }</span>
<span class="new">+  void verify(bool slow) const;</span>
<span class="new">+  void verify_locked(bool slow) const;</span>
<span class="new">+#endif</span>
 
 };
 
<span class="new">+</span>
 } // namespace metaspace
 
 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/virtualSpaceNode.cpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspaceChunkFreeListSummary.hpp.udiff.html' target='_top'>next &gt</a></center>
</body></html>

