<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60538">60538</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>

   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  26 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  27 
<a name="2" id="anc2"></a><span class="changed">  28 #include "memory/virtualspace.hpp"</span>





  29 #include "memory/memRegion.hpp"
<a name="3" id="anc3"></a>
  30 #include "utilities/debug.hpp"
<a name="4" id="anc4"></a>
  31 #include "utilities/globalDefinitions.hpp"
  32 
<a name="5" id="anc5"></a>
  33 class outputStream;
  34 
  35 namespace metaspace {
  36 
<a name="6" id="anc6"></a><span class="changed">  37 class Metachunk;</span>
<span class="changed">  38 class ChunkManager;</span>
<span class="changed">  39 class OccupancyMap;</span>







































  40 
<a name="7" id="anc7"></a><span class="removed">  41 // A VirtualSpaceList node.</span>
  42 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
<a name="8" id="anc8"></a><span class="removed">  43   friend class VirtualSpaceList;</span>
  44 
  45   // Link to next VirtualSpaceNode
  46   VirtualSpaceNode* _next;
  47 
<a name="9" id="anc9"></a><span class="changed">  48   // Whether this node is contained in class or metaspace.</span>
<span class="changed">  49   const bool _is_class;</span>
<span class="changed">  50 </span>
<span class="changed">  51   // total in the VirtualSpace</span>
  52   ReservedSpace _rs;
<a name="10" id="anc10"></a><span class="removed">  53   VirtualSpace _virtual_space;</span>
<span class="removed">  54   MetaWord* _top;</span>
<span class="removed">  55   // count of chunks contained in this VirtualSpace</span>
<span class="removed">  56   uintx _container_count;</span>
<span class="removed">  57 </span>
<span class="removed">  58   OccupancyMap* _occupancy_map;</span>
<span class="removed">  59 </span>
<span class="removed">  60   // Convenience functions to access the _virtual_space</span>
<span class="removed">  61   char* low()  const { return virtual_space()-&gt;low(); }</span>
<span class="removed">  62   char* high() const { return virtual_space()-&gt;high(); }</span>
<span class="removed">  63   char* low_boundary()  const { return virtual_space()-&gt;low_boundary(); }</span>
<span class="removed">  64   char* high_boundary() const { return virtual_space()-&gt;high_boundary(); }</span>
<span class="removed">  65 </span>
<span class="removed">  66   // The first Metachunk will be allocated at the bottom of the</span>
<span class="removed">  67   // VirtualSpace</span>
<span class="removed">  68   Metachunk* first_chunk() { return (Metachunk*) bottom(); }</span>
<span class="removed">  69 </span>
<span class="removed">  70   // Committed but unused space in the virtual space</span>
<span class="removed">  71   size_t free_words_in_vs() const;</span>
<span class="removed">  72 </span>
<span class="removed">  73   // True if this node belongs to class metaspace.</span>
<span class="removed">  74   bool is_class() const { return _is_class; }</span>
<span class="removed">  75 </span>
<span class="removed">  76   // Helper function for take_from_committed: allocate padding chunks</span>
<span class="removed">  77   // until top is at the given address.</span>
<span class="removed">  78   void allocate_padding_chunks_until_top_is_at(MetaWord* target_top);</span>
<span class="removed">  79 </span>
<span class="removed">  80  public:</span>
<span class="removed">  81 </span>
<span class="removed">  82   VirtualSpaceNode(bool is_class, size_t byte_size);</span>
<span class="removed">  83   VirtualSpaceNode(bool is_class, ReservedSpace rs) :</span>
<span class="removed">  84     _next(NULL), _is_class(is_class), _rs(rs), _top(NULL), _container_count(0), _occupancy_map(NULL) {}</span>
<span class="removed">  85   ~VirtualSpaceNode();</span>
<span class="removed">  86 </span>
<span class="removed">  87   // Convenience functions for logical bottom and (committed) end</span>
<span class="removed">  88   MetaWord* bottom() const { return (MetaWord*) _virtual_space.low(); }</span>
<span class="removed">  89   MetaWord* end() const { return (MetaWord*) _virtual_space.high(); }</span>
<span class="removed">  90 </span>
<span class="removed">  91   const OccupancyMap* occupancy_map() const { return _occupancy_map; }</span>
<span class="removed">  92   OccupancyMap* occupancy_map() { return _occupancy_map; }</span>
<span class="removed">  93 </span>
<span class="removed">  94   bool contains(const void* ptr) { return ptr &gt;= low() &amp;&amp; ptr &lt; high(); }</span>
  95 
<a name="11" id="anc11"></a><span class="changed">  96   size_t reserved_words() const  { return _virtual_space.reserved_size() / BytesPerWord; }</span>
<span class="changed">  97   size_t committed_words() const { return _virtual_space.actual_committed_size() / BytesPerWord; }</span>
  98 
<a name="12" id="anc12"></a><span class="changed">  99   bool is_pre_committed() const { return _virtual_space.special(); }</span>

 100 
<a name="13" id="anc13"></a><span class="changed"> 101   // address of next available space in _virtual_space;</span>
<span class="changed"> 102   // Accessors</span>
<span class="changed"> 103   VirtualSpaceNode* next() { return _next; }</span>
<span class="changed"> 104   void set_next(VirtualSpaceNode* v) { _next = v; }</span>
 105 
<a name="14" id="anc14"></a><span class="changed"> 106   void set_top(MetaWord* v) { _top = v; }</span>

























































 107 
<a name="15" id="anc15"></a><span class="changed"> 108   // Accessors</span>
<span class="changed"> 109   VirtualSpace* virtual_space() const { return (VirtualSpace*) &amp;_virtual_space; }</span>
<span class="changed"> 110 </span>
<span class="changed"> 111   // Returns true if "word_size" is available in the VirtualSpace</span>
<span class="changed"> 112   bool is_available(size_t word_size) { return word_size &lt;= pointer_delta(end(), _top, sizeof(MetaWord)); }</span>
<span class="changed"> 113 </span>
<span class="changed"> 114   MetaWord* top() const { return _top; }</span>
<span class="changed"> 115   void inc_top(size_t word_size) { _top += word_size; }</span>
<span class="changed"> 116 </span>
<span class="changed"> 117   uintx container_count() { return _container_count; }</span>
<span class="changed"> 118   void inc_container_count();</span>
<span class="changed"> 119   void dec_container_count();</span>
<span class="changed"> 120 </span>
<span class="changed"> 121   // used and capacity in this single entry in the list</span>
<span class="changed"> 122   size_t used_words_in_vs() const;</span>
<span class="changed"> 123   size_t capacity_words_in_vs() const;</span>
<span class="changed"> 124 </span>
<span class="changed"> 125   bool initialize();</span>
<span class="changed"> 126 </span>
<span class="changed"> 127   // get space from the virtual space</span>
<span class="changed"> 128   Metachunk* take_from_committed(size_t chunk_word_size);</span>
<span class="changed"> 129 </span>
<span class="changed"> 130   // Allocate a chunk from the virtual space and return it.</span>
<span class="changed"> 131   Metachunk* get_chunk_vs(size_t chunk_word_size);</span>
<span class="changed"> 132 </span>
<span class="changed"> 133   // Expands the committed space by at least min_words words.</span>
<span class="changed"> 134   bool expand_by(size_t min_words, size_t preferred_words);</span>
 135 
<a name="16" id="anc16"></a><span class="changed"> 136   // In preparation for deleting this node, remove all the chunks</span>
<span class="changed"> 137   // in the node from any freelist.</span>
<span class="changed"> 138   void purge(ChunkManager* chunk_manager);</span>
 139 
<a name="17" id="anc17"></a><span class="changed"> 140   // If an allocation doesn't fit in the current node a new node is created.</span>
<span class="changed"> 141   // Allocate chunks out of the remaining committed space in this node</span>
<span class="changed"> 142   // to avoid wasting that memory.</span>
<span class="changed"> 143   // This always adds up because all the chunk sizes are multiples of</span>
<span class="changed"> 144   // the smallest chunk size.</span>
<span class="changed"> 145   void retire(ChunkManager* chunk_manager);</span>
 146 
<a name="18" id="anc18"></a><span class="changed"> 147   void print_on(outputStream* st) const                 { print_on(st, K); }</span>
<span class="changed"> 148   void print_on(outputStream* st, size_t scale) const;</span>
<span class="changed"> 149   void print_map(outputStream* st, bool is_class) const;</span>
 150 
<a name="19" id="anc19"></a><span class="changed"> 151   // Debug support</span>
<span class="changed"> 152   DEBUG_ONLY(void mangle();)</span>
<span class="changed"> 153   // Verify counters and basic structure. Slow mode: verify all chunks in depth and occupancy map.</span>
<span class="changed"> 154   DEBUG_ONLY(void verify(bool slow);)</span>
<span class="changed"> 155   // Verify that all free chunks in this node are ideally merged</span>
<span class="changed"> 156   // (there should not be multiple small chunks where a large chunk could exist.)</span>
<span class="changed"> 157   DEBUG_ONLY(void verify_free_chunks_are_ideally_merged();)</span>







































































































 158 
 159 };
<a name="20" id="anc20"></a>
 160 
 161 } // namespace metaspace
 162 
 163 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="21" type="hidden" /></form></body></html>
