<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/prims/whitebox.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 
  27 #include &lt;new&gt;
  28 
  29 #include "classfile/classLoaderDataGraph.hpp"
  30 #include "classfile/javaClasses.inline.hpp"
  31 #include "classfile/modules.hpp"
  32 #include "classfile/protectionDomainCache.hpp"
  33 #include "classfile/stringTable.hpp"
  34 #include "classfile/symbolTable.hpp"
  35 #include "code/codeCache.hpp"
  36 #include "compiler/compilationPolicy.hpp"
  37 #include "compiler/methodMatcher.hpp"
  38 #include "compiler/directivesParser.hpp"
  39 #include "gc/shared/concurrentGCBreakpoints.hpp"
  40 #include "gc/shared/gcConfig.hpp"
  41 #include "gc/shared/genArguments.hpp"
  42 #include "gc/shared/genCollectedHeap.hpp"
  43 #include "jvmtifiles/jvmtiEnv.hpp"
  44 #include "logging/log.hpp"
  45 #include "memory/filemap.hpp"
  46 #include "memory/heapShared.inline.hpp"
  47 #include "memory/metaspaceShared.hpp"
  48 #include "memory/metadataFactory.hpp"
  49 #include "memory/iterator.hpp"
  50 #include "memory/resourceArea.hpp"
  51 #include "memory/universe.hpp"
  52 #include "memory/oopFactory.hpp"
  53 #include "oops/array.hpp"
  54 #include "oops/compressedOops.hpp"
  55 #include "oops/constantPool.inline.hpp"
  56 #include "oops/method.inline.hpp"
  57 #include "oops/objArrayKlass.hpp"
  58 #include "oops/objArrayOop.inline.hpp"
  59 #include "oops/oop.inline.hpp"
  60 #include "oops/typeArrayOop.inline.hpp"
  61 #include "prims/resolvedMethodTable.hpp"
  62 #include "prims/wbtestmethods/parserTests.hpp"
  63 #include "prims/whitebox.inline.hpp"
  64 #include "runtime/arguments.hpp"
  65 #include "runtime/atomic.hpp"
  66 #include "runtime/deoptimization.hpp"
  67 #include "runtime/fieldDescriptor.inline.hpp"
  68 #include "runtime/flags/jvmFlag.hpp"
  69 #include "runtime/frame.inline.hpp"
  70 #include "runtime/handles.inline.hpp"
  71 #include "runtime/handshake.hpp"
  72 #include "runtime/interfaceSupport.inline.hpp"
  73 #include "runtime/javaCalls.hpp"
  74 #include "runtime/jniHandles.inline.hpp"
  75 #include "runtime/os.hpp"
  76 #include "runtime/sweeper.hpp"
  77 #include "runtime/synchronizer.hpp"
  78 #include "runtime/thread.hpp"
  79 #include "runtime/threadSMR.hpp"
  80 #include "runtime/vm_version.hpp"
  81 #include "services/memoryService.hpp"
  82 #include "utilities/align.hpp"
  83 #include "utilities/debug.hpp"
  84 #include "utilities/elfFile.hpp"
  85 #include "utilities/exceptions.hpp"
  86 #include "utilities/macros.hpp"
  87 #if INCLUDE_CDS
  88 #include "prims/cdsoffsets.hpp"
  89 #endif // INCLUDE_CDS
  90 #if INCLUDE_G1GC
  91 #include "gc/g1/g1Arguments.hpp"
  92 #include "gc/g1/g1CollectedHeap.inline.hpp"
  93 #include "gc/g1/g1ConcurrentMark.hpp"
  94 #include "gc/g1/g1ConcurrentMarkThread.hpp"
  95 #include "gc/g1/heapRegionRemSet.hpp"
  96 #include "gc/g1/heterogeneousHeapRegionManager.hpp"
  97 #endif // INCLUDE_G1GC
  98 #if INCLUDE_PARALLELGC
  99 #include "gc/parallel/parallelScavengeHeap.inline.hpp"
 100 #endif // INCLUDE_PARALLELGC
 101 #if INCLUDE_NMT
 102 #include "services/mallocSiteTable.hpp"
 103 #include "services/memTracker.hpp"
 104 #include "utilities/nativeCallStack.hpp"
 105 #endif // INCLUDE_NMT
 106 #if INCLUDE_AOT
 107 #include "aot/aotLoader.hpp"
 108 #endif // INCLUDE_AOT
 109 
 110 #ifdef LINUX
 111 #include "osContainer_linux.hpp"
 112 #include "cgroupSubsystem_linux.hpp"
 113 #endif
 114 
 115 #define SIZE_T_MAX_VALUE ((size_t) -1)
 116 
 117 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 118   do {                                                                 \
 119     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 120     THREAD-&gt;clear_pending_jni_exception_check();                       \
 121     if (HAS_PENDING_EXCEPTION) {                                       \
 122       return(value);                                                   \
 123     }                                                                  \
 124   } while (0)
 125 
 126 #define CHECK_JNI_EXCEPTION(env)                                       \
 127   do {                                                                 \
 128     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 129     THREAD-&gt;clear_pending_jni_exception_check();                       \
 130     if (HAS_PENDING_EXCEPTION) {                                       \
 131       return;                                                          \
 132     }                                                                  \
 133   } while (0)
 134 
 135 bool WhiteBox::_used = false;
 136 volatile bool WhiteBox::compilation_locked = false;
 137 
 138 class VM_WhiteBoxOperation : public VM_Operation {
 139  public:
 140   VM_WhiteBoxOperation()                         { }
 141   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 142   bool allow_nested_vm_operations() const        { return true; }
 143 };
 144 
 145 
 146 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 147   return (jlong)(void*)JNIHandles::resolve(obj);
 148 WB_END
 149 
 150 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 151   return heapOopSize;
 152 WB_END
 153 
 154 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 155   return os::vm_page_size();
 156 WB_END
 157 
 158 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 159   return os::vm_allocation_granularity();
 160 WB_END
 161 
 162 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 163   return os::large_page_size();
 164 WB_END
 165 
 166 class WBIsKlassAliveClosure : public LockedClassesDo {
 167     Symbol* _name;
 168     int _count;
 169 public:
 170     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 171 
 172     void do_klass(Klass* k) {
 173       Symbol* ksym = k-&gt;name();
 174       if (ksym-&gt;fast_compare(_name) == 0) {
 175         _count++;
 176       }
 177     }
 178 
 179     int count() const {
 180         return _count;
 181     }
 182 };
 183 
 184 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 185   oop h_name = JNIHandles::resolve(name);
 186   if (h_name == NULL) return false;
 187   Symbol* sym = java_lang_String::as_symbol(h_name);
 188   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 189 
 190   WBIsKlassAliveClosure closure(sym);
 191   ClassLoaderDataGraph::classes_do(&amp;closure);
 192 
 193   // Return the count of alive classes with this name.
 194   return closure.count();
 195 WB_END
 196 
 197 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 198   oop h_name = JNIHandles::resolve(name);
 199   if (h_name == NULL) return false;
 200   Symbol* sym = java_lang_String::as_symbol(h_name);
 201   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 202   return (jint)sym-&gt;refcount();
 203 WB_END
 204 
 205 
 206 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 207 #if INCLUDE_JVMTI
 208   ResourceMark rm;
 209   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 210   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 211   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 212   assert(err == JVMTI_ERROR_NONE, "must not fail");
 213 #endif
 214 }
 215 WB_END
 216 
 217 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 218 #if INCLUDE_JVMTI
 219   ResourceMark rm;
 220   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 221   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 222   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 223   assert(err == JVMTI_ERROR_NONE, "must not fail");
 224 #endif
 225 }
 226 WB_END
 227 
 228 
 229 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 230   return (jlong)Arguments::max_heap_for_compressed_oops();
 231 }
 232 WB_END
 233 
 234 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 235   tty-&gt;print_cr("Minimum heap " SIZE_FORMAT " Initial heap " SIZE_FORMAT " "
 236                 "Maximum heap " SIZE_FORMAT " Space alignment " SIZE_FORMAT " Heap alignment " SIZE_FORMAT,
 237                 MinHeapSize,
 238                 InitialHeapSize,
 239                 MaxHeapSize,
 240                 SpaceAlignment,
 241                 HeapAlignment);
 242 }
 243 WB_END
 244 
 245 #ifndef PRODUCT
 246 // Forward declaration
 247 void TestReservedSpace_test();
 248 void TestReserveMemorySpecial_test();
 249 void TestVirtualSpace_test();
 250 #endif
 251 
 252 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 253 #ifndef PRODUCT
 254   TestReservedSpace_test();
 255   TestReserveMemorySpecial_test();
 256   TestVirtualSpace_test();
 257 #endif
 258 WB_END
 259 
 260 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 261   size_t granularity = os::vm_allocation_granularity();
 262   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 263   VirtualSpace vs;
 264   vs.initialize(rhs, 50 * granularity);
 265 
 266   // Check if constraints are complied
 267   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 268          CompressedOops::base() != NULL &amp;&amp;
 269          CompressedOops::use_implicit_null_checks() )) {
 270     tty-&gt;print_cr("WB_ReadFromNoaccessArea method is useless:\n "
 271                   "\tUseCompressedOops is %d\n"
 272                   "\trhs.base() is " PTR_FORMAT "\n"
 273                   "\tCompressedOops::base() is " PTR_FORMAT "\n"
 274                   "\tCompressedOops::use_implicit_null_checks() is %d",
 275                   UseCompressedOops,
 276                   p2i(rhs.base()),
 277                   p2i(CompressedOops::base()),
 278                   CompressedOops::use_implicit_null_checks());
 279     return;
 280   }
 281   tty-&gt;print_cr("Reading from no access area... ");
 282   tty-&gt;print_cr("*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c",
 283                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 284 WB_END
 285 
 286 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 287                                            size_t magnitude, size_t iterations) {
 288   size_t granularity = os::vm_allocation_granularity();
 289   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 290   VirtualSpace vs;
 291   if (!vs.initialize(rhs, 0)) {
 292     tty-&gt;print_cr("Failed to initialize VirtualSpace. Can't proceed.");
 293     return 3;
 294   }
 295 
 296   int seed = os::random();
 297   tty-&gt;print_cr("Random seed is %d", seed);
 298   os::init_random(seed);
 299 
 300   for (size_t i = 0; i &lt; iterations; i++) {
 301 
 302     // Whether we will shrink or grow
 303     bool shrink = os::random() % 2L == 0;
 304 
 305     // Get random delta to resize virtual space
 306     size_t delta = (size_t)os::random() % magnitude;
 307 
 308     // If we are about to shrink virtual space below zero, then expand instead
 309     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 310       shrink = false;
 311     }
 312 
 313     // Resizing by delta
 314     if (shrink) {
 315       vs.shrink_by(delta);
 316     } else {
 317       // If expanding fails expand_by will silently return false
 318       vs.expand_by(delta, true);
 319     }
 320   }
 321   return 0;
 322 }
 323 
 324 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 325         jlong reserved_space_size, jlong magnitude, jlong iterations))
 326   tty-&gt;print_cr("reservedSpaceSize=" JLONG_FORMAT ", magnitude=" JLONG_FORMAT ", "
 327                 "iterations=" JLONG_FORMAT "\n", reserved_space_size, magnitude,
 328                 iterations);
 329   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 330     tty-&gt;print_cr("One of variables printed above is negative. Can't proceed.\n");
 331     return 1;
 332   }
 333 
 334   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 335   // always 8 byte. That's why we should avoid overflow in case of 32bit platform.
 336   if (sizeof(size_t) &lt; sizeof(jlong)) {
 337     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 338     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 339         || iterations &gt; size_t_max_value) {
 340       tty-&gt;print_cr("One of variables printed above overflows size_t. Can't proceed.\n");
 341       return 2;
 342     }
 343   }
 344 
 345   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 346                                         (size_t) magnitude, (size_t) iterations);
 347 WB_END
 348 
 349 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 350   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 351 WB_END
 352 
 353 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 354   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 355 WB_END
 356 
 357 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 358   return GCConfig::is_gc_selected_ergonomically();
 359 WB_END
 360 
 361 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 362   oop p = JNIHandles::resolve(obj);
 363 #if INCLUDE_G1GC
 364   if (UseG1GC) {
 365     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 366     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 367     if (hr == NULL) {
 368       return false;
 369     }
 370     return !(hr-&gt;is_young());
 371   }
 372 #endif
 373 #if INCLUDE_PARALLELGC
 374   if (UseParallelGC) {
 375     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 376     return !psh-&gt;is_in_young(p);
 377   }
 378 #endif
 379 #if INCLUDE_ZGC
 380   if (UseZGC) {
 381     return Universe::heap()-&gt;is_in(p);
 382   }
 383 #endif
 384   GenCollectedHeap* gch = GenCollectedHeap::heap();
 385   return !gch-&gt;is_in_young(p);
 386 WB_END
 387 
 388 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 389   oop p = JNIHandles::resolve(obj);
 390   return p-&gt;size() * HeapWordSize;
 391 WB_END
 392 
 393 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 394   return (jlong)SpaceAlignment;
 395 WB_END
 396 
 397 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 398   return (jlong)HeapAlignment;
 399 WB_END
 400 
 401 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 402   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 403 WB_END
 404 
 405 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 406   ConcurrentGCBreakpoints::acquire_control();
 407 WB_END
 408 
 409 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 410   ConcurrentGCBreakpoints::release_control();
 411 WB_END
 412 
 413 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 414   ConcurrentGCBreakpoints::run_to_idle();
 415 WB_END
 416 
 417 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 418   Handle h_name(THREAD, JNIHandles::resolve(at));
 419   ResourceMark rm;
 420   const char* c_name = java_lang_String::as_utf8_string(h_name());
 421   return ConcurrentGCBreakpoints::run_to(c_name);
 422 WB_END
 423 
 424 #if INCLUDE_G1GC
 425 
 426 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 427   if (UseG1GC) {
 428     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 429     oop result = JNIHandles::resolve(obj);
 430     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 431     return hr-&gt;is_humongous();
 432   }
 433   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1IsHumongous: G1 GC is not enabled");
 434 WB_END
 435 
 436 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 437   if (UseG1GC) {
 438     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 439     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 440     return hr-&gt;is_humongous();
 441   }
 442   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToHumongousRegion: G1 GC is not enabled");
 443 WB_END
 444 
 445 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 446   if (UseG1GC) {
 447     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 448     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 449     return hr-&gt;is_free();
 450   }
 451   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToFreeRegion: G1 GC is not enabled");
 452 WB_END
 453 
 454 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 455   if (UseG1GC) {
 456     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 457     size_t nr = g1h-&gt;max_regions();
 458     return (jlong)nr;
 459   }
 460   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumMaxRegions: G1 GC is not enabled");
 461 WB_END
 462 
 463 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 464   if (UseG1GC) {
 465     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 466     size_t nr = g1h-&gt;num_free_regions();
 467     return (jlong)nr;
 468   }
 469   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumFreeRegions: G1 GC is not enabled");
 470 WB_END
 471 
 472 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 473   if (UseG1GC) {
 474     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 475     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 476   }
 477   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1InConcurrentMark: G1 GC is not enabled");
 478 WB_END
 479 
 480 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 481   if (UseG1GC) {
 482     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 483     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 484       g1h-&gt;collect(GCCause::_wb_conc_mark);
 485       return true;
 486     }
 487     return false;
 488   }
 489   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1StartMarkCycle: G1 GC is not enabled");
 490 WB_END
 491 
 492 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 493   if (UseG1GC) {
 494     return (jint)HeapRegion::GrainBytes;
 495   }
 496   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1RegionSize: G1 GC is not enabled");
 497 WB_END
 498 
 499 #endif // INCLUDE_G1GC
 500 
 501 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 502 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 503 #if INCLUDE_G1GC
 504   if (UseG1GC) {
 505     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 506     HeapWord* base = g1h-&gt;reserved().start();
 507     if (g1h-&gt;is_heterogeneous_heap()) {
 508       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 509       return (jlong)(base + start_region * HeapRegion::GrainBytes);
 510     } else {
 511       return (jlong)base;
 512     }
 513   }
 514 #endif // INCLUDE_G1GC
 515 #if INCLUDE_PARALLELGC
 516   if (UseParallelGC) {
 517     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 518     if (AllocateOldGenAt != NULL) {
 519       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 520       return (jlong)reserved.start();
 521     } else {
 522       return (jlong)ps_heap-&gt;base();
 523     }
 524   }
 525 #endif // INCLUDE_PARALLELGC
 526   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedStart: enabled only for G1 and Parallel GC");
 527 WB_END
 528 
 529 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 530 #if INCLUDE_G1GC
 531   if (UseG1GC) {
 532     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 533     HeapWord* base = g1h-&gt;reserved().start();
 534     if (g1h-&gt;is_heterogeneous_heap()) {
 535       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 536       return (jlong)(base + (end_region + 1) * HeapRegion::GrainBytes - 1);
 537     } else {
 538       return (jlong)base + G1Arguments::heap_max_size_bytes();
 539     }
 540   }
 541 #endif // INCLUDE_G1GC
 542 #if INCLUDE_PARALLELGC
 543   if (UseParallelGC) {
 544     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 545     if (AllocateOldGenAt != NULL) {
 546       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 547       return (jlong)reserved.end();
 548     } else {
 549       return (jlong)ps_heap-&gt;reserved_region().end();
 550     }
 551   }
 552 #endif // INCLUDE_PARALLELGC
 553   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedEnd: enabled only for G1 and Parallel GC");
 554 WB_END
 555 
 556 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 557 #if INCLUDE_G1GC
 558   if (UseG1GC) {
 559     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 560     if (g1h-&gt;is_heterogeneous_heap()) {
 561       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 562       return (jlong)(g1h-&gt;reserved().start() + start_region * HeapRegion::GrainBytes);
 563     } else {
 564       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 565     }
 566   }
 567 #endif // INCLUDE_G1GC
 568 #if INCLUDE_PARALLELGC
 569   if (UseParallelGC) {
 570     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 571     if (AllocateOldGenAt != NULL) {
 572       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 573       return (jlong)reserved.start();
 574     } else {
 575       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 576     }
 577   }
 578 #endif // INCLUDE_PARALLELGC
 579   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: enabled only for G1 and Parallel GC");
 580 WB_END
 581 
 582 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 583 #if INCLUDE_G1GC
 584   if (UseG1GC) {
 585     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 586     if (g1h-&gt;is_heterogeneous_heap()) {
 587       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 588       return (jlong)(g1h-&gt;reserved().start() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 589     } else {
 590       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 591     }
 592   }
 593 #endif // INCLUDE_G1GC
 594 #if INCLUDE_PARALLELGC
 595   if (UseParallelGC) {
 596     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 597     if (AllocateOldGenAt != NULL) {
 598       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 599       return (jlong)reserved.end();
 600       } else {
 601       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 602     }
 603   }
 604 #endif // INCLUDE_PARALLELGC
 605   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC");
 606 WB_END
 607 
 608 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 609 
 610 #if INCLUDE_PARALLELGC
 611 
 612 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 613   if (UseParallelGC) {
 614     return GenAlignment;
 615   }
 616   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSVirtualSpaceAlignment: Parallel GC is not enabled");
 617 WB_END
 618 
 619 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 620   if (UseParallelGC) {
 621     return GenAlignment;
 622   }
 623   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSHeapGenerationAlignment: Parallel GC is not enabled");
 624 WB_END
 625 
 626 #endif // INCLUDE_PARALLELGC
 627 
 628 #if INCLUDE_G1GC
 629 
 630 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 631   if (UseG1GC) {
 632     ResourceMark rm(THREAD);
 633     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 634     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 635     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 636     return JNIHandles::make_local(THREAD, h());
 637   }
 638   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled");
 639 WB_END
 640 
 641 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 642   if (UseG1GC) {
 643     G1NUMA* numa = G1NUMA::numa();
 644     return (jint)numa-&gt;num_active_nodes();
 645   }
 646   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1ActiveMemoryNodeCount: G1 GC is not enabled");
 647 WB_END
 648 
 649 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 650   if (UseG1GC) {
 651     G1NUMA* numa = G1NUMA::numa();
 652     int num_node_ids = (int)numa-&gt;num_active_nodes();
 653     const int* node_ids = numa-&gt;node_ids();
 654 
 655     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 656     for (int i = 0; i &lt; num_node_ids; i++) {
 657       result-&gt;int_at_put(i, (jint)node_ids[i]);
 658     }
 659     return (jintArray) JNIHandles::make_local(THREAD, result);
 660   }
 661   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1MemoryNodeIds: G1 GC is not enabled");
 662 WB_END
 663 
 664 class OldRegionsLivenessClosure: public HeapRegionClosure {
 665 
 666  private:
 667   const int _liveness;
 668   size_t _total_count;
 669   size_t _total_memory;
 670   size_t _total_memory_to_free;
 671 
 672  public:
 673   OldRegionsLivenessClosure(int liveness) :
 674     _liveness(liveness),
 675     _total_count(0),
 676     _total_memory(0),
 677     _total_memory_to_free(0) { }
 678 
 679     size_t total_count() { return _total_count; }
 680     size_t total_memory() { return _total_memory; }
 681     size_t total_memory_to_free() { return _total_memory_to_free; }
 682 
 683   bool do_heap_region(HeapRegion* r) {
 684     if (r-&gt;is_old()) {
 685       size_t prev_live = r-&gt;marked_bytes();
 686       size_t live = r-&gt;live_bytes();
 687       size_t size = r-&gt;used();
 688       size_t reg_size = HeapRegion::GrainBytes;
 689       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 690         _total_memory += size;
 691         ++_total_count;
 692         if (size == reg_size) {
 693         // we don't include non-full regions since they are unlikely included in mixed gc
 694         // for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed
 695           _total_memory_to_free += size - prev_live;
 696         }
 697       }
 698     }
 699     return false;
 700   }
 701 };
 702 
 703 
 704 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 705   if (!UseG1GC) {
 706     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1GetMixedGCInfo: G1 GC is not enabled");
 707   }
 708   if (liveness &lt; 0) {
 709     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "liveness value should be non-negative");
 710   }
 711 
 712   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 713   OldRegionsLivenessClosure rli(liveness);
 714   g1h-&gt;heap_region_iterate(&amp;rli);
 715 
 716   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 717   result-&gt;long_at_put(0, rli.total_count());
 718   result-&gt;long_at_put(1, rli.total_memory());
 719   result-&gt;long_at_put(2, rli.total_memory_to_free());
 720   return (jlongArray) JNIHandles::make_local(THREAD, result);
 721 WB_END
 722 
 723 #endif // INCLUDE_G1GC
 724 
 725 #if INCLUDE_NMT
 726 // Alloc memory using the test memory type so that we can use that to see if
 727 // NMT picks it up correctly
 728 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 729   jlong addr = 0;
 730   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 731   return addr;
 732 WB_END
 733 
 734 // Alloc memory with pseudo call stack. The test can create psudo malloc
 735 // allocation site to stress the malloc tracking.
 736 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 737   address pc = (address)(size_t)pseudo_stack;
 738   NativeCallStack stack(&amp;pc, 1);
 739   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 740 WB_END
 741 
 742 // Alloc memory with pseudo call stack and specific memory type.
 743 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 744   address pc = (address)(size_t)pseudo_stack;
 745   NativeCallStack stack(&amp;pc, 1);
 746   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 747 WB_END
 748 
 749 // Free the memory allocated by NMTAllocTest
 750 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 751   os::free((void*)(uintptr_t)mem);
 752 WB_END
 753 
 754 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 755   jlong addr = 0;
 756 
 757   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 758   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 759 
 760   return addr;
 761 WB_END
 762 
 763 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 764   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 765   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 766 
 767   return addr;
 768 WB_END
 769 
 770 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 771   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 772   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 773 WB_END
 774 
 775 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 776   os::uncommit_memory((char *)(uintptr_t)addr, size);
 777 WB_END
 778 
 779 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 780   os::release_memory((char *)(uintptr_t)addr, size);
 781 WB_END
 782 
 783 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 784   // Test that we can downgrade NMT levels but not upgrade them.
 785   if (MemTracker::tracking_level() == NMT_off) {
 786     MemTracker::transition_to(NMT_off);
 787     return MemTracker::tracking_level() == NMT_off;
 788   } else {
 789     assert(MemTracker::tracking_level() == NMT_detail, "Should start out as detail tracking");
 790     MemTracker::transition_to(NMT_summary);
 791     assert(MemTracker::tracking_level() == NMT_summary, "Should be summary now");
 792 
 793     // Can't go to detail once NMT is set to summary.
 794     MemTracker::transition_to(NMT_detail);
 795     assert(MemTracker::tracking_level() == NMT_summary, "Should still be summary now");
 796 
 797     // Shutdown sets tracking level to minimal.
 798     MemTracker::shutdown();
 799     assert(MemTracker::tracking_level() == NMT_minimal, "Should be minimal now");
 800 
 801     // Once the tracking level is minimal, we cannot increase to summary.
 802     // The code ignores this request instead of asserting because if the malloc site
 803     // table overflows in another thread, it tries to change the code to summary.
 804     MemTracker::transition_to(NMT_summary);
 805     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 806 
 807     // Really can never go up to detail, verify that the code would never do this.
 808     MemTracker::transition_to(NMT_detail);
 809     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 810     return MemTracker::tracking_level() == NMT_minimal;
 811   }
 812 WB_END
 813 
 814 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 815   int hash_size = MallocSiteTable::hash_buckets();
 816   assert(hash_size &gt; 0, "NMT hash_size should be &gt; 0");
 817   return (jint)hash_size;
 818 WB_END
 819 
 820 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 821   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 822   return (jlong)arena;
 823 WB_END
 824 
 825 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 826   Arena* a = (Arena*)arena;
 827   delete a;
 828 WB_END
 829 
 830 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 831   Arena* a = (Arena*)arena;
 832   a-&gt;Amalloc(size_t(size));
 833 WB_END
 834 #endif // INCLUDE_NMT
 835 
 836 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 837   assert(method != NULL, "method should not be null");
 838   ThreadToNativeFromVM ttn(thread);
 839   return env-&gt;FromReflectedMethod(method);
 840 }
 841 
 842 static CompLevel highestCompLevel() {
 843   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 844 }
 845 
 846 // Deoptimizes all compiled frames and makes nmethods not entrant if it's requested
 847 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 848  private:
 849   int _result;
 850   const bool _make_not_entrant;
 851  public:
 852   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 853         _result(0), _make_not_entrant(make_not_entrant) { }
 854   int  result() const { return _result; }
 855 
 856   void doit() {
 857     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 858       if (t-&gt;has_last_Java_frame()) {
 859         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 860           frame* f = fst.current();
 861           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 862             Deoptimization::deoptimize(t, *f);
 863             if (_make_not_entrant) {
 864                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 865                 assert(cm != NULL, "sanity check");
 866                 cm-&gt;make_not_entrant();
 867             }
 868             ++_result;
 869           }
 870         }
 871       }
 872     }
 873   }
 874 };
 875 
 876 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 877   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 878   VMThread::execute(&amp;op);
 879   return op.result();
 880 WB_END
 881 
 882 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 883   CodeCache::mark_all_nmethods_for_deoptimization();
 884   Deoptimization::deoptimize_all_marked();
 885 WB_END
 886 
 887 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 888   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 889   int result = 0;
 890   CHECK_JNI_EXCEPTION_(env, result);
 891   MutexLocker mu(Compile_lock);
 892   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 893   if (is_osr) {
 894     result += mh-&gt;mark_osr_nmethods();
 895   } else if (mh-&gt;code() != NULL) {
 896     mh-&gt;code()-&gt;mark_for_deoptimization();
 897     ++result;
 898   }
 899   result += CodeCache::mark_for_deoptimization(mh());
 900   if (result &gt; 0) {
 901     Deoptimization::deoptimize_all_marked();
 902   }
 903   return result;
 904 WB_END
 905 
 906 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 907   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 908   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 909   MutexLocker mu(Compile_lock);
 910   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 911   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 912   if (code == NULL) {
 913     return JNI_FALSE;
 914   }
 915   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 916 WB_END
 917 
 918 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 919   if (method == NULL || comp_level &gt; highestCompLevel()) {
 920     return false;
 921   }
 922   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 923   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 924   MutexLocker mu(Compile_lock);
 925   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 926   if (is_osr) {
 927     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 928   } else {
 929     return CompilationPolicy::can_be_compiled(mh, comp_level);
 930   }
 931 WB_END
 932 
 933 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 934   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 935   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 936   MutexLocker mu(Compile_lock);
 937   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 938   return mh-&gt;queued_for_compilation();
 939 WB_END
 940 
 941 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 942   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 943     return false; // Intrinsic is not available on a non-existent compilation level.
 944   }
 945   jmethodID method_id, compilation_context_id;
 946   method_id = reflected_method_to_jmid(thread, env, method);
 947   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 948   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 949 
 950   DirectiveSet* directive;
 951   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 952   assert(comp != NULL, "compiler not available");
 953   if (compilation_context != NULL) {
 954     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 955     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 956     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 957     directive = DirectivesStack::getMatchingDirective(cch, comp);
 958   } else {
 959     // Calling with NULL matches default directive
 960     directive = DirectivesStack::getDefaultDirective(comp);
 961   }
 962   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 963   DirectivesStack::release(directive);
 964   return result;
 965 WB_END
 966 
 967 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 968   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 969   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 970   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 971   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 972   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 973 WB_END
 974 
 975 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 976   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 977   CHECK_JNI_EXCEPTION(env);
 978   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 979   if (is_osr) {
 980     mh-&gt;set_not_osr_compilable("WhiteBox", comp_level);
 981   } else {
 982     mh-&gt;set_not_compilable("WhiteBox", comp_level);
 983   }
 984 WB_END
 985 
 986 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 987   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 988   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 989   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 990   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 991   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 992 WB_END
 993 
 994 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 995   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 996   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 997   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 998   bool result = mh-&gt;dont_inline();
 999   mh-&gt;set_dont_inline(value == JNI_TRUE);
1000   return result;
1001 WB_END
1002 
1003 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1004   if (comp_level == CompLevel_any) {
1005     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1006         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1007   } else {
1008     return CompileBroker::queue_size(comp_level);
1009   }
1010 WB_END
1011 
1012 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1013   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1014   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1015   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1016   bool result = mh-&gt;force_inline();
1017   mh-&gt;set_force_inline(value == JNI_TRUE);
1018   return result;
1019 WB_END
1020 
1021 #ifdef LINUX
1022 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1023                                const char* proc_self_cgroup,
1024                                const char* proc_self_mountinfo,
1025                                u1* cg_flags) {
1026   CgroupInfo cg_infos[4];
1027   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1028                                                     proc_self_cgroup,
1029                                                     proc_self_mountinfo, cg_flags);
1030 }
1031 #endif
1032 
1033 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1034   // Screen for unavailable/bad comp level or null method
1035   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1036   if (method == NULL) {
1037     tty-&gt;print_cr("WB error: request to compile NULL method");
1038     return false;
1039   }
1040   if (comp_level &gt; highestCompLevel()) {
1041     tty-&gt;print_cr("WB error: invalid compilation level %d", comp_level);
1042     return false;
1043   }
1044   if (comp == NULL) {
1045     tty-&gt;print_cr("WB error: no compiler for requested compilation level %d", comp_level);
1046     return false;
1047   }
1048 
1049   // Check if compilation is blocking
1050   methodHandle mh(THREAD, method);
1051   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1052   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1053   DirectivesStack::release(directive);
1054 
1055   // Compile method and check result
1056   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1057   MutexLocker mu(THREAD, Compile_lock);
1058   bool is_queued = mh-&gt;queued_for_compilation();
1059   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1060     return true;
1061   }
1062   tty-&gt;print("WB error: failed to %s compile at level %d method ", is_blocking ? "blocking" : "", comp_level);
1063   mh-&gt;print_short_name(tty);
1064   tty-&gt;cr();
1065   if (is_blocking &amp;&amp; is_queued) {
1066     tty-&gt;print_cr("WB error: blocking compilation is still in queue!");
1067   }
1068   return false;
1069 }
1070 
1071 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1072   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1073   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1074   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1075 WB_END
1076 
1077 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1078   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1079   Method* clinit = ik-&gt;class_initializer();
1080   if (clinit == NULL) {
1081     return false;
1082   }
1083   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1084 WB_END
1085 
1086 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1087   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1088   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1089 
1090   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1091   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1092   bool result = directive-&gt;PrintAssemblyOption;
1093   DirectivesStack::release(directive);
1094 
1095   return result;
1096 WB_END
1097 
1098 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1099   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1100   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1101 
1102   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1103 
1104   ResourceMark rm(THREAD);
1105   const char* error_msg = NULL;
1106   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1107   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1108 
1109   if (m == NULL) {
1110     assert(error_msg != NULL, "Always have an error message");
1111     tty-&gt;print_cr("Got error: %s", error_msg);
1112     return -1; // Pattern failed
1113   }
1114 
1115   // Pattern works - now check if it matches
1116   int result;
1117   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1118     result = 2; // Force inline match
1119   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1120     result = 1; // Dont inline match
1121   } else {
1122     result = 0; // No match
1123   }
1124   delete m;
1125   return result;
1126 WB_END
1127 
1128 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1129   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1130   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1131 
1132   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1133 
1134   ResourceMark rm;
1135   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1136 
1137   const char* error_msg = NULL;
1138 
1139   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1140   if (m == NULL) {
1141     assert(error_msg != NULL, "Must have error_msg");
1142     tty-&gt;print_cr("Got error: %s", error_msg);
1143     return -1;
1144   }
1145 
1146   // Pattern works - now check if it matches
1147   int result = m-&gt;matches(mh);
1148   delete m;
1149   assert(result == 0 || result == 1, "Result out of range");
1150   return result;
1151 WB_END
1152 
1153 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1154   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1155   CHECK_JNI_EXCEPTION(env);
1156   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1157 
1158   MethodData* mdo = mh-&gt;method_data();
1159   if (mdo == NULL) {
1160     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1161     mdo = mh-&gt;method_data();
1162   }
1163   mdo-&gt;init();
1164   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1165   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1166   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1167   icnt-&gt;set(Tier4MinInvocationThreshold);
1168   bcnt-&gt;set(Tier4CompileThreshold);
1169 WB_END
1170 
1171 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1172   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1173   CHECK_JNI_EXCEPTION(env);
1174   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1175   MutexLocker mu(THREAD, Compile_lock);
1176   MethodData* mdo = mh-&gt;method_data();
1177   MethodCounters* mcs = mh-&gt;method_counters();
1178 
1179   if (mdo != NULL) {
1180     mdo-&gt;init();
1181     ResourceMark rm(THREAD);
1182     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1183     for (int i = 0; i &lt; arg_count; i++) {
1184       mdo-&gt;set_arg_modified(i, 0);
1185     }
1186     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1187     mdo-&gt;clean_method_data(/*always_clean*/true);
1188   }
1189 
1190   mh-&gt;clear_not_c1_compilable();
1191   mh-&gt;clear_not_c2_compilable();
1192   mh-&gt;clear_not_c2_osr_compilable();
1193   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1194   if (mcs != NULL) {
1195     mcs-&gt;backedge_counter()-&gt;init();
1196     mcs-&gt;invocation_counter()-&gt;init();
1197     mcs-&gt;set_interpreter_invocation_count(0);
1198     mcs-&gt;set_interpreter_throwout_count(0);
1199 
1200 #ifdef TIERED
1201     mcs-&gt;set_rate(0.0F);
1202     mh-&gt;set_prev_event_count(0);
1203     mh-&gt;set_prev_time(0);
1204 #endif
1205   }
1206 WB_END
1207 
1208 template &lt;typename T&gt;
1209 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1210   if (name == NULL) {
1211     return false;
1212   }
1213   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1214   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1215   CHECK_JNI_EXCEPTION_(env, false);
1216   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1217   JVMFlag::Error result = (*TAt)(flag, value);
1218   env-&gt;ReleaseStringUTFChars(name, flag_name);
1219   return (result == JVMFlag::SUCCESS);
1220 }
1221 
1222 template &lt;typename T&gt;
1223 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1224   if (name == NULL) {
1225     return false;
1226   }
1227   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1228   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1229   CHECK_JNI_EXCEPTION_(env, false);
1230   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1231   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1232   env-&gt;ReleaseStringUTFChars(name, flag_name);
1233   return (result == JVMFlag::SUCCESS);
1234 }
1235 
1236 template &lt;typename T&gt;
1237 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1238   ResourceMark rm(thread);
1239   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1240   CHECK_JNI_EXCEPTION_(env, NULL);
1241   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1242         vmSymbols::valueOf_name()-&gt;as_C_string(),
1243         sig-&gt;as_C_string());
1244   CHECK_JNI_EXCEPTION_(env, NULL);
1245   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1246   CHECK_JNI_EXCEPTION_(env, NULL);
1247   return result;
1248 }
1249 
1250 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1251   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1252 }
1253 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1254   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1255 }
1256 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1257   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1258 }
1259 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1260   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1261 }*/
1262 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1263   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1264 }
1265 
1266 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1267   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1268   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1269   CHECK_JNI_EXCEPTION_(env, NULL);
1270   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1271   env-&gt;ReleaseStringUTFChars(name, flag_name);
1272   return result;
1273 }
1274 
1275 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1276   const JVMFlag* flag = getVMFlag(thread, env, name);
1277   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1278 WB_END
1279 
1280 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1281   const JVMFlag* flag = getVMFlag(thread, env, name);
1282   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1283 WB_END
1284 
1285 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1286   bool result;
1287   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1288     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1289     return booleanBox(thread, env, result);
1290   }
1291   return NULL;
1292 WB_END
1293 
1294 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1295   int result;
1296   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1297     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1298     return longBox(thread, env, result);
1299   }
1300   return NULL;
1301 WB_END
1302 
1303 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1304   uint result;
1305   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1306     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1307     return longBox(thread, env, result);
1308   }
1309   return NULL;
1310 WB_END
1311 
1312 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1313   intx result;
1314   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1315     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1316     return longBox(thread, env, result);
1317   }
1318   return NULL;
1319 WB_END
1320 
1321 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1322   uintx result;
1323   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1324     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1325     return longBox(thread, env, result);
1326   }
1327   return NULL;
1328 WB_END
1329 
1330 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1331   uint64_t result;
1332   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1333     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1334     return longBox(thread, env, result);
1335   }
1336   return NULL;
1337 WB_END
1338 
1339 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1340   size_t result;
1341   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1342     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1343     return longBox(thread, env, result);
1344   }
1345   return NULL;
1346 WB_END
1347 
1348 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1349   double result;
1350   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1351     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1352     return doubleBox(thread, env, result);
1353   }
1354   return NULL;
1355 WB_END
1356 
1357 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1358   ccstr ccstrResult;
1359   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1360     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1361     jstring result = env-&gt;NewStringUTF(ccstrResult);
1362     CHECK_JNI_EXCEPTION_(env, NULL);
1363     return result;
1364   }
1365   return NULL;
1366 WB_END
1367 
1368 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1369   bool result = value == JNI_TRUE ? true : false;
1370   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1374   int result = value;
1375   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1376 WB_END
1377 
1378 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1379   uint result = value;
1380   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1381 WB_END
1382 
1383 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1384   intx result = value;
1385   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1386 WB_END
1387 
1388 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1389   uintx result = value;
1390   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1391 WB_END
1392 
1393 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1394   uint64_t result = value;
1395   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1396 WB_END
1397 
1398 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1399   size_t result = value;
1400   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1401 WB_END
1402 
1403 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1404   double result = value;
1405   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1406 WB_END
1407 
1408 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1409   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1410   const char* ccstrValue;
1411   if (value == NULL) {
1412     ccstrValue = NULL;
1413   }
1414   else {
1415     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1416     CHECK_JNI_EXCEPTION(env);
1417   }
1418   ccstr ccstrResult = ccstrValue;
1419   bool needFree;
1420   {
1421     ThreadInVMfromNative ttvfn(thread); // back to VM
1422     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1423   }
1424   if (value != NULL) {
1425     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1426   }
1427   if (needFree) {
1428     FREE_C_HEAP_ARRAY(char, ccstrResult);
1429   }
1430 WB_END
1431 
1432 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1433   WhiteBox::compilation_locked = true;
1434 WB_END
1435 
1436 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1437   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1438   WhiteBox::compilation_locked = false;
1439   mo.notify_all();
1440 WB_END
1441 
1442 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1443   // Force a code cache sweep and block until it finished
1444   NMethodSweeper::force_sweep();
1445 WB_END
1446 
1447 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1448   ResourceMark rm(THREAD);
1449   int len;
1450   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1451   return (StringTable::lookup(name, len) != NULL);
1452 WB_END
1453 
1454 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1455   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1456   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1457 #if INCLUDE_G1GC
1458   if (UseG1GC) {
1459     // Needs to be cleared explicitly for G1
1460     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1461   }
1462 #endif // INCLUDE_G1GC
1463 WB_END
1464 
1465 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1466   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1467 WB_END
1468 
1469 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1470   // static+volatile in order to force the read to happen
1471   // (not be eliminated by the compiler)
1472   static char c;
1473   static volatile char* p;
1474 
1475   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1476   if (p == NULL) {
1477     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to reserve memory");
1478   }
1479 
1480   c = *p;
1481 WB_END
1482 
1483 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1484   const char* features = VM_Version::features_string();
1485   ThreadToNativeFromVM ttn(thread);
1486   jstring features_string = env-&gt;NewStringUTF(features);
1487 
1488   CHECK_JNI_EXCEPTION_(env, NULL);
1489 
1490   return features_string;
1491 WB_END
1492 
1493 int WhiteBox::get_blob_type(const CodeBlob* code) {
1494   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1495   if (code-&gt;is_aot()) {
1496     return -1;
1497   }
1498   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1499 }
1500 
1501 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1502   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1503   return CodeCache::get_code_heap(blob_type);
1504 }
1505 
1506 struct CodeBlobStub {
1507   CodeBlobStub(const CodeBlob* blob) :
1508       name(os::strdup(blob-&gt;name())),
1509       size(blob-&gt;size()),
1510       blob_type(WhiteBox::get_blob_type(blob)),
1511       address((jlong) blob) { }
1512   ~CodeBlobStub() { os::free((void*) name); }
1513   const char* const name;
1514   const jint        size;
1515   const jint        blob_type;
1516   const jlong       address;
1517 };
1518 
1519 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1520   ResourceMark rm;
1521   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1522   CHECK_JNI_EXCEPTION_(env, NULL);
1523   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1524 
1525   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1526   CHECK_JNI_EXCEPTION_(env, NULL);
1527   env-&gt;SetObjectArrayElement(result, 0, name);
1528 
1529   jobject obj = integerBox(thread, env, cb-&gt;size);
1530   CHECK_JNI_EXCEPTION_(env, NULL);
1531   env-&gt;SetObjectArrayElement(result, 1, obj);
1532 
1533   obj = integerBox(thread, env, cb-&gt;blob_type);
1534   CHECK_JNI_EXCEPTION_(env, NULL);
1535   env-&gt;SetObjectArrayElement(result, 2, obj);
1536 
1537   obj = longBox(thread, env, cb-&gt;address);
1538   CHECK_JNI_EXCEPTION_(env, NULL);
1539   env-&gt;SetObjectArrayElement(result, 3, obj);
1540 
1541   return result;
1542 }
1543 
1544 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1545   ResourceMark rm(THREAD);
1546   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1547   CHECK_JNI_EXCEPTION_(env, NULL);
1548   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1549   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1550   jobjectArray result = NULL;
1551   if (code == NULL) {
1552     return result;
1553   }
1554   int comp_level = code-&gt;comp_level();
1555   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1556 
1557   ThreadToNativeFromVM ttn(thread);
1558   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1559   CHECK_JNI_EXCEPTION_(env, NULL);
1560   result = env-&gt;NewObjectArray(5, clazz, NULL);
1561   if (result == NULL) {
1562     return result;
1563   }
1564 
1565   CodeBlobStub stub(code);
1566   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1567   CHECK_JNI_EXCEPTION_(env, NULL);
1568   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1569 
1570   jobject level = integerBox(thread, env, comp_level);
1571   CHECK_JNI_EXCEPTION_(env, NULL);
1572   env-&gt;SetObjectArrayElement(result, 1, level);
1573 
1574   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1575   CHECK_JNI_EXCEPTION_(env, NULL);
1576   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1577   env-&gt;SetObjectArrayElement(result, 2, insts);
1578 
1579   jobject id = integerBox(thread, env, code-&gt;compile_id());
1580   CHECK_JNI_EXCEPTION_(env, NULL);
1581   env-&gt;SetObjectArrayElement(result, 3, id);
1582 
1583   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1584   CHECK_JNI_EXCEPTION_(env, NULL);
1585   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1586 
1587   return result;
1588 WB_END
1589 
1590 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1591   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1592   BufferBlob* blob;
1593   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1594   if (full_size &lt; size) {
1595     full_size += align_up(size - full_size, oopSize);
1596   }
1597   {
1598     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1599     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1600     if (blob != NULL) {
1601       ::new (blob) BufferBlob("WB::DummyBlob", full_size);
1602     }
1603   }
1604   // Track memory usage statistic after releasing CodeCache_lock
1605   MemoryService::track_code_cache_memory_usage();
1606   return blob;
1607 }
1608 
1609 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1610   if (size &lt; 0) {
1611     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1612       err_msg("WB_AllocateCodeBlob: size is negative: " INT32_FORMAT, size));
1613   }
1614   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1615 WB_END
1616 
1617 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1618   if (addr == 0) {
1619     return;
1620   }
1621   BufferBlob::free((BufferBlob*) addr);
1622 WB_END
1623 
1624 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1625   ResourceMark rm;
1626   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1627   {
1628     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1629     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1630     if (heap == NULL) {
1631       return NULL;
1632     }
1633     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1634          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1635       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1636       new (stub) CodeBlobStub(cb);
1637       blobs.append(stub);
1638     }
1639   }
1640   ThreadToNativeFromVM ttn(thread);
1641   jobjectArray result = NULL;
1642   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1643   CHECK_JNI_EXCEPTION_(env, NULL);
1644   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1645   CHECK_JNI_EXCEPTION_(env, NULL);
1646   if (result == NULL) {
1647     return result;
1648   }
1649   int i = 0;
1650   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1651        it != blobs.end(); ++it) {
1652     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1653     CHECK_JNI_EXCEPTION_(env, NULL);
1654     env-&gt;SetObjectArrayElement(result, i, obj);
1655     CHECK_JNI_EXCEPTION_(env, NULL);
1656     ++i;
1657   }
1658   return result;
1659 WB_END
1660 
1661 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1662   return CompileBroker::get_compilation_activity_mode();
1663 WB_END
1664 
1665 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1666   if (addr == 0) {
1667     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1668       "WB_GetCodeBlob: addr is null");
1669   }
1670   ThreadToNativeFromVM ttn(thread);
1671   CodeBlobStub stub((CodeBlob*) addr);
1672   return codeBlob2objectArray(thread, env, &amp;stub);
1673 WB_END
1674 
1675 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1676   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1677   CHECK_JNI_EXCEPTION_(env, 0);
1678   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1679   return (jlong) mh-&gt;method_data();
1680 WB_END
1681 
1682 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1683   return (jlong) thread-&gt;stack_size();
1684 WB_END
1685 
1686 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1687   return (jlong) thread-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1688 WB_END
1689 
1690 
1691 int WhiteBox::array_bytes_to_length(size_t bytes) {
1692   return Array&lt;u1&gt;::bytes_to_length(bytes);
1693 }
1694 
1695 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1696   if (size &lt; 0) {
1697     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1698         err_msg("WB_AllocateMetaspace: size is negative: " JLONG_FORMAT, size));
1699   }
1700 
1701   oop class_loader_oop = JNIHandles::resolve(class_loader);
1702   ClassLoaderData* cld = class_loader_oop != NULL
1703       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1704       : ClassLoaderData::the_null_class_loader_data();
1705 
1706   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1707 
1708   return (jlong)(uintptr_t)metadata;
1709 WB_END
1710 
1711 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1712   oop class_loader_oop = JNIHandles::resolve(class_loader);
1713   ClassLoaderData* cld = class_loader_oop != NULL
1714       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1715       : ClassLoaderData::the_null_class_loader_data();
1716 
1717   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1718 WB_END
1719 
1720 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1721                                 jstring version, jstring location, jobjectArray packages))
1722   Modules::define_module(module, is_open, version, location, packages, CHECK);
1723 WB_END
1724 
1725 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1726   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1727 WB_END
1728 
1729 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1730   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1731 WB_END
1732 
1733 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1734   Modules::add_module_exports(module, package, NULL, CHECK);
1735 WB_END
1736 
1737 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1738   Modules::add_reads_module(from_module, source_module, CHECK);
1739 WB_END
1740 
1741 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1742   if (inc &lt; 0) {
1743     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1744         err_msg("WB_IncMetaspaceCapacityUntilGC: inc is negative: " JLONG_FORMAT, inc));
1745   }
1746 
1747   jlong max_size_t = (jlong) ((size_t) -1);
1748   if (inc &gt; max_size_t) {
1749     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1750         err_msg("WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: " JLONG_FORMAT, inc));
1751   }
1752 
1753   size_t new_cap_until_GC = 0;
1754   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1755   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1756   if (!success) {
1757     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1758                 "WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC "
1759                 "due to contention with another thread");
1760   }
1761   return (jlong) new_cap_until_GC;
1762 WB_END
1763 
1764 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1765   return (jlong) MetaspaceGC::capacity_until_GC();
1766 WB_END
1767 
1768 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1769   return (jlong)Metaspace::reserve_alignment();
1770 WB_END
1771 
1772 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1773   oop obj_oop = JNIHandles::resolve(obj);
1774   return (jboolean) obj_oop-&gt;mark().has_monitor();
1775 WB_END
1776 
1777 WB_ENTRY(jboolean, WB_DeflateIdleMonitors(JNIEnv* env, jobject wb))
1778   log_info(monitorinflation)("WhiteBox initiated DeflateIdleMonitors");
1779   return ObjectSynchronizer::request_deflate_idle_monitors();
1780 WB_END
1781 
1782 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1783   VM_ForceSafepoint force_safepoint_op;
1784   VMThread::execute(&amp;force_safepoint_op);
1785 WB_END
1786 
1787 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1788   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1789   return (jlong) ik-&gt;constants();
1790 WB_END
1791 
1792 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1793   return ConstantPool::CPCACHE_INDEX_TAG;
1794 WB_END
1795 
1796 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1797   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1798   ConstantPool* cp = ik-&gt;constants();
1799   if (cp-&gt;cache() == NULL) {
1800       return -1;
1801   }
1802   return cp-&gt;cache()-&gt;length();
1803 WB_END
1804 
1805 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1806   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1807   ConstantPool* cp = ik-&gt;constants();
1808   if (cp-&gt;cache() == NULL) {
1809     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), "Constant pool does not have a cache");
1810   }
1811   jint cpci = index;
1812   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1813   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1814     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Constant pool cache index is out of range");
1815   }
1816   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1817   return cpi;
1818 WB_END
1819 
1820 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1821   return ConstantPool::encode_invokedynamic_index(index);
1822 WB_END
1823 
1824 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1825   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1826   VMThread::execute(&amp;clear_ics);
1827 WB_END
1828 
1829 template &lt;typename T&gt;
1830 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1831   assert(value != NULL, "sanity");
1832   if (method == NULL || name == NULL) {
1833     return false;
1834   }
1835   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1836   CHECK_JNI_EXCEPTION_(env, false);
1837   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1838   // can't be in VM when we call JNI
1839   ThreadToNativeFromVM ttnfv(thread);
1840   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1841   CHECK_JNI_EXCEPTION_(env, false);
1842   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1843   env-&gt;ReleaseStringUTFChars(name, flag_name);
1844   return result;
1845 }
1846 
1847 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1848   bool result;
1849   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1850     // can't be in VM when we call JNI
1851     ThreadToNativeFromVM ttnfv(thread);
1852     return booleanBox(thread, env, result);
1853   }
1854   return NULL;
1855 WB_END
1856 
1857 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1858   intx result;
1859   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1860     // can't be in VM when we call JNI
1861     ThreadToNativeFromVM ttnfv(thread);
1862     return longBox(thread, env, result);
1863   }
1864   return NULL;
1865 WB_END
1866 
1867 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1868   uintx result;
1869   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1870     // can't be in VM when we call JNI
1871     ThreadToNativeFromVM ttnfv(thread);
1872     return longBox(thread, env, result);
1873   }
1874   return NULL;
1875 WB_END
1876 
1877 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1878   double result;
1879   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1880     // can't be in VM when we call JNI
1881     ThreadToNativeFromVM ttnfv(thread);
1882     return doubleBox(thread, env, result);
1883   }
1884   return NULL;
1885 WB_END
1886 
1887 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1888   ccstr ccstrResult;
1889   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1890     // can't be in VM when we call JNI
1891     ThreadToNativeFromVM ttnfv(thread);
1892     jstring result = env-&gt;NewStringUTF(ccstrResult);
1893     CHECK_JNI_EXCEPTION_(env, NULL);
1894     return result;
1895   }
1896   return NULL;
1897 WB_END
1898 
1899 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1900   const char* p = Arguments::get_default_shared_archive_path();
1901   ThreadToNativeFromVM ttn(thread);
1902   jstring path_string = env-&gt;NewStringUTF(p);
1903 
1904   CHECK_JNI_EXCEPTION_(env, NULL);
1905 
1906   return path_string;
1907 WB_END
1908 
1909 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1910   return UseSharedSpaces;
1911 WB_END
1912 
1913 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
1914   return FileMapInfo::memory_mapping_failed();
1915 WB_END
1916 
1917 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1918   oop obj_oop = JNIHandles::resolve(obj);
1919   return HeapShared::is_archived_object(obj_oop);
1920 WB_END
1921 
1922 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1923   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1924 WB_END
1925 
1926 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
1927   return !HeapShared::closed_archive_heap_region_mapped();
1928 WB_END
1929 
1930 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
1931   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1932   if (k-&gt;is_instance_klass()) {
1933     InstanceKlass *ik = InstanceKlass::cast(k);
1934     ConstantPool *cp = ik-&gt;constants();
1935     objArrayOop refs =  cp-&gt;resolved_references();
1936     return (jobject)JNIHandles::make_local(THREAD, refs);
1937   } else {
1938     return NULL;
1939   }
1940 WB_END
1941 
1942 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1943   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1944   if (!k-&gt;is_instance_klass()) {
1945     return;
1946   }
1947   InstanceKlass *ik = InstanceKlass::cast(k);
1948   ik-&gt;link_class(THREAD); // may throw verification error
1949 WB_END
1950 
1951 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
1952   return HeapShared::open_archive_heap_region_mapped();
1953 WB_END
1954 
1955 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
1956 #if INCLUDE_CDS
1957   return true;
1958 #else
1959   return false;
1960 #endif // INCLUDE_CDS
1961 WB_END
1962 
1963 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
1964 #if COMPILER2_OR_JVMCI
1965   return true;
1966 #else
1967   return false;
1968 #endif
1969 WB_END
1970 
1971 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
1972   return HeapShared::is_heap_object_archiving_allowed();
1973 WB_END
1974 
1975 
1976 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
1977 #if INCLUDE_JFR
1978   return true;
1979 #else
1980   return false;
1981 #endif // INCLUDE_JFR
1982 WB_END
1983 
1984 #if INCLUDE_CDS
1985 
1986 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
1987   ResourceMark rm;
1988   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
1989   int result = CDSOffsets::find_offset(c_name);
1990   return (jint)result;
1991 WB_END
1992 
1993 #endif // INCLUDE_CDS
1994 
1995 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
1996   class TraceSelfClosure : public HandshakeClosure {
1997     jint _num_threads_completed;
1998 
1999     void do_thread(Thread* th) {
2000       assert(th-&gt;is_Java_thread(), "sanity");
2001       JavaThread* jt = (JavaThread*)th;
2002       ResourceMark rm;
2003 
2004       jt-&gt;print_on(tty);
2005       jt-&gt;print_stack_on(tty);
2006       tty-&gt;cr();
2007       Atomic::inc(&amp;_num_threads_completed);
2008     }
2009 
2010   public:
2011     TraceSelfClosure(Thread* thread) : HandshakeClosure("WB_TraceSelf"), _num_threads_completed(0) {}
2012 
2013     jint num_threads_completed() const { return _num_threads_completed; }
2014   };
2015   TraceSelfClosure tsc(Thread::current());
2016 
2017   if (all_threads) {
2018     Handshake::execute(&amp;tsc);
2019   } else {
2020     oop thread_oop = JNIHandles::resolve(thread_handle);
2021     if (thread_oop != NULL) {
2022       JavaThread* target = java_lang_Thread::thread(thread_oop);
2023       Handshake::execute(&amp;tsc, target);
2024     }
2025   }
2026   return tsc.num_threads_completed();
2027 WB_END
2028 
2029 //Some convenience methods to deal with objects from java
2030 int WhiteBox::offset_for_field(const char* field_name, oop object,
2031     Symbol* signature_symbol) {
2032   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, "Field name not valid");
2033   Thread* THREAD = Thread::current();
2034 
2035   //Get the class of our object
2036   Klass* arg_klass = object-&gt;klass();
2037   //Turn it into an instance-klass
2038   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2039 
2040   //Create symbols to look for in the class
2041   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2042 
2043   //To be filled in with an offset of the field we're looking for
2044   fieldDescriptor fd;
2045 
2046   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2047   if (res == NULL) {
2048     tty-&gt;print_cr("Invalid layout of %s at %s", ik-&gt;external_name(),
2049         name_symbol-&gt;as_C_string());
2050     vm_exit_during_initialization("Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class");
2051   }
2052 
2053   //fetch the field at the offset we've found
2054   int dest_offset = fd.offset();
2055 
2056   return dest_offset;
2057 }
2058 
2059 
2060 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2061   int offset = offset_for_field(field_name, object,
2062       vmSymbols::string_signature());
2063   oop string = object-&gt;obj_field(offset);
2064   if (string == NULL) {
2065     return NULL;
2066   }
2067   const char* ret = java_lang_String::as_utf8_string(string);
2068   return ret;
2069 }
2070 
2071 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2072   int offset =
2073       offset_for_field(field_name, object, vmSymbols::bool_signature());
2074   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2075   return ret;
2076 }
2077 
2078 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2079   ResourceMark rm;
2080   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
2081 
2082   //  one by one registration natives for exception catching
2083   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2084   CHECK_JNI_EXCEPTION(env);
2085   for (int i = 0, n = method_count; i &lt; n; ++i) {
2086     // Skip dummy entries
2087     if (method_array[i].fnPtr == NULL) continue;
2088     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2089       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2090       if (throwable_obj != NULL) {
2091         env-&gt;ExceptionClear();
2092         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2093           // NoSuchMethodError is thrown when a method can't be found or a method is not native.
2094           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2095           tty-&gt;print_cr("Warning: 'NoSuchMethodError' on register of sun.hotspot.WhiteBox::%s%s",
2096               method_array[i].name, method_array[i].signature);
2097         }
2098       } else {
2099         // Registration failed unexpectedly.
2100         tty-&gt;print_cr("Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered",
2101             method_array[i].name, method_array[i].signature);
2102         env-&gt;UnregisterNatives(wbclass);
2103         break;
2104       }
2105     }
2106   }
2107 }
2108 
2109 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2110   // can't be in VM when we call JNI
2111   ThreadToNativeFromVM ttnfv(thread);
2112   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2113   CHECK_JNI_EXCEPTION_(env, 0);
2114   int ret;
2115   {
2116     ThreadInVMfromNative ttvfn(thread); // back to VM
2117     ret = DirectivesParser::parse_string(dir, tty);
2118   }
2119   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2120   // -1 for error parsing directive. Return 0 as number of directives added.
2121   if (ret == -1) {
2122     ret = 0;
2123   }
2124   return (jint) ret;
2125 WB_END
2126 
2127 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2128   DirectivesStack::pop(count);
2129 WB_END
2130 
2131 // Checks that the library libfile has the noexecstack bit set.
2132 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2133   jboolean ret = false;
2134 #ifdef LINUX
2135   // Can't be in VM when we call JNI.
2136   ThreadToNativeFromVM ttnfv(thread);
2137   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2138   CHECK_JNI_EXCEPTION_(env, 0);
2139   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2140   env-&gt;ReleaseStringUTFChars(libfile, lf);
2141 #endif
2142   return ret;
2143 WB_END
2144 
2145 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2146   LINUX_ONLY(return OSContainer::is_containerized();)
2147   return false;
2148 WB_END
2149 
2150 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2151                                     jobject o,
2152                                     jstring proc_cgroups,
2153                                     jstring proc_self_cgroup,
2154                                     jstring proc_self_mountinfo))
2155   jint ret = 0;
2156 #ifdef LINUX
2157   ThreadToNativeFromVM ttnfv(thread);
2158   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2159   CHECK_JNI_EXCEPTION_(env, 0);
2160   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2161   CHECK_JNI_EXCEPTION_(env, 0);
2162   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2163   CHECK_JNI_EXCEPTION_(env, 0);
2164   u1 cg_type_flags = 0;
2165   // This sets cg_type_flags
2166   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2167   ret = (jint)cg_type_flags;
2168   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2169   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2170   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2171 #endif
2172   return ret;
2173 WB_END
2174 
2175 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2176   os::print_os_info(tty);
2177 WB_END
2178 
2179 // Elf decoder
2180 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2181 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2182   ElfFile::_do_not_cache_elf_section = true;
2183 #endif
2184 WB_END
2185 
2186 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2187   return (jlong) ResolvedMethodTable::items_count();
2188 WB_END
2189 
2190 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2191   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2192 WB_END
2193 
2194 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2195   jint result = 0;
2196 #if INCLUDE_AOT
2197   result = (jint) AOTLoader::heaps_count();
2198 #endif
2199   return result;
2200 WB_END
2201 
2202 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2203   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2204   // Return size in bytes.
2205   return k-&gt;size() * wordSize;
2206 WB_END
2207 
2208 // See test/hotspot/jtreg/runtime/Thread/ThreadObjAccessAtExit.java.
2209 // It explains how the thread's priority field is used for test state coordination.
2210 //
2211 WB_ENTRY(void, WB_CheckThreadObjOfTerminatingThread(JNIEnv* env, jobject wb, jobject target_handle))
2212   oop target_oop = JNIHandles::resolve_non_null(target_handle);
2213   jlong tid = java_lang_Thread::thread_id(target_oop);
2214   JavaThread* target = java_lang_Thread::thread(target_oop);
2215 
2216   // Grab a ThreadsListHandle to protect the target thread whilst terminating
2217   ThreadsListHandle tlh;
2218 
2219   // Look up the target thread by tid to ensure it is present
2220   JavaThread* t = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
2221   if (t == NULL) {
2222     THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread not found in ThreadsList!");
2223   }
2224 
2225   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is protected");
2226   // Allow target to terminate by boosting priority
2227   java_lang_Thread::set_priority(t-&gt;threadObj(), ThreadPriority(NormPriority + 1));
2228 
2229   // Now wait for the target to terminate
2230   while (!target-&gt;is_terminated()) {
2231     ThreadBlockInVM tbivm(thread);  // just in case target is involved in a safepoint
2232     os::naked_short_sleep(0);
2233   }
2234 
2235   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is terminated");
2236 
2237   // Now release the GC inducing thread - we have to re-resolve the external oop that
2238   // was passed in as GC may have occurred and we don't know if we can trust t-&gt;threadObj() now.
2239   oop original = JNIHandles::resolve_non_null(target_handle);
2240   java_lang_Thread::set_priority(original, ThreadPriority(NormPriority + 2));
2241 
2242   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: GC has been initiated - checking threadObj:");
2243 
2244   // The Java code should be creating garbage and triggering GC, which would potentially move
2245   // the threadObj oop. If the exiting thread is properly protected then its threadObj should
2246   // remain valid and equal to our initial target_handle. Loop a few times to give GC a chance to
2247   // kick in.
2248   for (int i = 0; i &lt; 5; i++) {
2249     oop original = JNIHandles::resolve_non_null(target_handle);
2250     oop current = t-&gt;threadObj();
2251     if (original != current) {
2252       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: failed comparison on iteration %d", i);
2253       THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread oop has changed!");
2254     } else {
2255       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: successful comparison on iteration %d", i);
2256       ThreadBlockInVM tbivm(thread);
2257       os::naked_short_sleep(50);
2258     }
2259   }
2260 WB_END
2261 
2262 WB_ENTRY(jboolean, WB_IsJVMTIIncluded(JNIEnv* env, jobject wb))
2263   return INCLUDE_JVMTI ? JNI_TRUE : JNI_FALSE;
2264 WB_END
2265 
2266 #define CC (char*)
2267 
2268 static JNINativeMethod methods[] = {
2269   {CC"getObjectAddress0",                CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectAddress  },
2270   {CC"getObjectSize0",                   CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectSize     },
2271   {CC"isObjectInOldGen0",                CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_isObjectInOldGen  },
2272   {CC"getHeapOopSize",                   CC"()I",                   (void*)&amp;WB_GetHeapOopSize    },
2273   {CC"getVMPageSize",                    CC"()I",                   (void*)&amp;WB_GetVMPageSize     },
2274   {CC"getVMAllocationGranularity",       CC"()J",                   (void*)&amp;WB_GetVMAllocationGranularity },
2275   {CC"getVMLargePageSize",               CC"()J",                   (void*)&amp;WB_GetVMLargePageSize},
2276   {CC"getHeapSpaceAlignment",            CC"()J",                   (void*)&amp;WB_GetHeapSpaceAlignment},
2277   {CC"getHeapAlignment",                 CC"()J",                   (void*)&amp;WB_GetHeapAlignment},
2278   {CC"countAliveClasses0",               CC"(Ljava/lang/String;)I", (void*)&amp;WB_CountAliveClasses },
2279   {CC"getSymbolRefcount",                CC"(Ljava/lang/String;)I", (void*)&amp;WB_GetSymbolRefcount },
2280   {CC"parseCommandLine0",
2281       CC"(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;",
2282       (void*) &amp;WB_ParseCommandLine
2283   },
2284   {CC"addToBootstrapClassLoaderSearch0", CC"(Ljava/lang/String;)V",
2285                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2286   {CC"addToSystemClassLoaderSearch0",    CC"(Ljava/lang/String;)V",
2287                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2288   {CC"getCompressedOopsMaxHeapSize", CC"()J",
2289       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2290   {CC"printHeapSizes",     CC"()V",                   (void*)&amp;WB_PrintHeapSizes    },
2291   {CC"runMemoryUnitTests", CC"()V",                   (void*)&amp;WB_RunMemoryUnitTests},
2292   {CC"readFromNoaccessArea",CC"()V",                  (void*)&amp;WB_ReadFromNoaccessArea},
2293   {CC"stressVirtualSpaceResize",CC"(JJJ)I",           (void*)&amp;WB_StressVirtualSpaceResize},
2294 #if INCLUDE_CDS
2295   {CC"getOffsetForName0", CC"(Ljava/lang/String;)I",  (void*)&amp;WB_GetOffsetForName},
2296 #endif
2297 #if INCLUDE_G1GC
2298   {CC"g1InConcurrentMark", CC"()Z",                   (void*)&amp;WB_G1InConcurrentMark},
2299   {CC"g1IsHumongous0",      CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_G1IsHumongous     },
2300   {CC"g1BelongsToHumongousRegion0", CC"(J)Z",         (void*)&amp;WB_G1BelongsToHumongousRegion},
2301   {CC"g1BelongsToFreeRegion0", CC"(J)Z",              (void*)&amp;WB_G1BelongsToFreeRegion},
2302   {CC"g1NumMaxRegions",    CC"()J",                   (void*)&amp;WB_G1NumMaxRegions  },
2303   {CC"g1NumFreeRegions",   CC"()J",                   (void*)&amp;WB_G1NumFreeRegions  },
2304   {CC"g1RegionSize",       CC"()I",                   (void*)&amp;WB_G1RegionSize      },
2305   {CC"g1StartConcMarkCycle",       CC"()Z",           (void*)&amp;WB_G1StartMarkCycle  },
2306   {CC"g1AuxiliaryMemoryUsage", CC"()Ljava/lang/management/MemoryUsage;",
2307                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2308   {CC"g1ActiveMemoryNodeCount", CC"()I",              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2309   {CC"g1MemoryNodeIds",    CC"()[I",                  (void*)&amp;WB_G1MemoryNodeIds },
2310   {CC"g1GetMixedGCInfo",   CC"(I)[J",                 (void*)&amp;WB_G1GetMixedGCInfo },
2311 #endif // INCLUDE_G1GC
2312 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2313   {CC"dramReservedStart",   CC"()J",                  (void*)&amp;WB_DramReservedStart },
2314   {CC"dramReservedEnd",     CC"()J",                  (void*)&amp;WB_DramReservedEnd },
2315   {CC"nvdimmReservedStart", CC"()J",                  (void*)&amp;WB_NvdimmReservedStart },
2316   {CC"nvdimmReservedEnd",   CC"()J",                  (void*)&amp;WB_NvdimmReservedEnd },
2317 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2318 #if INCLUDE_PARALLELGC
2319   {CC"psVirtualSpaceAlignment",CC"()J",               (void*)&amp;WB_PSVirtualSpaceAlignment},
2320   {CC"psHeapGenerationAlignment",CC"()J",             (void*)&amp;WB_PSHeapGenerationAlignment},
2321 #endif
2322 #if INCLUDE_NMT
2323   {CC"NMTMalloc",           CC"(J)J",                 (void*)&amp;WB_NMTMalloc          },
2324   {CC"NMTMallocWithPseudoStack", CC"(JI)J",           (void*)&amp;WB_NMTMallocWithPseudoStack},
2325   {CC"NMTMallocWithPseudoStackAndType", CC"(JII)J",   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2326   {CC"NMTFree",             CC"(J)V",                 (void*)&amp;WB_NMTFree            },
2327   {CC"NMTReserveMemory",    CC"(J)J",                 (void*)&amp;WB_NMTReserveMemory   },
2328   {CC"NMTAttemptReserveMemoryAt",    CC"(JJ)J",       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2329   {CC"NMTCommitMemory",     CC"(JJ)V",                (void*)&amp;WB_NMTCommitMemory    },
2330   {CC"NMTUncommitMemory",   CC"(JJ)V",                (void*)&amp;WB_NMTUncommitMemory  },
2331   {CC"NMTReleaseMemory",    CC"(JJ)V",                (void*)&amp;WB_NMTReleaseMemory   },
2332   {CC"NMTChangeTrackingLevel", CC"()Z",               (void*)&amp;WB_NMTChangeTrackingLevel},
2333   {CC"NMTGetHashSize",      CC"()I",                  (void*)&amp;WB_NMTGetHashSize     },
2334   {CC"NMTNewArena",         CC"(J)J",                 (void*)&amp;WB_NMTNewArena        },
2335   {CC"NMTFreeArena",        CC"(J)V",                 (void*)&amp;WB_NMTFreeArena       },
2336   {CC"NMTArenaMalloc",      CC"(JJ)V",                (void*)&amp;WB_NMTArenaMalloc     },
2337 #endif // INCLUDE_NMT
2338   {CC"deoptimizeFrames",   CC"(Z)I",                  (void*)&amp;WB_DeoptimizeFrames  },
2339   {CC"deoptimizeAll",      CC"()V",                   (void*)&amp;WB_DeoptimizeAll     },
2340   {CC"deoptimizeMethod0",   CC"(Ljava/lang/reflect/Executable;Z)I",
2341                                                       (void*)&amp;WB_DeoptimizeMethod  },
2342   {CC"isMethodCompiled0",   CC"(Ljava/lang/reflect/Executable;Z)Z",
2343                                                       (void*)&amp;WB_IsMethodCompiled  },
2344   {CC"isMethodCompilable0", CC"(Ljava/lang/reflect/Executable;IZ)Z",
2345                                                       (void*)&amp;WB_IsMethodCompilable},
2346   {CC"isMethodQueuedForCompilation0",
2347       CC"(Ljava/lang/reflect/Executable;)Z",          (void*)&amp;WB_IsMethodQueuedForCompilation},
2348   {CC"isIntrinsicAvailable0",
2349       CC"(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z",
2350                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2351   {CC"makeMethodNotCompilable0",
2352       CC"(Ljava/lang/reflect/Executable;IZ)V",        (void*)&amp;WB_MakeMethodNotCompilable},
2353   {CC"testSetDontInlineMethod0",
2354       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetDontInlineMethod},
2355   {CC"getMethodCompilationLevel0",
2356       CC"(Ljava/lang/reflect/Executable;Z)I",         (void*)&amp;WB_GetMethodCompilationLevel},
2357   {CC"getMethodEntryBci0",
2358       CC"(Ljava/lang/reflect/Executable;)I",          (void*)&amp;WB_GetMethodEntryBci},
2359   {CC"getCompileQueueSize",
2360       CC"(I)I",                                       (void*)&amp;WB_GetCompileQueueSize},
2361   {CC"testSetForceInlineMethod0",
2362       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetForceInlineMethod},
2363   {CC"enqueueMethodForCompilation0",
2364       CC"(Ljava/lang/reflect/Executable;II)Z",        (void*)&amp;WB_EnqueueMethodForCompilation},
2365   {CC"enqueueInitializerForCompilation0",
2366       CC"(Ljava/lang/Class;I)Z",                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2367   {CC"markMethodProfiled",
2368       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_MarkMethodProfiled},
2369   {CC"clearMethodState0",
2370       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_ClearMethodState},
2371   {CC"lockCompilation",    CC"()V",                   (void*)&amp;WB_LockCompilation},
2372   {CC"unlockCompilation",  CC"()V",                   (void*)&amp;WB_UnlockCompilation},
2373   {CC"matchesMethod",
2374       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2375                                                       (void*)&amp;WB_MatchesMethod},
2376   {CC"matchesInline",
2377       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2378                                                       (void*)&amp;WB_MatchesInline},
2379   {CC"shouldPrintAssembly",
2380         CC"(Ljava/lang/reflect/Executable;I)Z",
2381                                                         (void*)&amp;WB_ShouldPrintAssembly},
2382 
2383   {CC"isConstantVMFlag",   CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsConstantVMFlag},
2384   {CC"isLockedVMFlag",     CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsLockedVMFlag},
2385   {CC"setBooleanVMFlag",   CC"(Ljava/lang/String;Z)V",(void*)&amp;WB_SetBooleanVMFlag},
2386   {CC"setIntVMFlag",       CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntVMFlag},
2387   {CC"setUintVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintVMFlag},
2388   {CC"setIntxVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntxVMFlag},
2389   {CC"setUintxVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintxVMFlag},
2390   {CC"setUint64VMFlag",    CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUint64VMFlag},
2391   {CC"setSizeTVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetSizeTVMFlag},
2392   {CC"setDoubleVMFlag",    CC"(Ljava/lang/String;D)V",(void*)&amp;WB_SetDoubleVMFlag},
2393   {CC"setStringVMFlag",    CC"(Ljava/lang/String;Ljava/lang/String;)V",
2394                                                       (void*)&amp;WB_SetStringVMFlag},
2395   {CC"getBooleanVMFlag",   CC"(Ljava/lang/String;)Ljava/lang/Boolean;",
2396                                                       (void*)&amp;WB_GetBooleanVMFlag},
2397   {CC"getIntVMFlag",       CC"(Ljava/lang/String;)Ljava/lang/Long;",
2398                                                       (void*)&amp;WB_GetIntVMFlag},
2399   {CC"getUintVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2400                                                       (void*)&amp;WB_GetUintVMFlag},
2401   {CC"getIntxVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2402                                                       (void*)&amp;WB_GetIntxVMFlag},
2403   {CC"getUintxVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2404                                                       (void*)&amp;WB_GetUintxVMFlag},
2405   {CC"getUint64VMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Long;",
2406                                                       (void*)&amp;WB_GetUint64VMFlag},
2407   {CC"getSizeTVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2408                                                       (void*)&amp;WB_GetSizeTVMFlag},
2409   {CC"getDoubleVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Double;",
2410                                                       (void*)&amp;WB_GetDoubleVMFlag},
2411   {CC"getStringVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/String;",
2412                                                       (void*)&amp;WB_GetStringVMFlag},
2413   {CC"isInStringTable",    CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsInStringTable  },
2414   {CC"fullGC",   CC"()V",                             (void*)&amp;WB_FullGC },
2415   {CC"youngGC",  CC"()V",                             (void*)&amp;WB_YoungGC },
2416   {CC"readReservedMemory", CC"()V",                   (void*)&amp;WB_ReadReservedMemory },
2417   {CC"allocateMetaspace",
2418      CC"(Ljava/lang/ClassLoader;J)J",                 (void*)&amp;WB_AllocateMetaspace },
2419   {CC"freeMetaspace",
2420      CC"(Ljava/lang/ClassLoader;JJ)V",                (void*)&amp;WB_FreeMetaspace },
2421   {CC"incMetaspaceCapacityUntilGC", CC"(J)J",         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2422   {CC"metaspaceCapacityUntilGC", CC"()J",             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2423   {CC"metaspaceReserveAlignment", CC"()J",            (void*)&amp;WB_MetaspaceReserveAlignment },
2424   {CC"getCPUFeatures",     CC"()Ljava/lang/String;",  (void*)&amp;WB_GetCPUFeatures     },
2425   {CC"getNMethod0",         CC"(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;",
2426                                                       (void*)&amp;WB_GetNMethod         },
2427   {CC"forceNMethodSweep",  CC"()V",                   (void*)&amp;WB_ForceNMethodSweep  },
2428   {CC"allocateCodeBlob",   CC"(II)J",                 (void*)&amp;WB_AllocateCodeBlob   },
2429   {CC"freeCodeBlob",       CC"(J)V",                  (void*)&amp;WB_FreeCodeBlob       },
2430   {CC"getCodeHeapEntries", CC"(I)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeHeapEntries },
2431   {CC"getCompilationActivityMode",
2432                            CC"()I",                   (void*)&amp;WB_GetCompilationActivityMode},
2433   {CC"getMethodData0",     CC"(Ljava/lang/reflect/Executable;)J",
2434                                                       (void*)&amp;WB_GetMethodData      },
2435   {CC"getCodeBlob",        CC"(J)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeBlob        },
2436   {CC"getThreadStackSize", CC"()J",                   (void*)&amp;WB_GetThreadStackSize },
2437   {CC"getThreadRemainingStackSize", CC"()J",          (void*)&amp;WB_GetThreadRemainingStackSize },
2438   {CC"DefineModule",       CC"(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V",
2439                                                       (void*)&amp;WB_DefineModule },
2440   {CC"AddModuleExports",   CC"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V",
2441                                                       (void*)&amp;WB_AddModuleExports },
2442   {CC"AddReadsModule",     CC"(Ljava/lang/Object;Ljava/lang/Object;)V",
2443                                                       (void*)&amp;WB_AddReadsModule },
2444   {CC"AddModuleExportsToAllUnnamed", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2445                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2446   {CC"AddModuleExportsToAll", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2447                                                       (void*)&amp;WB_AddModuleExportsToAll },
2448   {CC"deflateIdleMonitors", CC"()Z",                  (void*)&amp;WB_DeflateIdleMonitors },
2449   {CC"isMonitorInflated0", CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsMonitorInflated  },
2450   {CC"forceSafepoint",     CC"()V",                   (void*)&amp;WB_ForceSafepoint     },
2451   {CC"getConstantPool0",   CC"(Ljava/lang/Class;)J",  (void*)&amp;WB_GetConstantPool    },
2452   {CC"getConstantPoolCacheIndexTag0", CC"()I",  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2453   {CC"getConstantPoolCacheLength0", CC"(Ljava/lang/Class;)I",  (void*)&amp;WB_GetConstantPoolCacheLength},
2454   {CC"remapInstructionOperandFromCPCache0",
2455       CC"(Ljava/lang/Class;I)I",                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2456   {CC"encodeConstantPoolIndyIndex0",
2457       CC"(I)I",                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2458   {CC"getMethodBooleanOption",
2459       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;",
2460                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2461   {CC"getMethodIntxOption",
2462       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2463                                                       (void*)&amp;WB_GetMethodIntxOption},
2464   {CC"getMethodUintxOption",
2465       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2466                                                       (void*)&amp;WB_GetMethodUintxOption},
2467   {CC"getMethodDoubleOption",
2468       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;",
2469                                                       (void*)&amp;WB_GetMethodDoubleOption},
2470   {CC"getMethodStringOption",
2471       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;",
2472                                                       (void*)&amp;WB_GetMethodStringOption},
2473   {CC"getDefaultArchivePath",             CC"()Ljava/lang/String;",
2474                                                       (void*)&amp;WB_GetDefaultArchivePath},
2475   {CC"isSharingEnabled",   CC"()Z",                   (void*)&amp;WB_IsSharingEnabled},
2476   {CC"isShared",           CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsShared },
2477   {CC"isSharedClass",      CC"(Ljava/lang/Class;)Z",  (void*)&amp;WB_IsSharedClass },
2478   {CC"areSharedStringsIgnored",           CC"()Z",    (void*)&amp;WB_AreSharedStringsIgnored },
2479   {CC"getResolvedReferences", CC"(Ljava/lang/Class;)Ljava/lang/Object;", (void*)&amp;WB_GetResolvedReferences},
2480   {CC"linkClass",          CC"(Ljava/lang/Class;)V",  (void*)&amp;WB_LinkClass},
2481   {CC"areOpenArchiveHeapObjectsMapped",   CC"()Z",    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2482   {CC"isCDSIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2483   {CC"isJFRIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2484   {CC"isC2OrJVMCIIncludedInVmBuild",      CC"()Z",    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2485   {CC"isJavaHeapArchiveSupported",        CC"()Z",    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2486   {CC"cdsMemoryMappingFailed",            CC"()Z",    (void*)&amp;WB_CDSMemoryMappingFailed },
2487 
2488   {CC"clearInlineCaches0",  CC"(Z)V",                 (void*)&amp;WB_ClearInlineCaches },
2489   {CC"handshakeWalkStack", CC"(Ljava/lang/Thread;Z)I", (void*)&amp;WB_HandshakeWalkStack },
2490   {CC"checkThreadObjOfTerminatingThread", CC"(Ljava/lang/Thread;)V", (void*)&amp;WB_CheckThreadObjOfTerminatingThread },
2491   {CC"addCompilerDirective",    CC"(Ljava/lang/String;)I",
2492                                                       (void*)&amp;WB_AddCompilerDirective },
2493   {CC"removeCompilerDirective",   CC"(I)V",           (void*)&amp;WB_RemoveCompilerDirective },
2494   {CC"isGCSupported",             CC"(I)Z",           (void*)&amp;WB_IsGCSupported},
2495   {CC"isGCSelected",              CC"(I)Z",           (void*)&amp;WB_IsGCSelected},
2496   {CC"isGCSelectedErgonomically", CC"()Z",            (void*)&amp;WB_IsGCSelectedErgonomically},
2497   {CC"supportsConcurrentGCBreakpoints", CC"()Z",      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2498   {CC"concurrentGCAcquireControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCAcquireControl},
2499   {CC"concurrentGCReleaseControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCReleaseControl},
2500   {CC"concurrentGCRunToIdle0",    CC"()V",            (void*)&amp;WB_ConcurrentGCRunToIdle},
2501   {CC"concurrentGCRunTo0",        CC"(Ljava/lang/String;)Z",
2502                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2503   {CC"checkLibSpecifiesNoexecstack", CC"(Ljava/lang/String;)Z",
2504                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2505   {CC"isContainerized",           CC"()Z",            (void*)&amp;WB_IsContainerized },
2506   {CC"validateCgroup",
2507       CC"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
2508                                                       (void*)&amp;WB_ValidateCgroup },
2509   {CC"printOsInfo",               CC"()V",            (void*)&amp;WB_PrintOsInfo },
2510   {CC"disableElfSectionCache",    CC"()V",            (void*)&amp;WB_DisableElfSectionCache },
2511   {CC"resolvedMethodItemsCount",  CC"()J",            (void*)&amp;WB_ResolvedMethodItemsCount },
2512   {CC"protectionDomainRemovedCount",   CC"()I",       (void*)&amp;WB_ProtectionDomainRemovedCount },
2513   {CC"aotLibrariesCount", CC"()I",                    (void*)&amp;WB_AotLibrariesCount },
2514   {CC"getKlassMetadataSize", CC"(Ljava/lang/Class;)I",(void*)&amp;WB_GetKlassMetadataSize},
2515   {CC"isJVMTIIncluded", CC"()Z",                      (void*)&amp;WB_IsJVMTIIncluded},
2516 };
2517 
2518 
2519 #undef CC
2520 
2521 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2522   {
2523     if (WhiteBoxAPI) {
2524       // Make sure that wbclass is loaded by the null classloader
2525       InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));
2526       Handle loader(THREAD, ik-&gt;class_loader());
2527       if (loader.is_null()) {
2528         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2529         WhiteBox::set_used();
2530       }
2531     }
2532   }
2533 JVM_END
</pre></body></html>
