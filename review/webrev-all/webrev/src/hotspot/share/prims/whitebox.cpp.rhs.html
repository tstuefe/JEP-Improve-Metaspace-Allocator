<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60818">60818</a> : imported patch jep387-all.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 
  27 #include &lt;new&gt;
  28 
  29 #include "classfile/classLoaderDataGraph.hpp"
  30 #include "classfile/javaClasses.inline.hpp"
  31 #include "classfile/modules.hpp"
  32 #include "classfile/protectionDomainCache.hpp"
  33 #include "classfile/stringTable.hpp"
  34 #include "classfile/symbolTable.hpp"
  35 #include "code/codeCache.hpp"
  36 #include "compiler/compilationPolicy.hpp"
  37 #include "compiler/methodMatcher.hpp"
  38 #include "compiler/directivesParser.hpp"
  39 #include "gc/shared/concurrentGCBreakpoints.hpp"
  40 #include "gc/shared/gcConfig.hpp"
  41 #include "gc/shared/genArguments.hpp"
  42 #include "gc/shared/genCollectedHeap.hpp"
  43 #include "jvmtifiles/jvmtiEnv.hpp"
  44 #include "logging/log.hpp"
  45 #include "memory/filemap.hpp"
  46 #include "memory/heapShared.inline.hpp"
  47 #include "memory/metaspaceShared.hpp"
  48 #include "memory/metadataFactory.hpp"
<a name="1" id="anc1"></a><span class="new">  49 #include "memory/metaspace/msTestHelpers.hpp"</span>
  50 #include "memory/iterator.hpp"
  51 #include "memory/resourceArea.hpp"
  52 #include "memory/universe.hpp"
  53 #include "memory/oopFactory.hpp"
  54 #include "oops/array.hpp"
  55 #include "oops/compressedOops.hpp"
  56 #include "oops/constantPool.inline.hpp"
  57 #include "oops/method.inline.hpp"
  58 #include "oops/objArrayKlass.hpp"
  59 #include "oops/objArrayOop.inline.hpp"
  60 #include "oops/oop.inline.hpp"
  61 #include "oops/typeArrayOop.inline.hpp"
  62 #include "prims/resolvedMethodTable.hpp"
  63 #include "prims/wbtestmethods/parserTests.hpp"
  64 #include "prims/whitebox.inline.hpp"
  65 #include "runtime/arguments.hpp"
  66 #include "runtime/atomic.hpp"
  67 #include "runtime/deoptimization.hpp"
  68 #include "runtime/fieldDescriptor.inline.hpp"
  69 #include "runtime/flags/jvmFlag.hpp"
  70 #include "runtime/frame.inline.hpp"
  71 #include "runtime/handles.inline.hpp"
  72 #include "runtime/handshake.hpp"
  73 #include "runtime/interfaceSupport.inline.hpp"
  74 #include "runtime/javaCalls.hpp"
  75 #include "runtime/jniHandles.inline.hpp"
  76 #include "runtime/os.hpp"
  77 #include "runtime/sweeper.hpp"
  78 #include "runtime/synchronizer.hpp"
  79 #include "runtime/thread.hpp"
  80 #include "runtime/threadSMR.hpp"
  81 #include "runtime/vm_version.hpp"
  82 #include "services/memoryService.hpp"
  83 #include "utilities/align.hpp"
  84 #include "utilities/debug.hpp"
  85 #include "utilities/elfFile.hpp"
  86 #include "utilities/exceptions.hpp"
  87 #include "utilities/macros.hpp"
<a name="2" id="anc2"></a><span class="new">  88 #include "utilities/ostream.hpp"</span>
  89 #if INCLUDE_CDS
  90 #include "prims/cdsoffsets.hpp"
  91 #endif // INCLUDE_CDS
  92 #if INCLUDE_G1GC
  93 #include "gc/g1/g1Arguments.hpp"
  94 #include "gc/g1/g1CollectedHeap.inline.hpp"
  95 #include "gc/g1/g1ConcurrentMark.hpp"
  96 #include "gc/g1/g1ConcurrentMarkThread.hpp"
  97 #include "gc/g1/heapRegionRemSet.hpp"
  98 #include "gc/g1/heterogeneousHeapRegionManager.hpp"
  99 #endif // INCLUDE_G1GC
 100 #if INCLUDE_PARALLELGC
 101 #include "gc/parallel/parallelScavengeHeap.inline.hpp"
 102 #endif // INCLUDE_PARALLELGC
 103 #if INCLUDE_NMT
 104 #include "services/mallocSiteTable.hpp"
 105 #include "services/memTracker.hpp"
 106 #include "utilities/nativeCallStack.hpp"
 107 #endif // INCLUDE_NMT
 108 #if INCLUDE_AOT
 109 #include "aot/aotLoader.hpp"
 110 #endif // INCLUDE_AOT
 111 
 112 #ifdef LINUX
 113 #include "osContainer_linux.hpp"
 114 #include "cgroupSubsystem_linux.hpp"
 115 #endif
 116 
 117 #define SIZE_T_MAX_VALUE ((size_t) -1)
 118 
 119 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 120   do {                                                                 \
 121     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 122     THREAD-&gt;clear_pending_jni_exception_check();                       \
 123     if (HAS_PENDING_EXCEPTION) {                                       \
 124       return(value);                                                   \
 125     }                                                                  \
 126   } while (0)
 127 
 128 #define CHECK_JNI_EXCEPTION(env)                                       \
 129   do {                                                                 \
 130     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 131     THREAD-&gt;clear_pending_jni_exception_check();                       \
 132     if (HAS_PENDING_EXCEPTION) {                                       \
 133       return;                                                          \
 134     }                                                                  \
 135   } while (0)
 136 
 137 bool WhiteBox::_used = false;
 138 volatile bool WhiteBox::compilation_locked = false;
 139 
 140 class VM_WhiteBoxOperation : public VM_Operation {
 141  public:
 142   VM_WhiteBoxOperation()                         { }
 143   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 144   bool allow_nested_vm_operations() const        { return true; }
 145 };
 146 
 147 
 148 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 149   return (jlong)(void*)JNIHandles::resolve(obj);
 150 WB_END
 151 
 152 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 153   return heapOopSize;
 154 WB_END
 155 
 156 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 157   return os::vm_page_size();
 158 WB_END
 159 
 160 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 161   return os::vm_allocation_granularity();
 162 WB_END
 163 
 164 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 165   return os::large_page_size();
 166 WB_END
 167 
 168 class WBIsKlassAliveClosure : public LockedClassesDo {
 169     Symbol* _name;
 170     int _count;
 171 public:
 172     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 173 
 174     void do_klass(Klass* k) {
 175       Symbol* ksym = k-&gt;name();
 176       if (ksym-&gt;fast_compare(_name) == 0) {
 177         _count++;
 178       }
 179     }
 180 
 181     int count() const {
 182         return _count;
 183     }
 184 };
 185 
 186 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 187   oop h_name = JNIHandles::resolve(name);
 188   if (h_name == NULL) return false;
 189   Symbol* sym = java_lang_String::as_symbol(h_name);
 190   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 191 
 192   WBIsKlassAliveClosure closure(sym);
 193   ClassLoaderDataGraph::classes_do(&amp;closure);
 194 
 195   // Return the count of alive classes with this name.
 196   return closure.count();
 197 WB_END
 198 
 199 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 200   oop h_name = JNIHandles::resolve(name);
 201   if (h_name == NULL) return false;
 202   Symbol* sym = java_lang_String::as_symbol(h_name);
 203   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 204   return (jint)sym-&gt;refcount();
 205 WB_END
 206 
 207 
 208 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 209 #if INCLUDE_JVMTI
 210   ResourceMark rm;
 211   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 212   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 213   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 214   assert(err == JVMTI_ERROR_NONE, "must not fail");
 215 #endif
 216 }
 217 WB_END
 218 
 219 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 220 #if INCLUDE_JVMTI
 221   ResourceMark rm;
 222   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 223   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 224   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 225   assert(err == JVMTI_ERROR_NONE, "must not fail");
 226 #endif
 227 }
 228 WB_END
 229 
 230 
 231 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 232   return (jlong)Arguments::max_heap_for_compressed_oops();
 233 }
 234 WB_END
 235 
 236 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 237   tty-&gt;print_cr("Minimum heap " SIZE_FORMAT " Initial heap " SIZE_FORMAT " "
 238                 "Maximum heap " SIZE_FORMAT " Space alignment " SIZE_FORMAT " Heap alignment " SIZE_FORMAT,
 239                 MinHeapSize,
 240                 InitialHeapSize,
 241                 MaxHeapSize,
 242                 SpaceAlignment,
 243                 HeapAlignment);
 244 }
 245 WB_END
 246 
 247 #ifndef PRODUCT
 248 // Forward declaration
 249 void TestReservedSpace_test();
 250 void TestReserveMemorySpecial_test();
 251 void TestVirtualSpace_test();
 252 #endif
 253 
 254 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 255 #ifndef PRODUCT
 256   TestReservedSpace_test();
 257   TestReserveMemorySpecial_test();
 258   TestVirtualSpace_test();
 259 #endif
 260 WB_END
 261 
 262 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 263   size_t granularity = os::vm_allocation_granularity();
 264   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 265   VirtualSpace vs;
 266   vs.initialize(rhs, 50 * granularity);
 267 
 268   // Check if constraints are complied
 269   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 270          CompressedOops::base() != NULL &amp;&amp;
 271          CompressedOops::use_implicit_null_checks() )) {
 272     tty-&gt;print_cr("WB_ReadFromNoaccessArea method is useless:\n "
 273                   "\tUseCompressedOops is %d\n"
 274                   "\trhs.base() is " PTR_FORMAT "\n"
 275                   "\tCompressedOops::base() is " PTR_FORMAT "\n"
 276                   "\tCompressedOops::use_implicit_null_checks() is %d",
 277                   UseCompressedOops,
 278                   p2i(rhs.base()),
 279                   p2i(CompressedOops::base()),
 280                   CompressedOops::use_implicit_null_checks());
 281     return;
 282   }
 283   tty-&gt;print_cr("Reading from no access area... ");
 284   tty-&gt;print_cr("*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c",
 285                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 286 WB_END
 287 
 288 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 289                                            size_t magnitude, size_t iterations) {
 290   size_t granularity = os::vm_allocation_granularity();
 291   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 292   VirtualSpace vs;
 293   if (!vs.initialize(rhs, 0)) {
 294     tty-&gt;print_cr("Failed to initialize VirtualSpace. Can't proceed.");
 295     return 3;
 296   }
 297 
 298   int seed = os::random();
 299   tty-&gt;print_cr("Random seed is %d", seed);
 300   os::init_random(seed);
 301 
 302   for (size_t i = 0; i &lt; iterations; i++) {
 303 
 304     // Whether we will shrink or grow
 305     bool shrink = os::random() % 2L == 0;
 306 
 307     // Get random delta to resize virtual space
 308     size_t delta = (size_t)os::random() % magnitude;
 309 
 310     // If we are about to shrink virtual space below zero, then expand instead
 311     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 312       shrink = false;
 313     }
 314 
 315     // Resizing by delta
 316     if (shrink) {
 317       vs.shrink_by(delta);
 318     } else {
 319       // If expanding fails expand_by will silently return false
 320       vs.expand_by(delta, true);
 321     }
 322   }
 323   return 0;
 324 }
 325 
 326 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 327         jlong reserved_space_size, jlong magnitude, jlong iterations))
 328   tty-&gt;print_cr("reservedSpaceSize=" JLONG_FORMAT ", magnitude=" JLONG_FORMAT ", "
 329                 "iterations=" JLONG_FORMAT "\n", reserved_space_size, magnitude,
 330                 iterations);
 331   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 332     tty-&gt;print_cr("One of variables printed above is negative. Can't proceed.\n");
 333     return 1;
 334   }
 335 
 336   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 337   // always 8 byte. That's why we should avoid overflow in case of 32bit platform.
 338   if (sizeof(size_t) &lt; sizeof(jlong)) {
 339     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 340     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 341         || iterations &gt; size_t_max_value) {
 342       tty-&gt;print_cr("One of variables printed above overflows size_t. Can't proceed.\n");
 343       return 2;
 344     }
 345   }
 346 
 347   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 348                                         (size_t) magnitude, (size_t) iterations);
 349 WB_END
 350 
 351 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 352   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 353 WB_END
 354 
 355 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 356   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 357 WB_END
 358 
 359 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 360   return GCConfig::is_gc_selected_ergonomically();
 361 WB_END
 362 
 363 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 364   oop p = JNIHandles::resolve(obj);
 365 #if INCLUDE_G1GC
 366   if (UseG1GC) {
 367     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 368     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 369     if (hr == NULL) {
 370       return false;
 371     }
 372     return !(hr-&gt;is_young());
 373   }
 374 #endif
 375 #if INCLUDE_PARALLELGC
 376   if (UseParallelGC) {
 377     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 378     return !psh-&gt;is_in_young(p);
 379   }
 380 #endif
 381 #if INCLUDE_ZGC
 382   if (UseZGC) {
 383     return Universe::heap()-&gt;is_in(p);
 384   }
 385 #endif
 386   GenCollectedHeap* gch = GenCollectedHeap::heap();
 387   return !gch-&gt;is_in_young(p);
 388 WB_END
 389 
 390 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 391   oop p = JNIHandles::resolve(obj);
 392   return p-&gt;size() * HeapWordSize;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 396   return (jlong)SpaceAlignment;
 397 WB_END
 398 
 399 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 400   return (jlong)HeapAlignment;
 401 WB_END
 402 
 403 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 404   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 405 WB_END
 406 
 407 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 408   ConcurrentGCBreakpoints::acquire_control();
 409 WB_END
 410 
 411 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 412   ConcurrentGCBreakpoints::release_control();
 413 WB_END
 414 
 415 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 416   ConcurrentGCBreakpoints::run_to_idle();
 417 WB_END
 418 
 419 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 420   Handle h_name(THREAD, JNIHandles::resolve(at));
 421   ResourceMark rm;
 422   const char* c_name = java_lang_String::as_utf8_string(h_name());
 423   return ConcurrentGCBreakpoints::run_to(c_name);
 424 WB_END
 425 
 426 #if INCLUDE_G1GC
 427 
 428 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 429   if (UseG1GC) {
 430     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 431     oop result = JNIHandles::resolve(obj);
 432     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 433     return hr-&gt;is_humongous();
 434   }
 435   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1IsHumongous: G1 GC is not enabled");
 436 WB_END
 437 
 438 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 439   if (UseG1GC) {
 440     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 441     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 442     return hr-&gt;is_humongous();
 443   }
 444   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToHumongousRegion: G1 GC is not enabled");
 445 WB_END
 446 
 447 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 448   if (UseG1GC) {
 449     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 450     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 451     return hr-&gt;is_free();
 452   }
 453   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1BelongsToFreeRegion: G1 GC is not enabled");
 454 WB_END
 455 
 456 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 457   if (UseG1GC) {
 458     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 459     size_t nr = g1h-&gt;max_regions();
 460     return (jlong)nr;
 461   }
 462   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumMaxRegions: G1 GC is not enabled");
 463 WB_END
 464 
 465 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 466   if (UseG1GC) {
 467     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 468     size_t nr = g1h-&gt;num_free_regions();
 469     return (jlong)nr;
 470   }
 471   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1NumFreeRegions: G1 GC is not enabled");
 472 WB_END
 473 
 474 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 475   if (UseG1GC) {
 476     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 477     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 478   }
 479   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1InConcurrentMark: G1 GC is not enabled");
 480 WB_END
 481 
 482 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 483   if (UseG1GC) {
 484     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 485     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 486       g1h-&gt;collect(GCCause::_wb_conc_mark);
 487       return true;
 488     }
 489     return false;
 490   }
 491   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1StartMarkCycle: G1 GC is not enabled");
 492 WB_END
 493 
 494 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 495   if (UseG1GC) {
 496     return (jint)HeapRegion::GrainBytes;
 497   }
 498   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1RegionSize: G1 GC is not enabled");
 499 WB_END
 500 
 501 #endif // INCLUDE_G1GC
 502 
 503 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 504 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 505 #if INCLUDE_G1GC
 506   if (UseG1GC) {
 507     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 508     HeapWord* base = g1h-&gt;reserved().start();
 509     if (g1h-&gt;is_heterogeneous_heap()) {
 510       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 511       return (jlong)(base + start_region * HeapRegion::GrainBytes);
 512     } else {
 513       return (jlong)base;
 514     }
 515   }
 516 #endif // INCLUDE_G1GC
 517 #if INCLUDE_PARALLELGC
 518   if (UseParallelGC) {
 519     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 520     if (AllocateOldGenAt != NULL) {
 521       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 522       return (jlong)reserved.start();
 523     } else {
 524       return (jlong)ps_heap-&gt;base();
 525     }
 526   }
 527 #endif // INCLUDE_PARALLELGC
 528   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedStart: enabled only for G1 and Parallel GC");
 529 WB_END
 530 
 531 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 532 #if INCLUDE_G1GC
 533   if (UseG1GC) {
 534     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 535     HeapWord* base = g1h-&gt;reserved().start();
 536     if (g1h-&gt;is_heterogeneous_heap()) {
 537       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 538       return (jlong)(base + (end_region + 1) * HeapRegion::GrainBytes - 1);
 539     } else {
 540       return (jlong)base + G1Arguments::heap_max_size_bytes();
 541     }
 542   }
 543 #endif // INCLUDE_G1GC
 544 #if INCLUDE_PARALLELGC
 545   if (UseParallelGC) {
 546     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 547     if (AllocateOldGenAt != NULL) {
 548       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 549       return (jlong)reserved.end();
 550     } else {
 551       return (jlong)ps_heap-&gt;reserved_region().end();
 552     }
 553   }
 554 #endif // INCLUDE_PARALLELGC
 555   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_DramReservedEnd: enabled only for G1 and Parallel GC");
 556 WB_END
 557 
 558 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 559 #if INCLUDE_G1GC
 560   if (UseG1GC) {
 561     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 562     if (g1h-&gt;is_heterogeneous_heap()) {
 563       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 564       return (jlong)(g1h-&gt;reserved().start() + start_region * HeapRegion::GrainBytes);
 565     } else {
 566       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 567     }
 568   }
 569 #endif // INCLUDE_G1GC
 570 #if INCLUDE_PARALLELGC
 571   if (UseParallelGC) {
 572     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 573     if (AllocateOldGenAt != NULL) {
 574       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 575       return (jlong)reserved.start();
 576     } else {
 577       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 578     }
 579   }
 580 #endif // INCLUDE_PARALLELGC
 581   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedStart: enabled only for G1 and Parallel GC");
 582 WB_END
 583 
 584 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 585 #if INCLUDE_G1GC
 586   if (UseG1GC) {
 587     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 588     if (g1h-&gt;is_heterogeneous_heap()) {
 589       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 590       return (jlong)(g1h-&gt;reserved().start() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 591     } else {
 592       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 593     }
 594   }
 595 #endif // INCLUDE_G1GC
 596 #if INCLUDE_PARALLELGC
 597   if (UseParallelGC) {
 598     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 599     if (AllocateOldGenAt != NULL) {
 600       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 601       return (jlong)reserved.end();
 602       } else {
 603       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag");
 604     }
 605   }
 606 #endif // INCLUDE_PARALLELGC
 607   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC");
 608 WB_END
 609 
 610 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 611 
 612 #if INCLUDE_PARALLELGC
 613 
 614 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 615   if (UseParallelGC) {
 616     return GenAlignment;
 617   }
 618   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSVirtualSpaceAlignment: Parallel GC is not enabled");
 619 WB_END
 620 
 621 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 622   if (UseParallelGC) {
 623     return GenAlignment;
 624   }
 625   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSHeapGenerationAlignment: Parallel GC is not enabled");
 626 WB_END
 627 
 628 #endif // INCLUDE_PARALLELGC
 629 
 630 #if INCLUDE_G1GC
 631 
 632 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 633   if (UseG1GC) {
 634     ResourceMark rm(THREAD);
 635     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 636     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 637     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 638     return JNIHandles::make_local(THREAD, h());
 639   }
 640   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled");
 641 WB_END
 642 
 643 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 644   if (UseG1GC) {
 645     G1NUMA* numa = G1NUMA::numa();
 646     return (jint)numa-&gt;num_active_nodes();
 647   }
 648   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1ActiveMemoryNodeCount: G1 GC is not enabled");
 649 WB_END
 650 
 651 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 652   if (UseG1GC) {
 653     G1NUMA* numa = G1NUMA::numa();
 654     int num_node_ids = (int)numa-&gt;num_active_nodes();
 655     const int* node_ids = numa-&gt;node_ids();
 656 
 657     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 658     for (int i = 0; i &lt; num_node_ids; i++) {
 659       result-&gt;int_at_put(i, (jint)node_ids[i]);
 660     }
 661     return (jintArray) JNIHandles::make_local(THREAD, result);
 662   }
 663   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1MemoryNodeIds: G1 GC is not enabled");
 664 WB_END
 665 
 666 class OldRegionsLivenessClosure: public HeapRegionClosure {
 667 
 668  private:
 669   const int _liveness;
 670   size_t _total_count;
 671   size_t _total_memory;
 672   size_t _total_memory_to_free;
 673 
 674  public:
 675   OldRegionsLivenessClosure(int liveness) :
 676     _liveness(liveness),
 677     _total_count(0),
 678     _total_memory(0),
 679     _total_memory_to_free(0) { }
 680 
 681     size_t total_count() { return _total_count; }
 682     size_t total_memory() { return _total_memory; }
 683     size_t total_memory_to_free() { return _total_memory_to_free; }
 684 
 685   bool do_heap_region(HeapRegion* r) {
 686     if (r-&gt;is_old()) {
 687       size_t prev_live = r-&gt;marked_bytes();
 688       size_t live = r-&gt;live_bytes();
 689       size_t size = r-&gt;used();
 690       size_t reg_size = HeapRegion::GrainBytes;
 691       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 692         _total_memory += size;
 693         ++_total_count;
 694         if (size == reg_size) {
 695         // we don't include non-full regions since they are unlikely included in mixed gc
 696         // for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed
 697           _total_memory_to_free += size - prev_live;
 698         }
 699       }
 700     }
 701     return false;
 702   }
 703 };
 704 
 705 
 706 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 707   if (!UseG1GC) {
 708     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), "WB_G1GetMixedGCInfo: G1 GC is not enabled");
 709   }
 710   if (liveness &lt; 0) {
 711     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "liveness value should be non-negative");
 712   }
 713 
 714   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 715   OldRegionsLivenessClosure rli(liveness);
 716   g1h-&gt;heap_region_iterate(&amp;rli);
 717 
 718   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 719   result-&gt;long_at_put(0, rli.total_count());
 720   result-&gt;long_at_put(1, rli.total_memory());
 721   result-&gt;long_at_put(2, rli.total_memory_to_free());
 722   return (jlongArray) JNIHandles::make_local(THREAD, result);
 723 WB_END
 724 
 725 #endif // INCLUDE_G1GC
 726 
 727 #if INCLUDE_NMT
 728 // Alloc memory using the test memory type so that we can use that to see if
 729 // NMT picks it up correctly
 730 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 731   jlong addr = 0;
 732   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 733   return addr;
 734 WB_END
 735 
 736 // Alloc memory with pseudo call stack. The test can create psudo malloc
 737 // allocation site to stress the malloc tracking.
 738 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 739   address pc = (address)(size_t)pseudo_stack;
 740   NativeCallStack stack(&amp;pc, 1);
 741   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 742 WB_END
 743 
 744 // Alloc memory with pseudo call stack and specific memory type.
 745 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 746   address pc = (address)(size_t)pseudo_stack;
 747   NativeCallStack stack(&amp;pc, 1);
 748   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 749 WB_END
 750 
 751 // Free the memory allocated by NMTAllocTest
 752 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 753   os::free((void*)(uintptr_t)mem);
 754 WB_END
 755 
 756 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 757   jlong addr = 0;
 758 
 759   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 760   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 761 
 762   return addr;
 763 WB_END
 764 
 765 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 766   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 767   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 768 
 769   return addr;
 770 WB_END
 771 
 772 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 773   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 774   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 775 WB_END
 776 
 777 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 778   os::uncommit_memory((char *)(uintptr_t)addr, size);
 779 WB_END
 780 
 781 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 782   os::release_memory((char *)(uintptr_t)addr, size);
 783 WB_END
 784 
 785 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 786   // Test that we can downgrade NMT levels but not upgrade them.
 787   if (MemTracker::tracking_level() == NMT_off) {
 788     MemTracker::transition_to(NMT_off);
 789     return MemTracker::tracking_level() == NMT_off;
 790   } else {
 791     assert(MemTracker::tracking_level() == NMT_detail, "Should start out as detail tracking");
 792     MemTracker::transition_to(NMT_summary);
 793     assert(MemTracker::tracking_level() == NMT_summary, "Should be summary now");
 794 
 795     // Can't go to detail once NMT is set to summary.
 796     MemTracker::transition_to(NMT_detail);
 797     assert(MemTracker::tracking_level() == NMT_summary, "Should still be summary now");
 798 
 799     // Shutdown sets tracking level to minimal.
 800     MemTracker::shutdown();
 801     assert(MemTracker::tracking_level() == NMT_minimal, "Should be minimal now");
 802 
 803     // Once the tracking level is minimal, we cannot increase to summary.
 804     // The code ignores this request instead of asserting because if the malloc site
 805     // table overflows in another thread, it tries to change the code to summary.
 806     MemTracker::transition_to(NMT_summary);
 807     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 808 
 809     // Really can never go up to detail, verify that the code would never do this.
 810     MemTracker::transition_to(NMT_detail);
 811     assert(MemTracker::tracking_level() == NMT_minimal, "Should still be minimal now");
 812     return MemTracker::tracking_level() == NMT_minimal;
 813   }
 814 WB_END
 815 
 816 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 817   int hash_size = MallocSiteTable::hash_buckets();
 818   assert(hash_size &gt; 0, "NMT hash_size should be &gt; 0");
 819   return (jint)hash_size;
 820 WB_END
 821 
 822 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 823   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 824   return (jlong)arena;
 825 WB_END
 826 
 827 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 828   Arena* a = (Arena*)arena;
 829   delete a;
 830 WB_END
 831 
 832 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 833   Arena* a = (Arena*)arena;
 834   a-&gt;Amalloc(size_t(size));
 835 WB_END
 836 #endif // INCLUDE_NMT
 837 
 838 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 839   assert(method != NULL, "method should not be null");
 840   ThreadToNativeFromVM ttn(thread);
 841   return env-&gt;FromReflectedMethod(method);
 842 }
 843 
 844 static CompLevel highestCompLevel() {
 845   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 846 }
 847 
 848 // Deoptimizes all compiled frames and makes nmethods not entrant if it's requested
 849 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 850  private:
 851   int _result;
 852   const bool _make_not_entrant;
 853  public:
 854   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 855         _result(0), _make_not_entrant(make_not_entrant) { }
 856   int  result() const { return _result; }
 857 
 858   void doit() {
 859     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 860       if (t-&gt;has_last_Java_frame()) {
 861         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 862           frame* f = fst.current();
 863           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 864             Deoptimization::deoptimize(t, *f);
 865             if (_make_not_entrant) {
 866                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 867                 assert(cm != NULL, "sanity check");
 868                 cm-&gt;make_not_entrant();
 869             }
 870             ++_result;
 871           }
 872         }
 873       }
 874     }
 875   }
 876 };
 877 
 878 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 879   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 880   VMThread::execute(&amp;op);
 881   return op.result();
 882 WB_END
 883 
 884 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 885   CodeCache::mark_all_nmethods_for_deoptimization();
 886   Deoptimization::deoptimize_all_marked();
 887 WB_END
 888 
 889 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 890   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 891   int result = 0;
 892   CHECK_JNI_EXCEPTION_(env, result);
 893   MutexLocker mu(Compile_lock);
 894   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 895   if (is_osr) {
 896     result += mh-&gt;mark_osr_nmethods();
 897   } else if (mh-&gt;code() != NULL) {
 898     mh-&gt;code()-&gt;mark_for_deoptimization();
 899     ++result;
 900   }
 901   result += CodeCache::mark_for_deoptimization(mh());
 902   if (result &gt; 0) {
 903     Deoptimization::deoptimize_all_marked();
 904   }
 905   return result;
 906 WB_END
 907 
 908 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 909   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 910   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 911   MutexLocker mu(Compile_lock);
 912   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 913   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 914   if (code == NULL) {
 915     return JNI_FALSE;
 916   }
 917   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 918 WB_END
 919 
 920 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 921   if (method == NULL || comp_level &gt; highestCompLevel()) {
 922     return false;
 923   }
 924   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 925   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 926   MutexLocker mu(Compile_lock);
 927   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 928   if (is_osr) {
 929     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 930   } else {
 931     return CompilationPolicy::can_be_compiled(mh, comp_level);
 932   }
 933 WB_END
 934 
 935 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 936   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 937   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 938   MutexLocker mu(Compile_lock);
 939   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 940   return mh-&gt;queued_for_compilation();
 941 WB_END
 942 
 943 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 944   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 945     return false; // Intrinsic is not available on a non-existent compilation level.
 946   }
 947   jmethodID method_id, compilation_context_id;
 948   method_id = reflected_method_to_jmid(thread, env, method);
 949   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 950   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 951 
 952   DirectiveSet* directive;
 953   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 954   assert(comp != NULL, "compiler not available");
 955   if (compilation_context != NULL) {
 956     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 957     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 958     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 959     directive = DirectivesStack::getMatchingDirective(cch, comp);
 960   } else {
 961     // Calling with NULL matches default directive
 962     directive = DirectivesStack::getDefaultDirective(comp);
 963   }
 964   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 965   DirectivesStack::release(directive);
 966   return result;
 967 WB_END
 968 
 969 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 970   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 971   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 972   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 973   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 974   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 975 WB_END
 976 
 977 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 978   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 979   CHECK_JNI_EXCEPTION(env);
 980   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 981   if (is_osr) {
 982     mh-&gt;set_not_osr_compilable("WhiteBox", comp_level);
 983   } else {
 984     mh-&gt;set_not_compilable("WhiteBox", comp_level);
 985   }
 986 WB_END
 987 
 988 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 989   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 990   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 991   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 992   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 993   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 994 WB_END
 995 
 996 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 997   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 998   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 999   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1000   bool result = mh-&gt;dont_inline();
1001   mh-&gt;set_dont_inline(value == JNI_TRUE);
1002   return result;
1003 WB_END
1004 
1005 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1006   if (comp_level == CompLevel_any) {
1007     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1008         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1009   } else {
1010     return CompileBroker::queue_size(comp_level);
1011   }
1012 WB_END
1013 
1014 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1015   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1016   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1017   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1018   bool result = mh-&gt;force_inline();
1019   mh-&gt;set_force_inline(value == JNI_TRUE);
1020   return result;
1021 WB_END
1022 
1023 #ifdef LINUX
1024 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1025                                const char* proc_self_cgroup,
1026                                const char* proc_self_mountinfo,
1027                                u1* cg_flags) {
1028   CgroupInfo cg_infos[4];
1029   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1030                                                     proc_self_cgroup,
1031                                                     proc_self_mountinfo, cg_flags);
1032 }
1033 #endif
1034 
1035 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1036   // Screen for unavailable/bad comp level or null method
1037   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1038   if (method == NULL) {
1039     tty-&gt;print_cr("WB error: request to compile NULL method");
1040     return false;
1041   }
1042   if (comp_level &gt; highestCompLevel()) {
1043     tty-&gt;print_cr("WB error: invalid compilation level %d", comp_level);
1044     return false;
1045   }
1046   if (comp == NULL) {
1047     tty-&gt;print_cr("WB error: no compiler for requested compilation level %d", comp_level);
1048     return false;
1049   }
1050 
1051   // Check if compilation is blocking
1052   methodHandle mh(THREAD, method);
1053   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1054   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1055   DirectivesStack::release(directive);
1056 
1057   // Compile method and check result
1058   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1059   MutexLocker mu(THREAD, Compile_lock);
1060   bool is_queued = mh-&gt;queued_for_compilation();
1061   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1062     return true;
1063   }
1064   tty-&gt;print("WB error: failed to %s compile at level %d method ", is_blocking ? "blocking" : "", comp_level);
1065   mh-&gt;print_short_name(tty);
1066   tty-&gt;cr();
1067   if (is_blocking &amp;&amp; is_queued) {
1068     tty-&gt;print_cr("WB error: blocking compilation is still in queue!");
1069   }
1070   return false;
1071 }
1072 
1073 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1074   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1075   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1076   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1077 WB_END
1078 
1079 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1080   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1081   Method* clinit = ik-&gt;class_initializer();
1082   if (clinit == NULL) {
1083     return false;
1084   }
1085   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1086 WB_END
1087 
1088 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1089   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1090   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1091 
1092   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1093   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1094   bool result = directive-&gt;PrintAssemblyOption;
1095   DirectivesStack::release(directive);
1096 
1097   return result;
1098 WB_END
1099 
1100 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1101   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1102   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1103 
1104   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1105 
1106   ResourceMark rm(THREAD);
1107   const char* error_msg = NULL;
1108   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1109   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1110 
1111   if (m == NULL) {
1112     assert(error_msg != NULL, "Always have an error message");
1113     tty-&gt;print_cr("Got error: %s", error_msg);
1114     return -1; // Pattern failed
1115   }
1116 
1117   // Pattern works - now check if it matches
1118   int result;
1119   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1120     result = 2; // Force inline match
1121   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1122     result = 1; // Dont inline match
1123   } else {
1124     result = 0; // No match
1125   }
1126   delete m;
1127   return result;
1128 WB_END
1129 
1130 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1131   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1132   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1133 
1134   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1135 
1136   ResourceMark rm;
1137   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1138 
1139   const char* error_msg = NULL;
1140 
1141   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1142   if (m == NULL) {
1143     assert(error_msg != NULL, "Must have error_msg");
1144     tty-&gt;print_cr("Got error: %s", error_msg);
1145     return -1;
1146   }
1147 
1148   // Pattern works - now check if it matches
1149   int result = m-&gt;matches(mh);
1150   delete m;
1151   assert(result == 0 || result == 1, "Result out of range");
1152   return result;
1153 WB_END
1154 
1155 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1156   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1157   CHECK_JNI_EXCEPTION(env);
1158   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1159 
1160   MethodData* mdo = mh-&gt;method_data();
1161   if (mdo == NULL) {
1162     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1163     mdo = mh-&gt;method_data();
1164   }
1165   mdo-&gt;init();
1166   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1167   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1168   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1169   icnt-&gt;set(Tier4MinInvocationThreshold);
1170   bcnt-&gt;set(Tier4CompileThreshold);
1171 WB_END
1172 
1173 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1174   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1175   CHECK_JNI_EXCEPTION(env);
1176   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1177   MutexLocker mu(THREAD, Compile_lock);
1178   MethodData* mdo = mh-&gt;method_data();
1179   MethodCounters* mcs = mh-&gt;method_counters();
1180 
1181   if (mdo != NULL) {
1182     mdo-&gt;init();
1183     ResourceMark rm(THREAD);
1184     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1185     for (int i = 0; i &lt; arg_count; i++) {
1186       mdo-&gt;set_arg_modified(i, 0);
1187     }
1188     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1189     mdo-&gt;clean_method_data(/*always_clean*/true);
1190   }
1191 
1192   mh-&gt;clear_not_c1_compilable();
1193   mh-&gt;clear_not_c2_compilable();
1194   mh-&gt;clear_not_c2_osr_compilable();
1195   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1196   if (mcs != NULL) {
1197     mcs-&gt;backedge_counter()-&gt;init();
1198     mcs-&gt;invocation_counter()-&gt;init();
1199     mcs-&gt;set_interpreter_invocation_count(0);
1200     mcs-&gt;set_interpreter_throwout_count(0);
1201 
1202 #ifdef TIERED
1203     mcs-&gt;set_rate(0.0F);
1204     mh-&gt;set_prev_event_count(0);
1205     mh-&gt;set_prev_time(0);
1206 #endif
1207   }
1208 WB_END
1209 
1210 template &lt;typename T&gt;
1211 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1212   if (name == NULL) {
1213     return false;
1214   }
1215   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1216   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1217   CHECK_JNI_EXCEPTION_(env, false);
1218   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1219   JVMFlag::Error result = (*TAt)(flag, value);
1220   env-&gt;ReleaseStringUTFChars(name, flag_name);
1221   return (result == JVMFlag::SUCCESS);
1222 }
1223 
1224 template &lt;typename T&gt;
1225 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1226   if (name == NULL) {
1227     return false;
1228   }
1229   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1230   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1231   CHECK_JNI_EXCEPTION_(env, false);
1232   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1233   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1234   env-&gt;ReleaseStringUTFChars(name, flag_name);
1235   return (result == JVMFlag::SUCCESS);
1236 }
1237 
1238 template &lt;typename T&gt;
1239 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1240   ResourceMark rm(thread);
1241   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1242   CHECK_JNI_EXCEPTION_(env, NULL);
1243   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1244         vmSymbols::valueOf_name()-&gt;as_C_string(),
1245         sig-&gt;as_C_string());
1246   CHECK_JNI_EXCEPTION_(env, NULL);
1247   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1248   CHECK_JNI_EXCEPTION_(env, NULL);
1249   return result;
1250 }
1251 
1252 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1253   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1254 }
1255 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1256   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1257 }
1258 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1259   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1260 }
1261 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1262   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1263 }*/
1264 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1265   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1266 }
1267 
1268 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1269   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1270   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1271   CHECK_JNI_EXCEPTION_(env, NULL);
1272   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1273   env-&gt;ReleaseStringUTFChars(name, flag_name);
1274   return result;
1275 }
1276 
1277 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1278   const JVMFlag* flag = getVMFlag(thread, env, name);
1279   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1280 WB_END
1281 
1282 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1283   const JVMFlag* flag = getVMFlag(thread, env, name);
1284   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1285 WB_END
1286 
1287 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1288   bool result;
1289   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1290     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1291     return booleanBox(thread, env, result);
1292   }
1293   return NULL;
1294 WB_END
1295 
1296 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1297   int result;
1298   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1299     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1300     return longBox(thread, env, result);
1301   }
1302   return NULL;
1303 WB_END
1304 
1305 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1306   uint result;
1307   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1308     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1309     return longBox(thread, env, result);
1310   }
1311   return NULL;
1312 WB_END
1313 
1314 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1315   intx result;
1316   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1317     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1318     return longBox(thread, env, result);
1319   }
1320   return NULL;
1321 WB_END
1322 
1323 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1324   uintx result;
1325   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1326     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1327     return longBox(thread, env, result);
1328   }
1329   return NULL;
1330 WB_END
1331 
1332 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1333   uint64_t result;
1334   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1335     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1336     return longBox(thread, env, result);
1337   }
1338   return NULL;
1339 WB_END
1340 
1341 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1342   size_t result;
1343   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1344     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1345     return longBox(thread, env, result);
1346   }
1347   return NULL;
1348 WB_END
1349 
1350 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1351   double result;
1352   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1353     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1354     return doubleBox(thread, env, result);
1355   }
1356   return NULL;
1357 WB_END
1358 
1359 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1360   ccstr ccstrResult;
1361   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1362     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1363     jstring result = env-&gt;NewStringUTF(ccstrResult);
1364     CHECK_JNI_EXCEPTION_(env, NULL);
1365     return result;
1366   }
1367   return NULL;
1368 WB_END
1369 
1370 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1371   bool result = value == JNI_TRUE ? true : false;
1372   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1373 WB_END
1374 
1375 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1376   int result = value;
1377   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1378 WB_END
1379 
1380 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1381   uint result = value;
1382   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1383 WB_END
1384 
1385 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1386   intx result = value;
1387   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1388 WB_END
1389 
1390 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1391   uintx result = value;
1392   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1393 WB_END
1394 
1395 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1396   uint64_t result = value;
1397   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1398 WB_END
1399 
1400 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1401   size_t result = value;
1402   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1403 WB_END
1404 
1405 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1406   double result = value;
1407   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1408 WB_END
1409 
1410 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1411   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
1412   const char* ccstrValue;
1413   if (value == NULL) {
1414     ccstrValue = NULL;
1415   }
1416   else {
1417     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1418     CHECK_JNI_EXCEPTION(env);
1419   }
1420   ccstr ccstrResult = ccstrValue;
1421   bool needFree;
1422   {
1423     ThreadInVMfromNative ttvfn(thread); // back to VM
1424     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1425   }
1426   if (value != NULL) {
1427     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1428   }
1429   if (needFree) {
1430     FREE_C_HEAP_ARRAY(char, ccstrResult);
1431   }
1432 WB_END
1433 
1434 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1435   WhiteBox::compilation_locked = true;
1436 WB_END
1437 
1438 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1439   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1440   WhiteBox::compilation_locked = false;
1441   mo.notify_all();
1442 WB_END
1443 
1444 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1445   // Force a code cache sweep and block until it finished
1446   NMethodSweeper::force_sweep();
1447 WB_END
1448 
1449 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1450   ResourceMark rm(THREAD);
1451   int len;
1452   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1453   return (StringTable::lookup(name, len) != NULL);
1454 WB_END
1455 
1456 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1457   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1458   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1459 #if INCLUDE_G1GC
1460   if (UseG1GC) {
1461     // Needs to be cleared explicitly for G1
1462     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1463   }
1464 #endif // INCLUDE_G1GC
1465 WB_END
1466 
1467 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1468   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1469 WB_END
1470 
1471 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1472   // static+volatile in order to force the read to happen
1473   // (not be eliminated by the compiler)
1474   static char c;
1475   static volatile char* p;
1476 
1477   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1478   if (p == NULL) {
1479     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), "Failed to reserve memory");
1480   }
1481 
1482   c = *p;
1483 WB_END
1484 
1485 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1486   const char* features = VM_Version::features_string();
1487   ThreadToNativeFromVM ttn(thread);
1488   jstring features_string = env-&gt;NewStringUTF(features);
1489 
1490   CHECK_JNI_EXCEPTION_(env, NULL);
1491 
1492   return features_string;
1493 WB_END
1494 
1495 int WhiteBox::get_blob_type(const CodeBlob* code) {
1496   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1497   if (code-&gt;is_aot()) {
1498     return -1;
1499   }
1500   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1501 }
1502 
1503 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1504   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1505   return CodeCache::get_code_heap(blob_type);
1506 }
1507 
1508 struct CodeBlobStub {
1509   CodeBlobStub(const CodeBlob* blob) :
1510       name(os::strdup(blob-&gt;name())),
1511       size(blob-&gt;size()),
1512       blob_type(WhiteBox::get_blob_type(blob)),
1513       address((jlong) blob) { }
1514   ~CodeBlobStub() { os::free((void*) name); }
1515   const char* const name;
1516   const jint        size;
1517   const jint        blob_type;
1518   const jlong       address;
1519 };
1520 
1521 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1522   ResourceMark rm;
1523   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1524   CHECK_JNI_EXCEPTION_(env, NULL);
1525   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1526 
1527   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1528   CHECK_JNI_EXCEPTION_(env, NULL);
1529   env-&gt;SetObjectArrayElement(result, 0, name);
1530 
1531   jobject obj = integerBox(thread, env, cb-&gt;size);
1532   CHECK_JNI_EXCEPTION_(env, NULL);
1533   env-&gt;SetObjectArrayElement(result, 1, obj);
1534 
1535   obj = integerBox(thread, env, cb-&gt;blob_type);
1536   CHECK_JNI_EXCEPTION_(env, NULL);
1537   env-&gt;SetObjectArrayElement(result, 2, obj);
1538 
1539   obj = longBox(thread, env, cb-&gt;address);
1540   CHECK_JNI_EXCEPTION_(env, NULL);
1541   env-&gt;SetObjectArrayElement(result, 3, obj);
1542 
1543   return result;
1544 }
1545 
1546 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1547   ResourceMark rm(THREAD);
1548   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1549   CHECK_JNI_EXCEPTION_(env, NULL);
1550   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1551   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1552   jobjectArray result = NULL;
1553   if (code == NULL) {
1554     return result;
1555   }
1556   int comp_level = code-&gt;comp_level();
1557   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1558 
1559   ThreadToNativeFromVM ttn(thread);
1560   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1561   CHECK_JNI_EXCEPTION_(env, NULL);
1562   result = env-&gt;NewObjectArray(5, clazz, NULL);
1563   if (result == NULL) {
1564     return result;
1565   }
1566 
1567   CodeBlobStub stub(code);
1568   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1569   CHECK_JNI_EXCEPTION_(env, NULL);
1570   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1571 
1572   jobject level = integerBox(thread, env, comp_level);
1573   CHECK_JNI_EXCEPTION_(env, NULL);
1574   env-&gt;SetObjectArrayElement(result, 1, level);
1575 
1576   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1577   CHECK_JNI_EXCEPTION_(env, NULL);
1578   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1579   env-&gt;SetObjectArrayElement(result, 2, insts);
1580 
1581   jobject id = integerBox(thread, env, code-&gt;compile_id());
1582   CHECK_JNI_EXCEPTION_(env, NULL);
1583   env-&gt;SetObjectArrayElement(result, 3, id);
1584 
1585   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1586   CHECK_JNI_EXCEPTION_(env, NULL);
1587   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1588 
1589   return result;
1590 WB_END
1591 
1592 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1593   guarantee(WhiteBoxAPI, "internal testing API :: WhiteBox has to be enabled");
1594   BufferBlob* blob;
1595   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1596   if (full_size &lt; size) {
1597     full_size += align_up(size - full_size, oopSize);
1598   }
1599   {
1600     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1601     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1602     if (blob != NULL) {
1603       ::new (blob) BufferBlob("WB::DummyBlob", full_size);
1604     }
1605   }
1606   // Track memory usage statistic after releasing CodeCache_lock
1607   MemoryService::track_code_cache_memory_usage();
1608   return blob;
1609 }
1610 
1611 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1612   if (size &lt; 0) {
1613     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1614       err_msg("WB_AllocateCodeBlob: size is negative: " INT32_FORMAT, size));
1615   }
1616   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1617 WB_END
1618 
1619 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1620   if (addr == 0) {
1621     return;
1622   }
1623   BufferBlob::free((BufferBlob*) addr);
1624 WB_END
1625 
1626 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1627   ResourceMark rm;
1628   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1629   {
1630     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1631     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1632     if (heap == NULL) {
1633       return NULL;
1634     }
1635     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1636          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1637       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1638       new (stub) CodeBlobStub(cb);
1639       blobs.append(stub);
1640     }
1641   }
1642   ThreadToNativeFromVM ttn(thread);
1643   jobjectArray result = NULL;
1644   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1645   CHECK_JNI_EXCEPTION_(env, NULL);
1646   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1647   CHECK_JNI_EXCEPTION_(env, NULL);
1648   if (result == NULL) {
1649     return result;
1650   }
1651   int i = 0;
1652   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1653        it != blobs.end(); ++it) {
1654     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1655     CHECK_JNI_EXCEPTION_(env, NULL);
1656     env-&gt;SetObjectArrayElement(result, i, obj);
1657     CHECK_JNI_EXCEPTION_(env, NULL);
1658     ++i;
1659   }
1660   return result;
1661 WB_END
1662 
1663 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1664   return CompileBroker::get_compilation_activity_mode();
1665 WB_END
1666 
1667 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1668   if (addr == 0) {
1669     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1670       "WB_GetCodeBlob: addr is null");
1671   }
1672   ThreadToNativeFromVM ttn(thread);
1673   CodeBlobStub stub((CodeBlob*) addr);
1674   return codeBlob2objectArray(thread, env, &amp;stub);
1675 WB_END
1676 
1677 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1678   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1679   CHECK_JNI_EXCEPTION_(env, 0);
1680   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1681   return (jlong) mh-&gt;method_data();
1682 WB_END
1683 
1684 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1685   return (jlong) thread-&gt;stack_size();
1686 WB_END
1687 
1688 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1689   return (jlong) thread-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1690 WB_END
1691 
1692 
1693 int WhiteBox::array_bytes_to_length(size_t bytes) {
1694   return Array&lt;u1&gt;::bytes_to_length(bytes);
1695 }
1696 
<a name="3" id="anc3"></a><span class="new">1697 ///////////////</span>
<span class="new">1698 // MetaspaceTestContext and MetaspaceTestArena</span>
<span class="new">1699 WB_ENTRY(jlong, WB_CreateMetaspaceTestContext(JNIEnv* env, jobject wb, jlong commit_limit, jlong reserve_limit))</span>
<span class="new">1700   metaspace::MetaspaceTestContext* context =</span>
<span class="new">1701       new metaspace::MetaspaceTestContext("whitebox-metaspace-context", (size_t) commit_limit, (size_t) reserve_limit);</span>
<span class="new">1702   return (jlong)p2i(context);</span>
<span class="new">1703 WB_END</span>
<span class="new">1704 </span>
<span class="new">1705 WB_ENTRY(void, WB_DestroyMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))</span>
<span class="new">1706   delete (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1707 WB_END</span>
<span class="new">1708 </span>
<span class="new">1709 WB_ENTRY(void, WB_PurgeMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))</span>
<span class="new">1710   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1711   context0-&gt;purge_area();</span>
<span class="new">1712 WB_END</span>
<span class="new">1713 </span>
<span class="new">1714 WB_ENTRY(void, WB_PrintMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))</span>
<span class="new">1715   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1716   context0-&gt;print_on(tty);</span>
<span class="new">1717 WB_END</span>
<span class="new">1718 </span>
<span class="new">1719 WB_ENTRY(jlong, WB_GetTotalCommittedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))</span>
<span class="new">1720   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1721   return context0-&gt;committed_words();</span>
<span class="new">1722 WB_END</span>
<span class="new">1723 </span>
<span class="new">1724 WB_ENTRY(jlong, WB_GetTotalUsedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))</span>
<span class="new">1725   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1726   return context0-&gt;used_words();</span>
<span class="new">1727 WB_END</span>
<span class="new">1728 </span>
<span class="new">1729 WB_ENTRY(jlong, WB_CreateArenaInTestContext(JNIEnv* env, jobject wb, jlong context, jboolean is_micro))</span>
<span class="new">1730   const Metaspace::MetaspaceType type = is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType;</span>
<span class="new">1731   metaspace::MetaspaceTestContext* context0 = (metaspace::MetaspaceTestContext*) context;</span>
<span class="new">1732   return (jlong)p2i(context0-&gt;create_arena(type));</span>
<span class="new">1733 WB_END</span>
<span class="new">1734 </span>
<span class="new">1735 WB_ENTRY(void, WB_DestroyMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena))</span>
<span class="new">1736   delete (metaspace::MetaspaceTestArena*) arena;</span>
<span class="new">1737 WB_END</span>
<span class="new">1738 </span>
<span class="new">1739 WB_ENTRY(jlong, WB_AllocateFromMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong word_size))</span>
<span class="new">1740   metaspace::MetaspaceTestArena* arena0 = (metaspace::MetaspaceTestArena*) arena;</span>
<span class="new">1741   MetaWord* p = arena0-&gt;allocate((size_t) word_size);</span>
<span class="new">1742   return (jlong)p2i(p);</span>
<span class="new">1743 WB_END</span>
<span class="new">1744 </span>
<span class="new">1745 WB_ENTRY(void, WB_DeallocateToMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong p, jlong word_size))</span>
<span class="new">1746   metaspace::MetaspaceTestArena* arena0 = (metaspace::MetaspaceTestArena*) arena;</span>
<span class="new">1747   arena0-&gt;deallocate((MetaWord*)p, (size_t) word_size);</span>
<span class="new">1748 WB_END</span>
<span class="new">1749 </span>
<span class="new">1750 WB_ENTRY(jlong, WB_GetMaxMetaspaceAllocationSize(JNIEnv* env, jobject wb))</span>
<span class="new">1751   return (jlong) Metaspace::max_allocation_word_size() * BytesPerWord;</span>
<span class="new">1752 WB_END</span>
<span class="new">1753 </span>
<span class="new">1754 //////////////</span>
<span class="new">1755 </span>
1756 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1757   if (size &lt; 0) {
1758     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1759         err_msg("WB_AllocateMetaspace: size is negative: " JLONG_FORMAT, size));
1760   }
1761 
1762   oop class_loader_oop = JNIHandles::resolve(class_loader);
1763   ClassLoaderData* cld = class_loader_oop != NULL
1764       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1765       : ClassLoaderData::the_null_class_loader_data();
1766 
1767   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1768 
1769   return (jlong)(uintptr_t)metadata;
1770 WB_END
1771 
<a name="4" id="anc4"></a>








1772 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1773                                 jstring version, jstring location, jobjectArray packages))
1774   Modules::define_module(module, is_open, version, location, packages, CHECK);
1775 WB_END
1776 
1777 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1778   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1779 WB_END
1780 
1781 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1782   Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
1783 WB_END
1784 
1785 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1786   Modules::add_module_exports(module, package, NULL, CHECK);
1787 WB_END
1788 
1789 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1790   Modules::add_reads_module(from_module, source_module, CHECK);
1791 WB_END
1792 
1793 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1794   if (inc &lt; 0) {
1795     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1796         err_msg("WB_IncMetaspaceCapacityUntilGC: inc is negative: " JLONG_FORMAT, inc));
1797   }
1798 
1799   jlong max_size_t = (jlong) ((size_t) -1);
1800   if (inc &gt; max_size_t) {
1801     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1802         err_msg("WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: " JLONG_FORMAT, inc));
1803   }
1804 
1805   size_t new_cap_until_GC = 0;
1806   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1807   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1808   if (!success) {
1809     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1810                 "WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC "
1811                 "due to contention with another thread");
1812   }
1813   return (jlong) new_cap_until_GC;
1814 WB_END
1815 
1816 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1817   return (jlong) MetaspaceGC::capacity_until_GC();
1818 WB_END
1819 
1820 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1821   return (jlong)Metaspace::reserve_alignment();
1822 WB_END
1823 
1824 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1825   oop obj_oop = JNIHandles::resolve(obj);
1826   return (jboolean) obj_oop-&gt;mark().has_monitor();
1827 WB_END
1828 
1829 WB_ENTRY(jboolean, WB_DeflateIdleMonitors(JNIEnv* env, jobject wb))
1830   log_info(monitorinflation)("WhiteBox initiated DeflateIdleMonitors");
1831   return ObjectSynchronizer::request_deflate_idle_monitors();
1832 WB_END
1833 
1834 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1835   VM_ForceSafepoint force_safepoint_op;
1836   VMThread::execute(&amp;force_safepoint_op);
1837 WB_END
1838 
1839 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1840   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1841   return (jlong) ik-&gt;constants();
1842 WB_END
1843 
1844 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1845   return ConstantPool::CPCACHE_INDEX_TAG;
1846 WB_END
1847 
1848 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1849   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1850   ConstantPool* cp = ik-&gt;constants();
1851   if (cp-&gt;cache() == NULL) {
1852       return -1;
1853   }
1854   return cp-&gt;cache()-&gt;length();
1855 WB_END
1856 
1857 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1858   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1859   ConstantPool* cp = ik-&gt;constants();
1860   if (cp-&gt;cache() == NULL) {
1861     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), "Constant pool does not have a cache");
1862   }
1863   jint cpci = index;
1864   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1865   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1866     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Constant pool cache index is out of range");
1867   }
1868   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1869   return cpi;
1870 WB_END
1871 
1872 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1873   return ConstantPool::encode_invokedynamic_index(index);
1874 WB_END
1875 
1876 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1877   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1878   VMThread::execute(&amp;clear_ics);
1879 WB_END
1880 
1881 template &lt;typename T&gt;
1882 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1883   assert(value != NULL, "sanity");
1884   if (method == NULL || name == NULL) {
1885     return false;
1886   }
1887   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1888   CHECK_JNI_EXCEPTION_(env, false);
1889   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1890   // can't be in VM when we call JNI
1891   ThreadToNativeFromVM ttnfv(thread);
1892   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1893   CHECK_JNI_EXCEPTION_(env, false);
1894   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1895   env-&gt;ReleaseStringUTFChars(name, flag_name);
1896   return result;
1897 }
1898 
1899 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1900   bool result;
1901   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1902     // can't be in VM when we call JNI
1903     ThreadToNativeFromVM ttnfv(thread);
1904     return booleanBox(thread, env, result);
1905   }
1906   return NULL;
1907 WB_END
1908 
1909 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1910   intx result;
1911   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1912     // can't be in VM when we call JNI
1913     ThreadToNativeFromVM ttnfv(thread);
1914     return longBox(thread, env, result);
1915   }
1916   return NULL;
1917 WB_END
1918 
1919 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1920   uintx result;
1921   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1922     // can't be in VM when we call JNI
1923     ThreadToNativeFromVM ttnfv(thread);
1924     return longBox(thread, env, result);
1925   }
1926   return NULL;
1927 WB_END
1928 
1929 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1930   double result;
1931   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1932     // can't be in VM when we call JNI
1933     ThreadToNativeFromVM ttnfv(thread);
1934     return doubleBox(thread, env, result);
1935   }
1936   return NULL;
1937 WB_END
1938 
1939 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1940   ccstr ccstrResult;
1941   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1942     // can't be in VM when we call JNI
1943     ThreadToNativeFromVM ttnfv(thread);
1944     jstring result = env-&gt;NewStringUTF(ccstrResult);
1945     CHECK_JNI_EXCEPTION_(env, NULL);
1946     return result;
1947   }
1948   return NULL;
1949 WB_END
1950 
1951 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1952   const char* p = Arguments::get_default_shared_archive_path();
1953   ThreadToNativeFromVM ttn(thread);
1954   jstring path_string = env-&gt;NewStringUTF(p);
1955 
1956   CHECK_JNI_EXCEPTION_(env, NULL);
1957 
1958   return path_string;
1959 WB_END
1960 
1961 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1962   return UseSharedSpaces;
1963 WB_END
1964 
1965 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
1966   return FileMapInfo::memory_mapping_failed();
1967 WB_END
1968 
1969 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1970   oop obj_oop = JNIHandles::resolve(obj);
1971   return HeapShared::is_archived_object(obj_oop);
1972 WB_END
1973 
1974 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1975   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1976 WB_END
1977 
1978 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
1979   return !HeapShared::closed_archive_heap_region_mapped();
1980 WB_END
1981 
1982 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
1983   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1984   if (k-&gt;is_instance_klass()) {
1985     InstanceKlass *ik = InstanceKlass::cast(k);
1986     ConstantPool *cp = ik-&gt;constants();
1987     objArrayOop refs =  cp-&gt;resolved_references();
1988     return (jobject)JNIHandles::make_local(THREAD, refs);
1989   } else {
1990     return NULL;
1991   }
1992 WB_END
1993 
1994 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1995   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1996   if (!k-&gt;is_instance_klass()) {
1997     return;
1998   }
1999   InstanceKlass *ik = InstanceKlass::cast(k);
2000   ik-&gt;link_class(THREAD); // may throw verification error
2001 WB_END
2002 
2003 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2004   return HeapShared::open_archive_heap_region_mapped();
2005 WB_END
2006 
2007 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2008 #if INCLUDE_CDS
2009   return true;
2010 #else
2011   return false;
2012 #endif // INCLUDE_CDS
2013 WB_END
2014 
2015 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2016 #if COMPILER2_OR_JVMCI
2017   return true;
2018 #else
2019   return false;
2020 #endif
2021 WB_END
2022 
2023 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2024   return HeapShared::is_heap_object_archiving_allowed();
2025 WB_END
2026 
2027 
2028 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2029 #if INCLUDE_JFR
2030   return true;
2031 #else
2032   return false;
2033 #endif // INCLUDE_JFR
2034 WB_END
2035 
2036 #if INCLUDE_CDS
2037 
2038 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2039   ResourceMark rm;
2040   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2041   int result = CDSOffsets::find_offset(c_name);
2042   return (jint)result;
2043 WB_END
2044 
2045 #endif // INCLUDE_CDS
2046 
2047 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2048   class TraceSelfClosure : public HandshakeClosure {
2049     jint _num_threads_completed;
2050 
2051     void do_thread(Thread* th) {
2052       assert(th-&gt;is_Java_thread(), "sanity");
2053       JavaThread* jt = (JavaThread*)th;
2054       ResourceMark rm;
2055 
2056       jt-&gt;print_on(tty);
2057       jt-&gt;print_stack_on(tty);
2058       tty-&gt;cr();
2059       Atomic::inc(&amp;_num_threads_completed);
2060     }
2061 
2062   public:
2063     TraceSelfClosure(Thread* thread) : HandshakeClosure("WB_TraceSelf"), _num_threads_completed(0) {}
2064 
2065     jint num_threads_completed() const { return _num_threads_completed; }
2066   };
2067   TraceSelfClosure tsc(Thread::current());
2068 
2069   if (all_threads) {
2070     Handshake::execute(&amp;tsc);
2071   } else {
2072     oop thread_oop = JNIHandles::resolve(thread_handle);
2073     if (thread_oop != NULL) {
2074       JavaThread* target = java_lang_Thread::thread(thread_oop);
2075       Handshake::execute(&amp;tsc, target);
2076     }
2077   }
2078   return tsc.num_threads_completed();
2079 WB_END
2080 
2081 //Some convenience methods to deal with objects from java
2082 int WhiteBox::offset_for_field(const char* field_name, oop object,
2083     Symbol* signature_symbol) {
2084   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, "Field name not valid");
2085   Thread* THREAD = Thread::current();
2086 
2087   //Get the class of our object
2088   Klass* arg_klass = object-&gt;klass();
2089   //Turn it into an instance-klass
2090   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2091 
2092   //Create symbols to look for in the class
2093   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2094 
2095   //To be filled in with an offset of the field we're looking for
2096   fieldDescriptor fd;
2097 
2098   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2099   if (res == NULL) {
2100     tty-&gt;print_cr("Invalid layout of %s at %s", ik-&gt;external_name(),
2101         name_symbol-&gt;as_C_string());
2102     vm_exit_during_initialization("Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class");
2103   }
2104 
2105   //fetch the field at the offset we've found
2106   int dest_offset = fd.offset();
2107 
2108   return dest_offset;
2109 }
2110 
2111 
2112 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2113   int offset = offset_for_field(field_name, object,
2114       vmSymbols::string_signature());
2115   oop string = object-&gt;obj_field(offset);
2116   if (string == NULL) {
2117     return NULL;
2118   }
2119   const char* ret = java_lang_String::as_utf8_string(string);
2120   return ret;
2121 }
2122 
2123 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2124   int offset =
2125       offset_for_field(field_name, object, vmSymbols::bool_signature());
2126   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2127   return ret;
2128 }
2129 
2130 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2131   ResourceMark rm;
2132   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
2133 
2134   //  one by one registration natives for exception catching
2135   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2136   CHECK_JNI_EXCEPTION(env);
2137   for (int i = 0, n = method_count; i &lt; n; ++i) {
2138     // Skip dummy entries
2139     if (method_array[i].fnPtr == NULL) continue;
2140     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2141       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2142       if (throwable_obj != NULL) {
2143         env-&gt;ExceptionClear();
2144         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2145           // NoSuchMethodError is thrown when a method can't be found or a method is not native.
2146           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2147           tty-&gt;print_cr("Warning: 'NoSuchMethodError' on register of sun.hotspot.WhiteBox::%s%s",
2148               method_array[i].name, method_array[i].signature);
2149         }
2150       } else {
2151         // Registration failed unexpectedly.
2152         tty-&gt;print_cr("Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered",
2153             method_array[i].name, method_array[i].signature);
2154         env-&gt;UnregisterNatives(wbclass);
2155         break;
2156       }
2157     }
2158   }
2159 }
2160 
2161 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2162   // can't be in VM when we call JNI
2163   ThreadToNativeFromVM ttnfv(thread);
2164   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2165   CHECK_JNI_EXCEPTION_(env, 0);
2166   int ret;
2167   {
2168     ThreadInVMfromNative ttvfn(thread); // back to VM
2169     ret = DirectivesParser::parse_string(dir, tty);
2170   }
2171   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2172   // -1 for error parsing directive. Return 0 as number of directives added.
2173   if (ret == -1) {
2174     ret = 0;
2175   }
2176   return (jint) ret;
2177 WB_END
2178 
2179 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2180   DirectivesStack::pop(count);
2181 WB_END
2182 
2183 // Checks that the library libfile has the noexecstack bit set.
2184 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2185   jboolean ret = false;
2186 #ifdef LINUX
2187   // Can't be in VM when we call JNI.
2188   ThreadToNativeFromVM ttnfv(thread);
2189   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2190   CHECK_JNI_EXCEPTION_(env, 0);
2191   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2192   env-&gt;ReleaseStringUTFChars(libfile, lf);
2193 #endif
2194   return ret;
2195 WB_END
2196 
2197 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2198   LINUX_ONLY(return OSContainer::is_containerized();)
2199   return false;
2200 WB_END
2201 
2202 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2203                                     jobject o,
2204                                     jstring proc_cgroups,
2205                                     jstring proc_self_cgroup,
2206                                     jstring proc_self_mountinfo))
2207   jint ret = 0;
2208 #ifdef LINUX
2209   ThreadToNativeFromVM ttnfv(thread);
2210   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2211   CHECK_JNI_EXCEPTION_(env, 0);
2212   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2213   CHECK_JNI_EXCEPTION_(env, 0);
2214   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2215   CHECK_JNI_EXCEPTION_(env, 0);
2216   u1 cg_type_flags = 0;
2217   // This sets cg_type_flags
2218   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2219   ret = (jint)cg_type_flags;
2220   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2221   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2222   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2223 #endif
2224   return ret;
2225 WB_END
2226 
2227 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2228   os::print_os_info(tty);
2229 WB_END
2230 
2231 // Elf decoder
2232 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2233 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2234   ElfFile::_do_not_cache_elf_section = true;
2235 #endif
2236 WB_END
2237 
2238 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2239   return (jlong) ResolvedMethodTable::items_count();
2240 WB_END
2241 
2242 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2243   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2244 WB_END
2245 
2246 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2247   jint result = 0;
2248 #if INCLUDE_AOT
2249   result = (jint) AOTLoader::heaps_count();
2250 #endif
2251   return result;
2252 WB_END
2253 
2254 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2255   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2256   // Return size in bytes.
2257   return k-&gt;size() * wordSize;
2258 WB_END
2259 
2260 // See test/hotspot/jtreg/runtime/Thread/ThreadObjAccessAtExit.java.
2261 // It explains how the thread's priority field is used for test state coordination.
2262 //
2263 WB_ENTRY(void, WB_CheckThreadObjOfTerminatingThread(JNIEnv* env, jobject wb, jobject target_handle))
2264   oop target_oop = JNIHandles::resolve_non_null(target_handle);
2265   jlong tid = java_lang_Thread::thread_id(target_oop);
2266   JavaThread* target = java_lang_Thread::thread(target_oop);
2267 
2268   // Grab a ThreadsListHandle to protect the target thread whilst terminating
2269   ThreadsListHandle tlh;
2270 
2271   // Look up the target thread by tid to ensure it is present
2272   JavaThread* t = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
2273   if (t == NULL) {
2274     THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread not found in ThreadsList!");
2275   }
2276 
2277   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is protected");
2278   // Allow target to terminate by boosting priority
2279   java_lang_Thread::set_priority(t-&gt;threadObj(), ThreadPriority(NormPriority + 1));
2280 
2281   // Now wait for the target to terminate
2282   while (!target-&gt;is_terminated()) {
2283     ThreadBlockInVM tbivm(thread);  // just in case target is involved in a safepoint
2284     os::naked_short_sleep(0);
2285   }
2286 
2287   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: target thread is terminated");
2288 
2289   // Now release the GC inducing thread - we have to re-resolve the external oop that
2290   // was passed in as GC may have occurred and we don't know if we can trust t-&gt;threadObj() now.
2291   oop original = JNIHandles::resolve_non_null(target_handle);
2292   java_lang_Thread::set_priority(original, ThreadPriority(NormPriority + 2));
2293 
2294   tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: GC has been initiated - checking threadObj:");
2295 
2296   // The Java code should be creating garbage and triggering GC, which would potentially move
2297   // the threadObj oop. If the exiting thread is properly protected then its threadObj should
2298   // remain valid and equal to our initial target_handle. Loop a few times to give GC a chance to
2299   // kick in.
2300   for (int i = 0; i &lt; 5; i++) {
2301     oop original = JNIHandles::resolve_non_null(target_handle);
2302     oop current = t-&gt;threadObj();
2303     if (original != current) {
2304       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: failed comparison on iteration %d", i);
2305       THROW_MSG(vmSymbols::java_lang_RuntimeException(), "Target thread oop has changed!");
2306     } else {
2307       tty-&gt;print_cr("WB_CheckThreadObjOfTerminatingThread: successful comparison on iteration %d", i);
2308       ThreadBlockInVM tbivm(thread);
2309       os::naked_short_sleep(50);
2310     }
2311   }
2312 WB_END
2313 
2314 WB_ENTRY(jboolean, WB_IsJVMTIIncluded(JNIEnv* env, jobject wb))
2315   return INCLUDE_JVMTI ? JNI_TRUE : JNI_FALSE;
2316 WB_END
2317 
2318 #define CC (char*)
2319 
2320 static JNINativeMethod methods[] = {
2321   {CC"getObjectAddress0",                CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectAddress  },
2322   {CC"getObjectSize0",                   CC"(Ljava/lang/Object;)J", (void*)&amp;WB_GetObjectSize     },
2323   {CC"isObjectInOldGen0",                CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_isObjectInOldGen  },
2324   {CC"getHeapOopSize",                   CC"()I",                   (void*)&amp;WB_GetHeapOopSize    },
2325   {CC"getVMPageSize",                    CC"()I",                   (void*)&amp;WB_GetVMPageSize     },
2326   {CC"getVMAllocationGranularity",       CC"()J",                   (void*)&amp;WB_GetVMAllocationGranularity },
2327   {CC"getVMLargePageSize",               CC"()J",                   (void*)&amp;WB_GetVMLargePageSize},
2328   {CC"getHeapSpaceAlignment",            CC"()J",                   (void*)&amp;WB_GetHeapSpaceAlignment},
2329   {CC"getHeapAlignment",                 CC"()J",                   (void*)&amp;WB_GetHeapAlignment},
2330   {CC"countAliveClasses0",               CC"(Ljava/lang/String;)I", (void*)&amp;WB_CountAliveClasses },
2331   {CC"getSymbolRefcount",                CC"(Ljava/lang/String;)I", (void*)&amp;WB_GetSymbolRefcount },
2332   {CC"parseCommandLine0",
2333       CC"(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;",
2334       (void*) &amp;WB_ParseCommandLine
2335   },
2336   {CC"addToBootstrapClassLoaderSearch0", CC"(Ljava/lang/String;)V",
2337                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2338   {CC"addToSystemClassLoaderSearch0",    CC"(Ljava/lang/String;)V",
2339                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2340   {CC"getCompressedOopsMaxHeapSize", CC"()J",
2341       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2342   {CC"printHeapSizes",     CC"()V",                   (void*)&amp;WB_PrintHeapSizes    },
2343   {CC"runMemoryUnitTests", CC"()V",                   (void*)&amp;WB_RunMemoryUnitTests},
2344   {CC"readFromNoaccessArea",CC"()V",                  (void*)&amp;WB_ReadFromNoaccessArea},
2345   {CC"stressVirtualSpaceResize",CC"(JJJ)I",           (void*)&amp;WB_StressVirtualSpaceResize},
2346 #if INCLUDE_CDS
2347   {CC"getOffsetForName0", CC"(Ljava/lang/String;)I",  (void*)&amp;WB_GetOffsetForName},
2348 #endif
2349 #if INCLUDE_G1GC
2350   {CC"g1InConcurrentMark", CC"()Z",                   (void*)&amp;WB_G1InConcurrentMark},
2351   {CC"g1IsHumongous0",      CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_G1IsHumongous     },
2352   {CC"g1BelongsToHumongousRegion0", CC"(J)Z",         (void*)&amp;WB_G1BelongsToHumongousRegion},
2353   {CC"g1BelongsToFreeRegion0", CC"(J)Z",              (void*)&amp;WB_G1BelongsToFreeRegion},
2354   {CC"g1NumMaxRegions",    CC"()J",                   (void*)&amp;WB_G1NumMaxRegions  },
2355   {CC"g1NumFreeRegions",   CC"()J",                   (void*)&amp;WB_G1NumFreeRegions  },
2356   {CC"g1RegionSize",       CC"()I",                   (void*)&amp;WB_G1RegionSize      },
2357   {CC"g1StartConcMarkCycle",       CC"()Z",           (void*)&amp;WB_G1StartMarkCycle  },
2358   {CC"g1AuxiliaryMemoryUsage", CC"()Ljava/lang/management/MemoryUsage;",
2359                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2360   {CC"g1ActiveMemoryNodeCount", CC"()I",              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2361   {CC"g1MemoryNodeIds",    CC"()[I",                  (void*)&amp;WB_G1MemoryNodeIds },
2362   {CC"g1GetMixedGCInfo",   CC"(I)[J",                 (void*)&amp;WB_G1GetMixedGCInfo },
2363 #endif // INCLUDE_G1GC
2364 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2365   {CC"dramReservedStart",   CC"()J",                  (void*)&amp;WB_DramReservedStart },
2366   {CC"dramReservedEnd",     CC"()J",                  (void*)&amp;WB_DramReservedEnd },
2367   {CC"nvdimmReservedStart", CC"()J",                  (void*)&amp;WB_NvdimmReservedStart },
2368   {CC"nvdimmReservedEnd",   CC"()J",                  (void*)&amp;WB_NvdimmReservedEnd },
2369 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2370 #if INCLUDE_PARALLELGC
2371   {CC"psVirtualSpaceAlignment",CC"()J",               (void*)&amp;WB_PSVirtualSpaceAlignment},
2372   {CC"psHeapGenerationAlignment",CC"()J",             (void*)&amp;WB_PSHeapGenerationAlignment},
2373 #endif
2374 #if INCLUDE_NMT
2375   {CC"NMTMalloc",           CC"(J)J",                 (void*)&amp;WB_NMTMalloc          },
2376   {CC"NMTMallocWithPseudoStack", CC"(JI)J",           (void*)&amp;WB_NMTMallocWithPseudoStack},
2377   {CC"NMTMallocWithPseudoStackAndType", CC"(JII)J",   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2378   {CC"NMTFree",             CC"(J)V",                 (void*)&amp;WB_NMTFree            },
2379   {CC"NMTReserveMemory",    CC"(J)J",                 (void*)&amp;WB_NMTReserveMemory   },
2380   {CC"NMTAttemptReserveMemoryAt",    CC"(JJ)J",       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2381   {CC"NMTCommitMemory",     CC"(JJ)V",                (void*)&amp;WB_NMTCommitMemory    },
2382   {CC"NMTUncommitMemory",   CC"(JJ)V",                (void*)&amp;WB_NMTUncommitMemory  },
2383   {CC"NMTReleaseMemory",    CC"(JJ)V",                (void*)&amp;WB_NMTReleaseMemory   },
2384   {CC"NMTChangeTrackingLevel", CC"()Z",               (void*)&amp;WB_NMTChangeTrackingLevel},
2385   {CC"NMTGetHashSize",      CC"()I",                  (void*)&amp;WB_NMTGetHashSize     },
2386   {CC"NMTNewArena",         CC"(J)J",                 (void*)&amp;WB_NMTNewArena        },
2387   {CC"NMTFreeArena",        CC"(J)V",                 (void*)&amp;WB_NMTFreeArena       },
2388   {CC"NMTArenaMalloc",      CC"(JJ)V",                (void*)&amp;WB_NMTArenaMalloc     },
2389 #endif // INCLUDE_NMT
2390   {CC"deoptimizeFrames",   CC"(Z)I",                  (void*)&amp;WB_DeoptimizeFrames  },
2391   {CC"deoptimizeAll",      CC"()V",                   (void*)&amp;WB_DeoptimizeAll     },
2392   {CC"deoptimizeMethod0",   CC"(Ljava/lang/reflect/Executable;Z)I",
2393                                                       (void*)&amp;WB_DeoptimizeMethod  },
2394   {CC"isMethodCompiled0",   CC"(Ljava/lang/reflect/Executable;Z)Z",
2395                                                       (void*)&amp;WB_IsMethodCompiled  },
2396   {CC"isMethodCompilable0", CC"(Ljava/lang/reflect/Executable;IZ)Z",
2397                                                       (void*)&amp;WB_IsMethodCompilable},
2398   {CC"isMethodQueuedForCompilation0",
2399       CC"(Ljava/lang/reflect/Executable;)Z",          (void*)&amp;WB_IsMethodQueuedForCompilation},
2400   {CC"isIntrinsicAvailable0",
2401       CC"(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z",
2402                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2403   {CC"makeMethodNotCompilable0",
2404       CC"(Ljava/lang/reflect/Executable;IZ)V",        (void*)&amp;WB_MakeMethodNotCompilable},
2405   {CC"testSetDontInlineMethod0",
2406       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetDontInlineMethod},
2407   {CC"getMethodCompilationLevel0",
2408       CC"(Ljava/lang/reflect/Executable;Z)I",         (void*)&amp;WB_GetMethodCompilationLevel},
2409   {CC"getMethodEntryBci0",
2410       CC"(Ljava/lang/reflect/Executable;)I",          (void*)&amp;WB_GetMethodEntryBci},
2411   {CC"getCompileQueueSize",
2412       CC"(I)I",                                       (void*)&amp;WB_GetCompileQueueSize},
2413   {CC"testSetForceInlineMethod0",
2414       CC"(Ljava/lang/reflect/Executable;Z)Z",         (void*)&amp;WB_TestSetForceInlineMethod},
2415   {CC"enqueueMethodForCompilation0",
2416       CC"(Ljava/lang/reflect/Executable;II)Z",        (void*)&amp;WB_EnqueueMethodForCompilation},
2417   {CC"enqueueInitializerForCompilation0",
2418       CC"(Ljava/lang/Class;I)Z",                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2419   {CC"markMethodProfiled",
2420       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_MarkMethodProfiled},
2421   {CC"clearMethodState0",
2422       CC"(Ljava/lang/reflect/Executable;)V",          (void*)&amp;WB_ClearMethodState},
2423   {CC"lockCompilation",    CC"()V",                   (void*)&amp;WB_LockCompilation},
2424   {CC"unlockCompilation",  CC"()V",                   (void*)&amp;WB_UnlockCompilation},
2425   {CC"matchesMethod",
2426       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2427                                                       (void*)&amp;WB_MatchesMethod},
2428   {CC"matchesInline",
2429       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)I",
2430                                                       (void*)&amp;WB_MatchesInline},
2431   {CC"shouldPrintAssembly",
2432         CC"(Ljava/lang/reflect/Executable;I)Z",
2433                                                         (void*)&amp;WB_ShouldPrintAssembly},
2434 
2435   {CC"isConstantVMFlag",   CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsConstantVMFlag},
2436   {CC"isLockedVMFlag",     CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsLockedVMFlag},
2437   {CC"setBooleanVMFlag",   CC"(Ljava/lang/String;Z)V",(void*)&amp;WB_SetBooleanVMFlag},
2438   {CC"setIntVMFlag",       CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntVMFlag},
2439   {CC"setUintVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintVMFlag},
2440   {CC"setIntxVMFlag",      CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetIntxVMFlag},
2441   {CC"setUintxVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUintxVMFlag},
2442   {CC"setUint64VMFlag",    CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetUint64VMFlag},
2443   {CC"setSizeTVMFlag",     CC"(Ljava/lang/String;J)V",(void*)&amp;WB_SetSizeTVMFlag},
2444   {CC"setDoubleVMFlag",    CC"(Ljava/lang/String;D)V",(void*)&amp;WB_SetDoubleVMFlag},
2445   {CC"setStringVMFlag",    CC"(Ljava/lang/String;Ljava/lang/String;)V",
2446                                                       (void*)&amp;WB_SetStringVMFlag},
2447   {CC"getBooleanVMFlag",   CC"(Ljava/lang/String;)Ljava/lang/Boolean;",
2448                                                       (void*)&amp;WB_GetBooleanVMFlag},
2449   {CC"getIntVMFlag",       CC"(Ljava/lang/String;)Ljava/lang/Long;",
2450                                                       (void*)&amp;WB_GetIntVMFlag},
2451   {CC"getUintVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2452                                                       (void*)&amp;WB_GetUintVMFlag},
2453   {CC"getIntxVMFlag",      CC"(Ljava/lang/String;)Ljava/lang/Long;",
2454                                                       (void*)&amp;WB_GetIntxVMFlag},
2455   {CC"getUintxVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2456                                                       (void*)&amp;WB_GetUintxVMFlag},
2457   {CC"getUint64VMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Long;",
2458                                                       (void*)&amp;WB_GetUint64VMFlag},
2459   {CC"getSizeTVMFlag",     CC"(Ljava/lang/String;)Ljava/lang/Long;",
2460                                                       (void*)&amp;WB_GetSizeTVMFlag},
2461   {CC"getDoubleVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/Double;",
2462                                                       (void*)&amp;WB_GetDoubleVMFlag},
2463   {CC"getStringVMFlag",    CC"(Ljava/lang/String;)Ljava/lang/String;",
2464                                                       (void*)&amp;WB_GetStringVMFlag},
2465   {CC"isInStringTable",    CC"(Ljava/lang/String;)Z", (void*)&amp;WB_IsInStringTable  },
2466   {CC"fullGC",   CC"()V",                             (void*)&amp;WB_FullGC },
2467   {CC"youngGC",  CC"()V",                             (void*)&amp;WB_YoungGC },
2468   {CC"readReservedMemory", CC"()V",                   (void*)&amp;WB_ReadReservedMemory },
2469   {CC"allocateMetaspace",
2470      CC"(Ljava/lang/ClassLoader;J)J",                 (void*)&amp;WB_AllocateMetaspace },
<a name="5" id="anc5"></a>

2471   {CC"incMetaspaceCapacityUntilGC", CC"(J)J",         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2472   {CC"metaspaceCapacityUntilGC", CC"()J",             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2473   {CC"metaspaceReserveAlignment", CC"()J",            (void*)&amp;WB_MetaspaceReserveAlignment },
2474   {CC"getCPUFeatures",     CC"()Ljava/lang/String;",  (void*)&amp;WB_GetCPUFeatures     },
2475   {CC"getNMethod0",         CC"(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;",
2476                                                       (void*)&amp;WB_GetNMethod         },
2477   {CC"forceNMethodSweep",  CC"()V",                   (void*)&amp;WB_ForceNMethodSweep  },
2478   {CC"allocateCodeBlob",   CC"(II)J",                 (void*)&amp;WB_AllocateCodeBlob   },
2479   {CC"freeCodeBlob",       CC"(J)V",                  (void*)&amp;WB_FreeCodeBlob       },
2480   {CC"getCodeHeapEntries", CC"(I)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeHeapEntries },
2481   {CC"getCompilationActivityMode",
2482                            CC"()I",                   (void*)&amp;WB_GetCompilationActivityMode},
2483   {CC"getMethodData0",     CC"(Ljava/lang/reflect/Executable;)J",
2484                                                       (void*)&amp;WB_GetMethodData      },
2485   {CC"getCodeBlob",        CC"(J)[Ljava/lang/Object;",(void*)&amp;WB_GetCodeBlob        },
2486   {CC"getThreadStackSize", CC"()J",                   (void*)&amp;WB_GetThreadStackSize },
2487   {CC"getThreadRemainingStackSize", CC"()J",          (void*)&amp;WB_GetThreadRemainingStackSize },
2488   {CC"DefineModule",       CC"(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V",
2489                                                       (void*)&amp;WB_DefineModule },
2490   {CC"AddModuleExports",   CC"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V",
2491                                                       (void*)&amp;WB_AddModuleExports },
2492   {CC"AddReadsModule",     CC"(Ljava/lang/Object;Ljava/lang/Object;)V",
2493                                                       (void*)&amp;WB_AddReadsModule },
2494   {CC"AddModuleExportsToAllUnnamed", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2495                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2496   {CC"AddModuleExportsToAll", CC"(Ljava/lang/Object;Ljava/lang/String;)V",
2497                                                       (void*)&amp;WB_AddModuleExportsToAll },
2498   {CC"deflateIdleMonitors", CC"()Z",                  (void*)&amp;WB_DeflateIdleMonitors },
2499   {CC"isMonitorInflated0", CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsMonitorInflated  },
2500   {CC"forceSafepoint",     CC"()V",                   (void*)&amp;WB_ForceSafepoint     },
2501   {CC"getConstantPool0",   CC"(Ljava/lang/Class;)J",  (void*)&amp;WB_GetConstantPool    },
2502   {CC"getConstantPoolCacheIndexTag0", CC"()I",  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2503   {CC"getConstantPoolCacheLength0", CC"(Ljava/lang/Class;)I",  (void*)&amp;WB_GetConstantPoolCacheLength},
2504   {CC"remapInstructionOperandFromCPCache0",
2505       CC"(Ljava/lang/Class;I)I",                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2506   {CC"encodeConstantPoolIndyIndex0",
2507       CC"(I)I",                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2508   {CC"getMethodBooleanOption",
2509       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;",
2510                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2511   {CC"getMethodIntxOption",
2512       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2513                                                       (void*)&amp;WB_GetMethodIntxOption},
2514   {CC"getMethodUintxOption",
2515       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;",
2516                                                       (void*)&amp;WB_GetMethodUintxOption},
2517   {CC"getMethodDoubleOption",
2518       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;",
2519                                                       (void*)&amp;WB_GetMethodDoubleOption},
2520   {CC"getMethodStringOption",
2521       CC"(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;",
2522                                                       (void*)&amp;WB_GetMethodStringOption},
2523   {CC"getDefaultArchivePath",             CC"()Ljava/lang/String;",
2524                                                       (void*)&amp;WB_GetDefaultArchivePath},
2525   {CC"isSharingEnabled",   CC"()Z",                   (void*)&amp;WB_IsSharingEnabled},
2526   {CC"isShared",           CC"(Ljava/lang/Object;)Z", (void*)&amp;WB_IsShared },
2527   {CC"isSharedClass",      CC"(Ljava/lang/Class;)Z",  (void*)&amp;WB_IsSharedClass },
2528   {CC"areSharedStringsIgnored",           CC"()Z",    (void*)&amp;WB_AreSharedStringsIgnored },
2529   {CC"getResolvedReferences", CC"(Ljava/lang/Class;)Ljava/lang/Object;", (void*)&amp;WB_GetResolvedReferences},
2530   {CC"linkClass",          CC"(Ljava/lang/Class;)V",  (void*)&amp;WB_LinkClass},
2531   {CC"areOpenArchiveHeapObjectsMapped",   CC"()Z",    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2532   {CC"isCDSIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2533   {CC"isJFRIncludedInVmBuild",            CC"()Z",    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2534   {CC"isC2OrJVMCIIncludedInVmBuild",      CC"()Z",    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2535   {CC"isJavaHeapArchiveSupported",        CC"()Z",    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2536   {CC"cdsMemoryMappingFailed",            CC"()Z",    (void*)&amp;WB_CDSMemoryMappingFailed },
2537 
2538   {CC"clearInlineCaches0",  CC"(Z)V",                 (void*)&amp;WB_ClearInlineCaches },
2539   {CC"handshakeWalkStack", CC"(Ljava/lang/Thread;Z)I", (void*)&amp;WB_HandshakeWalkStack },
2540   {CC"checkThreadObjOfTerminatingThread", CC"(Ljava/lang/Thread;)V", (void*)&amp;WB_CheckThreadObjOfTerminatingThread },
2541   {CC"addCompilerDirective",    CC"(Ljava/lang/String;)I",
2542                                                       (void*)&amp;WB_AddCompilerDirective },
2543   {CC"removeCompilerDirective",   CC"(I)V",           (void*)&amp;WB_RemoveCompilerDirective },
2544   {CC"isGCSupported",             CC"(I)Z",           (void*)&amp;WB_IsGCSupported},
2545   {CC"isGCSelected",              CC"(I)Z",           (void*)&amp;WB_IsGCSelected},
2546   {CC"isGCSelectedErgonomically", CC"()Z",            (void*)&amp;WB_IsGCSelectedErgonomically},
2547   {CC"supportsConcurrentGCBreakpoints", CC"()Z",      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2548   {CC"concurrentGCAcquireControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCAcquireControl},
2549   {CC"concurrentGCReleaseControl0", CC"()V",          (void*)&amp;WB_ConcurrentGCReleaseControl},
2550   {CC"concurrentGCRunToIdle0",    CC"()V",            (void*)&amp;WB_ConcurrentGCRunToIdle},
2551   {CC"concurrentGCRunTo0",        CC"(Ljava/lang/String;)Z",
2552                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2553   {CC"checkLibSpecifiesNoexecstack", CC"(Ljava/lang/String;)Z",
2554                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2555   {CC"isContainerized",           CC"()Z",            (void*)&amp;WB_IsContainerized },
2556   {CC"validateCgroup",
2557       CC"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
2558                                                       (void*)&amp;WB_ValidateCgroup },
2559   {CC"printOsInfo",               CC"()V",            (void*)&amp;WB_PrintOsInfo },
2560   {CC"disableElfSectionCache",    CC"()V",            (void*)&amp;WB_DisableElfSectionCache },
2561   {CC"resolvedMethodItemsCount",  CC"()J",            (void*)&amp;WB_ResolvedMethodItemsCount },
2562   {CC"protectionDomainRemovedCount",   CC"()I",       (void*)&amp;WB_ProtectionDomainRemovedCount },
2563   {CC"aotLibrariesCount", CC"()I",                    (void*)&amp;WB_AotLibrariesCount },
2564   {CC"getKlassMetadataSize", CC"(Ljava/lang/Class;)I",(void*)&amp;WB_GetKlassMetadataSize},
<a name="6" id="anc6"></a><span class="new">2565 </span>
<span class="new">2566   {CC"createMetaspaceTestContext", CC"(JJ)J",         (void*)&amp;WB_CreateMetaspaceTestContext},</span>
<span class="new">2567   {CC"destroyMetaspaceTestContext", CC"(J)V",         (void*)&amp;WB_DestroyMetaspaceTestContext},</span>
<span class="new">2568   {CC"purgeMetaspaceTestContext", CC"(J)V",           (void*)&amp;WB_PurgeMetaspaceTestContext},</span>
<span class="new">2569   {CC"printMetaspaceTestContext", CC"(J)V",           (void*)&amp;WB_PrintMetaspaceTestContext},</span>
<span class="new">2570   {CC"getTotalCommittedWordsInMetaspaceTestContext", CC"(J)J",(void*)&amp;WB_GetTotalCommittedWordsInMetaspaceTestContext},</span>
<span class="new">2571   {CC"getTotalUsedWordsInMetaspaceTestContext", CC"(J)J", (void*)&amp;WB_GetTotalUsedWordsInMetaspaceTestContext},</span>
<span class="new">2572   {CC"createArenaInTestContext", CC"(JZ)J",           (void*)&amp;WB_CreateArenaInTestContext},</span>
<span class="new">2573   {CC"destroyMetaspaceTestArena", CC"(J)V",           (void*)&amp;WB_DestroyMetaspaceTestArena},</span>
<span class="new">2574   {CC"allocateFromMetaspaceTestArena", CC"(JJ)J",     (void*)&amp;WB_AllocateFromMetaspaceTestArena},</span>
<span class="new">2575   {CC"deallocateToMetaspaceTestArena", CC"(JJJ)V",    (void*)&amp;WB_DeallocateToMetaspaceTestArena},</span>
<span class="new">2576   {CC"maxMetaspaceAllocationSize", CC"()J",           (void*)&amp;WB_GetMaxMetaspaceAllocationSize},</span>
<span class="new">2577 </span>
2578   {CC"isJVMTIIncluded", CC"()Z",                      (void*)&amp;WB_IsJVMTIIncluded},
2579 };
2580 
2581 
2582 #undef CC
2583 
2584 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2585   {
2586     if (WhiteBoxAPI) {
2587       // Make sure that wbclass is loaded by the null classloader
2588       InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));
2589       Handle loader(THREAD, ik-&gt;class_loader());
2590       if (loader.is_null()) {
2591         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2592         WhiteBox::set_used();
2593       }
2594     }
2595   }
2596 JVM_END
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="7" type="hidden" /></form></body></html>
