<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_spacemanager_stress.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 
  27 #include "precompiled.hpp"
  28 
  29 //#define LOG_PLEASE
  30 
  31 #include "metaspace/metaspaceTestsCommon.hpp"
  32 #include "metaspace/metaspace_sparsearray.hpp"
  33 #include "metaspace/metaspace_testhelper.hpp"
  34 
  35 // Little randomness helper
  36 static bool fifty_fifty() {
  37   return IntRange(100).random_value() &lt; 50;
  38 }
  39 
  40 // See spaceManager.cpp : needed for predicting commit sizes.
  41 namespace metaspace {
  42   extern size_t get_raw_allocation_word_size(size_t net_word_size);
  43 }
  44 
  45 // A SpaceManagerTestBed contains a single SpaceManager and its lock.
  46 // It keeps track of allocations done from this SpaceManager.
  47 class SpaceManagerTestBed : public CHeapObj&lt;mtInternal&gt; {
  48 
  49   SpaceManager* _sm;
  50 
  51   Mutex* _lock;
  52 
  53   const SizeRange _allocation_range;
  54   size_t _size_of_last_failed_allocation;
  55 
  56   // We keep track of all allocations done thru the SpaceManager to
  57   // later check for overwriters.
  58   struct allocation_t {
  59     allocation_t* next;
  60     MetaWord* p; // NULL if deallocated
  61     size_t word_size;
  62     void mark() {
  63       mark_range(p, word_size);
  64     }
  65     void verify() const {
  66       if (p != NULL) {
  67         check_marked_range(p, word_size);
  68       }
  69     }
  70   };
  71 
  72   allocation_t* _allocations;
  73 
  74   // We count how much we did allocate and deallocate
  75   MemRangeCounter _alloc_count;
  76   MemRangeCounter _dealloc_count;
  77 
  78   // Check statistics returned by SpaceManager::add_to_statistics() against what
  79   // we know we allocated. This is a bit flaky since SpaceManager has internal
  80   // overhead.
  81   void verify_sm_statistics() const {
  82 
  83     sm_stats_t stats;
  84     memset(&amp;stats, 0, sizeof(stats));
  85     _sm-&gt;add_to_statistics(&amp;stats);
  86     in_use_chunk_stats_t in_use_stats = stats.totals();
  87 
  88     assert(_dealloc_count.total_size() &lt;= _alloc_count.total_size() &amp;&amp;
  89            _dealloc_count.count() &lt;= _alloc_count.count(), "Sanity");
  90 
  91     // Check consistency of stats
  92     ASSERT_GE(in_use_stats.word_size, in_use_stats.committed_words);
  93     ASSERT_EQ(in_use_stats.committed_words,
  94               in_use_stats.used_words + in_use_stats.free_words + in_use_stats.waste_words);
  95     ASSERT_GE(in_use_stats.used_words, stats.free_blocks_word_size);
  96 
  97     // Note: reasons why the outside alloc counter and the inside used counter can differ:
  98     // - alignment/padding of allocations
  99     // - inside used counter contains blocks in free list
 100     // - free block list splinter threshold
 101 
 102     // Since what we deallocated may have been given back to us in a following allocation,
 103     // we only know fore sure we allocated what we did not give back.
 104     const size_t at_least_allocated = _alloc_count.total_size() - _dealloc_count.total_size();
 105 
 106     // At most we allocated this:
 107     const size_t max_word_overhead_per_alloc = 4;
 108     const size_t at_most_allocated = _alloc_count.total_size() + max_word_overhead_per_alloc * _alloc_count.count();
 109 
 110     ASSERT_LE(at_least_allocated, in_use_stats.used_words - stats.free_blocks_word_size);
 111     ASSERT_GE(at_most_allocated, in_use_stats.used_words - stats.free_blocks_word_size);
 112 
 113   }
 114 
 115 public:
 116 
 117   SpaceManager* sm() { return _sm; }
 118 
 119   SpaceManagerTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence,
 120                       SizeAtomicCounter* used_words_counter, SizeRange allocation_range)
 121     : _sm(NULL),
 122       _lock(NULL),
 123       _allocation_range(allocation_range),
 124       _size_of_last_failed_allocation(0),
 125       _allocations(NULL),
 126       _alloc_count(), _dealloc_count()
 127   {
 128     _lock = new Mutex(Monitor::native, "gtest-SpaceManagerTestBed-lock", false, Monitor::_safepoint_check_never);
 129     // Lock during space creation, since this is what happens in the VM too
 130     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
 131     MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
 132     _sm = new SpaceManager(cm, alloc_sequence, _lock, used_words_counter, "gtest-SpaceManagerTestBed-sm", false);
 133   }
 134 
 135   ~SpaceManagerTestBed() {
 136 
 137     verify_sm_statistics();
 138 
 139     allocation_t* a = _allocations;
 140     while (a != NULL) {
 141       allocation_t* b = a-&gt;next;
 142       a-&gt;verify();
 143       FREE_C_HEAP_OBJ(a);
 144       a = b;
 145     }
 146 
 147     DEBUG_ONLY(_sm-&gt;verify(true);)
 148 
 149     // Delete SpaceManager. That should clean up all metaspace.
 150     delete _sm;
 151     delete _lock;
 152 
 153   }
 154 
 155   size_t words_allocated() const        { return _alloc_count.total_size(); }
 156   int num_allocations() const           { return _alloc_count.count(); }
 157 
 158   size_t size_of_last_failed_allocation() const { return _size_of_last_failed_allocation; }
 159 
 160   // Allocate a random amount. Return false if the allocation failed.
 161   bool checked_random_allocate() {
 162     size_t word_size = 1 + _allocation_range.random_value();
 163     MetaWord* p = _sm-&gt;allocate(word_size);
 164     if (p != NULL) {
 165       EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));
 166       allocation_t* a = NEW_C_HEAP_OBJ(allocation_t, mtInternal);
 167       a-&gt;word_size = word_size;
 168       a-&gt;p = p;
 169       a-&gt;mark();
 170       a-&gt;next = _allocations;
 171       _allocations = a;
 172       _alloc_count.add(word_size);
 173       if ((_alloc_count.count() % 20) == 0) {
 174         verify_sm_statistics();
 175         DEBUG_ONLY(_sm-&gt;verify(true);)
 176       }
 177       return true;
 178     } else {
 179       _size_of_last_failed_allocation = word_size;
 180     }
 181     return false;
 182   }
 183 
 184   // Deallocate a random allocation
 185   void checked_random_deallocate() {
 186     allocation_t* a = _allocations;
 187     while (a &amp;&amp; a-&gt;p != NULL &amp;&amp; os::random() % 10 != 0) {
 188       a = a-&gt;next;
 189     }
 190     if (a != NULL &amp;&amp; a-&gt;p != NULL) {
 191       a-&gt;verify();
 192       _sm-&gt;deallocate(a-&gt;p, a-&gt;word_size);
 193       _dealloc_count.add(a-&gt;word_size);
 194       a-&gt;p = NULL; a-&gt;word_size = 0;
 195       if ((_dealloc_count.count() % 20) == 0) {
 196         verify_sm_statistics();
 197         DEBUG_ONLY(_sm-&gt;verify(true);)
 198       }
 199     }
 200   }
 201 
 202 }; // End: SpaceManagerTestBed
 203 
 204 
 205 class SpaceManagerTest {
 206 
 207   MetaspaceTestHelper _helper;
 208 
 209   SizeAtomicCounter _used_words_counter;
 210 
 211   const size_t _rss_at_start;
 212 
 213   SparseArray&lt;SpaceManagerTestBed*&gt; _testbeds;
 214   IntCounter _num_beds;
 215 
 216   //////// Bed creation, destruction ///////
 217 
 218   void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, SizeRange allocation_range) {
 219     DEBUG_ONLY(_testbeds.check_slot_is_null(slotindex));
 220     SpaceManagerTestBed* bed = new SpaceManagerTestBed(&amp;_helper.cm(), growth_policy,
 221                                                        &amp;_used_words_counter, allocation_range);
 222     _testbeds.set_at(slotindex, bed);
 223     _num_beds.increment();
 224   }
 225 
 226   void create_random_test_bed_at(int slotindex) {
 227     SizeRange allocation_range(1, 100); // randomize too?
 228     const ArenaGrowthPolicy* growth_policy = ArenaGrowthPolicy::policy_for_space_type(
 229         (fifty_fifty() ? metaspace::StandardMetaspaceType : metaspace::ReflectionMetaspaceType),
 230          fifty_fifty());
 231     create_new_test_bed_at(slotindex, growth_policy, allocation_range);
 232    }
 233 
 234   // Randomly create a random test bed at a random slot, and return its slot index
 235   // (returns false if we reached max number of test beds)
 236   bool create_random_test_bed() {
 237     const int slot = _testbeds.random_null_slot_index();
 238     if (slot != -1) {
 239       create_random_test_bed_at(slot);
 240     }
 241     return slot;
 242   }
 243 
 244   // Create test beds for all slots
 245   void create_all_test_beds() {
 246     for (int slot = 0; slot &lt; _testbeds.size(); slot ++) {
 247       if (_testbeds.slot_is_null(slot)) {
 248         create_random_test_bed_at(slot);
 249       }
 250     }
 251   }
 252 
 253   void delete_test_bed_at(int slotindex) {
 254     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex));
 255     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 256     delete bed; // This will return all its memory to the chunk manager
 257     _testbeds.set_at(slotindex, NULL);
 258     _num_beds.decrement();
 259   }
 260 
 261   // Randomly delete a random test bed at a random slot
 262   // Return false if there are no test beds to delete.
 263   bool delete_random_test_bed() {
 264     const int slotindex = _testbeds.random_non_null_slot_index();
 265     if (slotindex != -1) {
 266       delete_test_bed_at(slotindex);
 267       return true;
 268     }
 269     return false;
 270   }
 271 
 272   // Delete all test beds.
 273   void delete_all_test_beds() {
 274     for (int slot = _testbeds.first_non_null_slot(); slot != -1; slot = _testbeds.next_non_null_slot(slot)) {
 275       delete_test_bed_at(slot);
 276     }
 277   }
 278 
 279   //////// Allocating metaspace from test beds ///////
 280 
 281   bool random_allocate_from_testbed(int slotindex) {
 282     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex);)
 283     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 284     bool success = bed-&gt;checked_random_allocate();
 285     if (success == false) {
 286       // We must have hit a limit.
 287       EXPECT_LT(_helper.commit_limiter().possible_expansion_words(),
 288                 metaspace::get_raw_allocation_word_size(bed-&gt;size_of_last_failed_allocation()));
 289     }
 290     return success;
 291   }
 292 
 293   // Allocate multiple times random sizes from a single spacemanager.
 294   bool random_allocate_multiple_times_from_testbed(int slotindex, int num_allocations) {
 295     bool success = true;
 296     int n = 0;
 297     while (success &amp;&amp; n &lt; num_allocations) {
 298       success = random_allocate_from_testbed(slotindex);
 299       n ++;
 300     }
 301     return success;
 302   }
 303 
 304   // Allocate multiple times random sizes from a single random spacemanager.
 305   bool random_allocate_random_times_from_random_testbed() {
 306     int slot = _testbeds.random_non_null_slot_index();
 307     bool success = false;
 308     if (slot != -1) {
 309       const int n = IntRange(5, 20).random_value();
 310       success = random_allocate_multiple_times_from_testbed(slot, n);
 311     }
 312     return success;
 313   }
 314 
 315   /////// Deallocating from testbed ///////////////////
 316 
 317   void deallocate_from_testbed(int slotindex) {
 318     DEBUG_ONLY(_testbeds.check_slot_is_not_null(slotindex);)
 319     SpaceManagerTestBed* bed = _testbeds.at(slotindex);
 320     bed-&gt;checked_random_deallocate();
 321   }
 322 
 323   void deallocate_from_random_testbed() {
 324     int slot = _testbeds.random_non_null_slot_index();
 325     if (slot != -1) {
 326       deallocate_from_testbed(slot);
 327     }
 328   }
 329 
 330   /////// Stats ///////////////////////////////////////
 331 
 332   int get_total_number_of_allocations() const {
 333     int sum = 0;
 334     for (int i = _testbeds.first_non_null_slot(); i != -1; i = _testbeds.next_non_null_slot(i)) {
 335       sum += _testbeds.at(i)-&gt;num_allocations();
 336     }
 337     return sum;
 338   }
 339 
 340   size_t get_total_words_allocated() const {
 341     size_t sum = 0;
 342     for (int i = _testbeds.first_non_null_slot(); i != -1; i = _testbeds.next_non_null_slot(i)) {
 343       sum += _testbeds.at(i)-&gt;words_allocated();
 344     }
 345     return sum;
 346   }
 347 
 348 public:
 349 
 350   SpaceManagerTest(size_t commit_limit)
 351     : _helper(commit_limit),
 352       _rss_at_start(get_workingset_size()),
 353       _testbeds(32),
 354       _num_beds()
 355   {}
 356 
 357   ~SpaceManagerTest () {
 358 
 359     // We compare our footprint now against what we had when the test started. Note that this is
 360     // of course fuzzy. We only do this to catch run-away leaks.
 361 
 362     const size_t rss_after_test = get_workingset_size();
 363 
 364     const size_t estimated_gtest_footprint = 4 * M;
 365 
 366     const size_t estimated_footprint = estimated_gtest_footprint +
 367                                        get_total_words_allocated() +
 368                                        get_total_number_of_allocations() * 10 +
 369                                        (sizeof(SpaceManagerTestBed) + sizeof(SpaceManagerTestBed*)) * _testbeds.size();
 370 
 371     const float margin_factor = 1.5f;
 372     EXPECT_LE(rss_after_test, _rss_at_start + estimated_footprint * margin_factor);
 373 
 374     delete_all_test_beds();
 375 
 376     const size_t rss_after_cleanup = get_workingset_size();
 377 
 378     // Check for memory leaks. We should ideally be at the baseline of _rss_at_start. However, this depends
 379     // on whether this gtest was executed as a first test in the suite, since gtest suite adds overhead of 2-4 MB.
 380     EXPECT_LE(rss_after_cleanup, _rss_at_start + estimated_gtest_footprint);
 381 
 382     LOG("rss at start: " INTX_FORMAT ", after test " INTX_FORMAT " (+" INTX_FORMAT "), after cleanup: " INTX_FORMAT " (+" INTX_FORMAT ").", \
 383         _rss_at_start, rss_after_test, rss_after_test - _rss_at_start, rss_after_cleanup, rss_after_cleanup - _rss_at_start); \
 384 
 385   }
 386 
 387 
 388   //////////////// Tests ////////////////////////
 389 
 390   void test() {
 391 
 392     // In a big loop, randomly chose one of these actions
 393     // - creating a test bed (simulates a new loader creation)
 394     // - allocating from a test bed (simulates allocating metaspace for a loader)
 395     // - (rarely) deallocate (simulates metaspace deallocation, e.g. class redefinitions)
 396     // - delete a test bed (simulates collection of a loader and subsequent return of metaspace to freelists)
 397 
 398     const int iterations = 0x4000;
 399 
 400     // Lets have a ceiling on number of words allocated (this is independent from the commit limit)
 401     const size_t max_allocation_size = 8 * M;
 402 
 403     bool force_bed_deletion = false;
 404 
 405     for (int niter = 0; niter &lt; iterations; niter ++) {
 406 
 407       const int r = IntRange(100).random_value();
 408 
 409       if (force_bed_deletion || r &lt; 10) {
 410 
 411         force_bed_deletion = false;
 412         delete_random_test_bed();
 413 
 414       } else if (r &lt; 20 || _num_beds.get() &lt; (unsigned)_testbeds.size() / 2) {
 415 
 416         create_random_test_bed();
 417 
 418       } else if (r &lt; 95) {
 419 
 420         // If allocation fails, we hit the commit limit and should delete some beds first
 421         force_bed_deletion = ! random_allocate_random_times_from_random_testbed();
 422 
 423       } else {
 424 
 425         // Note: does not affect the used words counter.
 426         deallocate_from_random_testbed();
 427 
 428       }
 429 
 430       // If we are close to our quota, start bed deletion
 431       if (_used_words_counter.get() &gt;= max_allocation_size) {
 432 
 433         force_bed_deletion = true;
 434 
 435       }
 436 
 437     }
 438 
 439   }
 440 
 441 
 442 };
 443 
 444 
 445 TEST_VM(metaspace, spacemanager_random_allocs_no_commit_limit) {
 446   SpaceManagerTest test(max_uintx);
 447   test.test();
 448 }
 449 
 450 TEST_VM(metaspace, spacemanager_random_allocs_with_commit_limit) {
 451   SpaceManagerTest test(2 * M);
 452   test.test();
 453 }
 454 
 455 
 456 
</pre></body></html>
