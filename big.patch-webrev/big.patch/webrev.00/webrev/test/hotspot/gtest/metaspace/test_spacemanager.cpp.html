<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_spacemanager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 
  27 #include "precompiled.hpp"
  28 
  29 #define LOG_PLEASE
  30 
  31 #include "metaspace/metaspaceTestsCommon.hpp"
  32 #include "metaspace/metaspace_sparsearray.hpp"
  33 #include "metaspace/metaspace_testhelper.hpp"
  34 #include "utilities/ostream.hpp"
  35 
  36 class SpaceManagerTestHelper {
  37 
  38   MetaspaceTestHelper&amp; _helper;
  39 
  40   Mutex* _lock;
  41   const ArenaGrowthPolicy* _growth_policy;
  42   SizeAtomicCounter _used_words_counter;
  43   SpaceManager* _sm;
  44 
  45 public:
  46 
  47   SpaceManagerTestHelper(MetaspaceTestHelper&amp; helper, metaspace::MetaspaceType space_type)
  48     : _helper(helper),
  49       _lock(NULL),
  50       _growth_policy(NULL),
  51       _used_words_counter(),
  52       _sm(NULL)
  53   {
  54     _growth_policy = ArenaGrowthPolicy::policy_for_space_type(space_type, false);
  55     _lock = new Mutex(Monitor::native, "gtest-SpaceManagerTest-lock", false, Monitor::_safepoint_check_never);
  56     // Lock during space creation, since this is what happens in the VM too
  57     //  (see ClassLoaderData::metaspace_non_null(), which we mimick here).
  58     {
  59       MutexLocker ml(_lock,  Mutex::_no_safepoint_check_flag);
  60       _sm = new SpaceManager(&amp;_helper.cm(), _growth_policy, _lock, &amp;_used_words_counter, "gtest-SpaceManagerTest-sm", false);
  61     }
  62     DEBUG_ONLY(_sm-&gt;verify(true));
  63   }
  64 
  65   ~SpaceManagerTestHelper() {
  66     delete_sm_with_tests();
  67     delete _lock;
  68   }
  69 
  70   const CommitLimiter&amp; limiter() const { return _helper.commit_limiter(); }
  71   SpaceManager* sm() const { return _sm; }
  72   SizeAtomicCounter&amp; used_words_counter() { return _used_words_counter; }
  73 
  74   void delete_sm_with_tests() {
  75     if (_sm != NULL) {
  76       size_t used_words_before = _used_words_counter.get();
  77       size_t committed_words_before = limiter().committed_words();
  78       DEBUG_ONLY(_sm-&gt;verify(true));
  79       delete _sm;
  80       _sm = NULL;
  81       size_t used_words_after = _used_words_counter.get();
  82       size_t committed_words_after = limiter().committed_words();
  83       EXPECT_0(used_words_after);
  84       if (Settings::uncommit_on_return()) {
  85         EXPECT_LE(committed_words_after, committed_words_before);
  86       } else {
  87         EXPECT_EQ(committed_words_after, committed_words_before);
  88       }
  89     }
  90   }
  91 
  92   bool allocate_from_sm_with_tests(size_t word_size) {
  93     if (_sm != NULL) {
  94 
  95       size_t used_words_before = _used_words_counter.get();
  96       size_t committed_words_before = limiter().committed_words();
  97       size_t possible_expansion = limiter().possible_expansion_words();
  98 
  99       MetaWord* p = _sm-&gt;allocate(word_size);
 100 
 101       size_t used_words_after = _used_words_counter.get();
 102       size_t committed_words_after = limiter().committed_words();
 103 
 104       if (p == NULL) {
 105         EXPECT_LT(possible_expansion, word_size);
 106         EXPECT_EQ(used_words_after, used_words_before);
 107         return false;
 108       } else {
 109         EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));
 110         EXPECT_GE(used_words_after, used_words_before + word_size); // note: overhead in sm
 111         EXPECT_GE(committed_words_after, committed_words_before);
 112         return true;
 113       }
 114     }
 115     return false;
 116   }
 117 
 118 };
 119 
 120 
 121 static void test_basics(size_t commit_limit, bool is_micro) {
 122   MetaspaceTestHelper msthelper(commit_limit);
 123   SpaceManagerTestHelper helper(msthelper, is_micro ? metaspace::ReflectionMetaspaceType : metaspace::StandardMetaspaceType);
 124 
 125   helper.sm()-&gt;allocate(1);
 126   helper.sm()-&gt;allocate(128);
 127   helper.sm()-&gt;allocate(128 * K);
 128   helper.sm()-&gt;allocate(1);
 129   helper.sm()-&gt;allocate(128);
 130   helper.sm()-&gt;allocate(128 * K);
 131 }
 132 
 133 TEST_VM(metaspace, spacemanager_basics_micro_nolimit) {
 134   test_basics(max_uintx, true);
 135 }
 136 
 137 TEST_VM(metaspace, spacemanager_basics_micro_limit) {
 138   test_basics(256 * K, true);
 139 }
 140 
 141 TEST_VM(metaspace, spacemanager_basics_standard_nolimit) {
 142   test_basics(max_uintx, false);
 143 }
 144 
 145 TEST_VM(metaspace, spacemanager_basics_standard_limit) {
 146   test_basics(256 * K, false);
 147 }
 148 
 149 static void test_recover_from_commit_limit_hit() {
 150   // Test:
 151   // - Multiple SpaceManager allocate (operating under the same commit limiter).
 152   // - One, while attempting to commit parts of its current chunk on demand,
 153   //   triggers the limit and cannot commit its chunk further.
 154   // - We release the other SpaceManager - its content is put back to the
 155   //   freelists.
 156   // - We re-attempt allocation from the first manager. It should now succeed.
 157   //
 158   // This means if the first SpaceManager may have to let go of its current chunk and
 159   // retire it and take a fresh chunk from the freelist.
 160 
 161   const size_t commit_limit = Settings::commit_granule_words() * 10;
 162   MetaspaceTestHelper msthelper(commit_limit);
 163 
 164   // The first space managers mimick micro loaders. This will fill the free
 165   //  chunk list with very small chunks. We allocate from them in an interleaved
 166   //  way to cause fragmentation.
 167   SpaceManagerTestHelper helper1(msthelper, metaspace::ReflectionMetaspaceType);
 168   SpaceManagerTestHelper helper2(msthelper, metaspace::ReflectionMetaspaceType);
 169 
 170   // This SpaceManager should hit the limit. We use BootMetaspaceType here since
 171   // it gets a large initial chunk which is committed
 172   // on demand and we are likely to hit a commit limit while trying to expand it.
 173   SpaceManagerTestHelper helper3(msthelper, metaspace::BootMetaspaceType);
 174 
 175   // Allocate space until we have below two but above one granule left
 176   while (msthelper.commit_limiter().possible_expansion_words() &gt;= Settings::commit_granule_words() * 2) {
 177     helper1.allocate_from_sm_with_tests(1);
 178     helper2.allocate_from_sm_with_tests(1);
 179   }
 180 
 181   // Now, allocating from helper3, creep up on the limit
 182   size_t allocated_from_3 = 0;
 183   while (helper3.allocate_from_sm_with_tests(1) &amp;&amp;
 184          ++allocated_from_3 &lt; Settings::commit_granule_words() * 2);
 185 
 186   EXPECT_LE(allocated_from_3, Settings::commit_granule_words() * 2);
 187 
 188   // We expect the freelist to be empty of committed space...
 189   EXPECT_0(msthelper.cm().total_committed_word_size());
 190 
 191   //msthelper.cm().print_on(tty);
 192 
 193   // Release the first SpaceManager.
 194   helper1.delete_sm_with_tests();
 195 
 196   //msthelper.cm().print_on(tty);
 197 
 198   // Should have populated the freelist with committed space
 199   // We expect the freelist to be empty of committed space...
 200   EXPECT_GT(msthelper.cm().total_committed_word_size(), (size_t)0);
 201 
 202   // Repeat allocation from helper3, should now work.
 203   EXPECT_TRUE(helper3.allocate_from_sm_with_tests(1));
 204 
 205 }
 206 
 207 
 208 TEST_VM(metaspace, spacemanager_recover_from_limit_hit) {
 209   test_recover_from_commit_limit_hit();
 210 }
 211 
 212 
 213 
 214 
 215 
</pre></body></html>
