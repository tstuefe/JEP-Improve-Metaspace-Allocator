<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New test/hotspot/gtest/metaspace/test_chunkManager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 #include "precompiled.hpp"
  26 
  27 //#define LOG_PLEASE
  28 
  29 #include "metaspace/metaspace_sparsearray.hpp"
  30 #include "metaspace/metaspace_testhelper.hpp"
  31 #include "metaspace/metaspaceTestsCommon.hpp"
  32 
  33 
  34 class ChunkManagerRandomChunkAllocTest {
  35 
  36   static const size_t max_footprint_words = 8 * M;
  37 
  38   MetaspaceTestHelper _helper;
  39 
  40   // All allocated live chunks
  41   typedef SparseArray&lt;Metachunk*&gt; SparseArrayOfChunks;
  42   SparseArrayOfChunks _chunks;
  43 
  44   const ChunkLevelRange _chunklevel_range;
  45   const float _commit_factor;
  46 
  47   // Depending on a probability pattern, come up with a reasonable limit to number of live chunks
  48   static int max_num_live_chunks(ChunkLevelRange r, float commit_factor) {
  49     // Assuming we allocate only the largest type of chunk, committed to the fullest commit factor,
  50     // how many chunks can we accomodate before hitting max_footprint_words?
  51     const size_t largest_chunk_size = word_size_for_level(r.lowest());
  52     int max_chunks = (max_footprint_words * commit_factor) / largest_chunk_size;
  53     // .. but cap at (min) 50 and (max) 1000
  54     max_chunks = MIN2(1000, max_chunks);
  55     max_chunks = MAX2(50, max_chunks);
  56     return max_chunks;
  57   }
  58 
  59   // Return true if, after an allocation error happened, a reserve error seems likely.
  60   bool could_be_reserve_error() {
  61     return _helper.vslist().is_full();
  62   }
  63 
  64   // Return true if, after an allocation error happened, a commit error seems likely.
  65   bool could_be_commit_error(size_t additional_word_size) {
  66 
  67     // could it be commit limit hit?
  68     // Note that this is difficult to verify precisely, since there are
  69     // several layers of truth:
  70     // a) at the lowest layer (RootChunkArea) we have a bitmap of committed granules;
  71     // b) at the vslist layer, we keep running counters of committed/reserved words;
  72     // c) at the chunk layer, we keep a commit watermark (committed_words).
  73     //
  74     // (a) should mirror reality.
  75     // (a) and (b) should be precisely in sync. This is tested by
  76     // VirtualSpaceList::verify().
  77     // (c) can be, by design, imprecise (too low).
  78     //
  79     // Here, I check (b) and trust it to be correct. We also call vslist::verify().
  80     DEBUG_ONLY(_helper.verify();)
  81 
  82     const size_t commit_add = align_up(additional_word_size, Settings::commit_granule_words());
  83     if (_helper.commit_limit() &lt;= (commit_add + _helper.vslist().committed_words())) {
  84       return true;
  85     }
  86 
  87     return false;
  88 
  89   }
  90 
  91   // Given a chunk level and a factor, return a random commit size.
  92   static size_t random_committed_words(chunklevel_t lvl, float commit_factor) {
  93     const size_t sz = word_size_for_level(lvl) * commit_factor;
  94     if (sz &lt; 2) {
  95       return 0;
  96     }
  97     return MIN2(SizeRange(sz).random_value(), sz);
  98   }
  99 
 100 
 101   //// Chunk allocation ////
 102 
 103   // Given an slot index, allocate a random chunk and set it into that slot. Slot must be empty.
 104   // Returns false if allocation fails.
 105   bool allocate_random_chunk_at(int slot) {
 106 
 107     DEBUG_ONLY(_chunks.check_slot_is_null(slot);)
 108 
 109     const ChunkLevelRange r = _chunklevel_range.random_subrange();
 110     const chunklevel_t pref_level = r.lowest();
 111     const chunklevel_t max_level = r.highest();
 112     const size_t min_committed = random_committed_words(max_level, _commit_factor);
 113 
 114     Metachunk* c = _helper.alloc_chunk(r.lowest(), r.highest(), min_committed);
 115     if (c == NULL) {
 116       EXPECT_TRUE(could_be_reserve_error() ||
 117                   could_be_commit_error(min_committed));
 118       LOG("Alloc chunk at %d failed.", slot);
 119       return false;
 120     }
 121 
 122     _chunks.set_at(slot, c);
 123 
 124     LOG("Allocated chunk at %d: " METACHUNK_FORMAT ".", slot, METACHUNK_FORMAT_ARGS(c));
 125 
 126     return true;
 127 
 128   }
 129 
 130   // Allocates a random number of random chunks
 131   bool allocate_random_chunks() {
 132     int to_alloc = 1 + IntRange(MAX2(1, _chunks.size() / 8)).random_value();
 133     bool success = true;
 134     int slot = _chunks.first_null_slot();
 135     while (to_alloc &gt; 0 &amp;&amp; slot != -1 &amp;&amp; success) {
 136       success = allocate_random_chunk_at(slot);
 137       slot = _chunks.next_null_slot(slot);
 138       to_alloc --;
 139     }
 140     return success &amp;&amp; to_alloc == 0;
 141   }
 142 
 143   bool fill_all_slots_with_random_chunks() {
 144     bool success = true;
 145     for (int slot = _chunks.first_null_slot();
 146          slot != -1 &amp;&amp; success; slot = _chunks.next_null_slot(slot)) {
 147       success = allocate_random_chunk_at(slot);
 148     }
 149     return success;
 150   }
 151 
 152   //// Chunk return ////
 153 
 154   // Given an slot index, return the chunk in that slot to the chunk manager.
 155   void return_chunk_at(int slot) {
 156     Metachunk* c = _chunks.at(slot);
 157     LOG("Returning chunk at %d: " METACHUNK_FORMAT ".", slot, METACHUNK_FORMAT_ARGS(c));
 158     _helper.return_chunk(c);
 159     _chunks.set_at(slot, NULL);
 160   }
 161 
 162   // return a random number of chunks (at most a quarter of the full slot range)
 163   void return_random_chunks() {
 164     int to_free = 1 + IntRange(MAX2(1, _chunks.size() / 8)).random_value();
 165     int index = _chunks.first_non_null_slot();
 166     while (to_free &gt; 0 &amp;&amp; index != -1) {
 167       return_chunk_at(index);
 168       index = _chunks.next_non_null_slot(index);
 169       to_free --;
 170     }
 171   }
 172 
 173   void return_all_chunks() {
 174     for (int slot = _chunks.first_non_null_slot();
 175          slot != -1; slot = _chunks.next_non_null_slot(slot)) {
 176       return_chunk_at(slot);
 177     }
 178   }
 179 
 180   // adjust test if we change levels
 181   STATIC_ASSERT(HIGHEST_CHUNK_LEVEL == CHUNK_LEVEL_1K);
 182   STATIC_ASSERT(LOWEST_CHUNK_LEVEL == CHUNK_LEVEL_4M);
 183 
 184   void one_test() {
 185 
 186     fill_all_slots_with_random_chunks();
 187     _chunks.shuffle();
 188 
 189     IntRange rand(100);
 190 
 191     for (int j = 0; j &lt; 1000; j ++) {
 192 
 193       bool force_alloc = false;
 194       bool force_free = true;
 195 
 196       bool do_alloc =
 197           force_alloc ? true :
 198               (force_free ? false : rand.random_value() &gt;= 50);
 199       force_alloc = force_free = false;
 200 
 201       if (do_alloc) {
 202         if (!allocate_random_chunks()) {
 203           force_free = true;
 204         }
 205       } else {
 206         return_random_chunks();
 207       }
 208 
 209       _chunks.shuffle();
 210 
 211     }
 212 
 213     return_all_chunks();
 214 
 215   }
 216 
 217 
 218 public:
 219 
 220   // A test with no limits
 221   ChunkManagerRandomChunkAllocTest(ChunkLevelRange r, float commit_factor)
 222     : _helper(),
 223       _chunks(max_num_live_chunks(r, commit_factor)),
 224       _chunklevel_range(r),
 225       _commit_factor(commit_factor)
 226   {}
 227 
 228   // A test with no reserve limit but commit limit
 229   ChunkManagerRandomChunkAllocTest(size_t commit_limit,
 230                                    ChunkLevelRange r, float commit_factor)
 231     : _helper(commit_limit),
 232       _chunks(max_num_live_chunks(r, commit_factor)),
 233       _chunklevel_range(r),
 234       _commit_factor(commit_factor)
 235   {}
 236 
 237   // A test with both reserve and commit limit
 238   ChunkManagerRandomChunkAllocTest(size_t reserve_limit, size_t commit_limit,
 239                                    ChunkLevelRange r, float commit_factor)
 240     : _helper(reserve_limit, commit_limit),
 241       _chunks(max_num_live_chunks(r, commit_factor)),
 242       _chunklevel_range(r),
 243       _commit_factor(commit_factor)
 244   {}
 245 
 246 
 247   void do_tests() {
 248     const int num_runs = 5;
 249     for (int n = 0; n &lt; num_runs; n ++) {
 250       one_test();
 251     }
 252   }
 253 
 254 };
 255 
 256 #define DEFINE_TEST(name, range, commit_factor) \
 257 TEST_VM(metaspace, chunkmanager_##name) { \
 258         ChunkManagerRandomChunkAllocTest test(range, commit_factor); \
 259         test.do_tests(); \
 260 }
 261 
 262 DEFINE_TEST(test_nolimit_1, ChunkLevelRanges::small_chunks(), 0.0f)
 263 DEFINE_TEST(test_nolimit_2, ChunkLevelRanges::small_chunks(), 0.5f)
 264 DEFINE_TEST(test_nolimit_3, ChunkLevelRanges::small_chunks(), 1.0f)
 265 
 266 DEFINE_TEST(test_nolimit_4, ChunkLevelRanges::all_chunks(), 0.0f)
 267 DEFINE_TEST(test_nolimit_5, ChunkLevelRanges::all_chunks(), 0.5f)
 268 DEFINE_TEST(test_nolimit_6, ChunkLevelRanges::all_chunks(), 1.0f)
 269 
 270 #define DEFINE_TEST_2(name, range, commit_factor) \
 271 TEST_VM(metaspace, chunkmanager_##name) { \
 272   const size_t commit_limit = 256 * K; \
 273   ChunkManagerRandomChunkAllocTest test(commit_limit, range, commit_factor); \
 274   test.do_tests(); \
 275 }
 276 
 277 DEFINE_TEST_2(test_with_limit_1, ChunkLevelRanges::small_chunks(), 0.0f)
 278 DEFINE_TEST_2(test_with_limit_2, ChunkLevelRanges::small_chunks(), 0.5f)
 279 DEFINE_TEST_2(test_with_limit_3, ChunkLevelRanges::small_chunks(), 1.0f)
 280 
 281 DEFINE_TEST_2(test_with_limit_4, ChunkLevelRanges::all_chunks(), 0.0f)
 282 DEFINE_TEST_2(test_with_limit_5, ChunkLevelRanges::all_chunks(), 0.5f)
 283 DEFINE_TEST_2(test_with_limit_6, ChunkLevelRanges::all_chunks(), 1.0f)
 284 
 285 
</pre></body></html>
