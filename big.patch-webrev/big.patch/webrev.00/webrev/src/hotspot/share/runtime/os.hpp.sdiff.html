<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Sdiff src/hotspot/share/runtime </title>
</head><body id="SUNWwebrev">
<center><a href='../../../../src/hotspot/share/runtime/globals.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/vmOperations.cpp.sdiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/runtime/os.hpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 389 
 390   // Page manipulation
 391   struct page_info {
 392     size_t size;
 393     int lgrp_id;
 394   };
 395   static bool   get_page_info(char *start, page_info* info);
 396   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 397 
 398   static char*  non_memory_address_word();
 399   // reserve, commit and pin the entire memory region
 400   static char*  reserve_memory_special(size_t size, size_t alignment,
 401                                        char* addr, bool executable);
 402   static bool   release_memory_special(char* addr, size_t bytes);
 403   static void   large_page_init();
 404   static size_t large_page_size();
 405   static bool   can_commit_large_page_memory();
 406   static bool   can_execute_large_page_memory();
 407 
 408   // Check if pointer points to readable memory (by 4-byte read access)


 409   static bool    is_readable_pointer(const void* p);
 410   static bool    is_readable_range(const void* from, const void* to);
 411 
 412   // threads
 413 
 414   enum ThreadType {
 415     vm_thread,
 416     cgc_thread,        // Concurrent GC thread
 417     pgc_thread,        // Parallel GC thread
 418     java_thread,       // Java, CodeCacheSweeper, JVMTIAgent and Service threads.
 419     compiler_thread,
 420     watcher_thread,
 421     os_thread
 422   };
 423 
 424   static bool create_thread(Thread* thread,
 425                             ThreadType thr_type,
 426                             size_t req_stack_size = 0);
 427 
 428   // The "main thread", also known as "starting thread", is the thread

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 389 
 390   // Page manipulation
 391   struct page_info {
 392     size_t size;
 393     int lgrp_id;
 394   };
 395   static bool   get_page_info(char *start, page_info* info);
 396   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 397 
 398   static char*  non_memory_address_word();
 399   // reserve, commit and pin the entire memory region
 400   static char*  reserve_memory_special(size_t size, size_t alignment,
 401                                        char* addr, bool executable);
 402   static bool   release_memory_special(char* addr, size_t bytes);
 403   static void   large_page_init();
 404   static size_t large_page_size();
 405   static bool   can_commit_large_page_memory();
 406   static bool   can_execute_large_page_memory();
 407 
 408   // Check if pointer points to readable memory (by 4-byte read access)
<span class="new"> 409   // !! Unreliable before VM initialization! Use CanUseSafeFetch32() to test</span>
<span class="new"> 410   //    if this function is reliable !!</span>
 411   static bool    is_readable_pointer(const void* p);
 412   static bool    is_readable_range(const void* from, const void* to);
 413 
 414   // threads
 415 
 416   enum ThreadType {
 417     vm_thread,
 418     cgc_thread,        // Concurrent GC thread
 419     pgc_thread,        // Parallel GC thread
 420     java_thread,       // Java, CodeCacheSweeper, JVMTIAgent and Service threads.
 421     compiler_thread,
 422     watcher_thread,
 423     os_thread
 424   };
 425 
 426   static bool create_thread(Thread* thread,
 427                             ThreadType thr_type,
 428                             size_t req_stack_size = 0);
 429 
 430   // The "main thread", also known as "starting thread", is the thread

</pre><hr></hr>
</pre></td>
</tr></table>
<center><a href='../../../../src/hotspot/share/runtime/globals.hpp.sdiff.html' target='_top'>&lt prev</a> <a href='../../../../index.html' target='_top'>index</a> <a href='../../../../src/hotspot/share/runtime/vmOperations.cpp.sdiff.html' target='_top'>next &gt</a></center>
</body></html>
