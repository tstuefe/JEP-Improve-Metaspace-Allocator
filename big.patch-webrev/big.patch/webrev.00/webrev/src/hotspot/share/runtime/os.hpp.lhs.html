<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_RUNTIME_OS_HPP
  26 #define SHARE_RUNTIME_OS_HPP
  27 
  28 #include "jvm.h"
  29 #include "jvmtifiles/jvmti.h"
  30 #include "metaprogramming/isRegisteredEnum.hpp"
  31 #include "metaprogramming/integralConstant.hpp"
  32 #include "utilities/exceptions.hpp"
  33 #include "utilities/ostream.hpp"
  34 #include "utilities/macros.hpp"
  35 #ifndef _WINDOWS
  36 # include &lt;setjmp.h&gt;
  37 #endif
  38 #ifdef __APPLE__
  39 # include &lt;mach/mach_time.h&gt;
  40 #endif
  41 
  42 class AgentLibrary;
  43 class frame;
  44 
  45 // os defines the interface to operating system; this includes traditional
  46 // OS services (time, I/O) as well as other functionality with system-
  47 // dependent code.
  48 
  49 class Thread;
  50 class JavaThread;
  51 class NativeCallStack;
  52 class methodHandle;
  53 class OSThread;
  54 class Mutex;
  55 
  56 template&lt;class E&gt; class GrowableArray;
  57 
  58 // %%%%% Moved ThreadState, START_FN, OSThread to new osThread.hpp. -- Rose
  59 
  60 // Platform-independent error return values from OS functions
  61 enum OSReturn {
  62   OS_OK         =  0,        // Operation was successful
  63   OS_ERR        = -1,        // Operation failed
  64   OS_INTRPT     = -2,        // Operation was interrupted
  65   OS_TIMEOUT    = -3,        // Operation timed out
  66   OS_NOMEM      = -5,        // Operation failed for lack of memory
  67   OS_NORESOURCE = -6         // Operation failed for lack of nonmemory resource
  68 };
  69 
  70 enum ThreadPriority {        // JLS 20.20.1-3
  71   NoPriority       = -1,     // Initial non-priority value
  72   MinPriority      =  1,     // Minimum priority
  73   NormPriority     =  5,     // Normal (non-daemon) priority
  74   NearMaxPriority  =  9,     // High priority, used for VMThread
  75   MaxPriority      = 10,     // Highest priority, used for WatcherThread
  76                              // ensures that VMThread doesn't starve profiler
  77   CriticalPriority = 11      // Critical thread priority
  78 };
  79 
  80 // Executable parameter flag for os::commit_memory() and
  81 // os::commit_memory_or_exit().
  82 const bool ExecMem = true;
  83 
  84 // Typedef for structured exception handling support
  85 typedef void (*java_call_t)(JavaValue* value, const methodHandle&amp; method, JavaCallArguments* args, Thread* thread);
  86 
  87 class MallocTracker;
  88 
  89 class os: AllStatic {
  90   friend class VMStructs;
  91   friend class JVMCIVMStructs;
  92   friend class MallocTracker;
  93 
  94 #ifdef ASSERT
  95  private:
  96   static bool _mutex_init_done;
  97  public:
  98   static void set_mutex_init_done() { _mutex_init_done = true; }
  99   static bool mutex_init_done() { return _mutex_init_done; }
 100 #endif
 101 
 102  public:
 103   enum { page_sizes_max = 9 }; // Size of _page_sizes array (8 plus a sentinel)
 104 
 105  private:
 106   static OSThread*          _starting_thread;
 107   static address            _polling_page;
 108  public:
 109   static size_t             _page_sizes[page_sizes_max];
 110 
 111  private:
 112   static void init_page_sizes(size_t default_page_size) {
 113     _page_sizes[0] = default_page_size;
 114     _page_sizes[1] = 0; // sentinel
 115   }
 116 
 117   static char*  pd_reserve_memory(size_t bytes, char* addr = 0,
 118                                   size_t alignment_hint = 0);
 119   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);
 120   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);
 121   static bool   pd_commit_memory(char* addr, size_t bytes, bool executable);
 122   static bool   pd_commit_memory(char* addr, size_t size, size_t alignment_hint,
 123                                  bool executable);
 124   // Same as pd_commit_memory() that either succeeds or calls
 125   // vm_exit_out_of_memory() with the specified mesg.
 126   static void   pd_commit_memory_or_exit(char* addr, size_t bytes,
 127                                          bool executable, const char* mesg);
 128   static void   pd_commit_memory_or_exit(char* addr, size_t size,
 129                                          size_t alignment_hint,
 130                                          bool executable, const char* mesg);
 131   static bool   pd_uncommit_memory(char* addr, size_t bytes);
 132   static bool   pd_release_memory(char* addr, size_t bytes);
 133 
 134   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
 135                            char *addr, size_t bytes, bool read_only = false,
 136                            bool allow_exec = false);
 137   static char*  pd_remap_memory(int fd, const char* file_name, size_t file_offset,
 138                              char *addr, size_t bytes, bool read_only,
 139                              bool allow_exec);
 140   static bool   pd_unmap_memory(char *addr, size_t bytes);
 141   static void   pd_free_memory(char *addr, size_t bytes, size_t alignment_hint);
 142   static void   pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint);
 143 
 144   static char*  pd_reserve_memory_special(size_t size, size_t alignment,
 145                                           char* addr, bool executable);
 146   static bool   pd_release_memory_special(char* addr, size_t bytes);
 147 
 148   static size_t page_size_for_region(size_t region_size, size_t min_pages, bool must_be_aligned);
 149 
 150   // Get summary strings for system information in buffer provided
 151   static void  get_summary_cpu_info(char* buf, size_t buflen);
 152   static void  get_summary_os_info(char* buf, size_t buflen);
 153 
 154   static void initialize_initial_active_processor_count();
 155 
 156   LINUX_ONLY(static void pd_init_container_support();)
 157 
 158  public:
 159   static void init(void);                      // Called before command line parsing
 160 
 161   static void init_container_support() {       // Called during command line parsing.
 162      LINUX_ONLY(pd_init_container_support();)
 163   }
 164 
 165   static void init_before_ergo(void);          // Called after command line parsing
 166                                                // before VM ergonomics processing.
 167   static jint init_2(void);                    // Called after command line parsing
 168                                                // and VM ergonomics processing
 169 
 170   // unset environment variable
 171   static bool unsetenv(const char* name);
 172 
 173   static bool have_special_privileges();
 174 
 175   static jlong  javaTimeMillis();
 176   static jlong  javaTimeNanos();
 177   static void   javaTimeNanos_info(jvmtiTimerInfo *info_ptr);
 178   static void   javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos);
 179   static void   run_periodic_checks();
 180   static bool   supports_monotonic_clock();
 181 
 182   // Returns the elapsed time in seconds since the vm started.
 183   static double elapsedTime();
 184 
 185   // Returns real time in seconds since an arbitrary point
 186   // in the past.
 187   static bool getTimesSecs(double* process_real_time,
 188                            double* process_user_time,
 189                            double* process_system_time);
 190 
 191   // Interface to the performance counter
 192   static jlong elapsed_counter();
 193   static jlong elapsed_frequency();
 194 
 195   // The "virtual time" of a thread is the amount of time a thread has
 196   // actually run.  The first function indicates whether the OS supports
 197   // this functionality for the current thread, and if so the second
 198   // returns the elapsed virtual time for the current thread.
 199   static bool supports_vtime();
 200   static double elapsedVTime();
 201 
 202   // Return current local time in a string (YYYY-MM-DD HH:MM:SS).
 203   // It is MT safe, but not async-safe, as reading time zone
 204   // information may require a lock on some platforms.
 205   static char*      local_time_string(char *buf, size_t buflen);
 206   static struct tm* localtime_pd     (const time_t* clock, struct tm*  res);
 207   static struct tm* gmtime_pd        (const time_t* clock, struct tm*  res);
 208   // Fill in buffer with current local time as an ISO-8601 string.
 209   // E.g., YYYY-MM-DDThh:mm:ss.mmm+zzzz.
 210   // Returns buffer, or NULL if it failed.
 211   static char* iso8601_time(char* buffer, size_t buffer_length, bool utc = false);
 212 
 213   // Interface for detecting multiprocessor system
 214   static inline bool is_MP() {
 215     // During bootstrap if _processor_count is not yet initialized
 216     // we claim to be MP as that is safest. If any platform has a
 217     // stub generator that might be triggered in this phase and for
 218     // which being declared MP when in fact not, is a problem - then
 219     // the bootstrap routine for the stub generator needs to check
 220     // the processor count directly and leave the bootstrap routine
 221     // in place until called after initialization has ocurred.
 222     return (_processor_count != 1);
 223   }
 224 
 225   static julong available_memory();
 226   static julong physical_memory();
 227   static bool has_allocatable_memory_limit(julong* limit);
 228   static bool is_server_class_machine();
 229 
 230   // Returns the id of the processor on which the calling thread is currently executing.
 231   // The returned value is guaranteed to be between 0 and (os::processor_count() - 1).
 232   static uint processor_id();
 233 
 234   // number of CPUs
 235   static int processor_count() {
 236     return _processor_count;
 237   }
 238   static void set_processor_count(int count) { _processor_count = count; }
 239 
 240   // Returns the number of CPUs this process is currently allowed to run on.
 241   // Note that on some OSes this can change dynamically.
 242   static int active_processor_count();
 243 
 244   // At startup the number of active CPUs this process is allowed to run on.
 245   // This value does not change dynamically. May be different from active_processor_count().
 246   static int initial_active_processor_count() {
 247     assert(_initial_active_processor_count &gt; 0, "Initial active processor count not set yet.");
 248     return _initial_active_processor_count;
 249   }
 250 
 251   // Binds the current process to a processor.
 252   //    Returns true if it worked, false if it didn't.
 253   static bool bind_to_processor(uint processor_id);
 254 
 255   // Give a name to the current thread.
 256   static void set_native_thread_name(const char *name);
 257 
 258   // Interface for stack banging (predetect possible stack overflow for
 259   // exception processing)  There are guard pages, and above that shadow
 260   // pages for stack overflow checking.
 261   static bool uses_stack_guard_pages();
 262   static bool must_commit_stack_guard_pages();
 263   static void map_stack_shadow_pages(address sp);
 264   static bool stack_shadow_pages_available(Thread *thread, const methodHandle&amp; method, address sp);
 265 
 266   // Find committed memory region within specified range (start, start + size),
 267   // return true if found any
 268   static bool committed_in_range(address start, size_t size, address&amp; committed_start, size_t&amp; committed_size);
 269 
 270   // OS interface to Virtual Memory
 271 
 272   // Return the default page size.
 273   static int    vm_page_size();
 274 
 275   // Returns the page size to use for a region of memory.
 276   // region_size / min_pages will always be greater than or equal to the
 277   // returned value. The returned value will divide region_size.
 278   static size_t page_size_for_region_aligned(size_t region_size, size_t min_pages);
 279 
 280   // Returns the page size to use for a region of memory.
 281   // region_size / min_pages will always be greater than or equal to the
 282   // returned value. The returned value might not divide region_size.
 283   static size_t page_size_for_region_unaligned(size_t region_size, size_t min_pages);
 284 
 285   // Return the largest page size that can be used
 286   static size_t max_page_size() {
 287     // The _page_sizes array is sorted in descending order.
 288     return _page_sizes[0];
 289   }
 290 
 291   // Return a lower bound for page sizes. Also works before os::init completed.
 292   static size_t min_page_size() { return 4 * K; }
 293 
 294   // Methods for tracing page sizes returned by the above method.
 295   // The region_{min,max}_size parameters should be the values
 296   // passed to page_size_for_region() and page_size should be the result of that
 297   // call.  The (optional) base and size parameters should come from the
 298   // ReservedSpace base() and size() methods.
 299   static void trace_page_sizes(const char* str, const size_t* page_sizes, int count);
 300   static void trace_page_sizes(const char* str,
 301                                const size_t region_min_size,
 302                                const size_t region_max_size,
 303                                const size_t page_size,
 304                                const char* base,
 305                                const size_t size);
 306   static void trace_page_sizes_for_requested_size(const char* str,
 307                                                   const size_t requested_size,
 308                                                   const size_t page_size,
 309                                                   const size_t alignment,
 310                                                   const char* base,
 311                                                   const size_t size);
 312 
 313   static int    vm_allocation_granularity();
 314   static char*  reserve_memory(size_t bytes, char* addr = 0,
 315                                size_t alignment_hint = 0, int file_desc = -1);
 316   static char*  reserve_memory(size_t bytes, char* addr,
 317                                size_t alignment_hint, MEMFLAGS flags);
 318   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
 319   static char*  attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc = -1);
 320 
 321 
 322   // Split a reserved memory region [base, base+size) into two regions [base, base+split) and
 323   //  [base+split, base+size).
 324   //  This may remove the original mapping, so its content may be lost.
 325   // Both base and split point must be aligned to allocation granularity; split point shall
 326   //  be &gt;0 and &lt;size.
 327   // Splitting guarantees that the resulting two memory regions can be released independently
 328   //  from each other using os::release_memory(). It also means NMT will track these regions
 329   //  individually, allowing different tags to be set.
 330   static void   split_reserved_memory(char *base, size_t size, size_t split);
 331 
 332   static bool   commit_memory(char* addr, size_t bytes, bool executable);
 333   static bool   commit_memory(char* addr, size_t size, size_t alignment_hint,
 334                               bool executable);
 335   // Same as commit_memory() that either succeeds or calls
 336   // vm_exit_out_of_memory() with the specified mesg.
 337   static void   commit_memory_or_exit(char* addr, size_t bytes,
 338                                       bool executable, const char* mesg);
 339   static void   commit_memory_or_exit(char* addr, size_t size,
 340                                       size_t alignment_hint,
 341                                       bool executable, const char* mesg);
 342   static bool   uncommit_memory(char* addr, size_t bytes);
 343   static bool   release_memory(char* addr, size_t bytes);
 344 
 345   // Touch memory pages that cover the memory range from start to end (exclusive)
 346   // to make the OS back the memory range with actual memory.
 347   // Current implementation may not touch the last page if unaligned addresses
 348   // are passed.
 349   static void   pretouch_memory(void* start, void* end, size_t page_size = vm_page_size());
 350 
 351   enum ProtType { MEM_PROT_NONE, MEM_PROT_READ, MEM_PROT_RW, MEM_PROT_RWX };
 352   static bool   protect_memory(char* addr, size_t bytes, ProtType prot,
 353                                bool is_committed = true);
 354 
 355   static bool   guard_memory(char* addr, size_t bytes);
 356   static bool   unguard_memory(char* addr, size_t bytes);
 357   static bool   create_stack_guard_pages(char* addr, size_t bytes);
 358   static bool   pd_create_stack_guard_pages(char* addr, size_t bytes);
 359   static bool   remove_stack_guard_pages(char* addr, size_t bytes);
 360   // Helper function to create a new file with template jvmheap.XXXXXX.
 361   // Returns a valid fd on success or else returns -1
 362   static int create_file_for_heap(const char* dir);
 363   // Map memory to the file referred by fd. This function is slightly different from map_memory()
 364   // and is added to be used for implementation of -XX:AllocateHeapAt
 365   static char* map_memory_to_file(char* base, size_t size, int fd);
 366   // Replace existing reserved memory with file mapping
 367   static char* replace_existing_mapping_with_file_mapping(char* base, size_t size, int fd);
 368 
 369   static char*  map_memory(int fd, const char* file_name, size_t file_offset,
 370                            char *addr, size_t bytes, bool read_only = false,
 371                            bool allow_exec = false, MEMFLAGS flags = mtNone);
 372   static char*  remap_memory(int fd, const char* file_name, size_t file_offset,
 373                              char *addr, size_t bytes, bool read_only,
 374                              bool allow_exec);
 375   static bool   unmap_memory(char *addr, size_t bytes);
 376   static void   free_memory(char *addr, size_t bytes, size_t alignment_hint);
 377   static void   realign_memory(char *addr, size_t bytes, size_t alignment_hint);
 378 
 379   // NUMA-specific interface
 380   static bool   numa_has_static_binding();
 381   static bool   numa_has_group_homing();
 382   static void   numa_make_local(char *addr, size_t bytes, int lgrp_hint);
 383   static void   numa_make_global(char *addr, size_t bytes);
 384   static size_t numa_get_groups_num();
 385   static size_t numa_get_leaf_groups(int *ids, size_t size);
 386   static bool   numa_topology_changed();
 387   static int    numa_get_group_id();
 388   static int    numa_get_group_id_for_address(const void* address);
 389 
 390   // Page manipulation
 391   struct page_info {
 392     size_t size;
 393     int lgrp_id;
 394   };
 395   static bool   get_page_info(char *start, page_info* info);
 396   static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);
 397 
 398   static char*  non_memory_address_word();
 399   // reserve, commit and pin the entire memory region
 400   static char*  reserve_memory_special(size_t size, size_t alignment,
 401                                        char* addr, bool executable);
 402   static bool   release_memory_special(char* addr, size_t bytes);
 403   static void   large_page_init();
 404   static size_t large_page_size();
 405   static bool   can_commit_large_page_memory();
 406   static bool   can_execute_large_page_memory();
 407 
 408   // Check if pointer points to readable memory (by 4-byte read access)
<a name="1" id="anc1"></a>

 409   static bool    is_readable_pointer(const void* p);
 410   static bool    is_readable_range(const void* from, const void* to);
 411 
 412   // threads
 413 
 414   enum ThreadType {
 415     vm_thread,
 416     cgc_thread,        // Concurrent GC thread
 417     pgc_thread,        // Parallel GC thread
 418     java_thread,       // Java, CodeCacheSweeper, JVMTIAgent and Service threads.
 419     compiler_thread,
 420     watcher_thread,
 421     os_thread
 422   };
 423 
 424   static bool create_thread(Thread* thread,
 425                             ThreadType thr_type,
 426                             size_t req_stack_size = 0);
 427 
 428   // The "main thread", also known as "starting thread", is the thread
 429   // that loads/creates the JVM via JNI_CreateJavaVM.
 430   static bool create_main_thread(JavaThread* thread);
 431 
 432   // The primordial thread is the initial process thread. The java
 433   // launcher never uses the primordial thread as the main thread, but
 434   // applications that host the JVM directly may do so. Some platforms
 435   // need special-case handling of the primordial thread if it attaches
 436   // to the VM.
 437   static bool is_primordial_thread(void)
 438 #if defined(_WINDOWS) || defined(BSD)
 439     // No way to identify the primordial thread.
 440     { return false; }
 441 #else
 442   ;
 443 #endif
 444 
 445   static bool create_attached_thread(JavaThread* thread);
 446   static void pd_start_thread(Thread* thread);
 447   static void start_thread(Thread* thread);
 448 
 449   // Returns true if successful.
 450   static bool signal_thread(Thread* thread, int sig, const char* reason);
 451 
 452   static void free_thread(OSThread* osthread);
 453 
 454   // thread id on Linux/64bit is 64bit, on Windows it's 32bit
 455   static intx current_thread_id();
 456   static int current_process_id();
 457 
 458   // Short standalone OS sleep routines suitable for slow path spin loop.
 459   // Ignores safepoints/suspension/Thread.interrupt() (so keep it short).
 460   // ms/ns = 0, will sleep for the least amount of time allowed by the OS.
 461   // Maximum sleep time is just under 1 second.
 462   static void naked_short_sleep(jlong ms);
 463   static void naked_short_nanosleep(jlong ns);
 464   // Longer standalone OS sleep routine - a convenience wrapper around
 465   // multiple calls to naked_short_sleep. Only for use by non-JavaThreads.
 466   static void naked_sleep(jlong millis);
 467   // Never returns, use with CAUTION
 468   static void infinite_sleep();
 469   static void naked_yield () ;
 470   static OSReturn set_priority(Thread* thread, ThreadPriority priority);
 471   static OSReturn get_priority(const Thread* const thread, ThreadPriority&amp; priority);
 472 
 473   static int pd_self_suspend_thread(Thread* thread);
 474 
 475   static address    fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);
 476   static frame      fetch_frame_from_context(const void* ucVoid);
 477 
 478   static void breakpoint();
 479   static bool start_debugging(char *buf, int buflen);
 480 
 481   static address current_stack_pointer();
 482   static address current_stack_base();
 483   static size_t current_stack_size();
 484 
 485   static void verify_stack_alignment() PRODUCT_RETURN;
 486 
 487   static bool message_box(const char* title, const char* message);
 488 
 489   // run cmd in a separate process and return its exit code; or -1 on failures
 490   static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);
 491 
 492   // Call ::exit() on all platforms but Windows
 493   static void exit(int num);
 494 
 495   // Terminate the VM, but don't exit the process
 496   static void shutdown();
 497 
 498   // Terminate with an error.  Default is to generate a core file on platforms
 499   // that support such things.  This calls shutdown() and then aborts.
 500   static void abort(bool dump_core, void *siginfo, const void *context);
 501   static void abort(bool dump_core = true);
 502 
 503   // Die immediately, no exit hook, no abort hook, no cleanup.
 504   // Dump a core file, if possible, for debugging. os::abort() is the
 505   // preferred means to abort the VM on error. os::die() should only
 506   // be called if something has gone badly wrong. CreateCoredumpOnCrash
 507   // is intentionally not honored by this function.
 508   static void die();
 509 
 510   // File i/o operations
 511   static int open(const char *path, int oflag, int mode);
 512   static FILE* open(int fd, const char* mode);
 513   static FILE* fopen(const char* path, const char* mode);
 514   static int close(int fd);
 515   static jlong lseek(int fd, jlong offset, int whence);
 516   // This function, on Windows, canonicalizes a given path (see os_windows.cpp for details).
 517   // On Posix, this function is a noop: it does not change anything and just returns
 518   // the input pointer.
 519   static char* native_path(char *path);
 520   static int ftruncate(int fd, jlong length);
 521   static int fsync(int fd);
 522   static int available(int fd, jlong *bytes);
 523   static int get_fileno(FILE* fp);
 524   static void flockfile(FILE* fp);
 525   static void funlockfile(FILE* fp);
 526 
 527   static int compare_file_modified_times(const char* file1, const char* file2);
 528 
 529   static bool same_files(const char* file1, const char* file2);
 530 
 531   //File i/o operations
 532 
 533   static ssize_t read(int fd, void *buf, unsigned int nBytes);
 534   static ssize_t read_at(int fd, void *buf, unsigned int nBytes, jlong offset);
 535   static size_t write(int fd, const void *buf, unsigned int nBytes);
 536 
 537   // Reading directories.
 538   static DIR*           opendir(const char* dirname);
 539   static struct dirent* readdir(DIR* dirp);
 540   static int            closedir(DIR* dirp);
 541 
 542   // Dynamic library extension
 543   static const char*    dll_file_extension();
 544 
 545   static const char*    get_temp_directory();
 546   static const char*    get_current_directory(char *buf, size_t buflen);
 547 
 548   // Builds the platform-specific name of a library.
 549   // Returns false if the buffer is too small.
 550   static bool           dll_build_name(char* buffer, size_t size,
 551                                        const char* fname);
 552 
 553   // Builds a platform-specific full library path given an ld path and
 554   // unadorned library name. Returns true if the buffer contains a full
 555   // path to an existing file, false otherwise. If pathname is empty,
 556   // uses the path to the current directory.
 557   static bool           dll_locate_lib(char* buffer, size_t size,
 558                                        const char* pathname, const char* fname);
 559 
 560   // Symbol lookup, find nearest function name; basically it implements
 561   // dladdr() for all platforms. Name of the nearest function is copied
 562   // to buf. Distance from its base address is optionally returned as offset.
 563   // If function name is not found, buf[0] is set to '\0' and offset is
 564   // set to -1 (if offset is non-NULL).
 565   static bool dll_address_to_function_name(address addr, char* buf,
 566                                            int buflen, int* offset,
 567                                            bool demangle = true);
 568 
 569   // Locate DLL/DSO. On success, full path of the library is copied to
 570   // buf, and offset is optionally set to be the distance between addr
 571   // and the library's base address. On failure, buf[0] is set to '\0'
 572   // and offset is set to -1 (if offset is non-NULL).
 573   static bool dll_address_to_library_name(address addr, char* buf,
 574                                           int buflen, int* offset);
 575 
 576   // Find out whether the pc is in the static code for jvm.dll/libjvm.so.
 577   static bool address_is_in_vm(address addr);
 578 
 579   // Loads .dll/.so and
 580   // in case of error it checks if .dll/.so was built for the
 581   // same architecture as HotSpot is running on
 582   // in case of an error NULL is returned and an error message is stored in ebuf
 583   static void* dll_load(const char *name, char *ebuf, int ebuflen);
 584 
 585   // lookup symbol in a shared library
 586   static void* dll_lookup(void* handle, const char* name);
 587 
 588   // Unload library
 589   static void  dll_unload(void *lib);
 590 
 591   // Callback for loaded module information
 592   // Input parameters:
 593   //    char*     module_file_name,
 594   //    address   module_base_addr,
 595   //    address   module_top_addr,
 596   //    void*     param
 597   typedef int (*LoadedModulesCallbackFunc)(const char *, address, address, void *);
 598 
 599   static int get_loaded_modules_info(LoadedModulesCallbackFunc callback, void *param);
 600 
 601   // Return the handle of this process
 602   static void* get_default_process_handle();
 603 
 604   // Check for static linked agent library
 605   static bool find_builtin_agent(AgentLibrary *agent_lib, const char *syms[],
 606                                  size_t syms_len);
 607 
 608   // Find agent entry point
 609   static void *find_agent_function(AgentLibrary *agent_lib, bool check_lib,
 610                                    const char *syms[], size_t syms_len);
 611 
 612   // Provide C99 compliant versions of these functions, since some versions
 613   // of some platforms don't.
 614   static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args) ATTRIBUTE_PRINTF(3, 0);
 615   static int snprintf(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);
 616 
 617   // Get host name in buffer provided
 618   static bool get_host_name(char* buf, size_t buflen);
 619 
 620   // Print out system information; they are called by fatal error handler.
 621   // Output format may be different on different platforms.
 622   static void print_os_info(outputStream* st);
 623   static void print_os_info_brief(outputStream* st);
 624   static void print_cpu_info(outputStream* st, char* buf, size_t buflen);
 625   static void pd_print_cpu_info(outputStream* st, char* buf, size_t buflen);
 626   static void print_summary_info(outputStream* st, char* buf, size_t buflen);
 627   static void print_memory_info(outputStream* st);
 628   static void print_dll_info(outputStream* st);
 629   static void print_environment_variables(outputStream* st, const char** env_list);
 630   static void print_context(outputStream* st, const void* context);
 631   static void print_register_info(outputStream* st, const void* context);
 632   static bool signal_sent_by_kill(const void* siginfo);
 633   static void print_siginfo(outputStream* st, const void* siginfo);
 634   static void print_signal_handlers(outputStream* st, char* buf, size_t buflen);
 635   static void print_date_and_time(outputStream* st, char* buf, size_t buflen);
 636   static void print_instructions(outputStream* st, address pc, int unitsize);
 637 
 638   // helper for output of seconds in days , hours and months
 639   static void print_dhm(outputStream* st, const char* startStr, long sec);
 640 
 641   static void print_location(outputStream* st, intptr_t x, bool verbose = false);
 642   static size_t lasterror(char *buf, size_t len);
 643   static int get_last_error();
 644 
 645   // Replacement for strerror().
 646   // Will return the english description of the error (e.g. "File not found", as
 647   //  suggested in the POSIX standard.
 648   // Will return "Unknown error" for an unknown errno value.
 649   // Will not attempt to localize the returned string.
 650   // Will always return a valid string which is a static constant.
 651   // Will not change the value of errno.
 652   static const char* strerror(int e);
 653 
 654   // Will return the literalized version of the given errno (e.g. "EINVAL"
 655   //  for EINVAL).
 656   // Will return "Unknown error" for an unknown errno value.
 657   // Will always return a valid string which is a static constant.
 658   // Will not change the value of errno.
 659   static const char* errno_name(int e);
 660 
 661   // wait for a key press if PauseAtExit is set
 662   static void wait_for_keypress_at_exit(void);
 663 
 664   // The following two functions are used by fatal error handler to trace
 665   // native (C) frames. They are not part of frame.hpp/frame.cpp because
 666   // frame.hpp/cpp assume thread is JavaThread, and also because different
 667   // OS/compiler may have different convention or provide different API to
 668   // walk C frames.
 669   //
 670   // We don't attempt to become a debugger, so we only follow frames if that
 671   // does not require a lookup in the unwind table, which is part of the binary
 672   // file but may be unsafe to read after a fatal error. So on x86, we can
 673   // only walk stack if %ebp is used as frame pointer; on ia64, it's not
 674   // possible to walk C stack without having the unwind table.
 675   static bool is_first_C_frame(frame *fr);
 676   static frame get_sender_for_C_frame(frame *fr);
 677 
 678   // return current frame. pc() and sp() are set to NULL on failure.
 679   static frame      current_frame();
 680 
 681   static void print_hex_dump(outputStream* st, address start, address end, int unitsize);
 682 
 683   // returns a string to describe the exception/signal;
 684   // returns NULL if exception_code is not an OS exception/signal.
 685   static const char* exception_name(int exception_code, char* buf, size_t buflen);
 686 
 687   // Returns the signal number (e.g. 11) for a given signal name (SIGSEGV).
 688   static int get_signal_number(const char* signal_name);
 689 
 690   // Returns native Java library, loads if necessary
 691   static void*    native_java_library();
 692 
 693   // Fills in path to jvm.dll/libjvm.so (used by the Disassembler)
 694   static void     jvm_path(char *buf, jint buflen);
 695 
 696   // JNI names
 697   static void     print_jni_name_prefix_on(outputStream* st, int args_size);
 698   static void     print_jni_name_suffix_on(outputStream* st, int args_size);
 699 
 700   // Init os specific system properties values
 701   static void init_system_properties_values();
 702 
 703   // IO operations, non-JVM_ version.
 704   static int stat(const char* path, struct stat* sbuf);
 705   static bool dir_is_empty(const char* path);
 706 
 707   // IO operations on binary files
 708   static int create_binary_file(const char* path, bool rewrite_existing);
 709   static jlong current_file_offset(int fd);
 710   static jlong seek_to_file_offset(int fd, jlong offset);
 711 
 712   // Retrieve native stack frames.
 713   // Parameter:
 714   //   stack:  an array to storage stack pointers.
 715   //   frames: size of above array.
 716   //   toSkip: number of stack frames to skip at the beginning.
 717   // Return: number of stack frames captured.
 718   static int get_native_stack(address* stack, int size, int toSkip = 0);
 719 
 720   // General allocation (must be MT-safe)
 721   static void* malloc  (size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack);
 722   static void* malloc  (size_t size, MEMFLAGS flags);
 723   static void* realloc (void *memblock, size_t size, MEMFLAGS flag, const NativeCallStack&amp; stack);
 724   static void* realloc (void *memblock, size_t size, MEMFLAGS flag);
 725 
 726   // handles NULL pointers
 727   static void  free    (void *memblock);
 728   static char* strdup(const char *, MEMFLAGS flags = mtInternal);  // Like strdup
 729   // Like strdup, but exit VM when strdup() returns NULL
 730   static char* strdup_check_oom(const char*, MEMFLAGS flags = mtInternal);
 731 
 732 #ifndef PRODUCT
 733   static julong num_mallocs;         // # of calls to malloc/realloc
 734   static julong alloc_bytes;         // # of bytes allocated
 735   static julong num_frees;           // # of calls to free
 736   static julong free_bytes;          // # of bytes freed
 737 #endif
 738 
 739   // SocketInterface (ex HPI SocketInterface )
 740   static int socket(int domain, int type, int protocol);
 741   static int socket_close(int fd);
 742   static int recv(int fd, char* buf, size_t nBytes, uint flags);
 743   static int send(int fd, char* buf, size_t nBytes, uint flags);
 744   static int raw_send(int fd, char* buf, size_t nBytes, uint flags);
 745   static int connect(int fd, struct sockaddr* him, socklen_t len);
 746   static struct hostent* get_host_by_name(char* name);
 747 
 748   // Support for signals (see JVM_RaiseSignal, JVM_RegisterSignal)
 749   static void  initialize_jdk_signal_support(TRAPS);
 750   static void  signal_notify(int signal_number);
 751   static void* signal(int signal_number, void* handler);
 752   static void  signal_raise(int signal_number);
 753   static int   signal_wait();
 754   static void* user_handler();
 755   static void  terminate_signal_thread();
 756   static int   sigexitnum_pd();
 757 
 758   // random number generation
 759   static int random();                     // return 32bit pseudorandom number
 760   static void init_random(unsigned int initval);    // initialize random sequence
 761 
 762   // Structured OS Exception support
 763   static void os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle&amp; method, JavaCallArguments* args, Thread* thread);
 764 
 765   // On Posix compatible OS it will simply check core dump limits while on Windows
 766   // it will check if dump file can be created. Check or prepare a core dump to be
 767   // taken at a later point in the same thread in os::abort(). Use the caller
 768   // provided buffer as a scratch buffer. The status message which will be written
 769   // into the error log either is file location or a short error message, depending
 770   // on the checking result.
 771   static void check_dump_limit(char* buffer, size_t bufferSize);
 772 
 773   // Get the default path to the core file
 774   // Returns the length of the string
 775   static int get_core_path(char* buffer, size_t bufferSize);
 776 
 777   // JVMTI &amp; JVM monitoring and management support
 778   // The thread_cpu_time() and current_thread_cpu_time() are only
 779   // supported if is_thread_cpu_time_supported() returns true.
 780 
 781   // Thread CPU Time - return the fast estimate on a platform
 782   // On Linux   - fast clock_gettime where available - user+sys
 783   //            - otherwise: very slow /proc fs - user+sys
 784   // On Windows - GetThreadTimes - user+sys
 785   static jlong current_thread_cpu_time();
 786   static jlong thread_cpu_time(Thread* t);
 787 
 788   // Thread CPU Time with user_sys_cpu_time parameter.
 789   //
 790   // If user_sys_cpu_time is true, user+sys time is returned.
 791   // Otherwise, only user time is returned
 792   static jlong current_thread_cpu_time(bool user_sys_cpu_time);
 793   static jlong thread_cpu_time(Thread* t, bool user_sys_cpu_time);
 794 
 795   // Return a bunch of info about the timers.
 796   // Note that the returned info for these two functions may be different
 797   // on some platforms
 798   static void current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 799   static void thread_cpu_time_info(jvmtiTimerInfo *info_ptr);
 800 
 801   static bool is_thread_cpu_time_supported();
 802 
 803   // System loadavg support.  Returns -1 if load average cannot be obtained.
 804   static int loadavg(double loadavg[], int nelem);
 805 
 806   // Amount beyond the callee frame size that we bang the stack.
 807   static int extra_bang_size_in_bytes();
 808 
 809   static char** split_path(const char* path, size_t* elements, size_t file_name_length);
 810 
 811   // support for mapping non-volatile memory using MAP_SYNC
 812   static bool supports_map_sync();
 813 
 814  public:
 815   class CrashProtectionCallback : public StackObj {
 816   public:
 817     virtual void call() = 0;
 818   };
 819 
 820   // Platform dependent stuff
 821 #ifndef _WINDOWS
 822 # include "os_posix.hpp"
 823 #endif
 824 #include OS_CPU_HEADER(os)
 825 #include OS_HEADER(os)
 826 
 827 #ifndef OS_NATIVE_THREAD_CREATION_FAILED_MSG
 828 #define OS_NATIVE_THREAD_CREATION_FAILED_MSG "unable to create native thread: possibly out of memory or process/resource limits reached"
 829 #endif
 830 
 831  public:
 832 #ifndef PLATFORM_PRINT_NATIVE_STACK
 833   // No platform-specific code for printing the native stack.
 834   static bool platform_print_native_stack(outputStream* st, const void* context,
 835                                           char *buf, int buf_size) {
 836     return false;
 837   }
 838 #endif
 839 
 840   // debugging support (mostly used by debug.cpp but also fatal error handler)
 841   static bool find(address pc, outputStream* st = tty); // OS specific function to make sense out of an address
 842 
 843   static bool dont_yield();                     // when true, JVM_Yield() is nop
 844   static void print_statistics();
 845 
 846   // Thread priority helpers (implemented in OS-specific part)
 847   static OSReturn set_native_priority(Thread* thread, int native_prio);
 848   static OSReturn get_native_priority(const Thread* const thread, int* priority_ptr);
 849   static int java_to_os_priority[CriticalPriority + 1];
 850   // Hint to the underlying OS that a task switch would not be good.
 851   // Void return because it's a hint and can fail.
 852   static const char* native_thread_creation_failed_msg() {
 853     return OS_NATIVE_THREAD_CREATION_FAILED_MSG;
 854   }
 855 
 856   // Used at creation if requested by the diagnostic flag PauseAtStartup.
 857   // Causes the VM to wait until an external stimulus has been applied
 858   // (for Unix, that stimulus is a signal, for Windows, an external
 859   // ResumeThread call)
 860   static void pause();
 861 
 862   // Builds a platform dependent Agent_OnLoad_&lt;libname&gt; function name
 863   // which is used to find statically linked in agents.
 864   static char*  build_agent_function_name(const char *sym, const char *cname,
 865                                           bool is_absolute_path);
 866 
 867   class SuspendedThreadTaskContext {
 868   public:
 869     SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}
 870     Thread* thread() const { return _thread; }
 871     void* ucontext() const { return _ucontext; }
 872   private:
 873     Thread* _thread;
 874     void* _ucontext;
 875   };
 876 
 877   class SuspendedThreadTask {
 878   public:
 879     SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}
 880     void run();
 881     bool is_done() { return _done; }
 882     virtual void do_task(const SuspendedThreadTaskContext&amp; context) = 0;
 883   protected:
 884     ~SuspendedThreadTask() {}
 885   private:
 886     void internal_do_task();
 887     Thread* _thread;
 888     bool _done;
 889   };
 890 
 891 #ifndef _WINDOWS
 892   // Suspend/resume support
 893   // Protocol:
 894   //
 895   // a thread starts in SR_RUNNING
 896   //
 897   // SR_RUNNING can go to
 898   //   * SR_SUSPEND_REQUEST when the WatcherThread wants to suspend it
 899   // SR_SUSPEND_REQUEST can go to
 900   //   * SR_RUNNING if WatcherThread decides it waited for SR_SUSPENDED too long (timeout)
 901   //   * SR_SUSPENDED if the stopped thread receives the signal and switches state
 902   // SR_SUSPENDED can go to
 903   //   * SR_WAKEUP_REQUEST when the WatcherThread has done the work and wants to resume
 904   // SR_WAKEUP_REQUEST can go to
 905   //   * SR_RUNNING when the stopped thread receives the signal
 906   //   * SR_WAKEUP_REQUEST on timeout (resend the signal and try again)
 907   class SuspendResume {
 908    public:
 909     enum State {
 910       SR_RUNNING,
 911       SR_SUSPEND_REQUEST,
 912       SR_SUSPENDED,
 913       SR_WAKEUP_REQUEST
 914     };
 915 
 916   private:
 917     volatile State _state;
 918 
 919   private:
 920     /* try to switch state from state "from" to state "to"
 921      * returns the state set after the method is complete
 922      */
 923     State switch_state(State from, State to);
 924 
 925   public:
 926     SuspendResume() : _state(SR_RUNNING) { }
 927 
 928     State state() const { return _state; }
 929 
 930     State request_suspend() {
 931       return switch_state(SR_RUNNING, SR_SUSPEND_REQUEST);
 932     }
 933 
 934     State cancel_suspend() {
 935       return switch_state(SR_SUSPEND_REQUEST, SR_RUNNING);
 936     }
 937 
 938     State suspended() {
 939       return switch_state(SR_SUSPEND_REQUEST, SR_SUSPENDED);
 940     }
 941 
 942     State request_wakeup() {
 943       return switch_state(SR_SUSPENDED, SR_WAKEUP_REQUEST);
 944     }
 945 
 946     State running() {
 947       return switch_state(SR_WAKEUP_REQUEST, SR_RUNNING);
 948     }
 949 
 950     bool is_running() const {
 951       return _state == SR_RUNNING;
 952     }
 953 
 954     bool is_suspended() const {
 955       return _state == SR_SUSPENDED;
 956     }
 957   };
 958 #endif // !WINDOWS
 959 
 960 
 961  protected:
 962   static volatile unsigned int _rand_seed;    // seed for random number generator
 963   static int _processor_count;                // number of processors
 964   static int _initial_active_processor_count; // number of active processors during initialization.
 965 
 966   static char* format_boot_path(const char* format_string,
 967                                 const char* home,
 968                                 int home_len,
 969                                 char fileSep,
 970                                 char pathSep);
 971   static bool set_boot_path(char fileSep, char pathSep);
 972 
 973 };
 974 
 975 #ifndef _WINDOWS
 976 template&lt;&gt; struct IsRegisteredEnum&lt;os::SuspendResume::State&gt; : public TrueType {};
 977 #endif // !_WINDOWS
 978 
 979 // Note that "PAUSE" is almost always used with synchronization
 980 // so arguably we should provide Atomic::SpinPause() instead
 981 // of the global SpinPause() with C linkage.
 982 // It'd also be eligible for inlining on many platforms.
 983 
 984 extern "C" int SpinPause();
 985 
 986 #endif // SHARE_RUNTIME_OS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
