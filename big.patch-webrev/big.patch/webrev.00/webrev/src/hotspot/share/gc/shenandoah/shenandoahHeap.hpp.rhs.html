<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
  26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
  27 
  28 #include "gc/shared/markBitMap.hpp"
  29 #include "gc/shared/softRefPolicy.hpp"
  30 #include "gc/shared/collectedHeap.hpp"
  31 #include "gc/shenandoah/shenandoahAsserts.hpp"
  32 #include "gc/shenandoah/shenandoahAllocRequest.hpp"
  33 #include "gc/shenandoah/shenandoahLock.hpp"
  34 #include "gc/shenandoah/shenandoahEvacOOMHandler.hpp"
  35 #include "gc/shenandoah/shenandoahPadding.hpp"
  36 #include "gc/shenandoah/shenandoahSharedVariables.hpp"
  37 #include "gc/shenandoah/shenandoahUnload.hpp"
<a name="1" id="anc1"></a><span class="new">  38 #include "memory/metaspace.hpp"</span>
  39 #include "services/memoryManager.hpp"
  40 #include "utilities/globalDefinitions.hpp"
  41 
  42 class ConcurrentGCTimer;
  43 class ReferenceProcessor;
  44 class ShenandoahCollectorPolicy;
  45 class ShenandoahControlThread;
  46 class ShenandoahGCSession;
  47 class ShenandoahGCStateResetter;
  48 class ShenandoahHeuristics;
  49 class ShenandoahMarkingContext;
  50 class ShenandoahMarkCompact;
  51 class ShenandoahMode;
  52 class ShenandoahPhaseTimings;
  53 class ShenandoahHeap;
  54 class ShenandoahHeapRegion;
  55 class ShenandoahHeapRegionClosure;
  56 class ShenandoahCollectionSet;
  57 class ShenandoahFreeSet;
  58 class ShenandoahConcurrentMark;
  59 class ShenandoahMarkCompact;
  60 class ShenandoahMonitoringSupport;
  61 class ShenandoahPacer;
  62 class ShenandoahVerifier;
  63 class ShenandoahWorkGang;
  64 class VMStructs;
  65 
  66 // Used for buffering per-region liveness data.
  67 // Needed since ShenandoahHeapRegion uses atomics to update liveness.
  68 // The ShenandoahHeap array has max-workers elements, each of which is an array of
  69 // uint16_t * max_regions. The choice of uint16_t is not accidental:
  70 // there is a tradeoff between static/dynamic footprint that translates
  71 // into cache pressure (which is already high during marking), and
  72 // too many atomic updates. uint32_t is too large, uint8_t is too small.
  73 typedef uint16_t ShenandoahLiveData;
  74 #define SHENANDOAH_LIVEDATA_MAX ((ShenandoahLiveData)-1)
  75 
  76 class ShenandoahRegionIterator : public StackObj {
  77 private:
  78   ShenandoahHeap* _heap;
  79 
  80   shenandoah_padding(0);
  81   volatile size_t _index;
  82   shenandoah_padding(1);
  83 
  84   // No implicit copying: iterators should be passed by reference to capture the state
  85   NONCOPYABLE(ShenandoahRegionIterator);
  86 
  87 public:
  88   ShenandoahRegionIterator();
  89   ShenandoahRegionIterator(ShenandoahHeap* heap);
  90 
  91   // Reset iterator to default state
  92   void reset();
  93 
  94   // Returns next region, or NULL if there are no more regions.
  95   // This is multi-thread-safe.
  96   inline ShenandoahHeapRegion* next();
  97 
  98   // This is *not* MT safe. However, in the absence of multithreaded access, it
  99   // can be used to determine if there is more work to do.
 100   bool has_next() const;
 101 };
 102 
 103 class ShenandoahHeapRegionClosure : public StackObj {
 104 public:
 105   virtual void heap_region_do(ShenandoahHeapRegion* r) = 0;
 106   virtual bool is_thread_safe() { return false; }
 107 };
 108 
 109 #ifdef ASSERT
 110 class ShenandoahAssertToSpaceClosure : public OopClosure {
 111 private:
 112   template &lt;class T&gt;
 113   void do_oop_work(T* p);
 114 public:
 115   void do_oop(narrowOop* p);
 116   void do_oop(oop* p);
 117 };
 118 #endif
 119 
 120 typedef ShenandoahLock    ShenandoahHeapLock;
 121 typedef ShenandoahLocker  ShenandoahHeapLocker;
 122 
 123 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
 124 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
 125 // See ShenandoahControlThread for GC cycle structure.
 126 //
 127 class ShenandoahHeap : public CollectedHeap {
 128   friend class ShenandoahAsserts;
 129   friend class VMStructs;
 130   friend class ShenandoahGCSession;
 131   friend class ShenandoahGCStateResetter;
 132 
 133 // ---------- Locks that guard important data structures in Heap
 134 //
 135 private:
 136   ShenandoahHeapLock _lock;
 137 
 138 public:
 139   ShenandoahHeapLock* lock() {
 140     return &amp;_lock;
 141   }
 142 
 143 // ---------- Initialization, termination, identification, printing routines
 144 //
 145 public:
 146   static ShenandoahHeap* heap();
 147 
 148   const char* name()          const { return "Shenandoah"; }
 149   ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }
 150 
 151   ShenandoahHeap(ShenandoahCollectorPolicy* policy);
 152   jint initialize();
 153   void post_initialize();
 154   void initialize_heuristics();
 155 
 156   void initialize_serviceability();
 157 
 158   void print_on(outputStream* st)              const;
 159   void print_extended_on(outputStream *st)     const;
 160   void print_tracing_info()                    const;
 161   void print_heap_regions_on(outputStream* st) const;
 162 
 163   void stop();
 164 
 165   void prepare_for_verify();
 166   void verify(VerifyOption vo);
 167 
 168 // ---------- Heap counters and metrics
 169 //
 170 private:
 171            size_t _initial_size;
 172            size_t _minimum_size;
 173   shenandoah_padding(0);
 174   volatile size_t _used;
 175   volatile size_t _committed;
 176   volatile size_t _bytes_allocated_since_gc_start;
 177   shenandoah_padding(1);
 178 
 179 public:
 180   void increase_used(size_t bytes);
 181   void decrease_used(size_t bytes);
 182   void set_used(size_t bytes);
 183 
 184   void increase_committed(size_t bytes);
 185   void decrease_committed(size_t bytes);
 186   void increase_allocated(size_t bytes);
 187 
 188   size_t bytes_allocated_since_gc_start();
 189   void reset_bytes_allocated_since_gc_start();
 190 
 191   size_t min_capacity()     const;
 192   size_t max_capacity()     const;
 193   size_t initial_capacity() const;
 194   size_t capacity()         const;
 195   size_t used()             const;
 196   size_t committed()        const;
 197 
 198 // ---------- Workers handling
 199 //
 200 private:
 201   uint _max_workers;
 202   ShenandoahWorkGang* _workers;
 203   ShenandoahWorkGang* _safepoint_workers;
 204 
 205 public:
 206   uint max_workers();
 207   void assert_gc_workers(uint nworker) NOT_DEBUG_RETURN;
 208 
 209   WorkGang* workers() const;
 210   WorkGang* get_safepoint_workers();
 211 
 212   void gc_threads_do(ThreadClosure* tcl) const;
 213 
 214 // ---------- Heap regions handling machinery
 215 //
 216 private:
 217   MemRegion _heap_region;
 218   bool      _heap_region_special;
 219   size_t    _num_regions;
 220   ShenandoahHeapRegion** _regions;
 221   ShenandoahRegionIterator _update_refs_iterator;
 222 
 223 public:
 224 
 225   inline HeapWord* base() const { return _heap_region.start(); }
 226 
 227   inline size_t num_regions() const { return _num_regions; }
 228   inline bool is_heap_region_special() { return _heap_region_special; }
 229 
 230   inline ShenandoahHeapRegion* const heap_region_containing(const void* addr) const;
 231   inline size_t heap_region_index_containing(const void* addr) const;
 232 
 233   inline ShenandoahHeapRegion* const get_region(size_t region_idx) const;
 234 
 235   void heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
 236   void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
 237 
 238 // ---------- GC state machinery
 239 //
 240 // GC state describes the important parts of collector state, that may be
 241 // used to make barrier selection decisions in the native and generated code.
 242 // Multiple bits can be set at once.
 243 //
 244 // Important invariant: when GC state is zero, the heap is stable, and no barriers
 245 // are required.
 246 //
 247 public:
 248   enum GCStateBitPos {
 249     // Heap has forwarded objects: needs LRB barriers.
 250     HAS_FORWARDED_BITPOS   = 0,
 251 
 252     // Heap is under marking: needs SATB barriers.
 253     MARKING_BITPOS    = 1,
 254 
 255     // Heap is under evacuation: needs LRB barriers. (Set together with HAS_FORWARDED)
 256     EVACUATION_BITPOS = 2,
 257 
 258     // Heap is under updating: needs no additional barriers.
 259     UPDATEREFS_BITPOS = 3,
 260   };
 261 
 262   enum GCState {
 263     STABLE        = 0,
 264     HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
 265     MARKING       = 1 &lt;&lt; MARKING_BITPOS,
 266     EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
 267     UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
 268   };
 269 
 270 private:
 271   ShenandoahSharedBitmap _gc_state;
 272   ShenandoahSharedFlag   _degenerated_gc_in_progress;
 273   ShenandoahSharedFlag   _full_gc_in_progress;
 274   ShenandoahSharedFlag   _full_gc_move_in_progress;
 275   ShenandoahSharedFlag   _progress_last_gc;
 276   ShenandoahSharedFlag   _concurrent_strong_root_in_progress;
 277   ShenandoahSharedFlag   _concurrent_weak_root_in_progress;
 278 
 279   void set_gc_state_all_threads(char state);
 280   void set_gc_state_mask(uint mask, bool value);
 281 
 282 public:
 283   char gc_state() const;
 284   static address gc_state_addr();
 285 
 286   void set_concurrent_mark_in_progress(bool in_progress);
 287   void set_evacuation_in_progress(bool in_progress);
 288   void set_update_refs_in_progress(bool in_progress);
 289   void set_degenerated_gc_in_progress(bool in_progress);
 290   void set_full_gc_in_progress(bool in_progress);
 291   void set_full_gc_move_in_progress(bool in_progress);
 292   void set_has_forwarded_objects(bool cond);
 293   void set_concurrent_strong_root_in_progress(bool cond);
 294   void set_concurrent_weak_root_in_progress(bool cond);
 295 
 296   inline bool is_stable() const;
 297   inline bool is_idle() const;
 298   inline bool is_concurrent_mark_in_progress() const;
 299   inline bool is_update_refs_in_progress() const;
 300   inline bool is_evacuation_in_progress() const;
 301   inline bool is_degenerated_gc_in_progress() const;
 302   inline bool is_full_gc_in_progress() const;
 303   inline bool is_full_gc_move_in_progress() const;
 304   inline bool has_forwarded_objects() const;
 305   inline bool is_gc_in_progress_mask(uint mask) const;
 306   inline bool is_stw_gc_in_progress() const;
 307   inline bool is_concurrent_strong_root_in_progress() const;
 308   inline bool is_concurrent_weak_root_in_progress() const;
 309 
 310 // ---------- GC cancellation and degeneration machinery
 311 //
 312 // Cancelled GC flag is used to notify concurrent phases that they should terminate.
 313 //
 314 public:
 315   enum ShenandoahDegenPoint {
 316     _degenerated_unset,
 317     _degenerated_outside_cycle,
 318     _degenerated_mark,
 319     _degenerated_evac,
 320     _degenerated_updaterefs,
 321     _DEGENERATED_LIMIT
 322   };
 323 
 324   static const char* degen_point_to_string(ShenandoahDegenPoint point) {
 325     switch (point) {
 326       case _degenerated_unset:
 327         return "&lt;UNSET&gt;";
 328       case _degenerated_outside_cycle:
 329         return "Outside of Cycle";
 330       case _degenerated_mark:
 331         return "Mark";
 332       case _degenerated_evac:
 333         return "Evacuation";
 334       case _degenerated_updaterefs:
 335         return "Update Refs";
 336       default:
 337         ShouldNotReachHere();
 338         return "ERROR";
 339     }
 340   };
 341 
 342 private:
 343   enum CancelState {
 344     // Normal state. GC has not been cancelled and is open for cancellation.
 345     // Worker threads can suspend for safepoint.
 346     CANCELLABLE,
 347 
 348     // GC has been cancelled. Worker threads can not suspend for
 349     // safepoint but must finish their work as soon as possible.
 350     CANCELLED,
 351 
 352     // GC has not been cancelled and must not be cancelled. At least
 353     // one worker thread checks for pending safepoint and may suspend
 354     // if a safepoint is pending.
 355     NOT_CANCELLED
 356   };
 357 
 358   ShenandoahSharedEnumFlag&lt;CancelState&gt; _cancelled_gc;
 359   bool try_cancel_gc();
 360 
 361 public:
 362   static address cancelled_gc_addr();
 363 
 364   inline bool cancelled_gc() const;
 365   inline bool check_cancelled_gc_and_yield(bool sts_active = true);
 366 
 367   inline void clear_cancelled_gc();
 368 
 369   void cancel_gc(GCCause::Cause cause);
 370 
 371 // ---------- GC operations entry points
 372 //
 373 public:
 374   // Entry points to STW GC operations, these cause a related safepoint, that then
 375   // call the entry method below
 376   void vmop_entry_init_mark();
 377   void vmop_entry_final_mark();
 378   void vmop_entry_init_updaterefs();
 379   void vmop_entry_final_updaterefs();
 380   void vmop_entry_full(GCCause::Cause cause);
 381   void vmop_degenerated(ShenandoahDegenPoint point);
 382 
 383   // Entry methods to normally STW GC operations. These set up logging, monitoring
 384   // and workers for net VM operation
 385   void entry_init_mark();
 386   void entry_final_mark();
 387   void entry_init_updaterefs();
 388   void entry_final_updaterefs();
 389   void entry_full(GCCause::Cause cause);
 390   void entry_degenerated(int point);
 391 
 392   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
 393   // for concurrent operation.
 394   void entry_reset();
 395   void entry_mark();
 396   void entry_preclean();
 397   void entry_weak_roots();
 398   void entry_class_unloading();
 399   void entry_strong_roots();
 400   void entry_cleanup_early();
 401   void entry_evac();
 402   void entry_updaterefs();
 403   void entry_cleanup_complete();
 404   void entry_uncommit(double shrink_before);
 405 
 406 private:
 407   // Actual work for the phases
 408   void op_init_mark();
 409   void op_final_mark();
 410   void op_init_updaterefs();
 411   void op_final_updaterefs();
 412   void op_full(GCCause::Cause cause);
 413   void op_degenerated(ShenandoahDegenPoint point);
 414   void op_degenerated_fail();
 415   void op_degenerated_futile();
 416 
 417   void op_reset();
 418   void op_mark();
 419   void op_preclean();
 420   void op_weak_roots();
 421   void op_class_unloading();
 422   void op_strong_roots();
 423   void op_cleanup_early();
 424   void op_conc_evac();
 425   void op_stw_evac();
 426   void op_updaterefs();
 427   void op_cleanup_complete();
 428   void op_uncommit(double shrink_before);
 429 
 430   // Messages for GC trace events, they have to be immortal for
 431   // passing around the logging/tracing systems
 432   const char* init_mark_event_message() const;
 433   const char* final_mark_event_message() const;
 434   const char* conc_mark_event_message() const;
 435   const char* degen_event_message(ShenandoahDegenPoint point) const;
 436 
 437 // ---------- GC subsystems
 438 //
 439 private:
 440   ShenandoahControlThread*   _control_thread;
 441   ShenandoahCollectorPolicy* _shenandoah_policy;
 442   ShenandoahMode*            _gc_mode;
 443   ShenandoahHeuristics*      _heuristics;
 444   ShenandoahFreeSet*         _free_set;
 445   ShenandoahConcurrentMark*  _scm;
 446   ShenandoahMarkCompact*     _full_gc;
 447   ShenandoahPacer*           _pacer;
 448   ShenandoahVerifier*        _verifier;
 449 
 450   ShenandoahPhaseTimings*    _phase_timings;
 451 
 452   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
 453   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
 454 
 455 public:
 456   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
 457   ShenandoahMode*            mode()              const { return _gc_mode;           }
 458   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
 459   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
 460   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
 461   ShenandoahPacer*           pacer()             const { return _pacer;             }
 462 
 463   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
 464 
 465   ShenandoahVerifier*        verifier();
 466 
 467 // ---------- VM subsystem bindings
 468 //
 469 private:
 470   ShenandoahMonitoringSupport* _monitoring_support;
 471   MemoryPool*                  _memory_pool;
 472   GCMemoryManager              _stw_memory_manager;
 473   GCMemoryManager              _cycle_memory_manager;
 474   ConcurrentGCTimer*           _gc_timer;
 475   SoftRefPolicy                _soft_ref_policy;
 476 
 477   // For exporting to SA
 478   int                          _log_min_obj_alignment_in_bytes;
 479 public:
 480   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
 481   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
 482   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
 483   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
 484 
 485   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
 486   GrowableArray&lt;MemoryPool*&gt; memory_pools();
 487   MemoryUsage memory_usage();
 488   GCTracer* tracer();
 489   ConcurrentGCTimer* gc_timer() const;
 490 
 491 // ---------- Reference processing
 492 //
 493 private:
 494   AlwaysTrueClosure    _subject_to_discovery;
 495   ReferenceProcessor*  _ref_processor;
 496   ShenandoahSharedFlag _process_references;
 497   bool                 _ref_proc_mt_discovery;
 498   bool                 _ref_proc_mt_processing;
 499 
 500   void ref_processing_init();
 501 
 502 public:
 503   ReferenceProcessor* ref_processor() { return _ref_processor; }
 504   bool ref_processor_mt_discovery()   { return _ref_proc_mt_discovery;  }
 505   bool ref_processor_mt_processing()  { return _ref_proc_mt_processing; }
 506   void set_process_references(bool pr);
 507   bool process_references() const;
 508 
 509 // ---------- Class Unloading
 510 //
 511 private:
 512   ShenandoahSharedFlag _unload_classes;
 513   ShenandoahUnload     _unloader;
 514 
 515 public:
 516   void set_unload_classes(bool uc);
 517   bool unload_classes() const;
 518 
 519   // Perform STW class unloading and weak root cleaning
 520   void parallel_cleaning(bool full_gc);
 521 
 522 private:
 523   void stw_unload_classes(bool full_gc);
 524   void stw_process_weak_roots(bool full_gc);
 525 
 526   // Prepare concurrent root processing
 527   void prepare_concurrent_roots();
 528   // Prepare and finish concurrent unloading
 529   void prepare_concurrent_unloading();
 530   void finish_concurrent_unloading();
 531 
 532 // ---------- Generic interface hooks
 533 // Minor things that super-interface expects us to implement to play nice with
 534 // the rest of runtime. Some of the things here are not required to be implemented,
 535 // and can be stubbed out.
 536 //
 537 public:
 538   AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);
 539   bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);
 540 
 541   bool is_in(const void* p) const;
 542 
 543   MemRegion reserved_region() const { return _reserved; }
 544   bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }
 545 
 546   void collect(GCCause::Cause cause);
 547   void do_full_collection(bool clear_all_soft_refs);
 548 
 549   // Used for parsing heap during error printing
 550   HeapWord* block_start(const void* addr) const;
 551   bool block_is_obj(const HeapWord* addr) const;
 552   bool print_location(outputStream* st, void* addr) const;
 553 
 554   // Used for native heap walkers: heap dumpers, mostly
 555   void object_iterate(ObjectClosure* cl);
 556 
 557   // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
 558   void keep_alive(oop obj);
 559 
 560   // Used by RMI
 561   jlong millis_since_last_gc();
 562 
 563 // ---------- Safepoint interface hooks
 564 //
 565 public:
 566   void safepoint_synchronize_begin();
 567   void safepoint_synchronize_end();
 568 
 569 // ---------- Code roots handling hooks
 570 //
 571 public:
 572   void register_nmethod(nmethod* nm);
 573   void unregister_nmethod(nmethod* nm);
 574   void flush_nmethod(nmethod* nm);
 575   void verify_nmethod(nmethod* nm) {}
 576 
 577 // ---------- Pinning hooks
 578 //
 579 public:
 580   // Shenandoah supports per-object (per-region) pinning
 581   bool supports_object_pinning() const { return true; }
 582 
 583   oop pin_object(JavaThread* thread, oop obj);
 584   void unpin_object(JavaThread* thread, oop obj);
 585 
 586   void sync_pinned_region_status();
 587   void assert_pinned_region_status() NOT_DEBUG_RETURN;
 588 
 589 // ---------- Allocation support
 590 //
 591 private:
 592   HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest&amp; request, bool&amp; in_new_region);
 593   inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);
 594   HeapWord* allocate_from_gclab_slow(Thread* thread, size_t size);
 595   HeapWord* allocate_new_gclab(size_t min_size, size_t word_size, size_t* actual_size);
 596 
 597 public:
 598   HeapWord* allocate_memory(ShenandoahAllocRequest&amp; request);
 599   HeapWord* mem_allocate(size_t size, bool* what);
 600   MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 601                                                size_t size,
 602                                                Metaspace::MetadataType mdtype);
 603 
 604   void notify_mutator_alloc_words(size_t words, bool waste);
 605 
 606   // Shenandoah supports TLAB allocation
 607   bool supports_tlab_allocation() const { return true; }
 608 
 609   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
 610   size_t tlab_capacity(Thread *thr) const;
 611   size_t unsafe_max_tlab_alloc(Thread *thread) const;
 612   size_t max_tlab_size() const;
 613   size_t tlab_used(Thread* ignored) const;
 614 
 615   void ensure_parsability(bool retire_labs);
 616 
 617   void labs_make_parsable();
 618   void tlabs_retire(bool resize);
 619   void gclabs_retire(bool resize);
 620 
 621 // ---------- Marking support
 622 //
 623 private:
 624   ShenandoahMarkingContext* _marking_context;
 625   MemRegion  _bitmap_region;
 626   MemRegion  _aux_bitmap_region;
 627   MarkBitMap _verification_bit_map;
 628   MarkBitMap _aux_bit_map;
 629 
 630   size_t _bitmap_size;
 631   size_t _bitmap_regions_per_slice;
 632   size_t _bitmap_bytes_per_slice;
 633 
 634   size_t _pretouch_heap_page_size;
 635   size_t _pretouch_bitmap_page_size;
 636 
 637   bool _bitmap_region_special;
 638   bool _aux_bitmap_region_special;
 639 
 640   ShenandoahLiveData** _liveness_cache;
 641 
 642 public:
 643   inline ShenandoahMarkingContext* complete_marking_context() const;
 644   inline ShenandoahMarkingContext* marking_context() const;
 645   inline void mark_complete_marking_context();
 646   inline void mark_incomplete_marking_context();
 647 
 648   template&lt;class T&gt;
 649   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl);
 650 
 651   template&lt;class T&gt;
 652   inline void marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
 653 
 654   template&lt;class T&gt;
 655   inline void marked_object_oop_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit);
 656 
 657   void reset_mark_bitmap();
 658 
 659   // SATB barriers hooks
 660   inline bool requires_marking(const void* entry) const;
 661   void force_satb_flush_all_threads();
 662 
 663   // Support for bitmap uncommits
 664   bool commit_bitmap_slice(ShenandoahHeapRegion *r);
 665   bool uncommit_bitmap_slice(ShenandoahHeapRegion *r);
 666   bool is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self = false);
 667 
 668   // Liveness caching support
 669   ShenandoahLiveData* get_liveness_cache(uint worker_id);
 670   void flush_liveness_cache(uint worker_id);
 671 
 672   size_t pretouch_heap_page_size() { return _pretouch_heap_page_size; }
 673 
 674 // ---------- Evacuation support
 675 //
 676 private:
 677   ShenandoahCollectionSet* _collection_set;
 678   ShenandoahEvacOOMHandler _oom_evac_handler;
 679 
 680   void evacuate_and_update_roots();
 681 
 682 public:
 683   static address in_cset_fast_test_addr();
 684 
 685   ShenandoahCollectionSet* collection_set() const { return _collection_set; }
 686 
 687   // Checks if object is in the collection set.
 688   inline bool in_collection_set(oop obj) const;
 689 
 690   // Checks if location is in the collection set. Can be interior pointer, not the oop itself.
 691   inline bool in_collection_set_loc(void* loc) const;
 692 
 693   // Evacuates object src. Returns the evacuated object, either evacuated
 694   // by this thread, or by some other thread.
 695   inline oop evacuate_object(oop src, Thread* thread);
 696 
 697   // Call before/after evacuation.
 698   inline void enter_evacuation(Thread* t);
 699   inline void leave_evacuation(Thread* t);
 700 
 701 // ---------- Helper functions
 702 //
 703 public:
 704   template &lt;class T&gt;
 705   inline oop evac_update_with_forwarded(T* p);
 706 
 707   template &lt;class T&gt;
 708   inline oop maybe_update_with_forwarded(T* p);
 709 
 710   template &lt;class T&gt;
 711   inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);
 712 
 713   template &lt;class T&gt;
 714   inline oop update_with_forwarded_not_null(T* p, oop obj);
 715 
 716   static inline oop cas_oop(oop n, narrowOop* addr, oop c);
 717   static inline oop cas_oop(oop n, oop* addr, oop c);
 718   static inline oop cas_oop(oop n, narrowOop* addr, narrowOop c);
 719 
 720   void trash_humongous_region_at(ShenandoahHeapRegion *r);
 721 
 722   void deduplicate_string(oop str);
 723 
 724 private:
 725   void trash_cset_regions();
 726   void update_heap_references(bool concurrent);
 727 
 728 // ---------- Testing helpers functions
 729 //
 730 private:
 731   ShenandoahSharedFlag _inject_alloc_failure;
 732 
 733   void try_inject_alloc_failure();
 734   bool should_inject_alloc_failure();
 735 };
 736 
 737 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
