<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
<a name="1" id="anc1"></a><span class="changed">   2  * Copyright (c) 2019, SAP SE. All rights reserved.</span>
<span class="changed">   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #ifndef SHARE_MEMORY_METASPACE_METACHUNK_HPP
  26 #define SHARE_MEMORY_METASPACE_METACHUNK_HPP
  27 
<a name="2" id="anc2"></a><span class="changed">  28 </span>
<span class="changed">  29 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  30 #include "memory/metaspace/chunkLevel.hpp"</span>
  31 #include "utilities/debug.hpp"
  32 #include "utilities/globalDefinitions.hpp"
  33 
<a name="3" id="anc3"></a><span class="changed">  34 </span>
<span class="changed">  35 class outputStream;</span>
  36 
  37 namespace metaspace {
  38 
  39 class VirtualSpaceNode;
  40 
<a name="4" id="anc4"></a><span class="new">  41 // Todo: comment is outdated.</span>
<span class="new">  42 </span>
  43 //  Metachunk - Quantum of allocation from a Virtualspace
  44 //    Metachunks are reused (when freed are put on a global freelist) and
  45 //    have no permanent association to a SpaceManager.
  46 
<a name="5" id="anc5"></a><span class="changed">  47 //            +--------------+ &lt;- end    ----+         --+</span>
  48 //            |              |               |           |
  49 //            |              |               | free      |
<a name="6" id="anc6"></a><span class="new">  50 //            |              |               |</span>
<span class="new">  51 //            |              |               |           | size (aka capacity)</span>
  52 //            |              |               |           |
<a name="7" id="anc7"></a><span class="changed">  53 //            | -----------  | &lt;- top     -- +           |</span>


  54 //            |              |               |           |
  55 //            |              |               | used      |
<a name="8" id="anc8"></a><span class="changed">  56 //            +--------------+ &lt;- start   -- +        -- +</span>



















  57 
<a name="9" id="anc9"></a><span class="changed">  58 // Note: this is a chunk **descriptor**. The real Payload area lives in metaspace,</span>
<span class="changed">  59 // this class lives somewhere else.</span>
<span class="changed">  60 class Metachunk {</span>
<span class="changed">  61 </span>
<span class="changed">  62   // start of chunk memory; NULL if dead.</span>
<span class="changed">  63   MetaWord* _base;</span>
<span class="changed">  64 </span>
<span class="changed">  65   // Used words.</span>
<span class="changed">  66   size_t _used_words;</span>
<span class="changed">  67 </span>
<span class="changed">  68   // Size of the region, starting from base, which is guaranteed to be committed. In words.</span>
<span class="changed">  69   //  The actual size of committed regions may actually be larger.</span>
<span class="changed">  70   //</span>
<span class="changed">  71   //  (This is a performance optimization. The underlying VirtualSpaceNode knows</span>
<span class="changed">  72   //   which granules are committed; but we want to avoid having to ask.)</span>
<span class="changed">  73   size_t _committed_words;</span>
<span class="changed">  74 </span>
<span class="changed">  75   chunklevel_t _level; // aka size.</span>
<span class="changed">  76 </span>
<span class="changed">  77   // state_free:    free, owned by ChunkManager</span>
<span class="changed">  78   // state_in_use:  in-use, owned by SpaceManager</span>
<span class="changed">  79   // dead:          just a hollow chunk header without associated memory, owned</span>
<span class="changed">  80   //                 by chunk header pool.</span>
<span class="changed">  81   enum state_t {</span>
<span class="changed">  82     state_free = 0,</span>
<span class="changed">  83     state_in_use = 1,</span>
<span class="changed">  84     state_dead = 2</span>
  85   };
<a name="10" id="anc10"></a><span class="new">  86   state_t _state;</span>
  87 
<a name="11" id="anc11"></a><span class="changed">  88   // We need unfortunately a back link to the virtual space node</span>
<span class="changed">  89   // for splitting and merging nodes.</span>
<span class="changed">  90   VirtualSpaceNode* _vsnode;</span>
<span class="changed">  91 </span>
<span class="changed">  92 </span>
<span class="changed">  93   // A chunk header is kept in a list:</span>
<span class="changed">  94   // 1 in the list of used chunks inside a SpaceManager, if it is in use</span>
<span class="changed">  95   // 2 in the list of free chunks inside a ChunkManager, if it is free</span>
<span class="changed">  96   // 3 in the freelist of unused headers inside the ChunkHeaderPool,</span>
<span class="changed">  97   //   if it is unused (e.g. result of chunk merging) and has no associated</span>
<span class="changed">  98   //   memory area.</span>
<span class="changed">  99   Metachunk* _prev;</span>
<span class="changed"> 100   Metachunk* _next;</span>
<span class="changed"> 101 </span>
<span class="changed"> 102   // Furthermore, we keep, per chunk, information about the neighboring chunks.</span>
<span class="changed"> 103   // This is needed to split and merge chunks.</span>
<span class="changed"> 104   //</span>
<span class="changed"> 105   // Note: These members can be modified concurrently while a chunk is alive and in use.</span>
<span class="changed"> 106   // This can happen if a neighboring chunk is added or removed.</span>
<span class="changed"> 107   // This means only read or modify these members under expand lock protection.</span>
<span class="changed"> 108   Metachunk* _prev_in_vs;</span>
<span class="changed"> 109   Metachunk* _next_in_vs;</span>
<span class="changed"> 110 </span>
<span class="changed"> 111   // Commit uncommitted section of the chunk.</span>
<span class="changed"> 112   // Fails if we hit a commit limit.</span>
<span class="changed"> 113   bool commit_up_to(size_t new_committed_words);</span>
<span class="changed"> 114 </span>
<span class="changed"> 115   DEBUG_ONLY(static void assert_have_expand_lock();)</span>
<span class="changed"> 116 </span>
<span class="changed"> 117 public:</span>
<span class="changed"> 118 </span>
<span class="changed"> 119   Metachunk()</span>
<span class="changed"> 120     : _base(NULL),</span>
<span class="changed"> 121       _used_words(0),</span>
<span class="changed"> 122       _committed_words(0),</span>
<span class="changed"> 123       _level(chunklevel::ROOT_CHUNK_LEVEL),</span>
<span class="changed"> 124       _state(state_free),</span>
<span class="changed"> 125       _vsnode(NULL),</span>
<span class="changed"> 126       _prev(NULL), _next(NULL),</span>
<span class="changed"> 127       _prev_in_vs(NULL), _next_in_vs(NULL)</span>
<span class="changed"> 128   {}</span>
<span class="changed"> 129 </span>
<span class="changed"> 130  void clear() {</span>
<span class="changed"> 131    _base = NULL;</span>
<span class="changed"> 132    _used_words = 0;</span>
<span class="changed"> 133    _committed_words = 0;</span>
<span class="changed"> 134    _level = chunklevel::ROOT_CHUNK_LEVEL;</span>
<span class="changed"> 135    _state = state_free;</span>
<span class="changed"> 136    _vsnode = NULL;</span>
<span class="changed"> 137    _prev = NULL;</span>
<span class="changed"> 138    _next = NULL;</span>
<span class="changed"> 139    _prev_in_vs = NULL;</span>
<span class="changed"> 140    _next_in_vs = NULL;</span>
<span class="changed"> 141   }</span>
<span class="changed"> 142 </span>
<span class="changed"> 143 </span>
<span class="changed"> 144   size_t word_size() const        { return chunklevel::word_size_for_level(_level); }</span>
<span class="changed"> 145 </span>
<span class="changed"> 146   MetaWord* base() const          { return _base; }</span>
<span class="changed"> 147   MetaWord* top() const           { return base() + _used_words; }</span>
<span class="changed"> 148   MetaWord* committed_top() const { return base() + _committed_words; }</span>
<span class="changed"> 149   MetaWord* end() const           { return base() + word_size(); }</span>
<span class="changed"> 150 </span>
<span class="changed"> 151   // Chunk list wiring</span>
<span class="changed"> 152   void set_prev(Metachunk* c)     { _prev = c; }</span>
<span class="changed"> 153   Metachunk* prev() const         { return _prev; }</span>
<span class="changed"> 154   void set_next(Metachunk* c)     { _next = c; }</span>
<span class="changed"> 155   Metachunk* next() const         { return _next; }</span>
<span class="changed"> 156 </span>
<span class="changed"> 157   DEBUG_ONLY(bool in_list() const { return _prev != NULL || _next != NULL; })</span>
<span class="changed"> 158 </span>
<span class="changed"> 159   // Physical neighbors wiring</span>
<span class="changed"> 160   void set_prev_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _prev_in_vs = c; }</span>
<span class="changed"> 161   Metachunk* prev_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _prev_in_vs; }</span>
<span class="changed"> 162   void set_next_in_vs(Metachunk* c) { DEBUG_ONLY(assert_have_expand_lock()); _next_in_vs = c; }</span>
<span class="changed"> 163   Metachunk* next_in_vs() const     { DEBUG_ONLY(assert_have_expand_lock()); return _next_in_vs; }</span>
<span class="changed"> 164 </span>
<span class="changed"> 165   bool is_free() const            { return _state == state_free; }</span>
<span class="changed"> 166   bool is_in_use() const          { return _state == state_in_use; }</span>
<span class="changed"> 167   bool is_dead() const            { return _state == state_dead; }</span>
<span class="changed"> 168   void set_free()                 { _state = state_free; }</span>
<span class="changed"> 169   void set_in_use()               { _state = state_in_use; }</span>
<span class="changed"> 170   void set_dead()                 { _state = state_dead; }</span>
<span class="changed"> 171 </span>
<span class="changed"> 172   // Return a single char presentation of the state ('f', 'u', 'd')</span>
<span class="changed"> 173   char get_state_char() const;</span>
<span class="changed"> 174 </span>
<span class="changed"> 175   void inc_level()                { _level ++; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }</span>
<span class="changed"> 176   void dec_level()                { _level --; DEBUG_ONLY(chunklevel::is_valid_level(_level);) }</span>
<span class="changed"> 177   chunklevel_t level() const          { return _level; }</span>
<span class="changed"> 178 </span>
<span class="changed"> 179   // Convenience functions for extreme levels.</span>
<span class="changed"> 180   bool is_root_chunk() const      { return chunklevel::ROOT_CHUNK_LEVEL == _level; }</span>
<span class="changed"> 181   bool is_leaf_chunk() const      { return chunklevel::HIGHEST_CHUNK_LEVEL == _level; }</span>
<span class="changed"> 182 </span>
<span class="changed"> 183   VirtualSpaceNode* vsnode() const        { return _vsnode; }</span>
<span class="changed"> 184 </span>
<span class="changed"> 185   size_t used_words() const                   { return _used_words; }</span>
<span class="changed"> 186   size_t free_words() const                   { return word_size() - used_words(); }</span>
<span class="changed"> 187   size_t free_below_committed_words() const   { return committed_words() - used_words(); }</span>
<span class="changed"> 188   void reset_used_words()                     { _used_words = 0; }</span>
<span class="changed"> 189 </span>
<span class="changed"> 190   size_t committed_words() const      { return _committed_words; }</span>
<span class="changed"> 191   void set_committed_words(size_t v);</span>
<span class="changed"> 192   bool is_fully_committed() const     { return committed_words() == word_size(); }</span>
<span class="changed"> 193   bool is_fully_uncommitted() const   { return committed_words() == 0; }</span>
<span class="changed"> 194 </span>
<span class="changed"> 195   // Ensure that chunk is committed up to at least new_committed_words words.</span>
<span class="changed"> 196   // Fails if we hit a commit limit.</span>
<span class="changed"> 197   bool ensure_committed(size_t new_committed_words);</span>
<span class="changed"> 198   bool ensure_committed_locked(size_t new_committed_words);</span>
<span class="changed"> 199 </span>
<span class="changed"> 200   bool ensure_fully_committed()           { return ensure_committed(word_size()); }</span>
<span class="changed"> 201   bool ensure_fully_committed_locked()    { return ensure_committed_locked(word_size()); }</span>
<span class="changed"> 202 </span>
<span class="changed"> 203   // Ensure that the chunk is committed far enough to serve an additional allocation of word_size.</span>
<span class="changed"> 204   bool ensure_committed_additional(size_t additional_word_size)   {</span>
<span class="changed"> 205     return ensure_committed(used_words() + additional_word_size);</span>
<span class="changed"> 206   }</span>
<span class="changed"> 207 </span>
<span class="changed"> 208   // Uncommit chunk area. The area must be a common multiple of the</span>
<span class="changed"> 209   // commit granule size (in other words, we cannot uncommit chunks smaller than</span>
<span class="changed"> 210   // a commit granule size).</span>
<span class="changed"> 211   void uncommit();</span>
<span class="changed"> 212   void uncommit_locked();</span>
<span class="changed"> 213 </span>
<span class="changed"> 214   // Allocation from a chunk</span>
<span class="changed"> 215 </span>
<span class="changed"> 216   // Allocate word_size words from this chunk (word_size must be aligned to</span>
<span class="changed"> 217   //  allocation_alignment_words).</span>
<span class="changed"> 218   //</span>
<span class="changed"> 219   // Caller must make sure the chunk is both large enough and committed far enough</span>
<span class="changed"> 220   // to hold the allocation. Will always work.</span>
<span class="changed"> 221   //</span>
<span class="changed"> 222   MetaWord* allocate(size_t request_word_size);</span>
<span class="changed"> 223 </span>
<span class="changed"> 224   // Initialize structure for reuse.</span>
<span class="changed"> 225   void initialize(VirtualSpaceNode* node, MetaWord* base, chunklevel_t lvl) {</span>
<span class="changed"> 226     _vsnode = node; _base = base; _level = lvl;</span>
<span class="changed"> 227     _used_words = _committed_words = 0; _state = state_free;</span>
<span class="changed"> 228     _next = _prev = _next_in_vs = _prev_in_vs = NULL;</span>
<span class="changed"> 229   }</span>
<span class="changed"> 230 </span>
<span class="changed"> 231   // Returns true if this chunk is the leader in its buddy pair, false if not.</span>
<span class="changed"> 232   // Do not call for root chunks.</span>
<span class="changed"> 233   bool is_leader() const {</span>
<span class="changed"> 234     assert(!is_root_chunk(), "Root chunks have no buddy."); // Bit harsh?</span>
<span class="changed"> 235     return is_aligned(base(), chunklevel::word_size_for_level(level() - 1) * BytesPerWord);</span>
<span class="changed"> 236   }</span>
<span class="changed"> 237 </span>
<span class="changed"> 238   //// Debug stuff ////</span>
<span class="changed"> 239 #ifdef ASSERT</span>
<span class="changed"> 240   void verify(bool slow) const;</span>
<span class="changed"> 241   // Verifies linking with neighbors in virtual space. Needs expand lock protection.</span>
<span class="changed"> 242   void verify_neighborhood() const;</span>
<span class="changed"> 243   void zap_header(uint8_t c = 0x17);</span>
<span class="changed"> 244   void fill_with_pattern(MetaWord pattern, size_t word_size);</span>
<span class="changed"> 245   void check_pattern(MetaWord pattern, size_t word_size);</span>
<span class="changed"> 246 </span>
<span class="changed"> 247   // Returns true if given pointer points into the payload area of this chunk.</span>
<span class="changed"> 248   bool is_valid_pointer(const MetaWord* p) const {</span>
<span class="changed"> 249     return base() &lt;= p &amp;&amp; p &lt; top();</span>
<span class="changed"> 250   }</span>
<span class="changed"> 251 </span>
<span class="changed"> 252   // Returns true if given pointer points into the commmitted payload area of this chunk.</span>
<span class="changed"> 253   bool is_valid_committed_pointer(const MetaWord* p) const {</span>
<span class="changed"> 254     return base() &lt;= p &amp;&amp; p &lt; committed_top();</span>
<span class="changed"> 255   }</span>
 256 
<a name="12" id="anc12"></a><span class="changed"> 257 #endif // ASSERT</span>





















 258 
 259   void print_on(outputStream* st) const;
 260 
<a name="13" id="anc13"></a>














 261 };
 262 
<a name="14" id="anc14"></a><span class="new"> 263 // Little print helpers: since we often print out chunks, here some convenience macros</span>
<span class="new"> 264 #define METACHUNK_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT</span>
<span class="new"> 265 #define METACHUNK_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level()</span>
 266 
<a name="15" id="anc15"></a><span class="changed"> 267 #define METACHUNK_FULL_FORMAT                "@" PTR_FORMAT ", %c, base " PTR_FORMAT ", level " CHKLVL_FORMAT " (" SIZE_FORMAT "), used: " SIZE_FORMAT ", committed: " SIZE_FORMAT ", committed-free: " SIZE_FORMAT</span>
<span class="changed"> 268 #define METACHUNK_FULL_FORMAT_ARGS(chunk)    p2i(chunk), chunk-&gt;get_state_char(), p2i(chunk-&gt;base()), chunk-&gt;level(), chunk-&gt;word_size(), chunk-&gt;used_words(), chunk-&gt;committed_words(), chunk-&gt;free_below_committed_words()</span>




 269 
 270 } // namespace metaspace
 271 
 272 #endif // SHARE_MEMORY_METASPACE_METACHUNK_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="16" type="hidden" /></form></body></html>
