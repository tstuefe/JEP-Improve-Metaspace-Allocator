<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  27 #define SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace/chunkLevel.hpp"
  31 #include "memory/metaspace/counter.hpp"
  32 #include "memory/metaspace/freeChunkList.hpp"
  33 #include "memory/metaspace/metachunk.hpp"
  34 
  35 namespace metaspace {
  36 
  37 class VirtualSpaceList;
  38 struct cm_stats_t;
  39 
  40 // ChunkManager has a central role.
  41 
  42 // SpaceManagers request chunks from it. It keeps the freelists for chunks.
  43 // If the freelist is exhausted it allocates new chunks from a connected
  44 // VirtualSpaceList.
  45 //
  46 class ChunkManager : public CHeapObj&lt;mtMetaspace&gt; {
  47 
  48   // A chunk manager is connected to a virtual space list which is used
  49   // to allocate new root chunks when no free chunks are found.
  50   VirtualSpaceList* const _vslist;
  51 
  52   // Name
  53   const char* const _name;
  54 
  55   // Freelists
  56   FreeChunkListVector _chunks;
  57 
  58   // Returns true if this manager contains the given chunk. Slow (walks free lists) and
  59   // only needed for verifications.
  60   DEBUG_ONLY(bool contains_chunk(Metachunk* c) const;)
  61 
  62   // Given a chunk we are about to handout to the caller, make sure it is committed
  63   // according to constants::committed_words_on_fresh_chunks.
  64   // May fail if we hit the commit limit.
  65   static bool commit_chunk_before_handout(Metachunk* c);
  66 
  67   // Take a single chunk from the given freelist and adjust counters. Returns NULL
  68   // if there is no fitting chunk for this level.
  69   Metachunk* remove_first_chunk_at_level(chunklevel_t l);
  70 
  71   // Given a chunk, split it into a target chunk of a smaller size (target level)
  72   //  at least one, possible more splinter chunks. Splinter chunks are added to the
  73   //  freelist.
  74   // The original chunk must be outside of the freelist and its state must be free.
  75   // The resulting target chunk will be located at the same address as the original
  76   //  chunk, but it will of course be smaller (of a higher level).
  77   // The committed areas within the original chunk carry over to the resulting
  78   //  chunks.
  79   void split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level);
  80 
  81   // See get_chunk(s,s,s)
  82   Metachunk* get_chunk_locked(size_t preferred_word_size, size_t min_word_size, size_t min_committed_words);
  83 
  84   // Uncommit all chunks equal or below the given level.
  85   void uncommit_free_chunks(chunklevel_t max_level);
  86 
  87 public:
  88 
  89   // Creates a chunk manager with a given name (which is for debug purposes only)
  90   // and an associated space list which will be used to request new chunks from
  91   // (see get_chunk())
  92   ChunkManager(const char* name, VirtualSpaceList* space_list);
  93 
  94   // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
  95   //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
  96   // On error, will return NULL.
  97   //
  98   // This function may fail for two reasons:
  99   // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
 100   //   is non-expandable but needs expanding - aka out of compressed class space).
 101   // - Or, if the necessary space cannot be committed because we hit a commit limit.
 102   //   This may be either the GC threshold or MaxMetaspaceSize.
 103   Metachunk* get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words);
 104 
 105   // Convenience function - get a chunk of a given level, uncommitted.
 106   Metachunk* get_chunk(chunklevel_t lvl) { return get_chunk(lvl, lvl, 0); }
 107 
 108   // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 109   //  with neighbors.
 110   // Happens after a Classloader was unloaded and releases its metaspace chunks.
 111   // !! Notes:
 112   //    1) After this method returns, c may not be valid anymore. ** Do not access c after this function returns **.
 113   //    2) This function will not remove c from its current chunk list. This has to be done by the caller prior to
 114   //       calling this method.
 115   void return_chunk(Metachunk* c);
 116 
 117   // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
 118   void return_chunk_simple(Metachunk* c);
 119 
 120   // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
 121   // enlarge it in place by claiming its trailing buddy.
 122   //
 123   // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 124   //
 125   // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 126   // double in size (level decreased by one).
 127   //
 128   // On success, true is returned, false otherwise.
 129   bool attempt_enlarge_chunk(Metachunk* c);
 130 
 131   // Attempt to reclaim free areas in metaspace wholesale:
 132   // - first, attempt to purge nodes of the backing virtual space. This can only be successful
 133   //   if whole nodes are only containing free chunks, so it highly depends on fragmentation.
 134   // - then, it will uncommit areas of free chunks according to the rules laid down in
 135   //   settings (see settings.hpp).
 136   void wholesale_reclaim();
 137 
 138   // Run verifications. slow=true: verify chunk-internal integrity too.
 139   DEBUG_ONLY(void verify(bool slow) const;)
 140   DEBUG_ONLY(void verify_locked(bool slow) const;)
 141 
 142   // Returns the name of this chunk manager.
 143   const char* name() const                  { return _name; }
 144 
 145   // Returns total number of chunks
 146   int total_num_chunks() const              { return _chunks.num_chunks(); }
 147 
 148   // Returns number of words in all free chunks (regardless of commit state).
 149   size_t total_word_size() const            { return _chunks.word_size(); }
 150 
 151   // Returns number of committed words in all free chunks.
 152   size_t total_committed_word_size() const  { return _chunks.committed_word_size(); }
 153 
 154   // Update statistics.
 155   void add_to_statistics(cm_stats_t* out) const;
 156 
 157   void print_on(outputStream* st) const;
 158   void print_on_locked(outputStream* st) const;
 159 
 160 private:
 161 
 162   static ChunkManager* _chunkmanager_class;
 163   static ChunkManager* _chunkmanager_nonclass;
 164 
 165 public:
 166 
 167   static ChunkManager* chunkmanager_class() { return _chunkmanager_class; }
 168   static ChunkManager* chunkmanager_nonclass() { return _chunkmanager_nonclass; }
 169 
 170   static void set_chunkmanager_class(ChunkManager* cm);
 171   static void set_chunkmanager_nonclass(ChunkManager* cm);
 172 
 173 
 174 };
 175 
 176 } // namespace metaspace
 177 
 178 #endif // SHARE_MEMORY_METASPACE_CHUNKMANAGER_HPP
</pre></body></html>
