<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  26 #define SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
  27 
  28 #include "memory/virtualspace.hpp"
  29 #include "memory/memRegion.hpp"
  30 #include "utilities/debug.hpp"
  31 #include "utilities/globalDefinitions.hpp"
  32 
  33 class outputStream;
  34 
  35 namespace metaspace {
  36 
  37 class Metachunk;
  38 class ChunkManager;
  39 class OccupancyMap;
  40 
  41 // A VirtualSpaceList node.
  42 class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt; {
  43   friend class VirtualSpaceList;
  44 
  45   // Link to next VirtualSpaceNode
  46   VirtualSpaceNode* _next;
  47 
  48   // Whether this node is contained in class or metaspace.
  49   const bool _is_class;
  50 
  51   // total in the VirtualSpace
  52   ReservedSpace _rs;
  53   VirtualSpace _virtual_space;
  54   MetaWord* _top;
  55   // count of chunks contained in this VirtualSpace
  56   uintx _container_count;
  57 
  58   OccupancyMap* _occupancy_map;
  59 
  60   // Convenience functions to access the _virtual_space
  61   char* low()  const { return virtual_space()-&gt;low(); }
  62   char* high() const { return virtual_space()-&gt;high(); }
  63   char* low_boundary()  const { return virtual_space()-&gt;low_boundary(); }
  64   char* high_boundary() const { return virtual_space()-&gt;high_boundary(); }
  65 
  66   // The first Metachunk will be allocated at the bottom of the
  67   // VirtualSpace
  68   Metachunk* first_chunk() { return (Metachunk*) bottom(); }
  69 
  70   // Committed but unused space in the virtual space
  71   size_t free_words_in_vs() const;
  72 
  73   // True if this node belongs to class metaspace.
  74   bool is_class() const { return _is_class; }
  75 
  76   // Helper function for take_from_committed: allocate padding chunks
  77   // until top is at the given address.
  78   void allocate_padding_chunks_until_top_is_at(MetaWord* target_top);
  79 
  80  public:
  81 
  82   VirtualSpaceNode(bool is_class, size_t byte_size);
  83   VirtualSpaceNode(bool is_class, ReservedSpace rs) :
  84     _next(NULL), _is_class(is_class), _rs(rs), _top(NULL), _container_count(0), _occupancy_map(NULL) {}
  85   ~VirtualSpaceNode();
  86 
  87   // Convenience functions for logical bottom and (committed) end
  88   MetaWord* bottom() const { return (MetaWord*) _virtual_space.low(); }
  89   MetaWord* end() const { return (MetaWord*) _virtual_space.high(); }
  90 
  91   const OccupancyMap* occupancy_map() const { return _occupancy_map; }
  92   OccupancyMap* occupancy_map() { return _occupancy_map; }
  93 
  94   bool contains(const void* ptr) { return ptr &gt;= low() &amp;&amp; ptr &lt; high(); }
  95 
  96   size_t reserved_words() const  { return _virtual_space.reserved_size() / BytesPerWord; }
  97   size_t committed_words() const { return _virtual_space.actual_committed_size() / BytesPerWord; }
  98 
  99   bool is_pre_committed() const { return _virtual_space.special(); }
 100 
 101   // address of next available space in _virtual_space;
 102   // Accessors
 103   VirtualSpaceNode* next() { return _next; }
 104   void set_next(VirtualSpaceNode* v) { _next = v; }
 105 
 106   void set_top(MetaWord* v) { _top = v; }
 107 
 108   // Accessors
 109   VirtualSpace* virtual_space() const { return (VirtualSpace*) &amp;_virtual_space; }
 110 
 111   // Returns true if "word_size" is available in the VirtualSpace
 112   bool is_available(size_t word_size) { return word_size &lt;= pointer_delta(end(), _top, sizeof(MetaWord)); }
 113 
 114   MetaWord* top() const { return _top; }
 115   void inc_top(size_t word_size) { _top += word_size; }
 116 
 117   uintx container_count() { return _container_count; }
 118   void inc_container_count();
 119   void dec_container_count();
 120 
 121   // used and capacity in this single entry in the list
 122   size_t used_words_in_vs() const;
 123   size_t capacity_words_in_vs() const;
 124 
 125   bool initialize();
 126 
 127   // get space from the virtual space
 128   Metachunk* take_from_committed(size_t chunk_word_size);
 129 
 130   // Allocate a chunk from the virtual space and return it.
 131   Metachunk* get_chunk_vs(size_t chunk_word_size);
 132 
 133   // Expands the committed space by at least min_words words.
 134   bool expand_by(size_t min_words, size_t preferred_words);
 135 
 136   // In preparation for deleting this node, remove all the chunks
 137   // in the node from any freelist.
 138   void purge(ChunkManager* chunk_manager);
 139 
 140   // If an allocation doesn't fit in the current node a new node is created.
 141   // Allocate chunks out of the remaining committed space in this node
 142   // to avoid wasting that memory.
 143   // This always adds up because all the chunk sizes are multiples of
 144   // the smallest chunk size.
 145   void retire(ChunkManager* chunk_manager);
 146 
 147   void print_on(outputStream* st) const                 { print_on(st, K); }
 148   void print_on(outputStream* st, size_t scale) const;
 149   void print_map(outputStream* st, bool is_class) const;
 150 
 151   // Debug support
 152   DEBUG_ONLY(void mangle();)
 153   // Verify counters and basic structure. Slow mode: verify all chunks in depth and occupancy map.
 154   DEBUG_ONLY(void verify(bool slow);)
 155   // Verify that all free chunks in this node are ideally merged
 156   // (there should not be multiple small chunks where a large chunk could exist.)
 157   DEBUG_ONLY(void verify_free_chunks_are_ideally_merged();)
 158 
 159 };
 160 
 161 } // namespace metaspace
 162 
 163 #endif // SHARE_MEMORY_METASPACE_VIRTUALSPACENODE_HPP
</pre></body></html>
