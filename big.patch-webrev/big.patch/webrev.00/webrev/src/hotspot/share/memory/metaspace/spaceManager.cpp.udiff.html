<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>source Udiff src/hotspot/share/memory/metaspace/spaceManager.cpp</title>

<style type="text/css" media="screen">
span.new {
    color: blue;
    font-weight: normal;
}
</style>

</head>
<body id="SUNWwebrev">
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.udiff.html' target='_top'>next &gt</a></center>
<h2>src/hotspot/share/memory/metaspace/spaceManager.cpp</h2>
        <a class="print" href="javascript:print()">Print this page</a>
<pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre>
        <pre>
</pre><hr /><pre>
<span class="newmarker">@@ -1,7 +1,8 @@</span>
 /*
  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="new">+ * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
</pre><hr /><pre>
<span class="newmarker">@@ -23,506 +24,488 @@</span>
  */
 #include "precompiled.hpp"
 
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
<span class="new">+#include "memory/metaspace/allocationGuard.hpp"</span>
<span class="new">+#include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="new">+#include "memory/metaspace/freeBlocks.hpp"</span>
 #include "memory/metaspace/chunkManager.hpp"
<span class="new">+#include "memory/metaspace/internStat.hpp"</span>
 #include "memory/metaspace/metachunk.hpp"
<span class="removed">-#include "memory/metaspace/metaDebug.hpp"</span>
 #include "memory/metaspace/metaspaceCommon.hpp"
<span class="new">+#include "memory/metaspace/metaspaceStatistics.hpp"</span>
 #include "memory/metaspace/spaceManager.hpp"
 #include "memory/metaspace/virtualSpaceList.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/init.hpp"
 #include "services/memoryService.hpp"
<span class="new">+#include "utilities/align.hpp"</span>
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 
 namespace metaspace {
 
<span class="removed">-#define assert_counter(expected_value, real_value, msg) \</span>
<span class="removed">-  assert( (expected_value) == (real_value),             \</span>
<span class="removed">-         "Counter mismatch (%s): expected " SIZE_FORMAT \</span>
<span class="removed">-         ", but got: " SIZE_FORMAT ".", msg, expected_value, \</span>
<span class="removed">-         real_value);</span>
<span class="new">+#define LOGFMT_SPCMGR         "SpcMgr @" PTR_FORMAT " (%s)"</span>
<span class="new">+#define LOGFMT_SPCMGR_ARGS    p2i(this), this-&gt;_name</span>
 
<span class="removed">-// SpaceManager methods</span>
<span class="new">+// Given a net allocation word size, return the raw word size we actually allocate.</span>
<span class="new">+// Note: externally visible for gtests.</span>
<span class="new">+//static</span>
<span class="new">+size_t get_raw_allocation_word_size(size_t net_word_size) {</span>
 
<span class="removed">-size_t SpaceManager::adjust_initial_chunk_size(size_t requested, bool is_class_space) {</span>
<span class="removed">-  size_t chunk_sizes[] = {</span>
<span class="removed">-      specialized_chunk_size(is_class_space),</span>
<span class="removed">-      small_chunk_size(is_class_space),</span>
<span class="removed">-      medium_chunk_size(is_class_space)</span>
<span class="removed">-  };</span>
<span class="new">+  size_t byte_size = net_word_size * BytesPerWord;</span>
 
<span class="removed">-  // Adjust up to one of the fixed chunk sizes ...</span>
<span class="removed">-  for (size_t i = 0; i &lt; ARRAY_SIZE(chunk_sizes); i++) {</span>
<span class="removed">-    if (requested &lt;= chunk_sizes[i]) {</span>
<span class="removed">-      return chunk_sizes[i];</span>
<span class="removed">-    }</span>
<span class="new">+  // Deallocated metablocks are kept in a binlist which limits their minimal</span>
<span class="new">+  //  size to at least the size of a binlist item (2 words).</span>
<span class="new">+  byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);</span>
<span class="new">+</span>
<span class="new">+  // Metaspace allocations are aligned to word size.</span>
<span class="new">+  byte_size = align_up(byte_size, allocation_alignment_bytes);</span>
<span class="new">+</span>
<span class="new">+  // If we guard allocations, we need additional space for a prefix.</span>
<span class="new">+#ifdef ASSERT</span>
<span class="new">+  if (Settings::use_allocation_guard()) {</span>
<span class="new">+    byte_size += align_up(prefix_size(), allocation_alignment_bytes);</span>
   }
<span class="new">+#endif</span>
<span class="new">+</span>
<span class="new">+  size_t word_size = byte_size / BytesPerWord;</span>
<span class="new">+</span>
<span class="new">+  assert(word_size * BytesPerWord == byte_size, "Sanity");</span>
<span class="new">+</span>
<span class="new">+  return word_size;</span>
 
<span class="removed">-  // ... or return the size as a humongous chunk.</span>
<span class="removed">-  return requested;</span>
 }
 
<span class="removed">-size_t SpaceManager::adjust_initial_chunk_size(size_t requested) const {</span>
<span class="removed">-  return adjust_initial_chunk_size(requested, is_class());</span>
<span class="new">+// Returns the level of the next chunk to be added, acc to growth policy.</span>
<span class="new">+chunklevel_t SpaceManager::next_chunk_level() const {</span>
<span class="new">+  const int growth_step = _chunks.count();</span>
<span class="new">+  return _growth_policy-&gt;get_level_at_step(growth_step);</span>
 }
 
<span class="removed">-size_t SpaceManager::get_initial_chunk_size(Metaspace::MetaspaceType type) const {</span>
<span class="removed">-  size_t requested;</span>
<span class="new">+// Given a chunk, add its remaining free committed space to the free block list.</span>
<span class="new">+void SpaceManager::salvage_chunk(Metachunk* c) {</span>
 
<span class="removed">-  if (is_class()) {</span>
<span class="removed">-    switch (type) {</span>
<span class="removed">-    case Metaspace::BootMetaspaceType:              requested = Metaspace::first_class_chunk_word_size(); break;</span>
<span class="removed">-    case Metaspace::ClassMirrorHolderMetaspaceType: requested = ClassSpecializedChunk; break;</span>
<span class="removed">-    case Metaspace::ReflectionMetaspaceType:        requested = ClassSpecializedChunk; break;</span>
<span class="removed">-    default:                                        requested = ClassSmallChunk; break;</span>
<span class="removed">-    }</span>
<span class="removed">-  } else {</span>
<span class="removed">-    switch (type) {</span>
<span class="removed">-    case Metaspace::BootMetaspaceType:              requested = Metaspace::first_chunk_word_size(); break;</span>
<span class="removed">-    case Metaspace::ClassMirrorHolderMetaspaceType: requested = SpecializedChunk; break;</span>
<span class="removed">-    case Metaspace::ReflectionMetaspaceType:        requested = SpecializedChunk; break;</span>
<span class="removed">-    default:                                        requested = SmallChunk; break;</span>
<span class="new">+  if (Settings::handle_deallocations() == false) {</span>
<span class="new">+    return;</span>
     }
<span class="new">+</span>
<span class="new">+  assert_lock_strong(lock());</span>
<span class="new">+</span>
<span class="new">+  // If the chunk is completely empty, just return it to the chunk manager.</span>
<span class="new">+  if (c-&gt;used_words() == 0) {</span>
<span class="new">+    _chunk_manager-&gt;return_chunk(c);</span>
<span class="new">+    return;</span>
   }
 
<span class="removed">-  // Adjust to one of the fixed chunk sizes (unless humongous)</span>
<span class="removed">-  const size_t adjusted = adjust_initial_chunk_size(requested);</span>
<span class="new">+  size_t remaining_words = c-&gt;free_below_committed_words();</span>
 
<span class="removed">-  assert(adjusted != 0, "Incorrect initial chunk size. Requested: "</span>
<span class="removed">-         SIZE_FORMAT " adjusted: " SIZE_FORMAT, requested, adjusted);</span>
<span class="new">+  if (remaining_words &gt; FreeBlocks::minimal_word_size) {</span>
 
<span class="removed">-  return adjusted;</span>
<span class="removed">-}</span>
<span class="new">+    log_debug(metaspace)(LOGFMT_SPCMGR " @" PTR_FORMAT " : salvaging chunk " METACHUNK_FULL_FORMAT ".",</span>
<span class="new">+                         LOGFMT_SPCMGR_ARGS, p2i(this), METACHUNK_FULL_FORMAT_ARGS(c));</span>
<span class="new">+</span>
<span class="new">+    MetaWord* ptr = c-&gt;allocate(remaining_words);</span>
<span class="new">+    assert(ptr != NULL, "Should have worked");</span>
<span class="new">+    _total_used_words_counter-&gt;increment_by(remaining_words);</span>
<span class="new">+</span>
<span class="new">+    add_allocation_to_fbl(ptr, remaining_words);</span>
 
<span class="removed">-void SpaceManager::locked_print_chunks_in_use_on(outputStream* st) const {</span>
<span class="new">+    // After this operation: the chunk should have no free committed space left.</span>
<span class="new">+    assert(c-&gt;free_below_committed_words() == 0,</span>
<span class="new">+           "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",</span>
<span class="new">+           METACHUNK_FULL_FORMAT_ARGS(c));</span>
 
<span class="removed">-  for (ChunkIndex i = ZeroIndex; i &lt; NumberOfInUseLists; i = next_chunk_index(i)) {</span>
<span class="removed">-    st-&gt;print("SpaceManager: " UINTX_FORMAT " %s chunks.",</span>
<span class="removed">-        num_chunks_by_type(i), chunk_size_name(i));</span>
   }
 
<span class="removed">-  chunk_manager()-&gt;locked_print_free_chunks(st);</span>
 }
 
<span class="removed">-size_t SpaceManager::calc_chunk_size(size_t word_size) {</span>
<span class="new">+// Allocate a new chunk from the underlying chunk manager able to hold at least</span>
<span class="new">+// requested word size.</span>
<span class="new">+Metachunk* SpaceManager::allocate_new_chunk(size_t requested_word_size) {</span>
 
<span class="removed">-  // Decide between a small chunk and a medium chunk.  Up to</span>
<span class="removed">-  // _small_chunk_limit small chunks can be allocated.</span>
<span class="removed">-  // After that a medium chunk is preferred.</span>
<span class="removed">-  size_t chunk_word_size;</span>
<span class="new">+  assert_lock_strong(lock());</span>
 
<span class="removed">-  // Special case for hidden metadata space.</span>
<span class="removed">-  // ClassMirrorHolder metadata space is usually small since it is used for</span>
<span class="removed">-  // class loader data's whose life cycle is governed by one class such as a</span>
<span class="removed">-  // non-strong hidden class or unsafe anonymous class.  The majority within 1K - 2K range and</span>
<span class="removed">-  // rarely about 4K (64-bits JVM).</span>
<span class="removed">-  // Instead of jumping to SmallChunk after initial chunk exhausted, keeping allocation</span>
<span class="removed">-  // from SpecializeChunk up to _anon_or_delegating_metadata_specialize_chunk_limit (4)</span>
<span class="removed">-  // reduces space waste from 60+% to around 30%.</span>
<span class="removed">-  if ((_space_type == Metaspace::ClassMirrorHolderMetaspaceType || _space_type == Metaspace::ReflectionMetaspaceType) &amp;&amp;</span>
<span class="removed">-      _mdtype == Metaspace::NonClassType &amp;&amp;</span>
<span class="removed">-      num_chunks_by_type(SpecializedIndex) &lt; anon_and_delegating_metadata_specialize_chunk_limit &amp;&amp;</span>
<span class="removed">-      word_size + Metachunk::overhead() &lt;= SpecializedChunk) {</span>
<span class="removed">-    return SpecializedChunk;</span>
<span class="new">+  // Should this ever happen, we need to increase the maximum possible chunk size.</span>
<span class="new">+  guarantee(requested_word_size &lt;= chunklevel::MAX_CHUNK_WORD_SIZE,</span>
<span class="new">+            "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",</span>
<span class="new">+            requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="new">+</span>
<span class="new">+  const int growth_step = _chunks.count();</span>
<span class="new">+  const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);</span>
<span class="new">+  const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());</span>
<span class="new">+</span>
<span class="new">+  Metachunk* c = _chunk_manager-&gt;get_chunk(preferred_level, max_level, requested_word_size);</span>
<span class="new">+  if (c == NULL) {</span>
<span class="new">+    log_debug(metaspace)(LOGFMT_SPCMGR ": failed to allocate new chunk for requested word size " SIZE_FORMAT ".",</span>
<span class="new">+                         LOGFMT_SPCMGR_ARGS, requested_word_size);</span>
<span class="new">+    return NULL;</span>
   }
 
<span class="removed">-  if (num_chunks_by_type(MediumIndex) == 0 &amp;&amp;</span>
<span class="removed">-      num_chunks_by_type(SmallIndex) &lt; small_chunk_limit) {</span>
<span class="removed">-    chunk_word_size = (size_t) small_chunk_size();</span>
<span class="removed">-    if (word_size + Metachunk::overhead() &gt; small_chunk_size()) {</span>
<span class="removed">-      chunk_word_size = medium_chunk_size();</span>
<span class="removed">-    }</span>
<span class="removed">-  } else {</span>
<span class="removed">-    chunk_word_size = medium_chunk_size();</span>
<span class="removed">-  }</span>
<span class="new">+  assert(c-&gt;is_in_use(), "Wrong chunk state.");</span>
<span class="new">+  assert(c-&gt;free_below_committed_words() &gt;= requested_word_size, "Chunk not committed");</span>
 
<span class="removed">-  // Might still need a humongous chunk.  Enforce</span>
<span class="removed">-  // humongous allocations sizes to be aligned up to</span>
<span class="removed">-  // the smallest chunk size.</span>
<span class="removed">-  size_t if_humongous_sized_chunk =</span>
<span class="removed">-    align_up(word_size + Metachunk::overhead(),</span>
<span class="removed">-                  smallest_chunk_size());</span>
<span class="removed">-  chunk_word_size =</span>
<span class="removed">-    MAX2((size_t) chunk_word_size, if_humongous_sized_chunk);</span>
<span class="new">+  log_debug(metaspace)(LOGFMT_SPCMGR ": allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",</span>
<span class="new">+                       LOGFMT_SPCMGR_ARGS, METACHUNK_FORMAT_ARGS(c), requested_word_size);</span>
<span class="new">+</span>
<span class="new">+  return c;</span>
 
<span class="removed">-  assert(!SpaceManager::is_humongous(word_size) ||</span>
<span class="removed">-         chunk_word_size == if_humongous_sized_chunk,</span>
<span class="removed">-         "Size calculation is wrong, word_size " SIZE_FORMAT</span>
<span class="removed">-         " chunk_word_size " SIZE_FORMAT,</span>
<span class="removed">-         word_size, chunk_word_size);</span>
<span class="removed">-  Log(gc, metaspace, alloc) log;</span>
<span class="removed">-  if (log.is_trace() &amp;&amp; SpaceManager::is_humongous(word_size)) {</span>
<span class="removed">-    log.trace("Metadata humongous allocation:");</span>
<span class="removed">-    log.trace("  word_size " PTR_FORMAT, word_size);</span>
<span class="removed">-    log.trace("  chunk_word_size " PTR_FORMAT, chunk_word_size);</span>
<span class="removed">-    log.trace("    chunk overhead " PTR_FORMAT, Metachunk::overhead());</span>
<span class="removed">-  }</span>
<span class="removed">-  return chunk_word_size;</span>
 }
 
<span class="removed">-void SpaceManager::track_metaspace_memory_usage() {</span>
<span class="removed">-  if (is_init_completed()) {</span>
<span class="removed">-    if (is_class()) {</span>
<span class="removed">-      MemoryService::track_compressed_class_memory_usage();</span>
<span class="removed">-    }</span>
<span class="removed">-    MemoryService::track_metaspace_memory_usage();</span>
<span class="removed">-  }</span>
<span class="new">+void SpaceManager::add_allocation_to_fbl(MetaWord* p, size_t word_size) {</span>
<span class="new">+  assert(Settings::handle_deallocations(), "Sanity");</span>
<span class="new">+  if (_fbl == NULL) {</span>
<span class="new">+    _fbl = new FreeBlocks(); // Create only on demand</span>
<span class="new">+  }</span>
<span class="new">+  _fbl-&gt;add_block(p, word_size);</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+SpaceManager::SpaceManager(ChunkManager* chunk_manager,</span>
<span class="new">+             const ArenaGrowthPolicy* growth_policy,</span>
<span class="new">+             Mutex* lock,</span>
<span class="new">+             SizeAtomicCounter* total_used_words_counter,</span>
<span class="new">+             const char* name,</span>
<span class="new">+             bool is_micro_loader)</span>
<span class="new">+: _lock(lock),</span>
<span class="new">+  _chunk_manager(chunk_manager),</span>
<span class="new">+  _growth_policy(growth_policy),</span>
<span class="new">+  _chunks(),</span>
<span class="new">+  _fbl(NULL),</span>
<span class="new">+  _total_used_words_counter(total_used_words_counter),</span>
<span class="new">+  _name(name),</span>
<span class="new">+  _is_micro_loader(is_micro_loader)</span>
<span class="new">+{</span>
 }
 
<span class="removed">-MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {</span>
<span class="removed">-  assert_lock_strong(_lock);</span>
<span class="removed">-  assert(vs_list()-&gt;current_virtual_space() != NULL,</span>
<span class="removed">-         "Should have been set");</span>
<span class="removed">-  assert(current_chunk() == NULL ||</span>
<span class="removed">-         current_chunk()-&gt;allocate(word_size) == NULL,</span>
<span class="removed">-         "Don't need to expand");</span>
<span class="removed">-  MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="removed">-</span>
<span class="removed">-  if (log_is_enabled(Trace, gc, metaspace, freelist)) {</span>
<span class="removed">-    size_t words_left = 0;</span>
<span class="removed">-    size_t words_used = 0;</span>
<span class="removed">-    if (current_chunk() != NULL) {</span>
<span class="removed">-      words_left = current_chunk()-&gt;free_word_size();</span>
<span class="removed">-      words_used = current_chunk()-&gt;used_word_size();</span>
<span class="removed">-    }</span>
<span class="removed">-    log_trace(gc, metaspace, freelist)("SpaceManager::grow_and_allocate for " SIZE_FORMAT " words " SIZE_FORMAT " words used " SIZE_FORMAT " words left",</span>
<span class="removed">-                                       word_size, words_used, words_left);</span>
<span class="removed">-  }</span>
<span class="new">+SpaceManager::~SpaceManager() {</span>
 
<span class="removed">-  // Get another chunk</span>
<span class="removed">-  size_t chunk_word_size = calc_chunk_size(word_size);</span>
<span class="removed">-  Metachunk* next = get_new_chunk(chunk_word_size);</span>
<span class="new">+  DEBUG_ONLY(verify(true);)</span>
 
<span class="removed">-  MetaWord* mem = NULL;</span>
<span class="new">+  MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);</span>
 
<span class="removed">-  // If a chunk was available, add it to the in-use chunk list</span>
<span class="removed">-  // and do an allocation from it.</span>
<span class="removed">-  if (next != NULL) {</span>
<span class="removed">-    // Add to this manager's list of chunks in use.</span>
<span class="removed">-    // If the new chunk is humongous, it was created to serve a single large allocation. In that</span>
<span class="removed">-    // case it usually makes no sense to make it the current chunk, since the next allocation would</span>
<span class="removed">-    // need to allocate a new chunk anyway, while we would now prematurely retire a perfectly</span>
<span class="removed">-    // good chunk which could be used for more normal allocations.</span>
<span class="removed">-    bool make_current = true;</span>
<span class="removed">-    if (next-&gt;get_chunk_type() == HumongousIndex &amp;&amp;</span>
<span class="removed">-        current_chunk() != NULL) {</span>
<span class="removed">-      make_current = false;</span>
<span class="removed">-    }</span>
<span class="removed">-    add_chunk(next, make_current);</span>
<span class="removed">-    mem = next-&gt;allocate(word_size);</span>
<span class="removed">-  }</span>
<span class="new">+  size_t used_words_returned = 0;</span>
 
<span class="removed">-  // Track metaspace memory usage statistic.</span>
<span class="removed">-  track_metaspace_memory_usage();</span>
<span class="new">+  Metachunk* c = _chunks.first();</span>
<span class="new">+  Metachunk* c2 = NULL;</span>
 
<span class="removed">-  return mem;</span>
<span class="removed">-}</span>
<span class="new">+  while(c) {</span>
<span class="new">+    c2 = c-&gt;next();</span>
<span class="new">+    used_words_returned += c-&gt;used_words();</span>
<span class="new">+    DEBUG_ONLY(c-&gt;set_prev(NULL);)</span>
<span class="new">+    DEBUG_ONLY(c-&gt;set_next(NULL);)</span>
<span class="new">+    _chunk_manager-&gt;return_chunk(c);</span>
<span class="new">+    // c may be invalid after return_chunk(c) was called. Don't access anymore.</span>
<span class="new">+    c = c2;</span>
<span class="new">+  }</span>
 
<span class="removed">-void SpaceManager::print_on(outputStream* st) const {</span>
<span class="removed">-  SpaceManagerStatistics stat;</span>
<span class="removed">-  add_to_statistics(&amp;stat); // will lock _lock.</span>
<span class="removed">-  stat.print_on(st, 1*K, false);</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-SpaceManager::SpaceManager(Metaspace::MetadataType mdtype,</span>
<span class="removed">-                           Metaspace::MetaspaceType space_type,//</span>
<span class="removed">-                           Mutex* lock) :</span>
<span class="removed">-  _lock(lock),</span>
<span class="removed">-  _mdtype(mdtype),</span>
<span class="removed">-  _space_type(space_type),</span>
<span class="removed">-  _chunk_list(NULL),</span>
<span class="removed">-  _current_chunk(NULL),</span>
<span class="removed">-  _overhead_words(0),</span>
<span class="removed">-  _capacity_words(0),</span>
<span class="removed">-  _used_words(0),</span>
<span class="removed">-  _block_freelists(NULL) {</span>
<span class="removed">-  Metadebug::init_allocation_fail_alot_count();</span>
<span class="removed">-  memset(_num_chunks_by_type, 0, sizeof(_num_chunks_by_type));</span>
<span class="removed">-  log_trace(gc, metaspace, freelist)("SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-void SpaceManager::account_for_new_chunk(const Metachunk* new_chunk) {</span>
<span class="removed">-</span>
<span class="removed">-  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="removed">-</span>
<span class="removed">-  _capacity_words += new_chunk-&gt;word_size();</span>
<span class="removed">-  _overhead_words += Metachunk::overhead();</span>
<span class="removed">-  DEBUG_ONLY(new_chunk-&gt;verify());</span>
<span class="removed">-  _num_chunks_by_type[new_chunk-&gt;get_chunk_type()] ++;</span>
<span class="removed">-</span>
<span class="removed">-  // Adjust global counters:</span>
<span class="removed">-  MetaspaceUtils::inc_capacity(mdtype(), new_chunk-&gt;word_size());</span>
<span class="removed">-  MetaspaceUtils::inc_overhead(mdtype(), Metachunk::overhead());</span>
<span class="removed">-}</span>
<span class="removed">-</span>
<span class="removed">-void SpaceManager::account_for_allocation(size_t words) {</span>
<span class="removed">-  // Note: we should be locked with the ClassloaderData-specific metaspace lock.</span>
<span class="removed">-  // We may or may not be locked with the global metaspace expansion lock.</span>
<span class="removed">-  assert_lock_strong(lock());</span>
<span class="new">+  _total_used_words_counter-&gt;decrement_by(used_words_returned);</span>
<span class="new">+</span>
<span class="new">+  DEBUG_ONLY(chunk_manager()-&gt;verify(true);)</span>
 
<span class="removed">-  // Add to the per SpaceManager totals. This can be done non-atomically.</span>
<span class="removed">-  _used_words += words;</span>
<span class="new">+  delete _fbl;</span>
 
<span class="removed">-  // Adjust global counters. This will be done atomically.</span>
<span class="removed">-  MetaspaceUtils::inc_used(mdtype(), words);</span>
 }
 
<span class="removed">-void SpaceManager::account_for_spacemanager_death() {</span>
<span class="new">+// Attempt to enlarge the current chunk to make it large enough to hold at least</span>
<span class="new">+//  requested_word_size additional words.</span>
<span class="new">+//</span>
<span class="new">+// On success, true is returned, false otherwise.</span>
<span class="new">+bool SpaceManager::attempt_enlarge_current_chunk(size_t requested_word_size) {</span>
 
<span class="removed">-  assert_lock_strong(MetaspaceExpand_lock);</span>
<span class="new">+  Metachunk* c = current_chunk();</span>
<span class="new">+  assert(c-&gt;free_words() &lt; requested_word_size, "Sanity");</span>
 
<span class="removed">-  MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);</span>
<span class="removed">-  MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);</span>
<span class="removed">-  MetaspaceUtils::dec_used(mdtype(), _used_words);</span>
<span class="removed">-}</span>
<span class="new">+  // Not if chunk enlargment is switched off in general...</span>
<span class="new">+  if (Settings::enlarge_chunks_in_place() == false) {</span>
<span class="new">+    return false;</span>
<span class="new">+  }</span>
 
<span class="removed">-SpaceManager::~SpaceManager() {</span>
<span class="new">+  // Nor if the chunk is deemed to large to be thus expanded.</span>
<span class="new">+  //  (TODO : do we need this if we check the allowed chunk growth progression below? check)</span>
<span class="new">+  if (c-&gt;word_size() &lt;= Settings::enlarge_chunks_in_place_max_word_size()) {</span>
<span class="new">+    return false;</span>
<span class="new">+  }</span>
 
<span class="removed">-  // This call this-&gt;_lock which can't be done while holding MetaspaceExpand_lock</span>
<span class="removed">-  DEBUG_ONLY(verify_metrics());</span>
<span class="new">+  // Nor, obviously, if we are already a root chunk.</span>
<span class="new">+  if (c-&gt;is_root_chunk()) {</span>
<span class="new">+    return false;</span>
<span class="new">+  }</span>
 
<span class="removed">-  MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+  const chunklevel_t new_level =</span>
<span class="new">+      chunklevel::level_fitting_word_size(c-&gt;used_words() + requested_word_size);</span>
 
<span class="removed">-  account_for_spacemanager_death();</span>
<span class="new">+  // Atm we only attempt to enlarge by one level (so, doubling the chunk in size).</span>
<span class="new">+  // So, if the requested enlargement would require the chunk to more than double in size,</span>
<span class="new">+  // we bail. But this covers about 99% of all cases, so this is good enough.</span>
<span class="new">+  if (c-&gt;level() &gt; new_level + 1) {</span>
<span class="new">+    return false;</span>
<span class="new">+  }</span>
 
<span class="removed">-  Log(gc, metaspace, freelist) log;</span>
<span class="removed">-  if (log.is_trace()) {</span>
<span class="removed">-    log.trace("~SpaceManager(): " PTR_FORMAT, p2i(this));</span>
<span class="removed">-    ResourceMark rm;</span>
<span class="removed">-    LogStream ls(log.trace());</span>
<span class="removed">-    locked_print_chunks_in_use_on(&amp;ls);</span>
<span class="removed">-    if (block_freelists() != NULL) {</span>
<span class="removed">-      block_freelists()-&gt;print_on(&amp;ls);</span>
<span class="new">+  // This only works if chunk is the leader of its buddy pair (and also if buddy</span>
<span class="new">+  // is free and unsplit, but that we cannot check outside of metaspace lock).</span>
<span class="new">+  if (c-&gt;is_leader() == false) {</span>
<span class="new">+    return false;</span>
     }
<span class="new">+</span>
<span class="new">+  // If enlarging the chunk would increase the arena size faster than we are prepared</span>
<span class="new">+  // to grow, we don't enlarge the chunk.</span>
<span class="new">+  if (chunklevel::word_size_for_level(next_chunk_level()) &lt; c-&gt;word_size()) {</span>
<span class="new">+    return false;</span>
   }
 
<span class="removed">-  // Add all the chunks in use by this space manager</span>
<span class="removed">-  // to the global list of free chunks.</span>
<span class="new">+  bool success = _chunk_manager-&gt;attempt_enlarge_chunk(c);</span>
 
<span class="removed">-  // Follow each list of chunks-in-use and add them to the</span>
<span class="removed">-  // free lists.  Each list is NULL terminated.</span>
<span class="removed">-  chunk_manager()-&gt;return_chunk_list(chunk_list());</span>
<span class="removed">-#ifdef ASSERT</span>
<span class="removed">-  _chunk_list = NULL;</span>
<span class="removed">-  _current_chunk = NULL;</span>
<span class="removed">-#endif</span>
<span class="new">+  assert(success == false || c-&gt;free_words() &gt;= requested_word_size, "Sanity");</span>
 
<span class="removed">-#ifdef ASSERT</span>
<span class="removed">-  EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="removed">-    chunk_manager()-&gt;locked_verify(true);</span>
<span class="removed">-  END_EVERY_NTH</span>
<span class="removed">-#endif</span>
<span class="new">+  return success;</span>
 
<span class="removed">-  if (_block_freelists != NULL) {</span>
<span class="removed">-    delete _block_freelists;</span>
<span class="removed">-  }</span>
 }
 
<span class="removed">-void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="removed">-  assert_lock_strong(lock());</span>
<span class="removed">-  // Allocations and deallocations are in raw_word_size</span>
<span class="removed">-  size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="removed">-  // Lazily create a block_freelist</span>
<span class="removed">-  if (block_freelists() == NULL) {</span>
<span class="removed">-    _block_freelists = new BlockFreelist();</span>
<span class="removed">-  }</span>
<span class="removed">-  block_freelists()-&gt;return_block(p, raw_word_size);</span>
<span class="removed">-  DEBUG_ONLY(Atomic::inc(&amp;(g_internal_statistics.num_deallocs)));</span>
<span class="removed">-}</span>
<span class="new">+// Allocate memory from Metaspace.</span>
<span class="new">+// 1) Attempt to allocate from the free block list.</span>
<span class="new">+// 2) Attempt to allocate from the current chunk.</span>
<span class="new">+// 3) Attempt to enlarge the current chunk in place if it is too small.</span>
<span class="new">+// 4) Attempt to get a new chunk and allocate from that chunk.</span>
<span class="new">+// At any point, if we hit a commit limit, we return NULL.</span>
<span class="new">+MetaWord* SpaceManager::allocate(size_t requested_word_size) {</span>
 
<span class="removed">-// Adds a chunk to the list of chunks in use.</span>
<span class="removed">-void SpaceManager::add_chunk(Metachunk* new_chunk, bool make_current) {</span>
<span class="new">+  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
 
<span class="removed">-  assert_lock_strong(_lock);</span>
<span class="removed">-  assert(new_chunk != NULL, "Should not be NULL");</span>
<span class="removed">-  assert(new_chunk-&gt;next() == NULL, "Should not be on a list");</span>
<span class="new">+  log_debug(metaspace)(LOGFMT_SPCMGR ": requested " SIZE_FORMAT " words.",</span>
<span class="new">+                       LOGFMT_SPCMGR_ARGS, requested_word_size);</span>
 
<span class="removed">-  new_chunk-&gt;reset_empty();</span>
<span class="new">+  MetaWord* p = NULL;</span>
 
<span class="removed">-  // Find the correct list and and set the current</span>
<span class="removed">-  // chunk for that list.</span>
<span class="removed">-  ChunkIndex index = chunk_manager()-&gt;list_index(new_chunk-&gt;word_size());</span>
<span class="new">+  const size_t raw_word_size = get_raw_allocation_word_size(requested_word_size);</span>
 
<span class="removed">-  if (make_current) {</span>
<span class="removed">-    // If we are to make the chunk current, retire the old current chunk and replace</span>
<span class="removed">-    // it with the new chunk.</span>
<span class="removed">-    retire_current_chunk();</span>
<span class="removed">-    set_current_chunk(new_chunk);</span>
<span class="new">+  // 1) Attempt to allocate from the dictionary of deallocated blocks.</span>
<span class="new">+  if (Settings::handle_deallocations() &amp;&amp; _fbl != NULL &amp;&amp; !_fbl-&gt;is_empty()) {</span>
<span class="new">+    p = _fbl-&gt;get_block(raw_word_size);</span>
<span class="new">+    if (p != NULL) {</span>
<span class="new">+      DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)</span>
<span class="new">+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from free block list.", LOGFMT_SPCMGR_ARGS);</span>
<span class="new">+      // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -</span>
<span class="new">+      // that means that we do not modify any counters and therefore can skip the epilog.</span>
<span class="new">+      return p;</span>
<span class="new">+    }</span>
   }
 
<span class="removed">-  // Add the new chunk at the head of its respective chunk list.</span>
<span class="removed">-  new_chunk-&gt;set_next(_chunk_list);</span>
<span class="removed">-  _chunk_list = new_chunk;</span>
<span class="new">+  bool current_chunk_too_small = false;</span>
<span class="new">+  bool commit_failure = false;</span>
 
<span class="removed">-  // Adjust counters.</span>
<span class="removed">-  account_for_new_chunk(new_chunk);</span>
<span class="new">+  if (current_chunk() != NULL) {</span>
 
<span class="removed">-  assert(new_chunk-&gt;is_empty(), "Not ready for reuse");</span>
<span class="removed">-  Log(gc, metaspace, freelist) log;</span>
<span class="removed">-  if (log.is_trace()) {</span>
<span class="removed">-    log.trace("SpaceManager::added chunk: ");</span>
<span class="removed">-    ResourceMark rm;</span>
<span class="removed">-    LogStream ls(log.trace());</span>
<span class="removed">-    new_chunk-&gt;print_on(&amp;ls);</span>
<span class="removed">-    chunk_manager()-&gt;locked_print_free_chunks(&amp;ls);</span>
<span class="removed">-  }</span>
<span class="removed">-}</span>
<span class="new">+    // 2) Attempt to satisfy the allocation from the current chunk.</span>
 
<span class="removed">-void SpaceManager::retire_current_chunk() {</span>
<span class="removed">-  if (current_chunk() != NULL) {</span>
<span class="removed">-    size_t remaining_words = current_chunk()-&gt;free_word_size();</span>
<span class="removed">-    if (remaining_words &gt;= SmallBlocks::small_block_min_size()) {</span>
<span class="removed">-      MetaWord* ptr = current_chunk()-&gt;allocate(remaining_words);</span>
<span class="removed">-      deallocate(ptr, remaining_words);</span>
<span class="removed">-      account_for_allocation(remaining_words);</span>
<span class="new">+    // If the current chunk is too small to hold the requested size, attempt to enlarge it.</span>
<span class="new">+    // If that fails, retire the chunk.</span>
<span class="new">+    if (current_chunk()-&gt;free_words() &lt; raw_word_size) {</span>
<span class="new">+      if (!attempt_enlarge_current_chunk(raw_word_size)) {</span>
<span class="new">+        current_chunk_too_small = true;</span>
     }
   }
<span class="removed">-}</span>
 
<span class="removed">-Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {</span>
<span class="removed">-  // Get a chunk from the chunk freelist</span>
<span class="removed">-  Metachunk* next = chunk_manager()-&gt;chunk_freelist_allocate(chunk_word_size);</span>
<span class="new">+    // Commit the chunk far enough to hold the requested word size. If that fails, we</span>
<span class="new">+    // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the</span>
<span class="new">+    // chunk.</span>
<span class="new">+    if (!current_chunk_too_small) {</span>
<span class="new">+      if (!current_chunk()-&gt;ensure_committed_additional(raw_word_size)) {</span>
<span class="new">+        commit_failure = true;</span>
<span class="new">+      }</span>
<span class="new">+    }</span>
 
<span class="removed">-  if (next == NULL) {</span>
<span class="removed">-    next = vs_list()-&gt;get_new_chunk(chunk_word_size,</span>
<span class="removed">-                                    medium_chunk_bunch());</span>
<span class="new">+    // Allocate from the current chunk. This should work now.</span>
<span class="new">+    if (!current_chunk_too_small &amp;&amp; !commit_failure) {</span>
<span class="new">+      p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="new">+      assert(p != NULL, "Allocation from chunk failed.");</span>
<span class="new">+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from current chunk.", LOGFMT_SPCMGR_ARGS);</span>
   }
 
<span class="removed">-  Log(gc, metaspace, alloc) log;</span>
<span class="removed">-  if (log.is_trace() &amp;&amp; next != NULL &amp;&amp;</span>
<span class="removed">-      SpaceManager::is_humongous(next-&gt;word_size())) {</span>
<span class="removed">-    log.trace("  new humongous chunk word size " PTR_FORMAT, next-&gt;word_size());</span>
   }
 
<span class="removed">-  return next;</span>
<span class="removed">-}</span>
<span class="new">+  if (p == NULL) {</span>
 
<span class="removed">-MetaWord* SpaceManager::allocate(size_t word_size) {</span>
<span class="removed">-  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="removed">-  size_t raw_word_size = get_allocation_word_size(word_size);</span>
<span class="removed">-  BlockFreelist* fl =  block_freelists();</span>
<span class="removed">-  MetaWord* p = NULL;</span>
<span class="new">+    // If we are here, we either had no current chunk to begin with or it was deemed insufficient.</span>
<span class="new">+    assert(current_chunk() == NULL ||</span>
<span class="new">+           current_chunk_too_small || commit_failure, "Sanity");</span>
 
<span class="removed">-  // Allocation from the dictionary is expensive in the sense that</span>
<span class="removed">-  // the dictionary has to be searched for a size.  Don't allocate</span>
<span class="removed">-  // from the dictionary until it starts to get fat.  Is this</span>
<span class="removed">-  // a reasonable policy?  Maybe an skinny dictionary is fast enough</span>
<span class="removed">-  // for allocations.  Do some profiling.  JJJ</span>
<span class="removed">-  if (fl != NULL &amp;&amp; fl-&gt;total_size() &gt; allocation_from_dictionary_limit) {</span>
<span class="removed">-    p = fl-&gt;get_block(raw_word_size);</span>
<span class="removed">-    if (p != NULL) {</span>
<span class="removed">-      DEBUG_ONLY(Atomic::inc(&amp;g_internal_statistics.num_allocs_from_deallocated_blocks));</span>
<span class="new">+    Metachunk* new_chunk = allocate_new_chunk(raw_word_size);</span>
<span class="new">+</span>
<span class="new">+    if (new_chunk != NULL) {</span>
<span class="new">+</span>
<span class="new">+      assert(new_chunk-&gt;free_below_committed_words() &gt;= raw_word_size, "Sanity");</span>
<span class="new">+</span>
<span class="new">+      // We have a new chunk. Before making it the current chunk, retire the old one.</span>
<span class="new">+      if (current_chunk() != NULL) {</span>
<span class="new">+        salvage_chunk(current_chunk());</span>
<span class="new">+        DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)</span>
     }
<span class="new">+</span>
<span class="new">+      _chunks.add(new_chunk);</span>
<span class="new">+</span>
<span class="new">+      // Now, allocate from that chunk. That should work.</span>
<span class="new">+      p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="new">+      assert(p != NULL, "Allocation from chunk failed.");</span>
<span class="new">+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. allocated new chunk " CHKLVL_FORMAT " and taken from that.",</span>
<span class="new">+                           LOGFMT_SPCMGR_ARGS, current_chunk()-&gt;level());</span>
   }
<span class="removed">-  if (p == NULL) {</span>
<span class="removed">-    p = allocate_work(raw_word_size);</span>
<span class="new">+</span>
   }
 
 #ifdef ASSERT
<span class="removed">-  EVERY_NTH(VerifyMetaspaceInterval)</span>
<span class="removed">-    verify_metrics_locked();</span>
<span class="removed">-  END_EVERY_NTH</span>
<span class="new">+  // When using allocation guards, establish a prefix.</span>
<span class="new">+  if (p != NULL &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="new">+    p = establish_prefix(p, raw_word_size);</span>
<span class="new">+  }</span>
 #endif
 
<span class="new">+  if (p == NULL) {</span>
<span class="new">+    DEBUG_ONLY(InternalStats::inc_num_allocs_failed_limit();)</span>
<span class="new">+  } else {</span>
<span class="new">+    DEBUG_ONLY(InternalStats::inc_num_allocs();)</span>
<span class="new">+    _total_used_words_counter-&gt;increment_by(raw_word_size);</span>
<span class="new">+  }</span>
<span class="new">+</span>
<span class="new">+  SOMETIMES(verify_locked(true);)</span>
<span class="new">+</span>
<span class="new">+  log_trace(metaspace)(LOGFMT_SPCMGR ": returned " PTR_FORMAT ".",</span>
<span class="new">+                       LOGFMT_SPCMGR_ARGS, p2i(p));</span>
<span class="new">+</span>
   return p;
<span class="new">+</span>
 }
 
<span class="removed">-// Returns the address of spaced allocated for "word_size".</span>
<span class="removed">-// This methods does not know about blocks (Metablocks)</span>
<span class="removed">-MetaWord* SpaceManager::allocate_work(size_t word_size) {</span>
<span class="removed">-  assert_lock_strong(lock());</span>
<span class="removed">-#ifdef ASSERT</span>
<span class="removed">-  if (Metadebug::test_metadata_failure()) {</span>
<span class="removed">-    return NULL;</span>
<span class="removed">-  }</span>
<span class="removed">-#endif</span>
<span class="removed">-  // Is there space in the current chunk?</span>
<span class="removed">-  MetaWord* result = NULL;</span>
<span class="new">+// Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="new">+// because it is not needed anymore (requires CLD lock to be active).</span>
<span class="new">+void SpaceManager::deallocate_locked(MetaWord* p, size_t word_size) {</span>
 
<span class="removed">-  if (current_chunk() != NULL) {</span>
<span class="removed">-    result = current_chunk()-&gt;allocate(word_size);</span>
<span class="new">+  if (Settings::handle_deallocations() == false) {</span>
<span class="new">+    return;</span>
   }
 
<span class="removed">-  if (result == NULL) {</span>
<span class="removed">-    result = grow_and_allocate(word_size);</span>
<span class="removed">-  }</span>
<span class="new">+  assert_lock_strong(lock());</span>
 
<span class="removed">-  if (result != NULL) {</span>
<span class="removed">-    account_for_allocation(word_size);</span>
<span class="removed">-  }</span>
<span class="new">+  // At this point a current chunk must exist since we only deallocate if we did allocate before.</span>
<span class="new">+  assert(current_chunk() != NULL, "stray deallocation?");</span>
 
<span class="removed">-  return result;</span>
<span class="removed">-}</span>
<span class="new">+  assert(is_valid_area(p, word_size),</span>
<span class="new">+         "Pointer range not part of this SpaceManager and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",</span>
<span class="new">+         p2i(p), p2i(p + word_size));</span>
<span class="new">+</span>
<span class="new">+  log_debug(metaspace)(LOGFMT_SPCMGR ": deallocating " PTR_FORMAT</span>
<span class="new">+                       ", word size: " SIZE_FORMAT ".",</span>
<span class="new">+                       LOGFMT_SPCMGR_ARGS, p2i(p), word_size);</span>
<span class="new">+</span>
<span class="new">+  size_t raw_word_size = get_raw_allocation_word_size(word_size);</span>
<span class="new">+  add_allocation_to_fbl(p, raw_word_size);</span>
<span class="new">+</span>
<span class="new">+  DEBUG_ONLY(verify_locked(false);)</span>
 
<span class="removed">-void SpaceManager::verify() {</span>
<span class="removed">-  Metachunk* curr = chunk_list();</span>
<span class="removed">-  while (curr != NULL) {</span>
<span class="removed">-    DEBUG_ONLY(do_verify_chunk(curr);)</span>
<span class="removed">-    assert(curr-&gt;is_tagged_free() == false, "Chunk should be tagged as in use.");</span>
<span class="removed">-    curr = curr-&gt;next();</span>
<span class="removed">-  }</span>
 }
 
<span class="removed">-void SpaceManager::verify_chunk_size(Metachunk* chunk) {</span>
<span class="removed">-  assert(is_humongous(chunk-&gt;word_size()) ||</span>
<span class="removed">-         chunk-&gt;word_size() == medium_chunk_size() ||</span>
<span class="removed">-         chunk-&gt;word_size() == small_chunk_size() ||</span>
<span class="removed">-         chunk-&gt;word_size() == specialized_chunk_size(),</span>
<span class="removed">-         "Chunk size is wrong");</span>
<span class="removed">-  return;</span>
<span class="new">+// Prematurely returns a metaspace allocation to the _block_freelists because it is not</span>
<span class="new">+// needed anymore.</span>
<span class="new">+void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="new">+  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="new">+  deallocate_locked(p, word_size);</span>
 }
 
<span class="removed">-void SpaceManager::add_to_statistics_locked(SpaceManagerStatistics* out) const {</span>
<span class="removed">-  assert_lock_strong(lock());</span>
<span class="removed">-  Metachunk* chunk = chunk_list();</span>
<span class="removed">-  while (chunk != NULL) {</span>
<span class="removed">-    UsedChunksStatistics&amp; chunk_stat = out-&gt;chunk_stats(chunk-&gt;get_chunk_type());</span>
<span class="removed">-    chunk_stat.add_num(1);</span>
<span class="removed">-    chunk_stat.add_cap(chunk-&gt;word_size());</span>
<span class="removed">-    chunk_stat.add_overhead(Metachunk::overhead());</span>
<span class="removed">-    chunk_stat.add_used(chunk-&gt;used_word_size() - Metachunk::overhead());</span>
<span class="removed">-    if (chunk != current_chunk()) {</span>
<span class="removed">-      chunk_stat.add_waste(chunk-&gt;free_word_size());</span>
<span class="new">+// Update statistics. This walks all in-use chunks.</span>
<span class="new">+void SpaceManager::add_to_statistics(sm_stats_t* out) const {</span>
<span class="new">+</span>
<span class="new">+  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="new">+</span>
<span class="new">+  for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="new">+    in_use_chunk_stats_t&amp; ucs = out-&gt;stats[c-&gt;level()];</span>
<span class="new">+    ucs.num ++;</span>
<span class="new">+    ucs.word_size += c-&gt;word_size();</span>
<span class="new">+    ucs.committed_words += c-&gt;committed_words();</span>
<span class="new">+    ucs.used_words += c-&gt;used_words();</span>
<span class="new">+    // Note: for free and waste, we only count what's committed.</span>
<span class="new">+    if (c == current_chunk()) {</span>
<span class="new">+      ucs.free_words += c-&gt;free_below_committed_words();</span>
     } else {
<span class="removed">-      chunk_stat.add_free(chunk-&gt;free_word_size());</span>
<span class="new">+      ucs.waste_words += c-&gt;free_below_committed_words();</span>
     }
<span class="removed">-    chunk = chunk-&gt;next();</span>
   }
<span class="removed">-  if (block_freelists() != NULL) {</span>
<span class="removed">-    out-&gt;add_free_blocks_info(block_freelists()-&gt;num_blocks(), block_freelists()-&gt;total_size());</span>
<span class="new">+</span>
<span class="new">+  if (_fbl != NULL) {</span>
<span class="new">+    out-&gt;free_blocks_num += _fbl-&gt;count();</span>
<span class="new">+    out-&gt;free_blocks_word_size += _fbl-&gt;total_size();</span>
   }
<span class="removed">-}</span>
 
<span class="removed">-void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {</span>
<span class="removed">-  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="removed">-  add_to_statistics_locked(out);</span>
<span class="new">+  SOMETIMES(out-&gt;verify();)</span>
<span class="new">+</span>
 }
 
 #ifdef ASSERT
<span class="removed">-void SpaceManager::verify_metrics_locked() const {</span>
<span class="new">+</span>
<span class="new">+void SpaceManager::verify_locked(bool slow) const {</span>
<span class="new">+</span>
   assert_lock_strong(lock());
 
<span class="removed">-  SpaceManagerStatistics stat;</span>
<span class="removed">-  add_to_statistics_locked(&amp;stat);</span>
<span class="new">+  assert(_growth_policy != NULL &amp;&amp; _chunk_manager != NULL, "Sanity");</span>
 
<span class="removed">-  UsedChunksStatistics chunk_stats = stat.totals();</span>
<span class="new">+  _chunks.verify();</span>
<span class="new">+</span>
<span class="new">+  if (_fbl != NULL) {</span>
<span class="new">+    _fbl-&gt;verify();</span>
<span class="new">+  }</span>
 
<span class="removed">-  DEBUG_ONLY(chunk_stats.check_sanity());</span>
<span class="new">+  // In slow mode, verify guard zones of all allocations</span>
<span class="new">+  if (slow &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="new">+    for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="new">+      const MetaWord* p = c-&gt;base();</span>
<span class="new">+      while (p &lt; c-&gt;top()) {</span>
<span class="new">+        const prefix_t* pp = (const prefix_t*)p;</span>
<span class="new">+        check_prefix(pp);</span>
<span class="new">+        p += pp-&gt;word_size;</span>
<span class="new">+      }</span>
<span class="new">+    }</span>
<span class="new">+  }</span>
 
<span class="removed">-  assert_counter(_capacity_words, chunk_stats.cap(), "SpaceManager::_capacity_words");</span>
<span class="removed">-  assert_counter(_used_words, chunk_stats.used(), "SpaceManager::_used_words");</span>
<span class="removed">-  assert_counter(_overhead_words, chunk_stats.overhead(), "SpaceManager::_overhead_words");</span>
 }
 
<span class="removed">-void SpaceManager::verify_metrics() const {</span>
<span class="new">+void SpaceManager::verify(bool slow) const {</span>
<span class="new">+</span>
   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<span class="removed">-  verify_metrics_locked();</span>
<span class="new">+  verify_locked(slow);</span>
<span class="new">+</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+// Returns true if the area indicated by pointer and size have actually been allocated</span>
<span class="new">+// from this space manager.</span>
<span class="new">+bool SpaceManager::is_valid_area(MetaWord* p, size_t word_size) const {</span>
<span class="new">+  assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");</span>
<span class="new">+  bool found = false;</span>
<span class="new">+  if (!found) {</span>
<span class="new">+    for (const Metachunk* c = _chunks.first(); c != NULL &amp;&amp; !found; c = c-&gt;next()) {</span>
<span class="new">+      assert(c-&gt;is_valid_committed_pointer(p) ==</span>
<span class="new">+             c-&gt;is_valid_committed_pointer(p + word_size - 1), "range intersects");</span>
<span class="new">+      found = c-&gt;is_valid_committed_pointer(p);</span>
<span class="new">+    }</span>
<span class="new">+  }</span>
<span class="new">+  return found;</span>
 }
<span class="new">+</span>
 #endif // ASSERT
 
<span class="new">+void SpaceManager::print_on(outputStream* st) const {</span>
<span class="new">+  MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new">+  print_on_locked(st);</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+void SpaceManager::print_on_locked(outputStream* st) const {</span>
<span class="new">+  assert_lock_strong(_lock);</span>
<span class="new">+  st-&gt;print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="new">+               _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());</span>
<span class="new">+  _chunks.print_on(st);</span>
<span class="new">+  st-&gt;cr();</span>
<span class="new">+  st-&gt;print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,</span>
<span class="new">+                _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));</span>
<span class="new">+}</span>
<span class="new">+</span>
<span class="new">+</span>
 
 } // namespace metaspace
 
</pre>
<center><a href='../../../../../src/hotspot/share/memory/metaspace/printMetaspaceInfoKlassClosure.hpp.udiff.html' target='_top'>&lt prev</a> <a href='../../../../../index.html' target='_top'>index</a> <a href='../../../../../src/hotspot/share/memory/metaspace/spaceManager.hpp.udiff.html' target='_top'>next &gt</a></center>
</body></html>

