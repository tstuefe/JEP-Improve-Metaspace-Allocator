<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/blocktree.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "memory/metaspace/blocktree.hpp"
  28 #include "utilities/debug.hpp"
  29 #include "utilities/globalDefinitions.hpp"
  30 #include "utilities/ostream.hpp"
  31 
  32 namespace metaspace {
  33 
  34 
  35 #ifdef ASSERT
  36 
  37 // Tree verification
  38 
  39 // These asserts prints the tree, then asserts
  40 #define assrt(cond, format, ...) \
  41   if (!(cond)) { \
  42     print_tree(tty); \
  43     assert(cond, format, __VA_ARGS__); \
  44   }
  45 
  46   // This assert prints the tree, then stops (generic message)
  47 #define assrt0(cond) \
  48           if (!(cond)) { \
  49             print_tree(tty); \
  50             assert(cond, "sanity"); \
  51           }
  52 
  53 struct BlockTree::veri_data_t {
  54   MemRangeCounter counter;
  55   int max_edge;
  56   size_t largest;
  57 };
  58 
  59 // Given a node, check that all siblings have the same size and that we have no
  60 // (direct) circularities.
  61 void BlockTree::verify_node_siblings(node_t* n, veri_data_t* vd) const {
  62   const size_t size = n-&gt;size;
  63   node_t* n2 = n-&gt;next;
  64   node_t* prev_sib = NULL;
  65   while (n2 != NULL) {
  66     assrt0(n2-&gt;size == size);
  67     vd-&gt;counter.add(n2-&gt;size);
  68     if (prev_sib != NULL) {
  69       assrt0(prev_sib-&gt;next == n2);
  70       assrt0(prev_sib != n2);
  71     }
  72     prev_sib = n2;
  73     n2 = n2-&gt;next;
  74   }
  75 }
  76 
  77 // Given a node and outer bounds applying to it and all children, check it and all children recursively.
  78 void BlockTree::verify_node(node_t* n, size_t left_limit, size_t right_limit,
  79     veri_data_t* vd, int lvl) const {
  80 
  81   if (lvl &gt; vd-&gt;max_edge) {
  82     vd-&gt;max_edge = lvl;
  83   }
  84 
  85   if (n-&gt;size &gt; vd-&gt;largest) {
  86     vd-&gt;largest = n-&gt;size;
  87   }
  88 
  89   assrt0((n == _root &amp;&amp; n-&gt;parent == NULL) || (n != _root &amp;&amp; n-&gt;parent != NULL));
  90 
  91   // check all siblings
  92   if (n-&gt;next != NULL) {
  93     verify_node_siblings(n, vd);
  94   }
  95 
  96   // check order
  97   assrt(n-&gt;size &gt;= minimal_word_size &amp;&amp; n-&gt;size &lt;= maximal_word_size,
  98       "bad node size " SIZE_FORMAT, n-&gt;size);
  99   assrt0(n-&gt;size &lt; right_limit);
 100   assrt0(n-&gt;size &gt; left_limit);
 101 
 102   vd-&gt;counter.add(n-&gt;size);
 103 
 104   if (n-&gt;left != NULL) {
 105     assrt0(n != n-&gt;left);
 106     assrt0(n-&gt;left-&gt;parent == n);
 107     assrt0(n-&gt;left-&gt;size &lt; n-&gt;size);
 108     assrt0(n-&gt;left-&gt;size &gt; left_limit);
 109     verify_node(n-&gt;left, left_limit, n-&gt;size, vd, lvl + 1);
 110   }
 111 
 112   if (n-&gt;right != NULL) {
 113     assrt0(n != n-&gt;right);
 114     assrt0(n-&gt;right-&gt;parent == n);
 115     assrt0(n-&gt;right-&gt;size &lt; right_limit);
 116     assrt0(n-&gt;right-&gt;size &gt; n-&gt;size);
 117     verify_node(n-&gt;right, n-&gt;size, right_limit, vd, lvl + 1);
 118   }
 119 
 120 }
 121 
 122 void BlockTree::verify_tree() const {
 123   int num = 0;
 124   size_t size = 0;
 125   veri_data_t vd;
 126   vd.max_edge = 0;
 127   vd.largest = 0;
 128   if (_root != NULL) {
 129     assrt0(_root-&gt;parent == NULL);
 130     verify_node(_root, 0, maximal_word_size + 1, &amp;vd, 0);
 131     assrt0(vd.largest == _largest_size_added);
 132     vd.counter.check(_counter);
 133     assrt0(vd.counter.count() &gt; 0);
 134   }
 135 }
 136 
 137 void BlockTree::zap_range(MetaWord* p, size_t word_size) {
 138   memset(p, 0xF3, word_size * sizeof(MetaWord));
 139 }
 140 
 141 #undef assrt
 142 #undef assrt0
 143 
 144 #endif // ASSERT
 145 
 146 
 147 void BlockTree::print_node(outputStream* st, node_t* n, int lvl) {
 148   for (int i = 0; i &lt; lvl; i ++) {
 149     st-&gt;print("---");
 150   }
 151   st-&gt;print_cr("&lt;" PTR_FORMAT " (size " SIZE_FORMAT ")", p2i(n), n-&gt;size);
 152   if (n-&gt;left) {
 153     print_node(st, n-&gt;left, lvl + 1);
 154   }
 155   if (n-&gt;right) {
 156     print_node(st, n-&gt;right, lvl + 1);
 157   }
 158 }
 159 
 160 void BlockTree::print_tree(outputStream* st) const {
 161   if (_root != NULL) {
 162     print_node(st, _root, 0);
 163   } else {
 164     st-&gt;print_cr("&lt;no nodes&gt;");
 165   }
 166 }
 167 
 168 } // namespace metaspace
</pre></body></html>
