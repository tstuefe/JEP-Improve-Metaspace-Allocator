<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/chunkManager.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019, SAP SE. All rights reserved.
   3  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 
  28 
  29 #include "logging/log.hpp"
  30 #include "logging/logStream.hpp"
  31 #include "memory/metaspace/arenaGrowthPolicy.hpp"
  32 #include "memory/metaspace/chunkLevel.hpp"
  33 #include "memory/metaspace/chunkManager.hpp"
  34 #include "memory/metaspace/internStat.hpp"
  35 #include "memory/metaspace/metachunk.hpp"
  36 #include "memory/metaspace/metaspaceCommon.hpp"
  37 #include "memory/metaspace/metaspaceStatistics.hpp"
  38 #include "memory/metaspace/settings.hpp"
  39 #include "memory/metaspace/virtualSpaceNode.hpp"
  40 #include "memory/metaspace/virtualSpaceList.hpp"
  41 #include "runtime/mutexLocker.hpp"
  42 #include "utilities/debug.hpp"
  43 #include "utilities/globalDefinitions.hpp"
  44 
  45 namespace metaspace {
  46 
  47 
  48 // Return a single chunk to the freelist and adjust accounting. No merge is attempted.
  49 void ChunkManager::return_chunk_simple(Metachunk* c) {
  50 
  51   assert_lock_strong(MetaspaceExpand_lock);
  52 
  53   DEBUG_ONLY(c-&gt;verify(false));
  54 
  55   const chunklevel_t lvl = c-&gt;level();
  56   _chunks.add(c);
  57   c-&gt;reset_used_words();
  58 
  59   // Tracing
  60   log_debug(metaspace)("ChunkManager %s: returned chunk " METACHUNK_FORMAT ".",
  61                        _name, METACHUNK_FORMAT_ARGS(c));
  62 
  63 }
  64 
  65 // Take a single chunk from the given freelist and adjust counters. Returns NULL
  66 // if there is no fitting chunk for this level.
  67 Metachunk* ChunkManager::remove_first_chunk_at_level(chunklevel_t l) {
  68 
  69   assert_lock_strong(MetaspaceExpand_lock);
  70   DEBUG_ONLY(chunklevel::check_valid_level(l);)
  71 
  72   Metachunk* c = _chunks.remove_first(l);
  73 
  74   // Tracing
  75   if (c != NULL) {
  76     log_debug(metaspace)("ChunkManager %s: removed chunk " METACHUNK_FORMAT ".",
  77                          _name, METACHUNK_FORMAT_ARGS(c));
  78   } else {
  79     log_trace(metaspace)("ChunkManager %s: no chunk found for level " CHKLVL_FORMAT,
  80                          _name, l);
  81   }
  82 
  83   return c;
  84 }
  85 
  86 // Creates a chunk manager with a given name (which is for debug purposes only)
  87 // and an associated space list which will be used to request new chunks from
  88 // (see get_chunk())
  89 ChunkManager::ChunkManager(const char* name, VirtualSpaceList* space_list)
  90   : _vslist(space_list),
  91     _name(name),
  92     _chunks()
  93 {
  94 }
  95 
  96 // Given a chunk we are about to handout to the caller, make sure it is committed
  97 // according to constants::committed_words_on_fresh_chunks
  98 bool ChunkManager::commit_chunk_before_handout(Metachunk* c) {
  99   assert_lock_strong(MetaspaceExpand_lock);
 100   const size_t must_be_committed = MIN2(c-&gt;word_size(), Settings::committed_words_on_fresh_chunks());
 101   return c-&gt;ensure_committed_locked(must_be_committed);
 102 }
 103 
 104 // Given a chunk, split it into a target chunk of a smaller size (higher target level)
 105 //  and at least one, possible several splinter chunks.
 106 // The original chunk must be outside of the freelist and its state must be free.
 107 // The splinter chunks are added to the freelist.
 108 // The resulting target chunk will be located at the same address as the original
 109 //  chunk, but it will of course be smaller (of a higher level).
 110 // The committed areas within the original chunk carry over to the resulting
 111 //  chunks.
 112 void ChunkManager::split_chunk_and_add_splinters(Metachunk* c, chunklevel_t target_level) {
 113 
 114   assert_lock_strong(MetaspaceExpand_lock);
 115 
 116   assert(c-&gt;is_free(), "chunk to be split must be free.");
 117   assert(c-&gt;level() &lt; target_level, "Target level must be higher than current level.");
 118   assert(c-&gt;prev() == NULL &amp;&amp; c-&gt;next() == NULL, "Chunk must be outside of any list.");
 119 
 120   DEBUG_ONLY(chunklevel::check_valid_level(target_level);)
 121   DEBUG_ONLY(c-&gt;verify(true);)
 122 
 123   log_debug(metaspace)("ChunkManager %s: will split chunk " METACHUNK_FORMAT " to " CHKLVL_FORMAT ".",
 124                        _name, METACHUNK_FORMAT_ARGS(c), target_level);
 125 
 126   DEBUG_ONLY(size_t committed_words_before = c-&gt;committed_words();)
 127 
 128   const chunklevel_t orig_level = c-&gt;level();
 129   c-&gt;vsnode()-&gt;split(target_level, c, &amp;_chunks);
 130 
 131   // Splitting should never fail.
 132   assert(c-&gt;level() == target_level, "Sanity");
 133 
 134   // The size of the committed portion should not change (subject to the reduced chunk size of course)
 135 #ifdef ASSERT
 136   if (committed_words_before &gt; c-&gt;word_size()) {
 137     assert(c-&gt;is_fully_committed(), "Sanity");
 138   } else {
 139     assert(c-&gt;committed_words() == committed_words_before, "Sanity");
 140   }
 141 #endif
 142 
 143   DEBUG_ONLY(c-&gt;verify(false));
 144 
 145   DEBUG_ONLY(verify_locked(true);)
 146 
 147   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 148 
 149 }
 150 
 151 // On success, returns a chunk of level of &lt;preferred_level&gt;, but at most &lt;max_level&gt;.
 152 //  The first first &lt;min_committed_words&gt; of the chunk are guaranteed to be committed.
 153 // On error, will return NULL.
 154 //
 155 // This function may fail for two reasons:
 156 // - Either we are unable to reserve space for a new chunk (if the underlying VirtualSpaceList
 157 //   is non-expandable but needs expanding - aka out of compressed class space).
 158 // - Or, if the necessary space cannot be committed because we hit a commit limit.
 159 //   This may be either the GC threshold or MaxMetaspaceSize.
 160 Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {
 161 
 162   assert(preferred_level &lt;= max_level, "Sanity");
 163   assert(chunklevel::level_fitting_word_size(min_committed_words) &gt;= max_level, "Sanity");
 164 
 165   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 166 
 167   DEBUG_ONLY(verify_locked(false);)
 168 
 169   DEBUG_ONLY(chunklevel::check_valid_level(max_level);)
 170   DEBUG_ONLY(chunklevel::check_valid_level(preferred_level);)
 171   assert(max_level &gt;= preferred_level, "invalid level.");
 172 
 173   // First, optimistically look for a chunk which is already committed far enough to hold min_word_size.
 174 
 175   // Start at the preferred chunk size (level) and work your way down (up) to the minimum chunk size (level)
 176   Metachunk* c = NULL;
 177   c = _chunks.search_chunk_ascending(preferred_level, max_level, min_committed_words);
 178 
 179   // If that did not yield anything, look at larger chunks, which may be committed. We would have to split
 180   //  them first, of course.
 181   if (c == NULL) {
 182     c = _chunks.search_chunk_descending(preferred_level, min_committed_words);
 183   }
 184 
 185   // If that did not work, is there at least an uncommitted chunk? Repeat above search without the
 186   //  restriction of looking for committed space. We will have to commit the chunk then.
 187   if (c == NULL) {
 188     c = _chunks.search_chunk_ascending(preferred_level, max_level, 0);
 189   }
 190 
 191   if (c == NULL) {
 192     c = _chunks.search_chunk_descending(preferred_level, 0);
 193   }
 194 
 195   // Failing all that, allocate a new root chunk from the connected virtual space.
 196   // This may fail if the underlying vslist cannot be expanded (e.g. compressed class space)
 197   if (c == NULL) {
 198     c = _vslist-&gt;allocate_root_chunk();
 199     if (c == NULL) {
 200       log_debug(metaspace)("ChunkManager %s: failed to get new root chunk.", _name);
 201     } else {
 202       assert(c-&gt;level() == chunklevel::ROOT_CHUNK_LEVEL, "root chunk expected");
 203       log_debug(metaspace)("ChunkManager %s: allocated new root chunk.", _name);
 204     }
 205   }
 206 
 207   if (c == NULL) {
 208     log_debug(metaspace)("ChunkManager %s: failed to get chunk (preferred level: " CHKLVL_FORMAT
 209                          ", max level " CHKLVL_FORMAT ".", _name, preferred_level, max_level);
 210     return NULL;
 211   }
 212 
 213   // Now we have a chunk. It may be too large for the callers needs. It also may not be committed enough.
 214   // So we may have to split it, and commit its starting granules.
 215   //
 216   // Note that we, as step 1, commit the chunk. Committing may fail and by doing the committing before
 217   // the split we can easily add the still unsplit chunk back to the freelist without having to re-merge.
 218   //
 219   // As step 2 we split the chunk. Splitting preserves the committed regions underlying the chunk, and
 220   // since the target chunk is the first in the original chunk area, the target chunk will be committed
 221   // enough.
 222 
 223   const size_t need_to_commit = MAX2(Settings::committed_words_on_fresh_chunks(), min_committed_words);
 224   if (c-&gt;committed_words() &lt; need_to_commit) {
 225     if (c-&gt;ensure_committed_locked(need_to_commit) == false) {
 226       log_debug(metaspace)("ChunkManager %s: failed to commit " SIZE_FORMAT " words on chunk " METACHUNK_FORMAT ".",
 227                            _name, need_to_commit,  METACHUNK_FORMAT_ARGS(c));
 228       _chunks.add(c);
 229       return NULL;
 230     }
 231   }
 232 
 233   // If too large, split chunk and add the splinter chunks back to the freelist.
 234   if (c-&gt;level() &lt; preferred_level) {
 235     split_chunk_and_add_splinters(c, preferred_level);
 236     assert(c-&gt;level() == preferred_level, "split failed?");
 237   }
 238 
 239   // Any chunk returned from ChunkManager shall be marked as in use.
 240   c-&gt;set_in_use();
 241 
 242   DEBUG_ONLY(verify_locked(false);)
 243   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 244 
 245   log_debug(metaspace)("ChunkManager %s: handing out chunk " METACHUNK_FORMAT ".",
 246                        _name, METACHUNK_FORMAT_ARGS(c));
 247 
 248   DEBUG_ONLY(InternalStats::inc_num_chunks_taken_from_freelist();)
 249 
 250   return c;
 251 
 252 }
 253 
 254 // Return a single chunk to the ChunkManager and adjust accounting. May merge chunk
 255 //  with neighbors.
 256 // As a side effect this removes the chunk from whatever list it has been in previously.
 257 // Happens after a Classloader was unloaded and releases its metaspace chunks.
 258 // !! Note: this may invalidate the chunk. Do not access the chunk after
 259 //    this function returns !!
 260 void ChunkManager::return_chunk(Metachunk* c) {
 261 
 262   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 263 
 264   log_debug(metaspace)("ChunkManager %s: returning chunk " METACHUNK_FORMAT ".",
 265                        _name, METACHUNK_FORMAT_ARGS(c));
 266 
 267   DEBUG_ONLY(c-&gt;verify(true);)
 268 
 269   assert(contains_chunk(c) == false, "A chunk to be added to the freelist must not be in the freelist already.");
 270 
 271   assert(c-&gt;is_in_use(), "Unexpected chunk state");
 272   assert(!c-&gt;in_list(), "Remove from list first");
 273   c-&gt;set_free();
 274   c-&gt;reset_used_words();
 275 
 276   const chunklevel_t orig_lvl = c-&gt;level();
 277 
 278   Metachunk* merged = NULL;
 279   if (!c-&gt;is_root_chunk()) {
 280     // Only attempt merging if we are not of the lowest level already.
 281     merged = c-&gt;vsnode()-&gt;merge(c, &amp;_chunks);
 282   }
 283 
 284   if (merged != NULL) {
 285 
 286     DEBUG_ONLY(merged-&gt;verify(false));
 287 
 288     // We did merge our chunk into a different chunk.
 289 
 290     // We did merge chunks and now have a bigger chunk.
 291     assert(merged-&gt;level() &lt; orig_lvl, "Sanity");
 292 
 293     log_trace(metaspace)("ChunkManager %s: merged into chunk " METACHUNK_FORMAT ".",
 294                          _name, METACHUNK_FORMAT_ARGS(merged));
 295 
 296     c = merged;
 297 
 298   }
 299 
 300   if (Settings::uncommit_on_return() &amp;&amp;
 301       Settings::uncommit_on_return_min_word_size() &lt;= c-&gt;word_size())
 302   {
 303     log_trace(metaspace)("ChunkManager %s: uncommitting free chunk " METACHUNK_FORMAT ".",
 304                          _name, METACHUNK_FORMAT_ARGS(c));
 305     c-&gt;uncommit_locked();
 306   }
 307 
 308   return_chunk_simple(c);
 309 
 310   DEBUG_ONLY(verify_locked(false);)
 311   SOMETIMES(c-&gt;vsnode()-&gt;verify(true);)
 312 
 313   DEBUG_ONLY(InternalStats::inc_num_chunks_returned_to_freelist();)
 314 
 315 }
 316 
 317 // Given a chunk c, whose state must be "in-use" and must not be a root chunk, attempt to
 318 // enlarge it in place by claiming its trailing buddy.
 319 //
 320 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 321 //
 322 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 323 // double in size (level decreased by one).
 324 //
 325 // On success, true is returned, false otherwise.
 326 bool ChunkManager::attempt_enlarge_chunk(Metachunk* c) {
 327   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 328   return c-&gt;vsnode()-&gt;attempt_enlarge_chunk(c, &amp;_chunks);
 329 }
 330 
 331 static void print_word_size_delta(outputStream* st, size_t word_size_1, size_t word_size_2) {
 332   if (word_size_1 == word_size_2) {
 333     print_scaled_words(st, word_size_1);
 334     st-&gt;print (" (no change)");
 335   } else {
 336     print_scaled_words(st, word_size_1);
 337     st-&gt;print("-&gt;");
 338     print_scaled_words(st, word_size_2);
 339     st-&gt;print(" (");
 340     if (word_size_2 &lt;= word_size_1) {
 341       st-&gt;print("-");
 342       print_scaled_words(st, word_size_1 - word_size_2);
 343     } else {
 344       st-&gt;print("+");
 345       print_scaled_words(st, word_size_2 - word_size_1);
 346     }
 347     st-&gt;print(")");
 348   }
 349 }
 350 
 351 // Attempt to reclaim free areas in metaspace wholesale:
 352 // - first, attempt to purge nodes of the backing virtual space. This can only be successful
 353 //   if whole nodes are only containing free chunks, so it highly depends on fragmentation.
 354 // - then, it will uncommit areas of free chunks according to the rules laid down in
 355 //   settings (see settings.hpp).
 356 void ChunkManager::wholesale_reclaim() {
 357 
 358   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 359 
 360   log_info(metaspace)("ChunkManager \"%s\": reclaiming memory...", _name);
 361 
 362   const size_t reserved_before = _vslist-&gt;reserved_words();
 363   const size_t committed_before = _vslist-&gt;committed_words();
 364   int num_nodes_purged = 0;
 365 
 366   if (Settings::delete_nodes_on_purge()) {
 367     num_nodes_purged = _vslist-&gt;purge(&amp;_chunks);
 368     DEBUG_ONLY(InternalStats::inc_num_purges();)
 369   }
 370 
 371   if (Settings::uncommit_on_purge()) {
 372     const chunklevel_t max_level =
 373         chunklevel::level_fitting_word_size(Settings::uncommit_on_purge_min_word_size());
 374     for (chunklevel_t l = chunklevel::LOWEST_CHUNK_LEVEL;
 375          l &lt;= max_level;
 376          l ++)
 377     {
 378       for (Metachunk* c = _chunks.first_at_level(l); c != NULL; c = c-&gt;next()) {
 379         c-&gt;uncommit_locked();
 380       }
 381     }
 382     DEBUG_ONLY(InternalStats::inc_num_wholesale_uncommits();)
 383   }
 384 
 385   const size_t reserved_after = _vslist-&gt;reserved_words();
 386   const size_t committed_after = _vslist-&gt;committed_words();
 387 
 388   // Print a nice report.
 389   if (reserved_after == reserved_before &amp;&amp; committed_after == committed_before) {
 390     log_info(metaspace)("ChunkManager %s: ... nothing reclaimed.", _name);
 391   } else {
 392     LogTarget(Info, metaspace) lt;
 393     if (lt.is_enabled()) {
 394       LogStream ls(lt);
 395       ls.print_cr("ChunkManager %s: finished reclaiming memory: ", _name);
 396 
 397       ls.print("reserved: ");
 398       print_word_size_delta(&amp;ls, reserved_before, reserved_after);
 399       ls.cr();
 400 
 401       ls.print("committed: ");
 402       print_word_size_delta(&amp;ls, committed_before, committed_after);
 403       ls.cr();
 404 
 405       ls.print_cr("full nodes purged: %d", num_nodes_purged);
 406     }
 407   }
 408 
 409   DEBUG_ONLY(_vslist-&gt;verify_locked(true));
 410   DEBUG_ONLY(verify_locked(true));
 411 
 412 }
 413 
 414 
 415 ChunkManager* ChunkManager::_chunkmanager_class = NULL;
 416 ChunkManager* ChunkManager::_chunkmanager_nonclass = NULL;
 417 
 418 void ChunkManager::set_chunkmanager_class(ChunkManager* cm) {
 419   assert(_chunkmanager_class == NULL, "Sanity");
 420   _chunkmanager_class = cm;
 421 }
 422 
 423 void ChunkManager::set_chunkmanager_nonclass(ChunkManager* cm) {
 424   assert(_chunkmanager_nonclass == NULL, "Sanity");
 425   _chunkmanager_nonclass = cm;
 426 }
 427 
 428 
 429 
 430 // Update statistics.
 431 void ChunkManager::add_to_statistics(cm_stats_t* out) const {
 432 
 433   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 434 
 435   for (chunklevel_t l = chunklevel::ROOT_CHUNK_LEVEL; l &lt;= chunklevel::HIGHEST_CHUNK_LEVEL; l ++) {
 436     out-&gt;num_chunks[l] += _chunks.num_chunks_at_level(l);
 437     out-&gt;committed_word_size[l] += _chunks.committed_word_size_at_level(l);
 438   }
 439 
 440   DEBUG_ONLY(out-&gt;verify();)
 441 
 442 }
 443 
 444 #ifdef ASSERT
 445 
 446 void ChunkManager::verify(bool slow) const {
 447   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 448   verify_locked(slow);
 449 }
 450 
 451 void ChunkManager::verify_locked(bool slow) const {
 452   assert_lock_strong(MetaspaceExpand_lock);
 453   assert(_vslist != NULL, "No vslist");
 454   _chunks.verify();
 455 }
 456 
 457 bool ChunkManager::contains_chunk(Metachunk* c) const {
 458   return _chunks.contains(c);
 459 }
 460 
 461 #endif // ASSERT
 462 
 463 void ChunkManager::print_on(outputStream* st) const {
 464   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
 465   print_on_locked(st);
 466 }
 467 
 468 void ChunkManager::print_on_locked(outputStream* st) const {
 469   assert_lock_strong(MetaspaceExpand_lock);
 470   st-&gt;print_cr("cm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
 471                total_num_chunks(), total_word_size(), _chunks.committed_word_size());
 472   _chunks.print_on(st);
 473 }
 474 
 475 } // namespace metaspace
 476 
 477 
 478 
</pre></body></html>
