--- old/src/hotspot/share/memory/metaspace/spaceManager.hpp	2020-07-16 14:21:09.792251347 +0200
+++ new/src/hotspot/share/memory/metaspace/spaceManager.hpp	2020-07-16 14:21:09.444250023 +0200
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,207 +28,125 @@
 
 #include "memory/allocation.hpp"
 #include "memory/metaspace.hpp"
-#include "memory/metaspace/blockFreelist.hpp"
-#include "memory/metaspace/metaspaceCommon.hpp"
+#include "memory/metaspace/chunkManager.hpp"
 #include "memory/metaspace/metachunk.hpp"
-#include "memory/metaspace/metaspaceStatistics.hpp"
-#include "utilities/debug.hpp"
-#include "utilities/globalDefinitions.hpp"
+#include "memory/metaspace/metachunkList.hpp"
+#include "memory/metaspace/metaspaceCommon.hpp"
+
 
 class outputStream;
 class Mutex;
 
 namespace metaspace {
 
-//  SpaceManager - used by Metaspace to handle allocations
-class SpaceManager : public CHeapObj<mtClass> {
-  friend class ::ClassLoaderMetaspace;
-  friend class Metadebug;
-
- private:
-
-  // protects allocations
-  Mutex* const _lock;
-
-  // Type of metadata allocated.
-  const Metaspace::MetadataType   _mdtype;
-
-  // Type of metaspace
-  const Metaspace::MetaspaceType  _space_type;
-
-  // List of chunks in use by this SpaceManager.  Allocations
-  // are done from the current chunk.  The list is used for deallocating
-  // chunks when the SpaceManager is freed.
-  Metachunk* _chunk_list;
-  Metachunk* _current_chunk;
-
-  enum {
-
-    // Maximum number of small chunks to allocate to a SpaceManager
-    small_chunk_limit = 4,
-
-    // Maximum number of specialize chunks to allocate for anonymous and delegating
-    // metadata space to a SpaceManager
-    anon_and_delegating_metadata_specialize_chunk_limit = 4,
-
-    allocation_from_dictionary_limit = 4 * K
-
-  };
-
-  // Some running counters, but lets keep their number small to not add to much to
-  // the per-classloader footprint.
-  // Note: capacity = used + free + waste + overhead. We do not keep running counters for
-  // free and waste. Their sum can be deduced from the three other values.
-  size_t _overhead_words;
-  size_t _capacity_words;
-  size_t _used_words;
-  uintx _num_chunks_by_type[NumberOfInUseLists];
-
-  // Free lists of blocks are per SpaceManager since they
-  // are assumed to be in chunks in use by the SpaceManager
-  // and all chunks in use by a SpaceManager are freed when
-  // the class loader using the SpaceManager is collected.
-  BlockFreelist* _block_freelists;
 
- private:
-  // Accessors
-  Metachunk* chunk_list() const { return _chunk_list; }
+class ArenaGrowthPolicy;
+class FreeBlocks;
 
-  BlockFreelist* block_freelists() const { return _block_freelists; }
+struct sm_stats_t;
 
-  Metaspace::MetadataType mdtype() { return _mdtype; }
+// The SpaceManager:
+// - keeps a list of chunks-in-use by the class loader, as well as a current chunk used
+//   to allocate from
+// - keeps a dictionary of free MetaBlocks. Those can be remnants of a retired chunk or
+//   allocations which were not needed anymore for some reason (e.g. releasing half-allocated
+//   structures when class loading fails)
 
-  VirtualSpaceList* vs_list()   const { return Metaspace::get_space_list(_mdtype); }
-  ChunkManager* chunk_manager() const { return Metaspace::get_chunk_manager(_mdtype); }
-
-  Metachunk* current_chunk() const { return _current_chunk; }
-  void set_current_chunk(Metachunk* v) {
-    _current_chunk = v;
-  }
-
-  Metachunk* find_current_chunk(size_t word_size);
+class SpaceManager : public CHeapObj<mtClass> {
 
-  // Add chunk to the list of chunks in use
-  void add_chunk(Metachunk* v, bool make_current);
-  void retire_current_chunk();
+  // Lock handed down from the associated ClassLoaderData.
+  //  Protects allocations from this space.
+  Mutex* const _lock;
 
-  Mutex* lock() const { return _lock; }
+  // The chunk manager to allocate chunks from.
+  ChunkManager* const _chunk_manager;
 
-  // Adds to the given statistic object. Expects to be locked with lock().
-  void add_to_statistics_locked(SpaceManagerStatistics* out) const;
+  // The chunk allocation strategy to use.
+  const ArenaGrowthPolicy* const _growth_policy;
 
-  // Verify internal counters against the current state. Expects to be locked with lock().
-  DEBUG_ONLY(void verify_metrics_locked() const;)
+  // List of chunks. Head of the list is the current chunk.
+  MetachunkList _chunks;
 
- public:
-  SpaceManager(Metaspace::MetadataType mdtype,
-               Metaspace::MetaspaceType space_type,
-               Mutex* lock);
-  ~SpaceManager();
+  // Structure to take care of leftover/deallocated space in used chunks
+  FreeBlocks* _fbl;
 
-  enum ChunkMultiples {
-    MediumChunkMultiple = 4
-  };
+  Metachunk* current_chunk()              { return _chunks.first(); }
+  const Metachunk* current_chunk() const  { return _chunks.first(); }
 
-  static size_t specialized_chunk_size(bool is_class) { return is_class ? ClassSpecializedChunk : SpecializedChunk; }
-  static size_t small_chunk_size(bool is_class)       { return is_class ? ClassSmallChunk : SmallChunk; }
-  static size_t medium_chunk_size(bool is_class)      { return is_class ? ClassMediumChunk : MediumChunk; }
+  // Points to outside size counter which we are to increase/decrease when we allocate memory
+  // on behalf of a user or when we are destroyed.
+  SizeAtomicCounter* const _total_used_words_counter;
 
-  static size_t smallest_chunk_size(bool is_class)    { return specialized_chunk_size(is_class); }
+  const char* const _name;
 
-  // Accessors
-  bool is_class() const { return _mdtype == Metaspace::ClassType; }
+  // Whether or not this is a "micro loader" which is not expected to load more than one class.
+  const bool _is_micro_loader;
 
-  size_t specialized_chunk_size() const { return specialized_chunk_size(is_class()); }
-  size_t small_chunk_size()       const { return small_chunk_size(is_class()); }
-  size_t medium_chunk_size()      const { return medium_chunk_size(is_class()); }
+  Mutex* lock() const                           { return _lock; }
+  ChunkManager* chunk_manager() const           { return _chunk_manager; }
 
-  size_t smallest_chunk_size()    const { return smallest_chunk_size(is_class()); }
+  // free block list
+  FreeBlocks* fbl() const                       { return _fbl; }
+  void add_allocation_to_fbl(MetaWord* p, size_t word_size);
 
-  size_t medium_chunk_bunch()     const { return medium_chunk_size() * MediumChunkMultiple; }
+  // Given a chunk, add its remaining free committed space to the free block list.
+  void salvage_chunk(Metachunk* c);
 
-  bool is_humongous(size_t word_size) { return word_size > medium_chunk_size(); }
+  // Allocate a new chunk from the underlying chunk manager able to hold at least
+  // requested word size.
+  Metachunk* allocate_new_chunk(size_t requested_word_size);
 
-  size_t capacity_words() const     { return _capacity_words; }
-  size_t used_words() const         { return _used_words; }
-  size_t overhead_words() const     { return _overhead_words; }
+  // Returns the level of the next chunk to be added, acc to growth policy.
+  chunklevel_t next_chunk_level() const;
 
-  // Adjust local, global counters after a new chunk has been added.
-  void account_for_new_chunk(const Metachunk* new_chunk);
+  // Attempt to enlarge the current chunk to make it large enough to hold at least
+  //  requested_word_size additional words.
+  //
+  // On success, true is returned, false otherwise.
+  bool attempt_enlarge_current_chunk(size_t requested_word_size);
 
-  // Adjust local, global counters after space has been allocated from the current chunk.
-  void account_for_allocation(size_t words);
+  // Prematurely returns a metaspace allocation to the _block_freelists
+  // because it is not needed anymore (requires CLD lock to be active).
+  void deallocate_locked(MetaWord* p, size_t word_size);
 
-  // Adjust global counters just before the SpaceManager dies, after all its chunks
-  // have been returned to the freelist.
-  void account_for_spacemanager_death();
+  // Returns true if the area indicated by pointer and size have actually been allocated
+  // from this space manager.
+  DEBUG_ONLY(bool is_valid_area(MetaWord* p, size_t word_size) const;)
 
-  // Adjust the initial chunk size to match one of the fixed chunk list sizes,
-  // or return the unadjusted size if the requested size is humongous.
-  static size_t adjust_initial_chunk_size(size_t requested, bool is_class_space);
-  size_t adjust_initial_chunk_size(size_t requested) const;
+public:
 
-  // Get the initial chunks size for this metaspace type.
-  size_t get_initial_chunk_size(Metaspace::MetaspaceType type) const;
+  SpaceManager(ChunkManager* chunk_manager,
+               const ArenaGrowthPolicy* growth_policy,
+               Mutex* lock,
+               SizeAtomicCounter* total_used_words_counter,
+               const char* name,
+               bool is_micro_loader);
 
-  // Todo: remove this once we have counters by chunk type.
-  uintx num_chunks_by_type(ChunkIndex chunk_type) const       { return _num_chunks_by_type[chunk_type]; }
-
-  Metachunk* get_new_chunk(size_t chunk_word_size);
+  ~SpaceManager();
 
-  // Block allocation and deallocation.
-  // Allocates a block from the current chunk
+  // Allocate memory from Metaspace.
+  // 1) Attempt to allocate from the dictionary of deallocated blocks.
+  // 2) Attempt to allocate from the current chunk.
+  // 3) Attempt to enlarge the current chunk in place if it is too small.
+  // 4) Attempt to get a new chunk and allocate from that chunk.
+  // At any point, if we hit a commit limit, we return NULL.
   MetaWord* allocate(size_t word_size);
 
-  // Helper for allocations
-  MetaWord* allocate_work(size_t word_size);
-
-  // Returns a block to the per manager freelist
+  // Prematurely returns a metaspace allocation to the _block_freelists because it is not
+  // needed anymore.
   void deallocate(MetaWord* p, size_t word_size);
 
-  // Based on the allocation size and a minimum chunk size,
-  // returned chunk size (for expanding space for chunk allocation).
-  size_t calc_chunk_size(size_t allocation_word_size);
-
-  // Called when an allocation from the current chunk fails.
-  // Gets a new chunk (may require getting a new virtual space),
-  // and allocates from that chunk.
-  MetaWord* grow_and_allocate(size_t word_size);
-
-  // Notify memory usage to MemoryService.
-  void track_metaspace_memory_usage();
+  // Update statistics. This walks all in-use chunks.
+  void add_to_statistics(sm_stats_t* out) const;
 
-  // debugging support.
+  DEBUG_ONLY(void verify(bool slow) const;)
+  DEBUG_ONLY(void verify_locked(bool slow) const;)
 
   void print_on(outputStream* st) const;
-  void locked_print_chunks_in_use_on(outputStream* st) const;
-
-  void verify();
-  void verify_chunk_size(Metachunk* chunk);
-
-  // This adjusts the size given to be greater than the minimum allocation size in
-  // words for data in metaspace.  Esentially the minimum size is currently 3 words.
-  size_t get_allocation_word_size(size_t word_size) {
-    size_t byte_size = word_size * BytesPerWord;
-
-    size_t raw_bytes_size = MAX2(byte_size, sizeof(Metablock));
-    raw_bytes_size = align_up(raw_bytes_size, Metachunk::object_alignment());
-
-    size_t raw_word_size = raw_bytes_size / BytesPerWord;
-    assert(raw_word_size * BytesPerWord == raw_bytes_size, "Size problem");
-
-    return raw_word_size;
-  }
-
-  // Adds to the given statistic object.
-  void add_to_statistics(SpaceManagerStatistics* out) const;
-
-  // Verify internal counters against the current state.
-  DEBUG_ONLY(void verify_metrics() const;)
+  void print_on_locked(outputStream* st) const;
 
 };
 
-
 } // namespace metaspace
 
 #endif // SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
