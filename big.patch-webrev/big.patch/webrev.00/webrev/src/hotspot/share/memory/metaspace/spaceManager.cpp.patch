--- old/src/hotspot/share/memory/metaspace/spaceManager.cpp	2020-07-16 14:21:08.604246829 +0200
+++ new/src/hotspot/share/memory/metaspace/spaceManager.cpp	2020-07-16 14:21:08.256245504 +0200
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,504 +26,486 @@
 
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
+#include "memory/metaspace/allocationGuard.hpp"
+#include "memory/metaspace/arenaGrowthPolicy.hpp"
+#include "memory/metaspace/freeBlocks.hpp"
 #include "memory/metaspace/chunkManager.hpp"
+#include "memory/metaspace/internStat.hpp"
 #include "memory/metaspace/metachunk.hpp"
-#include "memory/metaspace/metaDebug.hpp"
 #include "memory/metaspace/metaspaceCommon.hpp"
+#include "memory/metaspace/metaspaceStatistics.hpp"
 #include "memory/metaspace/spaceManager.hpp"
 #include "memory/metaspace/virtualSpaceList.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/init.hpp"
 #include "services/memoryService.hpp"
+#include "utilities/align.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 
 namespace metaspace {
 
-#define assert_counter(expected_value, real_value, msg) \
-  assert( (expected_value) == (real_value),             \
-         "Counter mismatch (%s): expected " SIZE_FORMAT \
-         ", but got: " SIZE_FORMAT ".", msg, expected_value, \
-         real_value);
-
-// SpaceManager methods
-
-size_t SpaceManager::adjust_initial_chunk_size(size_t requested, bool is_class_space) {
-  size_t chunk_sizes[] = {
-      specialized_chunk_size(is_class_space),
-      small_chunk_size(is_class_space),
-      medium_chunk_size(is_class_space)
-  };
-
-  // Adjust up to one of the fixed chunk sizes ...
-  for (size_t i = 0; i < ARRAY_SIZE(chunk_sizes); i++) {
-    if (requested <= chunk_sizes[i]) {
-      return chunk_sizes[i];
-    }
-  }
+#define LOGFMT_SPCMGR         "SpcMgr @" PTR_FORMAT " (%s)"
+#define LOGFMT_SPCMGR_ARGS    p2i(this), this->_name
 
-  // ... or return the size as a humongous chunk.
-  return requested;
-}
+// Given a net allocation word size, return the raw word size we actually allocate.
+// Note: externally visible for gtests.
+//static
+size_t get_raw_allocation_word_size(size_t net_word_size) {
 
-size_t SpaceManager::adjust_initial_chunk_size(size_t requested) const {
-  return adjust_initial_chunk_size(requested, is_class());
-}
+  size_t byte_size = net_word_size * BytesPerWord;
 
-size_t SpaceManager::get_initial_chunk_size(Metaspace::MetaspaceType type) const {
-  size_t requested;
+  // Deallocated metablocks are kept in a binlist which limits their minimal
+  //  size to at least the size of a binlist item (2 words).
+  byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);
 
-  if (is_class()) {
-    switch (type) {
-    case Metaspace::BootMetaspaceType:              requested = Metaspace::first_class_chunk_word_size(); break;
-    case Metaspace::ClassMirrorHolderMetaspaceType: requested = ClassSpecializedChunk; break;
-    case Metaspace::ReflectionMetaspaceType:        requested = ClassSpecializedChunk; break;
-    default:                                        requested = ClassSmallChunk; break;
-    }
-  } else {
-    switch (type) {
-    case Metaspace::BootMetaspaceType:              requested = Metaspace::first_chunk_word_size(); break;
-    case Metaspace::ClassMirrorHolderMetaspaceType: requested = SpecializedChunk; break;
-    case Metaspace::ReflectionMetaspaceType:        requested = SpecializedChunk; break;
-    default:                                        requested = SmallChunk; break;
-    }
+  // Metaspace allocations are aligned to word size.
+  byte_size = align_up(byte_size, allocation_alignment_bytes);
+
+  // If we guard allocations, we need additional space for a prefix.
+#ifdef ASSERT
+  if (Settings::use_allocation_guard()) {
+    byte_size += align_up(prefix_size(), allocation_alignment_bytes);
   }
+#endif
+
+  size_t word_size = byte_size / BytesPerWord;
 
-  // Adjust to one of the fixed chunk sizes (unless humongous)
-  const size_t adjusted = adjust_initial_chunk_size(requested);
+  assert(word_size * BytesPerWord == byte_size, "Sanity");
 
-  assert(adjusted != 0, "Incorrect initial chunk size. Requested: "
-         SIZE_FORMAT " adjusted: " SIZE_FORMAT, requested, adjusted);
+  return word_size;
+
+}
 
-  return adjusted;
+// Returns the level of the next chunk to be added, acc to growth policy.
+chunklevel_t SpaceManager::next_chunk_level() const {
+  const int growth_step = _chunks.count();
+  return _growth_policy->get_level_at_step(growth_step);
 }
 
-void SpaceManager::locked_print_chunks_in_use_on(outputStream* st) const {
+// Given a chunk, add its remaining free committed space to the free block list.
+void SpaceManager::salvage_chunk(Metachunk* c) {
 
-  for (ChunkIndex i = ZeroIndex; i < NumberOfInUseLists; i = next_chunk_index(i)) {
-    st->print("SpaceManager: " UINTX_FORMAT " %s chunks.",
-        num_chunks_by_type(i), chunk_size_name(i));
+  if (Settings::handle_deallocations() == false) {
+    return;
   }
 
-  chunk_manager()->locked_print_free_chunks(st);
-}
+  assert_lock_strong(lock());
 
-size_t SpaceManager::calc_chunk_size(size_t word_size) {
+  // If the chunk is completely empty, just return it to the chunk manager.
+  if (c->used_words() == 0) {
+    _chunk_manager->return_chunk(c);
+    return;
+  }
 
-  // Decide between a small chunk and a medium chunk.  Up to
-  // _small_chunk_limit small chunks can be allocated.
-  // After that a medium chunk is preferred.
-  size_t chunk_word_size;
+  size_t remaining_words = c->free_below_committed_words();
 
-  // Special case for hidden metadata space.
-  // ClassMirrorHolder metadata space is usually small since it is used for
-  // class loader data's whose life cycle is governed by one class such as a
-  // non-strong hidden class or unsafe anonymous class.  The majority within 1K - 2K range and
-  // rarely about 4K (64-bits JVM).
-  // Instead of jumping to SmallChunk after initial chunk exhausted, keeping allocation
-  // from SpecializeChunk up to _anon_or_delegating_metadata_specialize_chunk_limit (4)
-  // reduces space waste from 60+% to around 30%.
-  if ((_space_type == Metaspace::ClassMirrorHolderMetaspaceType || _space_type == Metaspace::ReflectionMetaspaceType) &&
-      _mdtype == Metaspace::NonClassType &&
-      num_chunks_by_type(SpecializedIndex) < anon_and_delegating_metadata_specialize_chunk_limit &&
-      word_size + Metachunk::overhead() <= SpecializedChunk) {
-    return SpecializedChunk;
-  }
+  if (remaining_words > FreeBlocks::minimal_word_size) {
 
-  if (num_chunks_by_type(MediumIndex) == 0 &&
-      num_chunks_by_type(SmallIndex) < small_chunk_limit) {
-    chunk_word_size = (size_t) small_chunk_size();
-    if (word_size + Metachunk::overhead() > small_chunk_size()) {
-      chunk_word_size = medium_chunk_size();
-    }
-  } else {
-    chunk_word_size = medium_chunk_size();
-  }
+    log_debug(metaspace)(LOGFMT_SPCMGR " @" PTR_FORMAT " : salvaging chunk " METACHUNK_FULL_FORMAT ".",
+                         LOGFMT_SPCMGR_ARGS, p2i(this), METACHUNK_FULL_FORMAT_ARGS(c));
 
-  // Might still need a humongous chunk.  Enforce
-  // humongous allocations sizes to be aligned up to
-  // the smallest chunk size.
-  size_t if_humongous_sized_chunk =
-    align_up(word_size + Metachunk::overhead(),
-                  smallest_chunk_size());
-  chunk_word_size =
-    MAX2((size_t) chunk_word_size, if_humongous_sized_chunk);
-
-  assert(!SpaceManager::is_humongous(word_size) ||
-         chunk_word_size == if_humongous_sized_chunk,
-         "Size calculation is wrong, word_size " SIZE_FORMAT
-         " chunk_word_size " SIZE_FORMAT,
-         word_size, chunk_word_size);
-  Log(gc, metaspace, alloc) log;
-  if (log.is_trace() && SpaceManager::is_humongous(word_size)) {
-    log.trace("Metadata humongous allocation:");
-    log.trace("  word_size " PTR_FORMAT, word_size);
-    log.trace("  chunk_word_size " PTR_FORMAT, chunk_word_size);
-    log.trace("    chunk overhead " PTR_FORMAT, Metachunk::overhead());
-  }
-  return chunk_word_size;
-}
-
-void SpaceManager::track_metaspace_memory_usage() {
-  if (is_init_completed()) {
-    if (is_class()) {
-      MemoryService::track_compressed_class_memory_usage();
-    }
-    MemoryService::track_metaspace_memory_usage();
-  }
-}
+    MetaWord* ptr = c->allocate(remaining_words);
+    assert(ptr != NULL, "Should have worked");
+    _total_used_words_counter->increment_by(remaining_words);
 
-MetaWord* SpaceManager::grow_and_allocate(size_t word_size) {
-  assert_lock_strong(_lock);
-  assert(vs_list()->current_virtual_space() != NULL,
-         "Should have been set");
-  assert(current_chunk() == NULL ||
-         current_chunk()->allocate(word_size) == NULL,
-         "Don't need to expand");
-  MutexLocker cl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
-
-  if (log_is_enabled(Trace, gc, metaspace, freelist)) {
-    size_t words_left = 0;
-    size_t words_used = 0;
-    if (current_chunk() != NULL) {
-      words_left = current_chunk()->free_word_size();
-      words_used = current_chunk()->used_word_size();
-    }
-    log_trace(gc, metaspace, freelist)("SpaceManager::grow_and_allocate for " SIZE_FORMAT " words " SIZE_FORMAT " words used " SIZE_FORMAT " words left",
-                                       word_size, words_used, words_left);
-  }
+    add_allocation_to_fbl(ptr, remaining_words);
 
-  // Get another chunk
-  size_t chunk_word_size = calc_chunk_size(word_size);
-  Metachunk* next = get_new_chunk(chunk_word_size);
-
-  MetaWord* mem = NULL;
-
-  // If a chunk was available, add it to the in-use chunk list
-  // and do an allocation from it.
-  if (next != NULL) {
-    // Add to this manager's list of chunks in use.
-    // If the new chunk is humongous, it was created to serve a single large allocation. In that
-    // case it usually makes no sense to make it the current chunk, since the next allocation would
-    // need to allocate a new chunk anyway, while we would now prematurely retire a perfectly
-    // good chunk which could be used for more normal allocations.
-    bool make_current = true;
-    if (next->get_chunk_type() == HumongousIndex &&
-        current_chunk() != NULL) {
-      make_current = false;
-    }
-    add_chunk(next, make_current);
-    mem = next->allocate(word_size);
-  }
+    // After this operation: the chunk should have no free committed space left.
+    assert(c->free_below_committed_words() == 0,
+           "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",
+           METACHUNK_FULL_FORMAT_ARGS(c));
 
-  // Track metaspace memory usage statistic.
-  track_metaspace_memory_usage();
+  }
 
-  return mem;
 }
 
-void SpaceManager::print_on(outputStream* st) const {
-  SpaceManagerStatistics stat;
-  add_to_statistics(&stat); // will lock _lock.
-  stat.print_on(st, 1*K, false);
-}
-
-SpaceManager::SpaceManager(Metaspace::MetadataType mdtype,
-                           Metaspace::MetaspaceType space_type,//
-                           Mutex* lock) :
-  _lock(lock),
-  _mdtype(mdtype),
-  _space_type(space_type),
-  _chunk_list(NULL),
-  _current_chunk(NULL),
-  _overhead_words(0),
-  _capacity_words(0),
-  _used_words(0),
-  _block_freelists(NULL) {
-  Metadebug::init_allocation_fail_alot_count();
-  memset(_num_chunks_by_type, 0, sizeof(_num_chunks_by_type));
-  log_trace(gc, metaspace, freelist)("SpaceManager(): " PTR_FORMAT, p2i(this));
-}
-
-void SpaceManager::account_for_new_chunk(const Metachunk* new_chunk) {
-
-  assert_lock_strong(MetaspaceExpand_lock);
-
-  _capacity_words += new_chunk->word_size();
-  _overhead_words += Metachunk::overhead();
-  DEBUG_ONLY(new_chunk->verify());
-  _num_chunks_by_type[new_chunk->get_chunk_type()] ++;
-
-  // Adjust global counters:
-  MetaspaceUtils::inc_capacity(mdtype(), new_chunk->word_size());
-  MetaspaceUtils::inc_overhead(mdtype(), Metachunk::overhead());
-}
-
-void SpaceManager::account_for_allocation(size_t words) {
-  // Note: we should be locked with the ClassloaderData-specific metaspace lock.
-  // We may or may not be locked with the global metaspace expansion lock.
+// Allocate a new chunk from the underlying chunk manager able to hold at least
+// requested word size.
+Metachunk* SpaceManager::allocate_new_chunk(size_t requested_word_size) {
+
   assert_lock_strong(lock());
 
-  // Add to the per SpaceManager totals. This can be done non-atomically.
-  _used_words += words;
+  // Should this ever happen, we need to increase the maximum possible chunk size.
+  guarantee(requested_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE,
+            "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",
+            requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);
+
+  const int growth_step = _chunks.count();
+  const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);
+  const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());
+
+  Metachunk* c = _chunk_manager->get_chunk(preferred_level, max_level, requested_word_size);
+  if (c == NULL) {
+    log_debug(metaspace)(LOGFMT_SPCMGR ": failed to allocate new chunk for requested word size " SIZE_FORMAT ".",
+                         LOGFMT_SPCMGR_ARGS, requested_word_size);
+    return NULL;
+  }
+
+  assert(c->is_in_use(), "Wrong chunk state.");
+  assert(c->free_below_committed_words() >= requested_word_size, "Chunk not committed");
 
-  // Adjust global counters. This will be done atomically.
-  MetaspaceUtils::inc_used(mdtype(), words);
-}
+  log_debug(metaspace)(LOGFMT_SPCMGR ": allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",
+                       LOGFMT_SPCMGR_ARGS, METACHUNK_FORMAT_ARGS(c), requested_word_size);
 
-void SpaceManager::account_for_spacemanager_death() {
+  return c;
 
-  assert_lock_strong(MetaspaceExpand_lock);
+}
 
-  MetaspaceUtils::dec_capacity(mdtype(), _capacity_words);
-  MetaspaceUtils::dec_overhead(mdtype(), _overhead_words);
-  MetaspaceUtils::dec_used(mdtype(), _used_words);
+void SpaceManager::add_allocation_to_fbl(MetaWord* p, size_t word_size) {
+  assert(Settings::handle_deallocations(), "Sanity");
+  if (_fbl == NULL) {
+    _fbl = new FreeBlocks(); // Create only on demand
+  }
+  _fbl->add_block(p, word_size);
+}
+
+SpaceManager::SpaceManager(ChunkManager* chunk_manager,
+             const ArenaGrowthPolicy* growth_policy,
+             Mutex* lock,
+             SizeAtomicCounter* total_used_words_counter,
+             const char* name,
+             bool is_micro_loader)
+: _lock(lock),
+  _chunk_manager(chunk_manager),
+  _growth_policy(growth_policy),
+  _chunks(),
+  _fbl(NULL),
+  _total_used_words_counter(total_used_words_counter),
+  _name(name),
+  _is_micro_loader(is_micro_loader)
+{
 }
 
 SpaceManager::~SpaceManager() {
 
-  // This call this->_lock which can't be done while holding MetaspaceExpand_lock
-  DEBUG_ONLY(verify_metrics());
+  DEBUG_ONLY(verify(true);)
 
-  MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);
+  MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);
 
-  account_for_spacemanager_death();
+  size_t used_words_returned = 0;
 
-  Log(gc, metaspace, freelist) log;
-  if (log.is_trace()) {
-    log.trace("~SpaceManager(): " PTR_FORMAT, p2i(this));
-    ResourceMark rm;
-    LogStream ls(log.trace());
-    locked_print_chunks_in_use_on(&ls);
-    if (block_freelists() != NULL) {
-      block_freelists()->print_on(&ls);
-    }
+  Metachunk* c = _chunks.first();
+  Metachunk* c2 = NULL;
+
+  while(c) {
+    c2 = c->next();
+    used_words_returned += c->used_words();
+    DEBUG_ONLY(c->set_prev(NULL);)
+    DEBUG_ONLY(c->set_next(NULL);)
+    _chunk_manager->return_chunk(c);
+    // c may be invalid after return_chunk(c) was called. Don't access anymore.
+    c = c2;
   }
 
-  // Add all the chunks in use by this space manager
-  // to the global list of free chunks.
+  _total_used_words_counter->decrement_by(used_words_returned);
 
-  // Follow each list of chunks-in-use and add them to the
-  // free lists.  Each list is NULL terminated.
-  chunk_manager()->return_chunk_list(chunk_list());
-#ifdef ASSERT
-  _chunk_list = NULL;
-  _current_chunk = NULL;
-#endif
+  DEBUG_ONLY(chunk_manager()->verify(true);)
 
-#ifdef ASSERT
-  EVERY_NTH(VerifyMetaspaceInterval)
-    chunk_manager()->locked_verify(true);
-  END_EVERY_NTH
-#endif
+  delete _fbl;
 
-  if (_block_freelists != NULL) {
-    delete _block_freelists;
-  }
-}
-
-void SpaceManager::deallocate(MetaWord* p, size_t word_size) {
-  assert_lock_strong(lock());
-  // Allocations and deallocations are in raw_word_size
-  size_t raw_word_size = get_allocation_word_size(word_size);
-  // Lazily create a block_freelist
-  if (block_freelists() == NULL) {
-    _block_freelists = new BlockFreelist();
-  }
-  block_freelists()->return_block(p, raw_word_size);
-  DEBUG_ONLY(Atomic::inc(&(g_internal_statistics.num_deallocs)));
 }
 
-// Adds a chunk to the list of chunks in use.
-void SpaceManager::add_chunk(Metachunk* new_chunk, bool make_current) {
+// Attempt to enlarge the current chunk to make it large enough to hold at least
+//  requested_word_size additional words.
+//
+// On success, true is returned, false otherwise.
+bool SpaceManager::attempt_enlarge_current_chunk(size_t requested_word_size) {
 
-  assert_lock_strong(_lock);
-  assert(new_chunk != NULL, "Should not be NULL");
-  assert(new_chunk->next() == NULL, "Should not be on a list");
+  Metachunk* c = current_chunk();
+  assert(c->free_words() < requested_word_size, "Sanity");
 
-  new_chunk->reset_empty();
+  // Not if chunk enlargment is switched off in general...
+  if (Settings::enlarge_chunks_in_place() == false) {
+    return false;
+  }
 
-  // Find the correct list and and set the current
-  // chunk for that list.
-  ChunkIndex index = chunk_manager()->list_index(new_chunk->word_size());
+  // Nor if the chunk is deemed to large to be thus expanded.
+  //  (TODO : do we need this if we check the allowed chunk growth progression below? check)
+  if (c->word_size() <= Settings::enlarge_chunks_in_place_max_word_size()) {
+    return false;
+  }
 
-  if (make_current) {
-    // If we are to make the chunk current, retire the old current chunk and replace
-    // it with the new chunk.
-    retire_current_chunk();
-    set_current_chunk(new_chunk);
+  // Nor, obviously, if we are already a root chunk.
+  if (c->is_root_chunk()) {
+    return false;
   }
 
-  // Add the new chunk at the head of its respective chunk list.
-  new_chunk->set_next(_chunk_list);
-  _chunk_list = new_chunk;
+  const chunklevel_t new_level =
+      chunklevel::level_fitting_word_size(c->used_words() + requested_word_size);
 
-  // Adjust counters.
-  account_for_new_chunk(new_chunk);
+  // Atm we only attempt to enlarge by one level (so, doubling the chunk in size).
+  // So, if the requested enlargement would require the chunk to more than double in size,
+  // we bail. But this covers about 99% of all cases, so this is good enough.
+  if (c->level() > new_level + 1) {
+    return false;
+  }
 
-  assert(new_chunk->is_empty(), "Not ready for reuse");
-  Log(gc, metaspace, freelist) log;
-  if (log.is_trace()) {
-    log.trace("SpaceManager::added chunk: ");
-    ResourceMark rm;
-    LogStream ls(log.trace());
-    new_chunk->print_on(&ls);
-    chunk_manager()->locked_print_free_chunks(&ls);
+  // This only works if chunk is the leader of its buddy pair (and also if buddy
+  // is free and unsplit, but that we cannot check outside of metaspace lock).
+  if (c->is_leader() == false) {
+    return false;
   }
-}
 
-void SpaceManager::retire_current_chunk() {
-  if (current_chunk() != NULL) {
-    size_t remaining_words = current_chunk()->free_word_size();
-    if (remaining_words >= SmallBlocks::small_block_min_size()) {
-      MetaWord* ptr = current_chunk()->allocate(remaining_words);
-      deallocate(ptr, remaining_words);
-      account_for_allocation(remaining_words);
-    }
+  // If enlarging the chunk would increase the arena size faster than we are prepared
+  // to grow, we don't enlarge the chunk.
+  if (chunklevel::word_size_for_level(next_chunk_level()) < c->word_size()) {
+    return false;
   }
-}
 
-Metachunk* SpaceManager::get_new_chunk(size_t chunk_word_size) {
-  // Get a chunk from the chunk freelist
-  Metachunk* next = chunk_manager()->chunk_freelist_allocate(chunk_word_size);
+  bool success = _chunk_manager->attempt_enlarge_chunk(c);
 
-  if (next == NULL) {
-    next = vs_list()->get_new_chunk(chunk_word_size,
-                                    medium_chunk_bunch());
-  }
+  assert(success == false || c->free_words() >= requested_word_size, "Sanity");
 
-  Log(gc, metaspace, alloc) log;
-  if (log.is_trace() && next != NULL &&
-      SpaceManager::is_humongous(next->word_size())) {
-    log.trace("  new humongous chunk word size " PTR_FORMAT, next->word_size());
-  }
+  return success;
 
-  return next;
 }
 
-MetaWord* SpaceManager::allocate(size_t word_size) {
+// Allocate memory from Metaspace.
+// 1) Attempt to allocate from the free block list.
+// 2) Attempt to allocate from the current chunk.
+// 3) Attempt to enlarge the current chunk in place if it is too small.
+// 4) Attempt to get a new chunk and allocate from that chunk.
+// At any point, if we hit a commit limit, we return NULL.
+MetaWord* SpaceManager::allocate(size_t requested_word_size) {
+
   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
-  size_t raw_word_size = get_allocation_word_size(word_size);
-  BlockFreelist* fl =  block_freelists();
+
+  log_debug(metaspace)(LOGFMT_SPCMGR ": requested " SIZE_FORMAT " words.",
+                       LOGFMT_SPCMGR_ARGS, requested_word_size);
+
   MetaWord* p = NULL;
 
-  // Allocation from the dictionary is expensive in the sense that
-  // the dictionary has to be searched for a size.  Don't allocate
-  // from the dictionary until it starts to get fat.  Is this
-  // a reasonable policy?  Maybe an skinny dictionary is fast enough
-  // for allocations.  Do some profiling.  JJJ
-  if (fl != NULL && fl->total_size() > allocation_from_dictionary_limit) {
-    p = fl->get_block(raw_word_size);
+  const size_t raw_word_size = get_raw_allocation_word_size(requested_word_size);
+
+  // 1) Attempt to allocate from the dictionary of deallocated blocks.
+  if (Settings::handle_deallocations() && _fbl != NULL && !_fbl->is_empty()) {
+    p = _fbl->get_block(raw_word_size);
     if (p != NULL) {
-      DEBUG_ONLY(Atomic::inc(&g_internal_statistics.num_allocs_from_deallocated_blocks));
+      DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)
+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from free block list.", LOGFMT_SPCMGR_ARGS);
+      // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -
+      // that means that we do not modify any counters and therefore can skip the epilog.
+      return p;
     }
   }
-  if (p == NULL) {
-    p = allocate_work(raw_word_size);
+
+  bool current_chunk_too_small = false;
+  bool commit_failure = false;
+
+  if (current_chunk() != NULL) {
+
+    // 2) Attempt to satisfy the allocation from the current chunk.
+
+    // If the current chunk is too small to hold the requested size, attempt to enlarge it.
+    // If that fails, retire the chunk.
+    if (current_chunk()->free_words() < raw_word_size) {
+      if (!attempt_enlarge_current_chunk(raw_word_size)) {
+        current_chunk_too_small = true;
+      }
+    }
+
+    // Commit the chunk far enough to hold the requested word size. If that fails, we
+    // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the
+    // chunk.
+    if (!current_chunk_too_small) {
+      if (!current_chunk()->ensure_committed_additional(raw_word_size)) {
+        commit_failure = true;
+      }
+    }
+
+    // Allocate from the current chunk. This should work now.
+    if (!current_chunk_too_small && !commit_failure) {
+      p = current_chunk()->allocate(raw_word_size);
+      assert(p != NULL, "Allocation from chunk failed.");
+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from current chunk.", LOGFMT_SPCMGR_ARGS);
+    }
+
   }
 
-#ifdef ASSERT
-  EVERY_NTH(VerifyMetaspaceInterval)
-    verify_metrics_locked();
-  END_EVERY_NTH
-#endif
+  if (p == NULL) {
 
-  return p;
-}
+    // If we are here, we either had no current chunk to begin with or it was deemed insufficient.
+    assert(current_chunk() == NULL ||
+           current_chunk_too_small || commit_failure, "Sanity");
+
+    Metachunk* new_chunk = allocate_new_chunk(raw_word_size);
+
+    if (new_chunk != NULL) {
+
+      assert(new_chunk->free_below_committed_words() >= raw_word_size, "Sanity");
+
+      // We have a new chunk. Before making it the current chunk, retire the old one.
+      if (current_chunk() != NULL) {
+        salvage_chunk(current_chunk());
+        DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)
+      }
+
+      _chunks.add(new_chunk);
+
+      // Now, allocate from that chunk. That should work.
+      p = current_chunk()->allocate(raw_word_size);
+      assert(p != NULL, "Allocation from chunk failed.");
+      log_trace(metaspace)(LOGFMT_SPCMGR ": .. allocated new chunk " CHKLVL_FORMAT " and taken from that.",
+                           LOGFMT_SPCMGR_ARGS, current_chunk()->level());
+    }
+
+  }
 
-// Returns the address of spaced allocated for "word_size".
-// This methods does not know about blocks (Metablocks)
-MetaWord* SpaceManager::allocate_work(size_t word_size) {
-  assert_lock_strong(lock());
 #ifdef ASSERT
-  if (Metadebug::test_metadata_failure()) {
-    return NULL;
+  // When using allocation guards, establish a prefix.
+  if (p != NULL && Settings::use_allocation_guard()) {
+    p = establish_prefix(p, raw_word_size);
   }
 #endif
-  // Is there space in the current chunk?
-  MetaWord* result = NULL;
 
-  if (current_chunk() != NULL) {
-    result = current_chunk()->allocate(word_size);
+  if (p == NULL) {
+    DEBUG_ONLY(InternalStats::inc_num_allocs_failed_limit();)
+  } else {
+    DEBUG_ONLY(InternalStats::inc_num_allocs();)
+    _total_used_words_counter->increment_by(raw_word_size);
   }
 
-  if (result == NULL) {
-    result = grow_and_allocate(word_size);
-  }
+  SOMETIMES(verify_locked(true);)
 
-  if (result != NULL) {
-    account_for_allocation(word_size);
-  }
+  log_trace(metaspace)(LOGFMT_SPCMGR ": returned " PTR_FORMAT ".",
+                       LOGFMT_SPCMGR_ARGS, p2i(p));
+
+  return p;
 
-  return result;
 }
 
-void SpaceManager::verify() {
-  Metachunk* curr = chunk_list();
-  while (curr != NULL) {
-    DEBUG_ONLY(do_verify_chunk(curr);)
-    assert(curr->is_tagged_free() == false, "Chunk should be tagged as in use.");
-    curr = curr->next();
+// Prematurely returns a metaspace allocation to the _block_freelists
+// because it is not needed anymore (requires CLD lock to be active).
+void SpaceManager::deallocate_locked(MetaWord* p, size_t word_size) {
+
+  if (Settings::handle_deallocations() == false) {
+    return;
   }
+
+  assert_lock_strong(lock());
+
+  // At this point a current chunk must exist since we only deallocate if we did allocate before.
+  assert(current_chunk() != NULL, "stray deallocation?");
+
+  assert(is_valid_area(p, word_size),
+         "Pointer range not part of this SpaceManager and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",
+         p2i(p), p2i(p + word_size));
+
+  log_debug(metaspace)(LOGFMT_SPCMGR ": deallocating " PTR_FORMAT
+                       ", word size: " SIZE_FORMAT ".",
+                       LOGFMT_SPCMGR_ARGS, p2i(p), word_size);
+
+  size_t raw_word_size = get_raw_allocation_word_size(word_size);
+  add_allocation_to_fbl(p, raw_word_size);
+
+  DEBUG_ONLY(verify_locked(false);)
+
 }
 
-void SpaceManager::verify_chunk_size(Metachunk* chunk) {
-  assert(is_humongous(chunk->word_size()) ||
-         chunk->word_size() == medium_chunk_size() ||
-         chunk->word_size() == small_chunk_size() ||
-         chunk->word_size() == specialized_chunk_size(),
-         "Chunk size is wrong");
-  return;
+// Prematurely returns a metaspace allocation to the _block_freelists because it is not
+// needed anymore.
+void SpaceManager::deallocate(MetaWord* p, size_t word_size) {
+  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
+  deallocate_locked(p, word_size);
 }
 
-void SpaceManager::add_to_statistics_locked(SpaceManagerStatistics* out) const {
-  assert_lock_strong(lock());
-  Metachunk* chunk = chunk_list();
-  while (chunk != NULL) {
-    UsedChunksStatistics& chunk_stat = out->chunk_stats(chunk->get_chunk_type());
-    chunk_stat.add_num(1);
-    chunk_stat.add_cap(chunk->word_size());
-    chunk_stat.add_overhead(Metachunk::overhead());
-    chunk_stat.add_used(chunk->used_word_size() - Metachunk::overhead());
-    if (chunk != current_chunk()) {
-      chunk_stat.add_waste(chunk->free_word_size());
+// Update statistics. This walks all in-use chunks.
+void SpaceManager::add_to_statistics(sm_stats_t* out) const {
+
+  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
+
+  for (const Metachunk* c = _chunks.first(); c != NULL; c = c->next()) {
+    in_use_chunk_stats_t& ucs = out->stats[c->level()];
+    ucs.num ++;
+    ucs.word_size += c->word_size();
+    ucs.committed_words += c->committed_words();
+    ucs.used_words += c->used_words();
+    // Note: for free and waste, we only count what's committed.
+    if (c == current_chunk()) {
+      ucs.free_words += c->free_below_committed_words();
     } else {
-      chunk_stat.add_free(chunk->free_word_size());
+      ucs.waste_words += c->free_below_committed_words();
     }
-    chunk = chunk->next();
   }
-  if (block_freelists() != NULL) {
-    out->add_free_blocks_info(block_freelists()->num_blocks(), block_freelists()->total_size());
+
+  if (_fbl != NULL) {
+    out->free_blocks_num += _fbl->count();
+    out->free_blocks_word_size += _fbl->total_size();
   }
-}
 
-void SpaceManager::add_to_statistics(SpaceManagerStatistics* out) const {
-  MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
-  add_to_statistics_locked(out);
+  SOMETIMES(out->verify();)
+
 }
 
 #ifdef ASSERT
-void SpaceManager::verify_metrics_locked() const {
+
+void SpaceManager::verify_locked(bool slow) const {
+
   assert_lock_strong(lock());
 
-  SpaceManagerStatistics stat;
-  add_to_statistics_locked(&stat);
+  assert(_growth_policy != NULL && _chunk_manager != NULL, "Sanity");
 
-  UsedChunksStatistics chunk_stats = stat.totals();
+  _chunks.verify();
 
-  DEBUG_ONLY(chunk_stats.check_sanity());
+  if (_fbl != NULL) {
+    _fbl->verify();
+  }
+
+  // In slow mode, verify guard zones of all allocations
+  if (slow && Settings::use_allocation_guard()) {
+    for (const Metachunk* c = _chunks.first(); c != NULL; c = c->next()) {
+      const MetaWord* p = c->base();
+      while (p < c->top()) {
+        const prefix_t* pp = (const prefix_t*)p;
+        check_prefix(pp);
+        p += pp->word_size;
+      }
+    }
+  }
 
-  assert_counter(_capacity_words, chunk_stats.cap(), "SpaceManager::_capacity_words");
-  assert_counter(_used_words, chunk_stats.used(), "SpaceManager::_used_words");
-  assert_counter(_overhead_words, chunk_stats.overhead(), "SpaceManager::_overhead_words");
 }
 
-void SpaceManager::verify_metrics() const {
+void SpaceManager::verify(bool slow) const {
+
   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
-  verify_metrics_locked();
+  verify_locked(slow);
+
+}
+
+// Returns true if the area indicated by pointer and size have actually been allocated
+// from this space manager.
+bool SpaceManager::is_valid_area(MetaWord* p, size_t word_size) const {
+  assert(p != NULL && word_size > 0, "Sanity");
+  bool found = false;
+  if (!found) {
+    for (const Metachunk* c = _chunks.first(); c != NULL && !found; c = c->next()) {
+      assert(c->is_valid_committed_pointer(p) ==
+             c->is_valid_committed_pointer(p + word_size - 1), "range intersects");
+      found = c->is_valid_committed_pointer(p);
+    }
+  }
+  return found;
 }
+
 #endif // ASSERT
 
+void SpaceManager::print_on(outputStream* st) const {
+  MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);
+  print_on_locked(st);
+}
+
+void SpaceManager::print_on_locked(outputStream* st) const {
+  assert_lock_strong(_lock);
+  st->print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,
+               _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());
+  _chunks.print_on(st);
+  st->cr();
+  st->print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,
+                _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));
+}
+
+
 
 } // namespace metaspace
 
