<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="new">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 
  27 #include "precompiled.hpp"
  28 #include "logging/log.hpp"
<a name="2" id="anc2"></a>
  29 #include "memory/metaspace.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
<a name="3" id="anc3"></a><span class="changed">  31 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  32 #include "memory/metaspace/commitLimiter.hpp"</span>
<span class="changed">  33 #include "memory/metaspace/counter.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/freeChunkList.hpp"</span>
  35 #include "memory/metaspace/virtualSpaceList.hpp"
  36 #include "memory/metaspace/virtualSpaceNode.hpp"
<a name="4" id="anc4"></a>

  37 #include "runtime/mutexLocker.hpp"
<a name="5" id="anc5"></a><span class="changed">  38 </span>
  39 
  40 namespace metaspace {
  41 
<a name="6" id="anc6"></a><span class="new">  42 static int next_node_id = 0;</span>
  43 
<a name="7" id="anc7"></a><span class="changed">  44 // Create a new, empty, expandable list.</span>
<span class="changed">  45 VirtualSpaceList::VirtualSpaceList(const char* name, CommitLimiter* commit_limiter)</span>
<span class="changed">  46   : _name(name),</span>
<span class="changed">  47     _first_node(NULL),</span>
<span class="changed">  48     _can_expand(true),</span>
<span class="changed">  49     _can_purge(true),</span>
<span class="changed">  50     _commit_limiter(commit_limiter),</span>
<span class="changed">  51     _reserved_words_counter(),</span>
<span class="changed">  52     _committed_words_counter()</span>
<span class="changed">  53 {</span>
<span class="changed">  54 }</span>
<span class="changed">  55 </span>
<span class="changed">  56 // Create a new list. The list will contain one node only, which uses the given ReservedSpace.</span>
<span class="changed">  57 // It will be not expandable beyond that first node.</span>
<span class="changed">  58 VirtualSpaceList::VirtualSpaceList(const char* name, ReservedSpace rs, CommitLimiter* commit_limiter)</span>
<span class="changed">  59 : _name(name),</span>
<span class="changed">  60   _first_node(NULL),</span>
<span class="changed">  61   _can_expand(false),</span>
<span class="changed">  62   _can_purge(false),</span>
<span class="changed">  63   _commit_limiter(commit_limiter),</span>
<span class="changed">  64   _reserved_words_counter(),</span>
<span class="changed">  65   _committed_words_counter()</span>
<span class="changed">  66 {</span>
<span class="changed">  67   // Create the first node spanning the existing ReservedSpace. This will be the only node created</span>
<span class="changed">  68   // for this list since we cannot expand.</span>
<span class="changed">  69   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(next_node_id++,</span>
<span class="changed">  70                                                         rs, _commit_limiter,</span>
<span class="changed">  71                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed">  72   assert(vsn != NULL, "node creation failed");</span>
<span class="changed">  73   _first_node = vsn;</span>
<span class="changed">  74   _first_node-&gt;set_next(NULL);</span>
<span class="changed">  75   _nodes_counter.increment();</span>
  76 }
  77 
<a name="8" id="anc8"></a><span class="changed">  78 VirtualSpaceList::~VirtualSpaceList() {</span>
<span class="changed">  79   // Note: normally, there is no reason ever to delete a vslist since they are</span>
<span class="changed">  80   // global objects, but for gtests it makes sense to allow this.</span>
<span class="changed">  81   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed">  82   VirtualSpaceNode* vsn2 = vsn;</span>
<span class="changed">  83   while (vsn != NULL) {</span>
<span class="changed">  84     vsn2 = vsn-&gt;next();</span>
<span class="changed">  85     delete vsn;</span>
<span class="changed">  86     vsn = vsn2;</span>
<span class="changed">  87   }</span>
  88 }
  89 
<a name="9" id="anc9"></a><span class="changed">  90 // Create a new node and append it to the list. After</span>
<span class="changed">  91 // this function, _current_node shall point to a new empty node.</span>
<span class="changed">  92 // List must be expandable for this to work.</span>
<span class="changed">  93 void VirtualSpaceList::create_new_node() {</span>
<span class="changed">  94   assert(_can_expand, "List is not expandable");</span>


  95   assert_lock_strong(MetaspaceExpand_lock);
<a name="10" id="anc10"></a>
  96 
<a name="11" id="anc11"></a><span class="changed">  97   VirtualSpaceNode* vsn = VirtualSpaceNode::create_node(next_node_id ++,</span>
<span class="changed">  98                                                         Settings::virtual_space_node_default_word_size(),</span>
<span class="changed">  99                                                         _commit_limiter,</span>
<span class="changed"> 100                                                         &amp;_reserved_words_counter, &amp;_committed_words_counter);</span>
<span class="changed"> 101   assert(vsn != NULL, "node creation failed");</span>
<span class="changed"> 102   vsn-&gt;set_next(_first_node);</span>
<span class="changed"> 103   _first_node = vsn;</span>
<span class="changed"> 104   _nodes_counter.increment();</span>
 105 }
<a name="12" id="anc12"></a>


 106 
<a name="13" id="anc13"></a><span class="changed"> 107 // Allocate a root chunk from this list.</span>
<span class="changed"> 108 // Note: this just returns a chunk whose memory is reserved; no memory is committed yet.</span>
<span class="changed"> 109 // Hence, before using this chunk, it must be committed.</span>
<span class="changed"> 110 // Also, no limits are checked, since no committing takes place.</span>
<span class="changed"> 111 Metachunk*  VirtualSpaceList::allocate_root_chunk() {</span>
 112   assert_lock_strong(MetaspaceExpand_lock);
<a name="14" id="anc14"></a>






 113 
<a name="15" id="anc15"></a><span class="changed"> 114   log_debug(metaspace)("VirtualSpaceList %s: allocate root chunk.", _name);</span>



























 115 
<a name="16" id="anc16"></a><span class="changed"> 116   if (_first_node == NULL ||</span>
<span class="changed"> 117       _first_node-&gt;free_words() == 0) {</span>








 118 
<a name="17" id="anc17"></a><span class="changed"> 119     // The current node is fully used up.</span>
<span class="changed"> 120     log_debug(metaspace)("VirtualSpaceList %s: need new node.", _name);</span>





 121 
<a name="18" id="anc18"></a><span class="new"> 122     // Since all allocations from a VirtualSpaceNode happen in</span>
<span class="new"> 123     // root-chunk-size units, and the node size must be root-chunk-size aligned,</span>
<span class="new"> 124     // we should never have left-over space.</span>
<span class="new"> 125     assert(_first_node == NULL ||</span>
<span class="new"> 126            _first_node-&gt;free_words() == 0, "Sanity");</span>
 127 
<a name="19" id="anc19"></a><span class="changed"> 128     if (_can_expand) {</span>
<span class="changed"> 129       create_new_node();</span>
<span class="changed"> 130     } else {</span>
<span class="changed"> 131       return NULL; // We cannot expand this list.</span>









 132     }
 133   }
<a name="20" id="anc20"></a>

 134 
<a name="21" id="anc21"></a><span class="changed"> 135   Metachunk* c = _first_node-&gt;allocate_root_chunk();</span>

 136 
<a name="22" id="anc22"></a><span class="changed"> 137   assert(c != NULL, "This should have worked");</span>
 138 
<a name="23" id="anc23"></a><span class="changed"> 139   return c;</span>

 140 
<a name="24" id="anc24"></a>
 141 }
 142 
<a name="25" id="anc25"></a><span class="changed"> 143 // Attempts to purge nodes. This will remove and delete nodes which only contain free chunks.</span>
<span class="changed"> 144 // The free chunks are removed from the freelists before the nodes are deleted.</span>
<span class="changed"> 145 // Return number of purged nodes.</span>
<span class="changed"> 146 int VirtualSpaceList::purge(FreeChunkListVector* freelists) {</span>




























 147 
<a name="26" id="anc26"></a><span class="changed"> 148   // Note: I am not sure all that purging business is even necessary anymore</span>
<span class="changed"> 149   // since we have a good reclaim mechanism in place. Need to measure.</span>

 150 
<a name="27" id="anc27"></a>

 151   assert_lock_strong(MetaspaceExpand_lock);
 152 
<a name="28" id="anc28"></a><span class="changed"> 153   if (_can_purge == false) {</span>
<span class="changed"> 154     log_debug(metaspace)("VirtualSpaceList %s: cannot purge this list.", _name);</span>
<span class="changed"> 155     return 0;</span>


 156   }
 157 
<a name="29" id="anc29"></a><span class="changed"> 158   log_debug(metaspace)("VirtualSpaceList %s: purging...", _name);</span>



 159 
<a name="30" id="anc30"></a><span class="changed"> 160   VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 161   VirtualSpaceNode* prev_vsn = NULL;</span>
<span class="changed"> 162   int num = 0, num_purged = 0;</span>
<span class="changed"> 163   while (vsn != NULL) {</span>
<span class="changed"> 164     VirtualSpaceNode* next_vsn = vsn-&gt;next();</span>
<span class="changed"> 165     bool purged = vsn-&gt;attempt_purge(freelists);</span>
<span class="changed"> 166     if (purged) {</span>
<span class="changed"> 167       // Note: from now on do not dereference vsn!</span>
<span class="changed"> 168       log_debug(metaspace)("VirtualSpaceList %s: purged node @" PTR_FORMAT, _name, p2i(vsn));</span>
<span class="changed"> 169       if (_first_node == vsn) {</span>
<span class="changed"> 170         _first_node = next_vsn;</span>
<span class="changed"> 171       }</span>
<span class="changed"> 172       DEBUG_ONLY(vsn = (VirtualSpaceNode*)((uintptr_t)(0xdeadbeef));)</span>
<span class="changed"> 173       if (prev_vsn != NULL) {</span>
<span class="changed"> 174         prev_vsn-&gt;set_next(next_vsn);</span>



 175       }
<a name="31" id="anc31"></a><span class="changed"> 176       num_purged ++;</span>
<span class="changed"> 177       _nodes_counter.decrement();</span>






 178     } else {
<a name="32" id="anc32"></a><span class="changed"> 179       prev_vsn = vsn;</span>
 180     }
<a name="33" id="anc33"></a><span class="changed"> 181     vsn = next_vsn;</span>
<span class="changed"> 182     num ++;</span>











 183   }
<a name="34" id="anc34"></a>





 184 
<a name="35" id="anc35"></a><span class="changed"> 185   log_debug(metaspace)("VirtualSpaceList %s: purged %d/%d nodes.", _name, num_purged, num);</span>
 186 
<a name="36" id="anc36"></a><span class="changed"> 187   return num_purged;</span>
 188 
<a name="37" id="anc37"></a>




 189 }
 190 
<a name="38" id="anc38"></a><span class="changed"> 191 // Print all nodes in this space list.</span>
<span class="changed"> 192 void VirtualSpaceList::print_on(outputStream* st) const {</span>
<span class="changed"> 193   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>



 194 
<a name="39" id="anc39"></a><span class="changed"> 195   st-&gt;print_cr("vsl %s:", _name);</span>
<span class="changed"> 196   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 197   int n = 0;</span>
<span class="changed"> 198   while (vsn != NULL) {</span>
<span class="changed"> 199     st-&gt;print("- node #%d: ", n);</span>
<span class="changed"> 200     vsn-&gt;print_on(st);</span>
<span class="changed"> 201     vsn = vsn-&gt;next();</span>
<span class="changed"> 202     n ++;</span>
 203   }
<a name="40" id="anc40"></a><span class="changed"> 204   st-&gt;print_cr("- total %d nodes, " SIZE_FORMAT " reserved words, " SIZE_FORMAT " committed words.",</span>
<span class="changed"> 205                n, reserved_words(), committed_words());</span>








































 206 }
 207 
<a name="41" id="anc41"></a><span class="changed"> 208 #ifdef ASSERT</span>
<span class="changed"> 209 void VirtualSpaceList::verify_locked(bool slow) const {</span>














 210 
<a name="42" id="anc42"></a><span class="new"> 211   assert_lock_strong(MetaspaceExpand_lock);</span>
 212 
<a name="43" id="anc43"></a><span class="changed"> 213   assert(_name != NULL, "Sanity");</span>
 214 
<a name="44" id="anc44"></a><span class="changed"> 215   int n = 0;</span>

 216 
<a name="45" id="anc45"></a><span class="changed"> 217   if (_first_node != NULL) {</span>


 218 
<a name="46" id="anc46"></a><span class="changed"> 219     size_t total_reserved_words = 0;</span>
<span class="changed"> 220     size_t total_committed_words = 0;</span>
<span class="changed"> 221     const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 222     while (vsn != NULL) {</span>
<span class="changed"> 223       n ++;</span>
<span class="changed"> 224       vsn-&gt;verify(slow);</span>
<span class="changed"> 225       total_reserved_words += vsn-&gt;word_size();</span>
<span class="changed"> 226       total_committed_words += vsn-&gt;committed_words();</span>
<span class="changed"> 227       vsn = vsn-&gt;next();</span>
<span class="changed"> 228     }</span>
<span class="changed"> 229 </span>
<span class="changed"> 230     _nodes_counter.check(n);</span>
<span class="changed"> 231     _reserved_words_counter.check(total_reserved_words);</span>
<span class="changed"> 232     _committed_words_counter.check(total_committed_words);</span>
 233 
<a name="47" id="anc47"></a><span class="changed"> 234   } else {</span>


 235 
<a name="48" id="anc48"></a><span class="changed"> 236     _reserved_words_counter.check(0);</span>
<span class="changed"> 237     _committed_words_counter.check(0);</span>




 238 
<a name="49" id="anc49"></a>



 239   }
<a name="50" id="anc50"></a><span class="new"> 240 }</span>
 241 
<a name="51" id="anc51"></a><span class="changed"> 242 void VirtualSpaceList::verify(bool slow) const {</span>
<span class="changed"> 243   MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 244   verify_locked(slow);</span>
 245 }
<a name="52" id="anc52"></a><span class="new"> 246 #endif</span>
 247 
<a name="53" id="anc53"></a><span class="changed"> 248 // Returns true if this pointer is contained in one of our nodes.</span>
<span class="changed"> 249 bool VirtualSpaceList::contains(const MetaWord* p) const {</span>
<span class="changed"> 250   const VirtualSpaceNode* vsn = _first_node;</span>
<span class="changed"> 251   while (vsn != NULL) {</span>
<span class="changed"> 252     if (vsn-&gt;contains(p)) {</span>
<span class="changed"> 253       return true;</span>


 254     }
<a name="54" id="anc54"></a><span class="new"> 255     vsn = vsn-&gt;next();</span>
<span class="new"> 256   }</span>
<span class="new"> 257   return false;</span>
 258 }
 259 
<a name="55" id="anc55"></a><span class="changed"> 260 // Returns true if the vslist is not expandable and no more root chunks</span>
<span class="changed"> 261 // can be allocated.</span>
<span class="changed"> 262 bool VirtualSpaceList::is_full() const {</span>
<span class="changed"> 263   if (!_can_expand &amp;&amp; _first_node != NULL &amp;&amp; _first_node-&gt;free_words() == 0) {</span>
<span class="changed"> 264     return true;</span>




 265   }
<a name="56" id="anc56"></a><span class="new"> 266   return false;</span>
 267 }
 268 
<a name="57" id="anc57"></a><span class="changed"> 269 VirtualSpaceList* VirtualSpaceList::_vslist_class = NULL;</span>
<span class="changed"> 270 VirtualSpaceList* VirtualSpaceList::_vslist_nonclass = NULL;</span>



 271 
<a name="58" id="anc58"></a><span class="new"> 272 void VirtualSpaceList::set_vslist_class(VirtualSpaceList* vsl) {</span>
<span class="new"> 273   assert(_vslist_class == NULL, "Sanity");</span>
<span class="new"> 274   _vslist_class = vsl;</span>
<span class="new"> 275 }</span>
 276 
<a name="59" id="anc59"></a><span class="changed"> 277 void VirtualSpaceList::set_vslist_nonclass(VirtualSpaceList* vsl) {</span>
<span class="changed"> 278   assert(_vslist_nonclass == NULL, "Sanity");</span>
<span class="changed"> 279   _vslist_nonclass = vsl;</span>























 280 }
<a name="60" id="anc60"></a>
 281 
 282 } // namespace metaspace
<a name="61" id="anc61"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="61" type="hidden" /></form></body></html>
