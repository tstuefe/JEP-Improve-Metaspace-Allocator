<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="new">   3  * Copyright (c) 2018, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  27 #define SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
  28 
  29 #include "memory/allocation.hpp"
  30 #include "memory/metaspace.hpp"
<a name="2" id="anc2"></a><span class="changed">  31 #include "memory/metaspace/chunkManager.hpp"</span>

  32 #include "memory/metaspace/metachunk.hpp"
<a name="3" id="anc3"></a><span class="changed">  33 #include "memory/metaspace/metachunkList.hpp"</span>
<span class="changed">  34 #include "memory/metaspace/metaspaceCommon.hpp"</span>
<span class="changed">  35 </span>
  36 
  37 class outputStream;
  38 class Mutex;
  39 
  40 namespace metaspace {
  41 
<a name="4" id="anc4"></a>




















  42 
<a name="5" id="anc5"></a><span class="changed">  43 class ArenaGrowthPolicy;</span>
<span class="changed">  44 class FreeBlocks;</span>
  45 
<a name="6" id="anc6"></a><span class="changed">  46 struct sm_stats_t;</span>

  47 
<a name="7" id="anc7"></a><span class="changed">  48 // The SpaceManager:</span>
<span class="changed">  49 // - keeps a list of chunks-in-use by the class loader, as well as a current chunk used</span>
<span class="changed">  50 //   to allocate from</span>
<span class="changed">  51 // - keeps a dictionary of free MetaBlocks. Those can be remnants of a retired chunk or</span>
<span class="changed">  52 //   allocations which were not needed anymore for some reason (e.g. releasing half-allocated</span>
<span class="changed">  53 //   structures when class loading fails)</span>
  54 
<a name="8" id="anc8"></a><span class="changed">  55 class SpaceManager : public CHeapObj&lt;mtClass&gt; {</span>


  56 
<a name="9" id="anc9"></a><span class="changed">  57   // Lock handed down from the associated ClassLoaderData.</span>
<span class="changed">  58   //  Protects allocations from this space.</span>
<span class="changed">  59   Mutex* const _lock;</span>





  60 
<a name="10" id="anc10"></a><span class="changed">  61   // The chunk manager to allocate chunks from.</span>
<span class="changed">  62   ChunkManager* const _chunk_manager;</span>



  63 
<a name="11" id="anc11"></a><span class="changed">  64   // The chunk allocation strategy to use.</span>
<span class="changed">  65   const ArenaGrowthPolicy* const _growth_policy;</span>

  66 
<a name="12" id="anc12"></a><span class="changed">  67   // List of chunks. Head of the list is the current chunk.</span>
<span class="changed">  68   MetachunkList _chunks;</span>
  69 
<a name="13" id="anc13"></a><span class="changed">  70   // Structure to take care of leftover/deallocated space in used chunks</span>
<span class="changed">  71   FreeBlocks* _fbl;</span>
  72 
<a name="14" id="anc14"></a><span class="changed">  73   Metachunk* current_chunk()              { return _chunks.first(); }</span>
<span class="changed">  74   const Metachunk* current_chunk() const  { return _chunks.first(); }</span>
  75 
<a name="15" id="anc15"></a><span class="changed">  76   // Points to outside size counter which we are to increase/decrease when we allocate memory</span>
<span class="changed">  77   // on behalf of a user or when we are destroyed.</span>
<span class="changed">  78   SizeAtomicCounter* const _total_used_words_counter;</span>

  79 
<a name="16" id="anc16"></a><span class="changed">  80   const char* const _name;</span>
  81 
<a name="17" id="anc17"></a><span class="changed">  82   // Whether or not this is a "micro loader" which is not expected to load more than one class.</span>
<span class="changed">  83   const bool _is_micro_loader;</span>

  84 
  85   Mutex* lock() const                           { return _lock; }
<a name="18" id="anc18"></a><span class="new">  86   ChunkManager* chunk_manager() const           { return _chunk_manager; }</span>
  87 
<a name="19" id="anc19"></a><span class="changed">  88   // free block list</span>
<span class="changed">  89   FreeBlocks* fbl() const                       { return _fbl; }</span>
<span class="changed">  90   void add_allocation_to_fbl(MetaWord* p, size_t word_size);</span>
<span class="changed">  91 </span>
<span class="changed">  92   // Given a chunk, add its remaining free committed space to the free block list.</span>
<span class="changed">  93   void salvage_chunk(Metachunk* c);</span>
<span class="changed">  94 </span>
<span class="changed">  95   // Allocate a new chunk from the underlying chunk manager able to hold at least</span>
<span class="changed">  96   // requested word size.</span>
<span class="changed">  97   Metachunk* allocate_new_chunk(size_t requested_word_size);</span>
<span class="changed">  98 </span>
<span class="changed">  99   // Returns the level of the next chunk to be added, acc to growth policy.</span>
<span class="changed"> 100   chunklevel_t next_chunk_level() const;</span>
<span class="changed"> 101 </span>
<span class="changed"> 102   // Attempt to enlarge the current chunk to make it large enough to hold at least</span>
<span class="changed"> 103   //  requested_word_size additional words.</span>
<span class="changed"> 104   //</span>
<span class="changed"> 105   // On success, true is returned, false otherwise.</span>
<span class="changed"> 106   bool attempt_enlarge_current_chunk(size_t requested_word_size);</span>
<span class="changed"> 107 </span>
<span class="changed"> 108   // Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="changed"> 109   // because it is not needed anymore (requires CLD lock to be active).</span>
<span class="changed"> 110   void deallocate_locked(MetaWord* p, size_t word_size);</span>
<span class="changed"> 111 </span>
<span class="changed"> 112   // Returns true if the area indicated by pointer and size have actually been allocated</span>
<span class="changed"> 113   // from this space manager.</span>
<span class="changed"> 114   DEBUG_ONLY(bool is_valid_area(MetaWord* p, size_t word_size) const;)</span>
<span class="changed"> 115 </span>
<span class="changed"> 116 public:</span>
<span class="changed"> 117 </span>
<span class="changed"> 118   SpaceManager(ChunkManager* chunk_manager,</span>
<span class="changed"> 119                const ArenaGrowthPolicy* growth_policy,</span>
<span class="changed"> 120                Mutex* lock,</span>
<span class="changed"> 121                SizeAtomicCounter* total_used_words_counter,</span>
<span class="changed"> 122                const char* name,</span>
<span class="changed"> 123                bool is_micro_loader);</span>
 124 
<a name="20" id="anc20"></a>






 125   ~SpaceManager();
 126 
<a name="21" id="anc21"></a><span class="changed"> 127   // Allocate memory from Metaspace.</span>
<span class="changed"> 128   // 1) Attempt to allocate from the dictionary of deallocated blocks.</span>
<span class="changed"> 129   // 2) Attempt to allocate from the current chunk.</span>
<span class="changed"> 130   // 3) Attempt to enlarge the current chunk in place if it is too small.</span>
<span class="changed"> 131   // 4) Attempt to get a new chunk and allocate from that chunk.</span>
<span class="changed"> 132   // At any point, if we hit a commit limit, we return NULL.</span>














































 133   MetaWord* allocate(size_t word_size);
 134 
<a name="22" id="anc22"></a><span class="changed"> 135   // Prematurely returns a metaspace allocation to the _block_freelists because it is not</span>
<span class="changed"> 136   // needed anymore.</span>


 137   void deallocate(MetaWord* p, size_t word_size);
 138 
<a name="23" id="anc23"></a><span class="changed"> 139   // Update statistics. This walks all in-use chunks.</span>
<span class="changed"> 140   void add_to_statistics(sm_stats_t* out) const;</span>









 141 
<a name="24" id="anc24"></a><span class="changed"> 142   DEBUG_ONLY(void verify(bool slow) const;)</span>
<span class="changed"> 143   DEBUG_ONLY(void verify_locked(bool slow) const;)</span>
 144 
 145   void print_on(outputStream* st) const;
<a name="25" id="anc25"></a><span class="changed"> 146   void print_on_locked(outputStream* st) const;</span>























 147 
 148 };
<a name="26" id="anc26"></a>
 149 
 150 } // namespace metaspace
 151 
 152 #endif // SHARE_MEMORY_METASPACE_SPACEMANAGER_HPP
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="27" type="hidden" /></form></body></html>
