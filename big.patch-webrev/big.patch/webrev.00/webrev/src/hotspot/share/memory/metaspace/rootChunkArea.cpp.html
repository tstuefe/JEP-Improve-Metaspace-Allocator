<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/hotspot/share/memory/metaspace/rootChunkArea.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2019 SAP SE. All rights reserved.
   3  * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "memory/allocation.hpp"
  29 #include "memory/metaspace/chunkHeaderPool.hpp"
  30 #include "memory/metaspace/chunkManager.hpp"
  31 #include "memory/metaspace/freeChunkList.hpp"
  32 #include "memory/metaspace/internStat.hpp"
  33 #include "memory/metaspace/metachunk.hpp"
  34 #include "memory/metaspace/metaspaceCommon.hpp"
  35 #include "memory/metaspace/rootChunkArea.hpp"
  36 #include "runtime/mutexLocker.hpp"
  37 #include "utilities/debug.hpp"
  38 #include "utilities/globalDefinitions.hpp"
  39 
  40 namespace metaspace {
  41 
  42 RootChunkArea::RootChunkArea(const MetaWord* base)
  43   : _base(base), _first_chunk(NULL)
  44 {}
  45 
  46 RootChunkArea::~RootChunkArea() {
  47   // This is called when a VirtualSpaceNode is destructed (purged).
  48   // All chunks should be free of course. In fact, there should only
  49   // be one chunk, since all free chunks should have been merged.
  50   if (_first_chunk != NULL) {
  51     assert(_first_chunk-&gt;is_root_chunk() &amp;&amp; _first_chunk-&gt;is_free(),
  52            "Cannot delete root chunk area if not all chunks are free.");
  53     ChunkHeaderPool::pool().return_chunk_header(_first_chunk);
  54   }
  55 }
  56 
  57 // Initialize: allocate a root node and a root chunk header; return the
  58 // root chunk header. It will be partly initialized.
  59 // Note: this just allocates a memory-less header; memory itself is allocated inside VirtualSpaceNode.
  60 Metachunk* RootChunkArea::alloc_root_chunk_header(VirtualSpaceNode* node) {
  61 
  62   assert(_first_chunk == 0, "already have a root");
  63 
  64   Metachunk* c = ChunkHeaderPool::pool().allocate_chunk_header();
  65   c-&gt;initialize(node, const_cast&lt;MetaWord*&gt;(_base), chunklevel::ROOT_CHUNK_LEVEL);
  66 
  67   _first_chunk = c;
  68 
  69   return c;
  70 
  71 }
  72 
  73 // Given a chunk c, split it recursively until you get a chunk of the given target_level.
  74 //
  75 // The resulting target chunk resides at the same address as the original chunk.
  76 // The resulting splinters are added to freelists.
  77 //
  78 // Returns pointer to the result chunk; the splitted-off chunks are added as
  79 //  free chunks to the freelists.
  80 void RootChunkArea::split(chunklevel_t target_level, Metachunk* c, FreeChunkListVector* freelists) {
  81 
  82   // Splitting a chunk once works like this:
  83   //
  84   // For a given chunk we want to split:
  85   // - increase the chunk level (which halves its size)
  86   // - (but leave base address as it is since it will be the leader of the newly
  87   //    created chunk pair)
  88   // - then create a new chunk header of the same level, set its memory range
  89   //   to cover the second halfof the old chunk.
  90   // - wire them up (prev_in_vs/next_in_vs)
  91   // - return the follower chunk as "splinter chunk" in the splinters array.
  92 
  93   // Doing this multiple times will create a new free splinter chunk for every
  94   // level we split:
  95   //
  96   // A  &lt;- original chunk
  97   //
  98   // B B  &lt;- split into two halves
  99   //
 100   // C C B  &lt;- first half split again
 101   //
 102   // D D C B  &lt;- first half split again ...
 103   //
 104 
 105   // As an optimization, since we usually do not split once but multiple times,
 106   // to not do each split separately, since we would have to wire up prev_in_vs/next_in_vs
 107   // on every level just to tear it open in the next level when we reintroduce a new
 108   // half chunk splinter.
 109   // Instead, just split split split and delay building up the double linked list of the
 110   // new chunks at the end of all splits.
 111 
 112   DEBUG_ONLY(check_pointer(c-&gt;base());)
 113   DEBUG_ONLY(c-&gt;verify(false);)
 114   assert(c-&gt;is_free(), "Can only split free chunks.");
 115 
 116   DEBUG_ONLY(chunklevel::check_valid_level(target_level));
 117   assert(target_level &gt; c-&gt;level(), "Wrong target level");
 118 
 119   const chunklevel_t starting_level = c-&gt;level();
 120 
 121   while (c-&gt;level() &lt; target_level) {
 122 
 123     log_trace(metaspace)("Splitting chunk: " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));
 124 
 125     c-&gt;inc_level();
 126     Metachunk* splinter_chunk = ChunkHeaderPool::pool().allocate_chunk_header();
 127     splinter_chunk-&gt;initialize(c-&gt;vsnode(), c-&gt;end(), c-&gt;level());
 128 
 129     // Fix committed words info: If over the half of the original chunk was
 130     // committed, committed area spills over into the follower chunk.
 131     const size_t old_committed_words = c-&gt;committed_words();
 132     if (old_committed_words &gt; c-&gt;word_size()) {
 133       c-&gt;set_committed_words(c-&gt;word_size());
 134       splinter_chunk-&gt;set_committed_words(old_committed_words - c-&gt;word_size());
 135     } else {
 136       splinter_chunk-&gt;set_committed_words(0);
 137     }
 138 
 139     // Insert splinter chunk into vs list
 140     if (c-&gt;next_in_vs() != NULL) {
 141       c-&gt;next_in_vs()-&gt;set_prev_in_vs(splinter_chunk);
 142     }
 143     splinter_chunk-&gt;set_next_in_vs(c-&gt;next_in_vs());
 144     splinter_chunk-&gt;set_prev_in_vs(c);
 145     c-&gt;set_next_in_vs(splinter_chunk);
 146 
 147     log_trace(metaspace)(".. Result chunk: " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));
 148     log_trace(metaspace)(".. Splinter chunk: " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(splinter_chunk));
 149 
 150     // Add splinter to free lists
 151     freelists-&gt;add(splinter_chunk);
 152 
 153     DEBUG_ONLY(InternalStats::inc_num_chunks_added_to_freelist_due_to_split();)
 154 
 155   }
 156 
 157   assert(c-&gt;level() == target_level, "Sanity");
 158 
 159   DEBUG_ONLY(verify(true);)
 160   DEBUG_ONLY(c-&gt;verify(true);)
 161 
 162   DEBUG_ONLY(InternalStats::inc_num_chunk_splits();)
 163 
 164 }
 165 
 166 
 167 // Given a chunk, attempt to merge it recursively with its neighboring chunks.
 168 //
 169 // If successful (merged at least once), returns address of
 170 // the merged chunk; NULL otherwise.
 171 //
 172 // The merged chunks are removed from the freelists.
 173 //
 174 // !!! Please note that if this method returns a non-NULL value, the
 175 // original chunk will be invalid and should not be accessed anymore! !!!
 176 Metachunk* RootChunkArea::merge(Metachunk* c, FreeChunkListVector* freelists) {
 177 
 178   // Note rules:
 179   //
 180   // - a chunk always has a buddy, unless it is a root chunk.
 181   // - In that buddy pair, a chunk is either leader or follower.
 182   // - a chunk's base address is always aligned at its size.
 183   // - if chunk is leader, its base address is also aligned to the size of the next
 184   //   lower level, at least. A follower chunk is not.
 185 
 186   // How we merge once:
 187   //
 188   // For a given chunk c, which has to be free and non-root, we do:
 189   // - find out if we are the leader or the follower chunk
 190   // - if we are leader, next_in_vs must be the follower; if we are follower,
 191   //   prev_in_vs must be the leader. Now we have the buddy chunk.
 192   // - However, if the buddy chunk itself is split (of a level higher than us)
 193   //   we cannot merge.
 194   // - we can only merge if the buddy is of the same level as we are and it is
 195   //   free.
 196   // - Then we merge by simply removing the follower chunk from the address range
 197   //   linked list (returning the now useless header to the pool) and decreasing
 198   //   the leader chunk level by one. That makes it double the size.
 199 
 200   // Example:
 201   // (lower case chunks are free, the * indicates the chunk we want to merge):
 202   //
 203   // ........................
 204   // d d*c   b       A           &lt;- we return the second (d*) chunk...
 205   //
 206   // c*  c   b       A           &lt;- we merge it with its predecessor and decrease its level...
 207   //
 208   // b*      b       A           &lt;- we merge it again, since its new neighbor was free too...
 209   //
 210   // a*              A           &lt;- we merge it again, since its new neighbor was free too...
 211   //
 212   // And we are done, since its new neighbor, (A), is not free. We would also be done
 213   // if the new neighbor itself is splintered.
 214 
 215   DEBUG_ONLY(check_pointer(c-&gt;base());)
 216   assert(!c-&gt;is_root_chunk(), "Cannot be merged further.");
 217   assert(c-&gt;is_free(), "Can only merge free chunks.");
 218 
 219   DEBUG_ONLY(c-&gt;verify(false);)
 220 
 221   log_trace(metaspace)("Attempting to merge chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 222 
 223   const chunklevel_t starting_level = c-&gt;level();
 224 
 225   bool stop = false;
 226   Metachunk* result = NULL;
 227 
 228   do {
 229 
 230     // First find out if this chunk is the leader of its pair
 231     const bool is_leader = c-&gt;is_leader();
 232 
 233     // Note: this is either our buddy or a splinter of the buddy.
 234     Metachunk* const buddy = c-&gt;is_leader() ? c-&gt;next_in_vs() : c-&gt;prev_in_vs();
 235     DEBUG_ONLY(buddy-&gt;verify(true);)
 236 
 237     // A buddy chunk must be of the same or higher level (so, same size or smaller)
 238     // never be larger.
 239     assert(buddy-&gt;level() &gt;= c-&gt;level(), "Sanity");
 240 
 241     // Is this really my buddy (same level) or a splinter of it (higher level)?
 242     // Also, is it free?
 243     if (buddy-&gt;level() != c-&gt;level() || buddy-&gt;is_free() == false) {
 244 
 245       log_trace(metaspace)("cannot merge with chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(buddy));
 246 
 247       stop = true;
 248 
 249     } else {
 250 
 251       log_trace(metaspace)("will merge with chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(buddy));
 252 
 253       // We can merge with the buddy.
 254 
 255       // First, remove buddy from the chunk manager.
 256       assert(buddy-&gt;is_free(), "Sanity");
 257       freelists-&gt;remove(buddy);
 258       DEBUG_ONLY(InternalStats::inc_num_chunks_removed_from_freelist_due_to_merge();)
 259 
 260       // Determine current leader and follower
 261       Metachunk* leader;
 262       Metachunk* follower;
 263       if (is_leader) {
 264         leader = c; follower = buddy;
 265       } else {
 266         leader = buddy; follower = c;
 267       }
 268 
 269       // Last checkpoint
 270       assert(leader-&gt;end() == follower-&gt;base() &amp;&amp;
 271              leader-&gt;level() == follower-&gt;level() &amp;&amp;
 272              leader-&gt;is_free() &amp;&amp; follower-&gt;is_free(), "Sanity");
 273 
 274       // The new merged chunk is as far committed as possible (if leader
 275       // chunk is fully committed, as far as the follower chunk).
 276       size_t merged_committed_words = leader-&gt;committed_words();
 277       if (merged_committed_words == leader-&gt;word_size()) {
 278         merged_committed_words += follower-&gt;committed_words();
 279       }
 280 
 281       // Leader survives, follower chunk is freed. Remove follower from vslist ..
 282       leader-&gt;set_next_in_vs(follower-&gt;next_in_vs());
 283       if (follower-&gt;next_in_vs() != NULL) {
 284         follower-&gt;next_in_vs()-&gt;set_prev_in_vs(leader);
 285       }
 286 
 287       // .. and return follower chunk header to pool for reuse.
 288       ChunkHeaderPool::pool().return_chunk_header(follower);
 289 
 290       // Leader level gets decreased (leader chunk doubles in size) but
 291       // base address stays the same.
 292       leader-&gt;dec_level();
 293 
 294       // set commit boundary
 295       leader-&gt;set_committed_words(merged_committed_words);
 296 
 297       // If the leader is now of root chunk size, stop merging
 298       if (leader-&gt;is_root_chunk()) {
 299         stop = true;
 300       }
 301 
 302       result = c = leader;
 303 
 304       DEBUG_ONLY(leader-&gt;verify(true);)
 305 
 306     }
 307 
 308   } while (!stop);
 309 
 310 #ifdef ASSERT
 311   verify(true);
 312   if (result != NULL) {
 313     result-&gt;verify(true);
 314     if (result-&gt;level() &lt; starting_level) {
 315       DEBUG_ONLY(InternalStats::inc_num_chunk_merges();)
 316     }
 317   }
 318 #endif // ASSERT
 319 
 320   return result;
 321 
 322 }
 323 
 324 // Given a chunk c, which must be "in use" and must not be a root chunk, attempt to
 325 // enlarge it in place by claiming its trailing buddy.
 326 //
 327 // This will only work if c is the leader of the buddy pair and the trailing buddy is free.
 328 //
 329 // If successful, the follower chunk will be removed from the freelists, the leader chunk c will
 330 // double in size (level decreased by one).
 331 //
 332 // On success, true is returned, false otherwise.
 333 bool RootChunkArea::attempt_enlarge_chunk(Metachunk* c, FreeChunkListVector* freelists) {
 334 
 335   DEBUG_ONLY(check_pointer(c-&gt;base());)
 336   assert(!c-&gt;is_root_chunk(), "Cannot be merged further.");
 337 
 338   // There is no real reason for this limitation other than it is not
 339   // needed on free chunks since they should be merged already:
 340   assert(c-&gt;is_in_use(), "Can only enlarge in use chunks.");
 341 
 342   DEBUG_ONLY(c-&gt;verify(false);)
 343 
 344   if (!c-&gt;is_leader()) {
 345     return false;
 346   }
 347 
 348   // We are the leader, so the buddy must follow us.
 349   Metachunk* const buddy = c-&gt;next_in_vs();
 350   DEBUG_ONLY(buddy-&gt;verify(true);)
 351 
 352   // Of course buddy cannot be larger than us.
 353   assert(buddy-&gt;level() &gt;= c-&gt;level(), "Sanity");
 354 
 355   // We cannot merge buddy in if it is not free...
 356   if (!buddy-&gt;is_free()) {
 357     return false;
 358   }
 359 
 360   // ... nor if it is splintered.
 361   if (buddy-&gt;level() != c-&gt;level()) {
 362     return false;
 363   }
 364 
 365   // Okay, lets enlarge c.
 366 
 367   log_trace(metaspace)("Enlarging chunk " METACHUNK_FULL_FORMAT " by merging in follower " METACHUNK_FULL_FORMAT ".",
 368                        METACHUNK_FULL_FORMAT_ARGS(c), METACHUNK_FULL_FORMAT_ARGS(buddy));
 369 
 370   // the enlarged c is as far committed as possible:
 371   size_t merged_committed_words = c-&gt;committed_words();
 372   if (merged_committed_words == c-&gt;word_size()) {
 373     merged_committed_words += buddy-&gt;committed_words();
 374   }
 375 
 376   // Remove buddy from vs list...
 377   Metachunk* successor = buddy-&gt;next_in_vs();
 378   if (successor != NULL) {
 379     successor-&gt;set_prev_in_vs(c);
 380   }
 381   c-&gt;set_next_in_vs(successor);
 382 
 383   // .. and from freelist ...
 384   freelists-&gt;remove(buddy);
 385 
 386   // .. and return its empty husk to the pool...
 387   ChunkHeaderPool::pool().return_chunk_header(buddy);
 388 
 389   // Then decrease level of c.
 390   c-&gt;dec_level();
 391 
 392   // and correct committed words if needed.
 393   c-&gt;set_committed_words(merged_committed_words);
 394 
 395   log_debug(metaspace)("Enlarged chunk " METACHUNK_FULL_FORMAT ".", METACHUNK_FULL_FORMAT_ARGS(c));
 396 //  log_debug(metaspace)("Enlarged chunk " METACHUNK_FORMAT ".", METACHUNK_FORMAT_ARGS(c));
 397 
 398   DEBUG_ONLY(verify(true));
 399 
 400   return true;
 401 
 402 }
 403 
 404 
 405 #ifdef ASSERT
 406 
 407 #define assrt_(cond, ...) \
 408   if (!(cond)) { \
 409     fdStream errst(2); \
 410     this-&gt;print_on(&amp;errst); \
 411     vmassert(cond, __VA_ARGS__); \
 412   }
 413 
 414 void RootChunkArea::verify(bool slow) const {
 415 
 416 
 417   assert_lock_strong(MetaspaceExpand_lock);
 418   assert_is_aligned(_base, chunklevel::MAX_CHUNK_BYTE_SIZE);
 419 
 420   // Iterate thru all chunks in this area. They must be ordered correctly,
 421   // being adjacent to each other, and cover the complete area
 422   int num_chunk = 0;
 423 
 424   if (_first_chunk != NULL) {
 425 
 426     assrt_(_first_chunk-&gt;prev_in_vs() == NULL, "Sanity");
 427 
 428     const Metachunk* c = _first_chunk;
 429     const MetaWord* expected_next_base = _base;
 430     const MetaWord* const area_end = _base + word_size();
 431 
 432     while (c != NULL) {
 433 
 434       assrt_(c-&gt;base() == expected_next_base,
 435              "Chunk No. %d " METACHUNK_FORMAT " - unexpected base.",
 436              num_chunk, METACHUNK_FORMAT_ARGS(c));
 437 
 438       assrt_(c-&gt;base() &gt;= base() &amp;&amp; c-&gt;end() &lt;= end(),
 439              "chunk %d " METACHUNK_FORMAT " oob for this root area [" PTR_FORMAT ".." PTR_FORMAT ").",
 440              num_chunk, METACHUNK_FORMAT_ARGS(c), p2i(base()), p2i(end()));
 441 
 442       assrt_(is_aligned(c-&gt;base(), c-&gt;word_size()),
 443              "misaligned chunk %d " METACHUNK_FORMAT ".", num_chunk, METACHUNK_FORMAT_ARGS(c));
 444 
 445       c-&gt;verify_neighborhood();
 446       c-&gt;verify(slow);
 447 
 448       expected_next_base = c-&gt;end();
 449       num_chunk ++;
 450 
 451       c = c-&gt;next_in_vs();
 452 
 453     }
 454     assrt_(expected_next_base == _base + word_size(), "Sanity");
 455   }
 456 
 457 }
 458 
 459 void RootChunkArea::verify_area_is_ideally_merged() const {
 460 
 461   SOMETIMES(assert_lock_strong(MetaspaceExpand_lock);)
 462 
 463   int num_chunk = 0;
 464   for (const Metachunk* c = _first_chunk; c != NULL; c = c-&gt;next_in_vs()) {
 465     if (!c-&gt;is_root_chunk() &amp;&amp; c-&gt;is_free()) {
 466       // If a chunk is free, it must not have a buddy which is also free, because
 467       // those chunks should have been merged.
 468       // In other words, a buddy shall be either in-use or splintered
 469       // (which in turn would mean part of it are in use).
 470       Metachunk* const buddy = c-&gt;is_leader() ? c-&gt;next_in_vs() : c-&gt;prev_in_vs();
 471       assrt_(buddy-&gt;is_in_use() || buddy-&gt;level() &gt; c-&gt;level(),
 472              "Chunk No. %d " METACHUNK_FORMAT " : missed merge opportunity with neighbor " METACHUNK_FORMAT ".",
 473              num_chunk, METACHUNK_FORMAT_ARGS(c), METACHUNK_FORMAT_ARGS(buddy));
 474     }
 475     num_chunk ++;
 476   }
 477 }
 478 
 479 #endif
 480 
 481 void RootChunkArea::print_on(outputStream* st) const {
 482 
 483   st-&gt;print(PTR_FORMAT ": ", p2i(base()));
 484   if (_first_chunk != NULL) {
 485     const Metachunk* c = _first_chunk;
 486     //                                    01234567890123
 487     const char* letters_for_levels_cap = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 488     const char* letters_for_levels =     "abcdefghijklmnopqrstuvwxyz";
 489     while (c != NULL) {
 490       const chunklevel_t l = c-&gt;level();
 491       if (l &gt;= 0 &amp;&amp; (size_t)l &lt; strlen(letters_for_levels)) {
 492 //        c-&gt;print_on(st); st-&gt;cr();
 493         st-&gt;print("%c", c-&gt;is_free() ? letters_for_levels[c-&gt;level()] : letters_for_levels_cap[c-&gt;level()]);
 494       } else {
 495         // Obviously garbage, but lets not crash.
 496         st-&gt;print("?");
 497       }
 498       c = c-&gt;next_in_vs();
 499     }
 500   } else {
 501     st-&gt;print(" (no chunks)");
 502   }
 503   st-&gt;cr();
 504 
 505 }
 506 
 507 
 508 // Create an array of ChunkTree objects, all initialized to NULL, covering
 509 // a given memory range. Memory range must be a multiple of root chunk size.
 510 RootChunkAreaLUT::RootChunkAreaLUT(const MetaWord* base, size_t word_size)
 511   : _base(base),
 512     _num((int)(word_size / chunklevel::MAX_CHUNK_WORD_SIZE)),
 513     _arr(NULL)
 514 {
 515   assert_is_aligned(word_size, chunklevel::MAX_CHUNK_WORD_SIZE);
 516   _arr = NEW_C_HEAP_ARRAY(RootChunkArea, _num, mtClass);
 517   const MetaWord* this_base = _base;
 518   for (int i = 0; i &lt; _num; i ++) {
 519     RootChunkArea* rca = new(_arr + i) RootChunkArea(this_base);
 520     assert(rca == _arr + i, "Sanity");
 521     this_base += chunklevel::MAX_CHUNK_WORD_SIZE;
 522   }
 523 }
 524 
 525 RootChunkAreaLUT::~RootChunkAreaLUT() {
 526   for (int i = 0; i &lt; _num; i ++) {
 527     _arr[i].~RootChunkArea();
 528   }
 529   FREE_C_HEAP_ARRAY(RootChunkArea, _arr);
 530 }
 531 
 532 #ifdef ASSERT
 533 
 534 void RootChunkAreaLUT::verify(bool slow) const {
 535   for (int i = 0; i &lt; _num; i ++) {
 536     check_pointer(_arr[i].base());
 537     _arr[i].verify(slow);
 538   }
 539 }
 540 
 541 #endif
 542 
 543 void RootChunkAreaLUT::print_on(outputStream* st) const {
 544   for (int i = 0; i &lt; _num; i ++) {
 545     st-&gt;print("%2d:", i);
 546     _arr[i].print_on(st);
 547   }
 548 }
 549 
 550 
 551 } // end: namespace metaspace
</pre></body></html>
