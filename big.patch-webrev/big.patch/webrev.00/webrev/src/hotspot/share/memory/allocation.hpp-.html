<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/hotspot/share/memory/allocation.hpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_MEMORY_ALLOCATION_HPP
  26 #define SHARE_MEMORY_ALLOCATION_HPP
  27 
  28 #include "utilities/globalDefinitions.hpp"
  29 #include "utilities/macros.hpp"
  30 
  31 #include &lt;new&gt;
  32 
  33 class outputStream;
  34 class Thread;
  35 
  36 class AllocFailStrategy {
  37 public:
  38   enum AllocFailEnum { EXIT_OOM, RETURN_NULL };
  39 };
  40 typedef AllocFailStrategy::AllocFailEnum AllocFailType;
  41 
  42 // The virtual machine must never call one of the implicitly declared
  43 // global allocation or deletion functions.  (Such calls may result in
  44 // link-time or run-time errors.)  For convenience and documentation of
  45 // intended use, classes in the virtual machine may be derived from one
  46 // of the following allocation classes, some of which define allocation
  47 // and deletion functions.
  48 // Note: std::malloc and std::free should never called directly.
  49 
  50 //
  51 // For objects allocated in the resource area (see resourceArea.hpp).
  52 // - ResourceObj
  53 //
  54 // For objects allocated in the C-heap (managed by: free &amp; malloc and tracked with NMT)
  55 // - CHeapObj
  56 //
  57 // For objects allocated on the stack.
  58 // - StackObj
  59 //
  60 // For classes used as name spaces.
  61 // - AllStatic
  62 //
  63 // For classes in Metaspace (class data)
  64 // - MetaspaceObj
  65 //
  66 // The printable subclasses are used for debugging and define virtual
  67 // member functions for printing. Classes that avoid allocating the
  68 // vtbl entries in the objects should therefore not be the printable
  69 // subclasses.
  70 //
  71 // The following macros and function should be used to allocate memory
  72 // directly in the resource area or in the C-heap, The _OBJ variants
  73 // of the NEW/FREE_C_HEAP macros are used for alloc/dealloc simple
  74 // objects which are not inherited from CHeapObj, note constructor and
  75 // destructor are not called. The preferable way to allocate objects
  76 // is using the new operator.
  77 //
  78 // WARNING: The array variant must only be used for a homogenous array
  79 // where all objects are of the exact type specified. If subtypes are
  80 // stored in the array then must pay attention to calling destructors
  81 // at needed.
  82 //
  83 // NEW_RESOURCE_ARRAY*
  84 // REALLOC_RESOURCE_ARRAY*
  85 // FREE_RESOURCE_ARRAY*
  86 // NEW_RESOURCE_OBJ*
  87 // NEW_C_HEAP_ARRAY*
  88 // REALLOC_C_HEAP_ARRAY*
  89 // FREE_C_HEAP_ARRAY*
  90 // NEW_C_HEAP_OBJ*
  91 // FREE_C_HEAP_OBJ
  92 //
  93 // char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack&amp; stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
  94 // char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
  95 // char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
  96 // void FreeHeap(void* p);
  97 //
  98 // In non product mode we introduce a super class for all allocation classes
  99 // that supports printing.
 100 // We avoid the superclass in product mode to save space.
 101 
 102 #ifdef PRODUCT
 103 #define ALLOCATION_SUPER_CLASS_SPEC
 104 #else
 105 #define ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj
 106 class AllocatedObj {
 107  public:
 108   // Printing support
 109   void print() const;
 110   void print_value() const;
 111 
 112   virtual void print_on(outputStream* st) const;
 113   virtual void print_value_on(outputStream* st) const;
 114 };
 115 #endif
 116 
 117 #define MEMORY_TYPES_DO(f)                                                           \
 118   /* Memory type by sub systems. It occupies lower byte. */                          \
 119   f(mtJavaHeap,       "Java Heap")   /* Java heap                                 */ \
 120   f(mtClass,          "Class")       /* Java classes                              */ \
 121   f(mtThread,         "Thread")      /* thread objects                            */ \
 122   f(mtThreadStack,    "Thread Stack")                                                \
 123   f(mtCode,           "Code")        /* generated code                            */ \
 124   f(mtGC,             "GC")                                                          \
 125   f(mtCompiler,       "Compiler")                                                    \
 126   f(mtJVMCI,          "JVMCI")                                                       \
 127   f(mtInternal,       "Internal")    /* memory used by VM, but does not belong to */ \
 128                                      /* any of above categories, and not used by  */ \
 129                                      /* NMT                                       */ \
 130   f(mtOther,          "Other")       /* memory not used by VM                     */ \
 131   f(mtSymbol,         "Symbol")                                                      \
 132   f(mtNMT,            "Native Memory Tracking")  /* memory used by NMT            */ \
 133   f(mtClassShared,    "Shared class space")      /* class data sharing            */ \
 134   f(mtChunk,          "Arena Chunk") /* chunk that holds content of arenas        */ \
 135   f(mtTest,           "Test")        /* Test type for verifying NMT               */ \
 136   f(mtTracing,        "Tracing")                                                     \
 137   f(mtLogging,        "Logging")                                                     \
 138   f(mtStatistics,     "Statistics")                                                  \
 139   f(mtArguments,      "Arguments")                                                   \
 140   f(mtModule,         "Module")                                                      \
 141   f(mtSafepoint,      "Safepoint")                                                   \
 142   f(mtSynchronizer,   "Synchronization")                                             \
 143   f(mtServiceability, "Serviceability")                                              \
 144   f(mtNone,           "Unknown")                                                     \
 145   //end
 146 
 147 #define MEMORY_TYPE_DECLARE_ENUM(type, human_readable) \
 148   type,
 149 
 150 /*
 151  * Memory types
 152  */
 153 enum MemoryType {
 154   MEMORY_TYPES_DO(MEMORY_TYPE_DECLARE_ENUM)
 155   mt_number_of_types   // number of memory types (mtDontTrack
 156                        // is not included as validate type)
 157 };
 158 
 159 typedef MemoryType MEMFLAGS;
 160 
 161 
 162 #if INCLUDE_NMT
 163 
 164 extern bool NMT_track_callsite;
 165 
 166 #else
 167 
 168 const bool NMT_track_callsite = false;
 169 
 170 #endif // INCLUDE_NMT
 171 
 172 class NativeCallStack;
 173 
 174 
 175 char* AllocateHeap(size_t size,
 176                    MEMFLAGS flags,
 177                    const NativeCallStack&amp; stack,
 178                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 179 char* AllocateHeap(size_t size,
 180                    MEMFLAGS flags,
 181                    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 182 
 183 char* ReallocateHeap(char *old,
 184                      size_t size,
 185                      MEMFLAGS flag,
 186                      AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 187 
 188 // handles NULL pointers
 189 void FreeHeap(void* p);
 190 
 191 template &lt;MEMFLAGS F&gt; class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {
 192  public:
 193   ALWAYSINLINE void* operator new(size_t size) throw() {
 194     return (void*)AllocateHeap(size, F);
 195   }
 196 
 197   ALWAYSINLINE void* operator new(size_t size,
 198                                   const NativeCallStack&amp; stack) throw() {
 199     return (void*)AllocateHeap(size, F, stack);
 200   }
 201 
 202   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;,
 203                                   const NativeCallStack&amp; stack) throw() {
 204     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
 205   }
 206 
 207   ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&amp;) throw() {
 208     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
 209   }
 210 
 211   ALWAYSINLINE void* operator new[](size_t size) throw() {
 212     return (void*)AllocateHeap(size, F);
 213   }
 214 
 215   ALWAYSINLINE void* operator new[](size_t size,
 216                                   const NativeCallStack&amp; stack) throw() {
 217     return (void*)AllocateHeap(size, F, stack);
 218   }
 219 
 220   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;,
 221                                     const NativeCallStack&amp; stack) throw() {
 222     return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);
 223   }
 224 
 225   ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&amp;) throw() {
 226     return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);
 227   }
 228 
 229   void  operator delete(void* p)     { FreeHeap(p); }
 230   void  operator delete [] (void* p) { FreeHeap(p); }
 231 };
 232 
 233 // Base class for objects allocated on the stack only.
 234 // Calling new or delete will result in fatal error.
 235 
 236 class StackObj ALLOCATION_SUPER_CLASS_SPEC {
 237  private:
 238   void* operator new(size_t size) throw();
 239   void* operator new [](size_t size) throw();
 240   void  operator delete(void* p);
 241   void  operator delete [](void* p);
 242 };
 243 
 244 // Base class for objects stored in Metaspace.
 245 // Calling delete will result in fatal error.
 246 //
 247 // Do not inherit from something with a vptr because this class does
 248 // not introduce one.  This class is used to allocate both shared read-only
 249 // and shared read-write classes.
 250 //
 251 
 252 class ClassLoaderData;
 253 class MetaspaceClosure;
 254 
 255 class MetaspaceObj {
 256   friend class VMStructs;
 257   // When CDS is enabled, all shared metaspace objects are mapped
 258   // into a single contiguous memory block, so we can use these
 259   // two pointers to quickly determine if something is in the
 260   // shared metaspace.
 261   // When CDS is not enabled, both pointers are set to NULL.
 262   static void* _shared_metaspace_base;  // (inclusive) low address
 263   static void* _shared_metaspace_top;   // (exclusive) high address
 264 
 265  public:
 266 
 267   // Returns true if the pointer points to a valid MetaspaceObj. A valid
 268   // MetaspaceObj is MetaWord-aligned and contained within either
 269   // non-shared or shared metaspace.
 270   static bool is_valid(const MetaspaceObj* p);
 271 
 272   static bool is_shared(const MetaspaceObj* p) {
 273     // If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will
 274     // both be NULL and all values of p will be rejected quickly.
 275     return (((void*)p) &lt; _shared_metaspace_top &amp;&amp;
 276             ((void*)p) &gt;= _shared_metaspace_base);
 277   }
 278   bool is_shared() const { return MetaspaceObj::is_shared(this); }
 279 
 280   void print_address_on(outputStream* st) const;  // nonvirtual address printing
 281 
 282   static void set_shared_metaspace_range(void* base, void* top) {
 283     _shared_metaspace_base = base;
 284     _shared_metaspace_top = top;
 285   }
 286 
 287   static void* shared_metaspace_base() { return _shared_metaspace_base; }
 288   static void* shared_metaspace_top()  { return _shared_metaspace_top;  }
 289 
 290 #define METASPACE_OBJ_TYPES_DO(f) \
 291   f(Class) \
 292   f(Symbol) \
 293   f(TypeArrayU1) \
 294   f(TypeArrayU2) \
 295   f(TypeArrayU4) \
 296   f(TypeArrayU8) \
 297   f(TypeArrayOther) \
 298   f(Method) \
 299   f(ConstMethod) \
 300   f(MethodData) \
 301   f(ConstantPool) \
 302   f(ConstantPoolCache) \
 303   f(Annotations) \
 304   f(MethodCounters) \
 305   f(RecordComponent)
 306 
 307 #define METASPACE_OBJ_TYPE_DECLARE(name) name ## Type,
 308 #define METASPACE_OBJ_TYPE_NAME_CASE(name) case name ## Type: return #name;
 309 
 310   enum Type {
 311     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
 312     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
 313     _number_of_types
 314   };
 315 
 316   static const char * type_name(Type type) {
 317     switch(type) {
 318     METASPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
 319     default:
 320       ShouldNotReachHere();
 321       return NULL;
 322     }
 323   }
 324 
 325   static MetaspaceObj::Type array_type(size_t elem_size) {
 326     switch (elem_size) {
 327     case 1: return TypeArrayU1Type;
 328     case 2: return TypeArrayU2Type;
 329     case 4: return TypeArrayU4Type;
 330     case 8: return TypeArrayU8Type;
 331     default:
 332       return TypeArrayOtherType;
 333     }
 334   }
 335 
 336   void* operator new(size_t size, ClassLoaderData* loader_data,
 337                      size_t word_size,
 338                      Type type, Thread* thread) throw();
 339                      // can't use TRAPS from this header file.
 340   void operator delete(void* p) { ShouldNotCallThis(); }
 341 
 342   // Declare a *static* method with the same signature in any subclass of MetaspaceObj
 343   // that should be read-only by default. See symbol.hpp for an example. This function
 344   // is used by the templates in metaspaceClosure.hpp
 345   static bool is_read_only_by_default() { return false; }
 346 };
 347 
 348 // Base class for classes that constitute name spaces.
 349 
 350 class Arena;
 351 
 352 class AllStatic {
 353  public:
 354   AllStatic()  { ShouldNotCallThis(); }
 355   ~AllStatic() { ShouldNotCallThis(); }
 356 };
 357 
 358 
 359 extern char* resource_allocate_bytes(size_t size,
 360     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 361 extern char* resource_allocate_bytes(Thread* thread, size_t size,
 362     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 363 extern char* resource_reallocate_bytes( char *old, size_t old_size, size_t new_size,
 364     AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);
 365 extern void resource_free_bytes( char *old, size_t size );
 366 
 367 //----------------------------------------------------------------------
 368 // Base class for objects allocated in the resource area per default.
 369 // Optionally, objects may be allocated on the C heap with
 370 // new(ResourceObj::C_HEAP) Foo(...) or in an Arena with new (&amp;arena)
 371 // ResourceObj's can be allocated within other objects, but don't use
 372 // new or delete (allocation_type is unknown).  If new is used to allocate,
 373 // use delete to deallocate.
 374 class ResourceObj ALLOCATION_SUPER_CLASS_SPEC {
 375  public:
 376   enum allocation_type { STACK_OR_EMBEDDED = 0, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = 0x3 };
 377   static void set_allocation_type(address res, allocation_type type) NOT_DEBUG_RETURN;
 378 #ifdef ASSERT
 379  private:
 380   // When this object is allocated on stack the new() operator is not
 381   // called but garbage on stack may look like a valid allocation_type.
 382   // Store negated 'this' pointer when new() is called to distinguish cases.
 383   // Use second array's element for verification value to distinguish garbage.
 384   uintptr_t _allocation_t[2];
 385   bool is_type_set() const;
 386   void initialize_allocation_info();
 387  public:
 388   allocation_type get_allocation_type() const;
 389   bool allocated_on_stack()    const { return get_allocation_type() == STACK_OR_EMBEDDED; }
 390   bool allocated_on_res_area() const { return get_allocation_type() == RESOURCE_AREA; }
 391   bool allocated_on_C_heap()   const { return get_allocation_type() == C_HEAP; }
 392   bool allocated_on_arena()    const { return get_allocation_type() == ARENA; }
 393 protected:
 394   ResourceObj(); // default constructor
 395   ResourceObj(const ResourceObj&amp; r); // default copy constructor
 396   ResourceObj&amp; operator=(const ResourceObj&amp; r); // default copy assignment
 397   ~ResourceObj();
 398 #endif // ASSERT
 399 
 400  public:
 401   void* operator new(size_t size, allocation_type type, MEMFLAGS flags) throw();
 402   void* operator new [](size_t size, allocation_type type, MEMFLAGS flags) throw();
 403   void* operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant,
 404       allocation_type type, MEMFLAGS flags) throw();
 405   void* operator new [](size_t size, const std::nothrow_t&amp;  nothrow_constant,
 406       allocation_type type, MEMFLAGS flags) throw();
 407 
 408   void* operator new(size_t size, Arena *arena) throw();
 409 
 410   void* operator new [](size_t size, Arena *arena) throw();
 411 
 412   void* operator new(size_t size) throw() {
 413       address res = (address)resource_allocate_bytes(size);
 414       DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)
 415       return res;
 416   }
 417 
 418   void* operator new(size_t size, const std::nothrow_t&amp; nothrow_constant) throw() {
 419       address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);
 420       DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)
 421       return res;
 422   }
 423 
 424   void* operator new [](size_t size) throw() {
 425       address res = (address)resource_allocate_bytes(size);
 426       DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)
 427       return res;
 428   }
 429 
 430   void* operator new [](size_t size, const std::nothrow_t&amp; nothrow_constant) throw() {
 431       address res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);
 432       DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)
 433       return res;
 434   }
 435 
 436   void  operator delete(void* p);
 437   void  operator delete [](void* p);
 438 };
 439 
 440 // One of the following macros must be used when allocating an array
 441 // or object to determine whether it should reside in the C heap on in
 442 // the resource area.
 443 
 444 #define NEW_RESOURCE_ARRAY(type, size)\
 445   (type*) resource_allocate_bytes((size) * sizeof(type))
 446 
 447 #define NEW_RESOURCE_ARRAY_RETURN_NULL(type, size)\
 448   (type*) resource_allocate_bytes((size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
 449 
 450 #define NEW_RESOURCE_ARRAY_IN_THREAD(thread, type, size)\
 451   (type*) resource_allocate_bytes(thread, (size) * sizeof(type))
 452 
 453 #define NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(thread, type, size)\
 454   (type*) resource_allocate_bytes(thread, (size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
 455 
 456 #define REALLOC_RESOURCE_ARRAY(type, old, old_size, new_size)\
 457   (type*) resource_reallocate_bytes((char*)(old), (old_size) * sizeof(type), (new_size) * sizeof(type))
 458 
 459 #define REALLOC_RESOURCE_ARRAY_RETURN_NULL(type, old, old_size, new_size)\
 460   (type*) resource_reallocate_bytes((char*)(old), (old_size) * sizeof(type),\
 461                                     (new_size) * sizeof(type), AllocFailStrategy::RETURN_NULL)
 462 
 463 #define FREE_RESOURCE_ARRAY(type, old, size)\
 464   resource_free_bytes((char*)(old), (size) * sizeof(type))
 465 
 466 #define FREE_FAST(old)\
 467     /* nop */
 468 
 469 #define NEW_RESOURCE_OBJ(type)\
 470   NEW_RESOURCE_ARRAY(type, 1)
 471 
 472 #define NEW_RESOURCE_OBJ_RETURN_NULL(type)\
 473   NEW_RESOURCE_ARRAY_RETURN_NULL(type, 1)
 474 
 475 #define NEW_C_HEAP_ARRAY3(type, size, memflags, pc, allocfail)\
 476   (type*) AllocateHeap((size) * sizeof(type), memflags, pc, allocfail)
 477 
 478 #define NEW_C_HEAP_ARRAY2(type, size, memflags, pc)\
 479   (type*) (AllocateHeap((size) * sizeof(type), memflags, pc))
 480 
 481 #define NEW_C_HEAP_ARRAY(type, size, memflags)\
 482   (type*) (AllocateHeap((size) * sizeof(type), memflags))
 483 
 484 #define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, memflags, pc)\
 485   NEW_C_HEAP_ARRAY3(type, (size), memflags, pc, AllocFailStrategy::RETURN_NULL)
 486 
 487 #define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, memflags)\
 488   NEW_C_HEAP_ARRAY3(type, (size), memflags, CURRENT_PC, AllocFailStrategy::RETURN_NULL)
 489 
 490 #define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\
 491   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))
 492 
 493 #define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\
 494   (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))
 495 
 496 #define FREE_C_HEAP_ARRAY(type, old) \
 497   FreeHeap((char*)(old))
 498 
 499 // allocate type in heap without calling ctor
 500 #define NEW_C_HEAP_OBJ(type, memflags)\
 501   NEW_C_HEAP_ARRAY(type, 1, memflags)
 502 
 503 #define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\
 504   NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)
 505 
 506 // deallocate obj of type in heap without calling dtor
 507 #define FREE_C_HEAP_OBJ(objname)\
 508   FreeHeap((char*)objname);
 509 
 510 
 511 //------------------------------ReallocMark---------------------------------
 512 // Code which uses REALLOC_RESOURCE_ARRAY should check an associated
 513 // ReallocMark, which is declared in the same scope as the reallocated
 514 // pointer.  Any operation that could __potentially__ cause a reallocation
 515 // should check the ReallocMark.
 516 class ReallocMark: public StackObj {
 517 protected:
 518   NOT_PRODUCT(int _nesting;)
 519 
 520 public:
 521   ReallocMark()   PRODUCT_RETURN;
 522   void check()    PRODUCT_RETURN;
 523 };
 524 
 525 // Helper class to allocate arrays that may become large.
 526 // Uses the OS malloc for allocations smaller than ArrayAllocatorMallocLimit
 527 // and uses mapped memory for larger allocations.
 528 // Most OS mallocs do something similar but Solaris malloc does not revert
 529 // to mapped memory for large allocations. By default ArrayAllocatorMallocLimit
 530 // is set so that we always use malloc except for Solaris where we set the
 531 // limit to get mapped memory.
 532 template &lt;class E&gt;
 533 class ArrayAllocator : public AllStatic {
 534  private:
 535   static bool should_use_malloc(size_t length);
 536 
 537   static E* allocate_malloc(size_t length, MEMFLAGS flags);
 538   static E* allocate_mmap(size_t length, MEMFLAGS flags);
 539 
 540   static void free_malloc(E* addr, size_t length);
 541   static void free_mmap(E* addr, size_t length);
 542 
 543  public:
 544   static E* allocate(size_t length, MEMFLAGS flags);
 545   static E* reallocate(E* old_addr, size_t old_length, size_t new_length, MEMFLAGS flags);
 546   static void free(E* addr, size_t length);
 547 };
 548 
 549 // Uses mmaped memory for all allocations. All allocations are initially
 550 // zero-filled. No pre-touching.
 551 template &lt;class E&gt;
 552 class MmapArrayAllocator : public AllStatic {
 553  private:
 554   static size_t size_for(size_t length);
 555 
 556  public:
 557   static E* allocate_or_null(size_t length, MEMFLAGS flags);
 558   static E* allocate(size_t length, MEMFLAGS flags);
 559   static void free(E* addr, size_t length);
 560 };
 561 
 562 // Uses malloc:ed memory for all allocations.
 563 template &lt;class E&gt;
 564 class MallocArrayAllocator : public AllStatic {
 565  public:
 566   static size_t size_for(size_t length);
 567 
 568   static E* allocate(size_t length, MEMFLAGS flags);
 569   static void free(E* addr);
 570 };
 571 
 572 #endif // SHARE_MEMORY_ALLOCATION_HPP
</pre></body></html>
