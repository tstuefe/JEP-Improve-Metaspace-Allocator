<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-60221">60221</a> : imported patch big.patch</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="new">   3  * Copyright (c) 2018, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 #include "precompiled.hpp"
  26 
  27 #include "logging/log.hpp"
  28 #include "logging/logStream.hpp"
<a name="2" id="anc2"></a><span class="new">  29 #include "memory/metaspace/allocationGuard.hpp"</span>
<span class="new">  30 #include "memory/metaspace/arenaGrowthPolicy.hpp"</span>
<span class="new">  31 #include "memory/metaspace/freeBlocks.hpp"</span>
  32 #include "memory/metaspace/chunkManager.hpp"
<a name="3" id="anc3"></a><span class="new">  33 #include "memory/metaspace/internStat.hpp"</span>
  34 #include "memory/metaspace/metachunk.hpp"
<a name="4" id="anc4"></a>
  35 #include "memory/metaspace/metaspaceCommon.hpp"
<a name="5" id="anc5"></a><span class="new">  36 #include "memory/metaspace/metaspaceStatistics.hpp"</span>
  37 #include "memory/metaspace/spaceManager.hpp"
  38 #include "memory/metaspace/virtualSpaceList.hpp"
  39 #include "runtime/atomic.hpp"
  40 #include "runtime/init.hpp"
  41 #include "services/memoryService.hpp"
<a name="6" id="anc6"></a><span class="new">  42 #include "utilities/align.hpp"</span>
  43 #include "utilities/debug.hpp"
  44 #include "utilities/globalDefinitions.hpp"
  45 
  46 namespace metaspace {
  47 
<a name="7" id="anc7"></a><span class="changed">  48 #define LOGFMT_SPCMGR         "SpcMgr @" PTR_FORMAT " (%s)"</span>
<span class="changed">  49 #define LOGFMT_SPCMGR_ARGS    p2i(this), this-&gt;_name</span>



  50 
<a name="8" id="anc8"></a><span class="changed">  51 // Given a net allocation word size, return the raw word size we actually allocate.</span>
<span class="changed">  52 // Note: externally visible for gtests.</span>
<span class="changed">  53 //static</span>
<span class="changed">  54 size_t get_raw_allocation_word_size(size_t net_word_size) {</span>
  55 
<a name="9" id="anc9"></a><span class="changed">  56   size_t byte_size = net_word_size * BytesPerWord;</span>





  57 
<a name="10" id="anc10"></a><span class="changed">  58   // Deallocated metablocks are kept in a binlist which limits their minimal</span>
<span class="changed">  59   //  size to at least the size of a binlist item (2 words).</span>
<span class="changed">  60   byte_size = MAX2(byte_size, FreeBlocks::minimal_word_size * BytesPerWord);</span>
<span class="changed">  61 </span>
<span class="changed">  62   // Metaspace allocations are aligned to word size.</span>
<span class="changed">  63   byte_size = align_up(byte_size, allocation_alignment_bytes);</span>
<span class="changed">  64 </span>
<span class="changed">  65   // If we guard allocations, we need additional space for a prefix.</span>
<span class="changed">  66 #ifdef ASSERT</span>
<span class="changed">  67   if (Settings::use_allocation_guard()) {</span>
<span class="changed">  68     byte_size += align_up(prefix_size(), allocation_alignment_bytes);</span>
  69   }
<a name="11" id="anc11"></a><span class="new">  70 #endif</span>
<span class="new">  71 </span>
<span class="new">  72   size_t word_size = byte_size / BytesPerWord;</span>
<span class="new">  73 </span>
<span class="new">  74   assert(word_size * BytesPerWord == byte_size, "Sanity");</span>
<span class="new">  75 </span>
<span class="new">  76   return word_size;</span>
  77 
<a name="12" id="anc12"></a>

  78 }
  79 
<a name="13" id="anc13"></a><span class="changed">  80 // Returns the level of the next chunk to be added, acc to growth policy.</span>
<span class="changed">  81 chunklevel_t SpaceManager::next_chunk_level() const {</span>
<span class="changed">  82   const int growth_step = _chunks.count();</span>
<span class="changed">  83   return _growth_policy-&gt;get_level_at_step(growth_step);</span>
  84 }
  85 
<a name="14" id="anc14"></a><span class="changed">  86 // Given a chunk, add its remaining free committed space to the free block list.</span>
<span class="changed">  87 void SpaceManager::salvage_chunk(Metachunk* c) {</span>
  88 
<a name="15" id="anc15"></a><span class="changed">  89   if (Settings::handle_deallocations() == false) {</span>
<span class="changed">  90     return;</span>











  91   }
<a name="16" id="anc16"></a><span class="new">  92 </span>
<span class="new">  93   assert_lock_strong(lock());</span>
<span class="new">  94 </span>
<span class="new">  95   // If the chunk is completely empty, just return it to the chunk manager.</span>
<span class="new">  96   if (c-&gt;used_words() == 0) {</span>
<span class="new">  97     _chunk_manager-&gt;return_chunk(c);</span>
<span class="new">  98     return;</span>
  99   }
 100 
<a name="17" id="anc17"></a><span class="changed"> 101   size_t remaining_words = c-&gt;free_below_committed_words();</span>

 102 
<a name="18" id="anc18"></a><span class="changed"> 103   if (remaining_words &gt; FreeBlocks::minimal_word_size) {</span>

 104 
<a name="19" id="anc19"></a><span class="changed"> 105     log_debug(metaspace)(LOGFMT_SPCMGR " @" PTR_FORMAT " : salvaging chunk " METACHUNK_FULL_FORMAT ".",</span>
<span class="changed"> 106                          LOGFMT_SPCMGR_ARGS, p2i(this), METACHUNK_FULL_FORMAT_ARGS(c));</span>
<span class="changed"> 107 </span>
<span class="changed"> 108     MetaWord* ptr = c-&gt;allocate(remaining_words);</span>
<span class="changed"> 109     assert(ptr != NULL, "Should have worked");</span>
<span class="changed"> 110     _total_used_words_counter-&gt;increment_by(remaining_words);</span>
<span class="changed"> 111 </span>
<span class="changed"> 112     add_allocation_to_fbl(ptr, remaining_words);</span>
 113 
<a name="20" id="anc20"></a><span class="changed"> 114     // After this operation: the chunk should have no free committed space left.</span>
<span class="changed"> 115     assert(c-&gt;free_below_committed_words() == 0,</span>
<span class="changed"> 116            "Salvaging chunk failed (chunk " METACHUNK_FULL_FORMAT ").",</span>
<span class="changed"> 117            METACHUNK_FULL_FORMAT_ARGS(c));</span>
 118 
<a name="21" id="anc21"></a>


 119   }
 120 
<a name="22" id="anc22"></a>
 121 }
 122 
<a name="23" id="anc23"></a><span class="changed"> 123 // Allocate a new chunk from the underlying chunk manager able to hold at least</span>
<span class="changed"> 124 // requested word size.</span>
<span class="changed"> 125 Metachunk* SpaceManager::allocate_new_chunk(size_t requested_word_size) {</span>
 126 
<a name="24" id="anc24"></a><span class="changed"> 127   assert_lock_strong(lock());</span>



 128 
<a name="25" id="anc25"></a><span class="changed"> 129   // Should this ever happen, we need to increase the maximum possible chunk size.</span>
<span class="changed"> 130   guarantee(requested_word_size &lt;= chunklevel::MAX_CHUNK_WORD_SIZE,</span>
<span class="changed"> 131             "Requested size too large (" SIZE_FORMAT ") - max allowed size per allocation is " SIZE_FORMAT ".",</span>
<span class="changed"> 132             requested_word_size, chunklevel::MAX_CHUNK_WORD_SIZE);</span>
<span class="changed"> 133 </span>
<span class="changed"> 134   const int growth_step = _chunks.count();</span>
<span class="changed"> 135   const chunklevel_t max_level = chunklevel::level_fitting_word_size(requested_word_size);</span>
<span class="changed"> 136   const chunklevel_t preferred_level = MIN2(max_level, next_chunk_level());</span>
<span class="changed"> 137 </span>
<span class="changed"> 138   Metachunk* c = _chunk_manager-&gt;get_chunk(preferred_level, max_level, requested_word_size);</span>
<span class="changed"> 139   if (c == NULL) {</span>
<span class="changed"> 140     log_debug(metaspace)(LOGFMT_SPCMGR ": failed to allocate new chunk for requested word size " SIZE_FORMAT ".",</span>
<span class="changed"> 141                          LOGFMT_SPCMGR_ARGS, requested_word_size);</span>
<span class="changed"> 142     return NULL;</span>
 143   }
 144 
<a name="26" id="anc26"></a><span class="changed"> 145   assert(c-&gt;is_in_use(), "Wrong chunk state.");</span>
<span class="changed"> 146   assert(c-&gt;free_below_committed_words() &gt;= requested_word_size, "Chunk not committed");</span>







 147 
<a name="27" id="anc27"></a><span class="changed"> 148   log_debug(metaspace)(LOGFMT_SPCMGR ": allocated new chunk " METACHUNK_FORMAT " for requested word size " SIZE_FORMAT ".",</span>
<span class="changed"> 149                        LOGFMT_SPCMGR_ARGS, METACHUNK_FORMAT_ARGS(c), requested_word_size);</span>
<span class="changed"> 150 </span>
<span class="changed"> 151   return c;</span>




 152 
<a name="28" id="anc28"></a>












 153 }
 154 
<a name="29" id="anc29"></a><span class="changed"> 155 void SpaceManager::add_allocation_to_fbl(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 156   assert(Settings::handle_deallocations(), "Sanity");</span>
<span class="changed"> 157   if (_fbl == NULL) {</span>
<span class="changed"> 158     _fbl = new FreeBlocks(); // Create only on demand</span>
<span class="changed"> 159   }</span>
<span class="changed"> 160   _fbl-&gt;add_block(p, word_size);</span>
<span class="changed"> 161 }</span>
<span class="changed"> 162 </span>
<span class="changed"> 163 SpaceManager::SpaceManager(ChunkManager* chunk_manager,</span>
<span class="changed"> 164              const ArenaGrowthPolicy* growth_policy,</span>
<span class="changed"> 165              Mutex* lock,</span>
<span class="changed"> 166              SizeAtomicCounter* total_used_words_counter,</span>
<span class="changed"> 167              const char* name,</span>
<span class="changed"> 168              bool is_micro_loader)</span>
<span class="changed"> 169 : _lock(lock),</span>
<span class="changed"> 170   _chunk_manager(chunk_manager),</span>
<span class="changed"> 171   _growth_policy(growth_policy),</span>
<span class="changed"> 172   _chunks(),</span>
<span class="changed"> 173   _fbl(NULL),</span>
<span class="changed"> 174   _total_used_words_counter(total_used_words_counter),</span>
<span class="changed"> 175   _name(name),</span>
<span class="changed"> 176   _is_micro_loader(is_micro_loader)</span>
<span class="changed"> 177 {</span>
 178 }
 179 
<a name="30" id="anc30"></a><span class="changed"> 180 SpaceManager::~SpaceManager() {</span>


















 181 
<a name="31" id="anc31"></a><span class="changed"> 182   DEBUG_ONLY(verify(true);)</span>


 183 
<a name="32" id="anc32"></a><span class="changed"> 184   MutexLocker fcl(lock(), Mutex::_no_safepoint_check_flag);</span>
 185 
<a name="33" id="anc33"></a><span class="changed"> 186   size_t used_words_returned = 0;</span>















 187 
<a name="34" id="anc34"></a><span class="changed"> 188   Metachunk* c = _chunks.first();</span>
<span class="changed"> 189   Metachunk* c2 = NULL;</span>
 190 
<a name="35" id="anc35"></a><span class="changed"> 191   while(c) {</span>
<span class="changed"> 192     c2 = c-&gt;next();</span>
<span class="changed"> 193     used_words_returned += c-&gt;used_words();</span>
<span class="changed"> 194     DEBUG_ONLY(c-&gt;set_prev(NULL);)</span>
<span class="changed"> 195     DEBUG_ONLY(c-&gt;set_next(NULL);)</span>
<span class="changed"> 196     _chunk_manager-&gt;return_chunk(c);</span>
<span class="changed"> 197     // c may be invalid after return_chunk(c) was called. Don't access anymore.</span>
<span class="changed"> 198     c = c2;</span>
<span class="changed"> 199   }</span>
 200 
<a name="36" id="anc36"></a><span class="changed"> 201   _total_used_words_counter-&gt;decrement_by(used_words_returned);</span>
<span class="changed"> 202 </span>
<span class="changed"> 203   DEBUG_ONLY(chunk_manager()-&gt;verify(true);)</span>






































 204 
<a name="37" id="anc37"></a><span class="changed"> 205   delete _fbl;</span>

 206 
<a name="38" id="anc38"></a>

 207 }
 208 
<a name="39" id="anc39"></a><span class="changed"> 209 // Attempt to enlarge the current chunk to make it large enough to hold at least</span>
<span class="changed"> 210 //  requested_word_size additional words.</span>
<span class="changed"> 211 //</span>
<span class="changed"> 212 // On success, true is returned, false otherwise.</span>
<span class="changed"> 213 bool SpaceManager::attempt_enlarge_current_chunk(size_t requested_word_size) {</span>
 214 
<a name="40" id="anc40"></a><span class="changed"> 215   Metachunk* c = current_chunk();</span>
<span class="changed"> 216   assert(c-&gt;free_words() &lt; requested_word_size, "Sanity");</span>
 217 
<a name="41" id="anc41"></a><span class="changed"> 218   // Not if chunk enlargment is switched off in general...</span>
<span class="changed"> 219   if (Settings::enlarge_chunks_in_place() == false) {</span>
<span class="changed"> 220     return false;</span>
<span class="changed"> 221   }</span>
 222 
<a name="42" id="anc42"></a><span class="changed"> 223   // Nor if the chunk is deemed to large to be thus expanded.</span>
<span class="changed"> 224   //  (TODO : do we need this if we check the allowed chunk growth progression below? check)</span>
<span class="changed"> 225   if (c-&gt;word_size() &lt;= Settings::enlarge_chunks_in_place_max_word_size()) {</span>
<span class="changed"> 226     return false;</span>
<span class="changed"> 227   }</span>
 228 
<a name="43" id="anc43"></a><span class="changed"> 229   // Nor, obviously, if we are already a root chunk.</span>
<span class="changed"> 230   if (c-&gt;is_root_chunk()) {</span>
<span class="changed"> 231     return false;</span>
<span class="changed"> 232   }</span>
 233 
<a name="44" id="anc44"></a><span class="changed"> 234   const chunklevel_t new_level =</span>
<span class="changed"> 235       chunklevel::level_fitting_word_size(c-&gt;used_words() + requested_word_size);</span>
 236 
<a name="45" id="anc45"></a><span class="changed"> 237   // Atm we only attempt to enlarge by one level (so, doubling the chunk in size).</span>
<span class="changed"> 238   // So, if the requested enlargement would require the chunk to more than double in size,</span>
<span class="changed"> 239   // we bail. But this covers about 99% of all cases, so this is good enough.</span>
<span class="changed"> 240   if (c-&gt;level() &gt; new_level + 1) {</span>
<span class="changed"> 241     return false;</span>
<span class="changed"> 242   }</span>
 243 
<a name="46" id="anc46"></a><span class="changed"> 244   // This only works if chunk is the leader of its buddy pair (and also if buddy</span>
<span class="changed"> 245   // is free and unsplit, but that we cannot check outside of metaspace lock).</span>
<span class="changed"> 246   if (c-&gt;is_leader() == false) {</span>
<span class="changed"> 247     return false;</span>




 248   }
<a name="47" id="anc47"></a><span class="new"> 249 </span>
<span class="new"> 250   // If enlarging the chunk would increase the arena size faster than we are prepared</span>
<span class="new"> 251   // to grow, we don't enlarge the chunk.</span>
<span class="new"> 252   if (chunklevel::word_size_for_level(next_chunk_level()) &lt; c-&gt;word_size()) {</span>
<span class="new"> 253     return false;</span>
 254   }
 255 
<a name="48" id="anc48"></a><span class="changed"> 256   bool success = _chunk_manager-&gt;attempt_enlarge_chunk(c);</span>

 257 
<a name="49" id="anc49"></a><span class="changed"> 258   assert(success == false || c-&gt;free_words() &gt;= requested_word_size, "Sanity");</span>






 259 
<a name="50" id="anc50"></a><span class="changed"> 260   return success;</span>




 261 
<a name="51" id="anc51"></a>


 262 }
 263 
<a name="52" id="anc52"></a><span class="changed"> 264 // Allocate memory from Metaspace.</span>
<span class="changed"> 265 // 1) Attempt to allocate from the free block list.</span>
<span class="changed"> 266 // 2) Attempt to allocate from the current chunk.</span>
<span class="changed"> 267 // 3) Attempt to enlarge the current chunk in place if it is too small.</span>
<span class="changed"> 268 // 4) Attempt to get a new chunk and allocate from that chunk.</span>
<span class="changed"> 269 // At any point, if we hit a commit limit, we return NULL.</span>
<span class="changed"> 270 MetaWord* SpaceManager::allocate(size_t requested_word_size) {</span>




 271 
<a name="53" id="anc53"></a><span class="changed"> 272   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>

 273 
<a name="54" id="anc54"></a><span class="changed"> 274   log_debug(metaspace)(LOGFMT_SPCMGR ": requested " SIZE_FORMAT " words.",</span>
<span class="changed"> 275                        LOGFMT_SPCMGR_ARGS, requested_word_size);</span>

 276 
<a name="55" id="anc55"></a><span class="changed"> 277   MetaWord* p = NULL;</span>
 278 
<a name="56" id="anc56"></a><span class="changed"> 279   const size_t raw_word_size = get_raw_allocation_word_size(requested_word_size);</span>


 280 
<a name="57" id="anc57"></a><span class="changed"> 281   // 1) Attempt to allocate from the dictionary of deallocated blocks.</span>
<span class="changed"> 282   if (Settings::handle_deallocations() &amp;&amp; _fbl != NULL &amp;&amp; !_fbl-&gt;is_empty()) {</span>
<span class="changed"> 283     p = _fbl-&gt;get_block(raw_word_size);</span>
<span class="changed"> 284     if (p != NULL) {</span>
<span class="changed"> 285       DEBUG_ONLY(InternalStats::inc_num_allocs_from_deallocated_blocks();)</span>
<span class="changed"> 286       log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from free block list.", LOGFMT_SPCMGR_ARGS);</span>
<span class="changed"> 287       // Note: Space in the freeblock dictionary counts as already used (see retire_current_chunk()) -</span>
<span class="changed"> 288       // that means that we do not modify any counters and therefore can skip the epilog.</span>
<span class="changed"> 289       return p;</span>
<span class="changed"> 290     }</span>
 291   }
 292 
<a name="58" id="anc58"></a><span class="changed"> 293   bool current_chunk_too_small = false;</span>
<span class="changed"> 294   bool commit_failure = false;</span>

 295 
<a name="59" id="anc59"></a><span class="changed"> 296   if (current_chunk() != NULL) {</span>

 297 
<a name="60" id="anc60"></a><span class="changed"> 298     // 2) Attempt to satisfy the allocation from the current chunk.</span>









 299 
<a name="61" id="anc61"></a><span class="changed"> 300     // If the current chunk is too small to hold the requested size, attempt to enlarge it.</span>
<span class="changed"> 301     // If that fails, retire the chunk.</span>
<span class="changed"> 302     if (current_chunk()-&gt;free_words() &lt; raw_word_size) {</span>
<span class="changed"> 303       if (!attempt_enlarge_current_chunk(raw_word_size)) {</span>
<span class="changed"> 304         current_chunk_too_small = true;</span>


 305       }
 306     }
<a name="62" id="anc62"></a>
 307 
<a name="63" id="anc63"></a><span class="changed"> 308     // Commit the chunk far enough to hold the requested word size. If that fails, we</span>
<span class="changed"> 309     // hit a limit (either GC threshold or MaxMetaspaceSize). In that case retire the</span>
<span class="changed"> 310     // chunk.</span>
<span class="changed"> 311     if (!current_chunk_too_small) {</span>
<span class="changed"> 312       if (!current_chunk()-&gt;ensure_committed_additional(raw_word_size)) {</span>
<span class="changed"> 313         commit_failure = true;</span>
<span class="changed"> 314       }</span>
<span class="changed"> 315     }</span>
 316 
<a name="64" id="anc64"></a><span class="changed"> 317     // Allocate from the current chunk. This should work now.</span>
<span class="changed"> 318     if (!current_chunk_too_small &amp;&amp; !commit_failure) {</span>
<span class="changed"> 319       p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="changed"> 320       assert(p != NULL, "Allocation from chunk failed.");</span>
<span class="changed"> 321       log_trace(metaspace)(LOGFMT_SPCMGR ": .. taken from current chunk.", LOGFMT_SPCMGR_ARGS);</span>
 322     }
 323 
<a name="65" id="anc65"></a>



 324   }
 325 
<a name="66" id="anc66"></a><span class="changed"> 326   if (p == NULL) {</span>

 327 
<a name="67" id="anc67"></a><span class="changed"> 328     // If we are here, we either had no current chunk to begin with or it was deemed insufficient.</span>
<span class="changed"> 329     assert(current_chunk() == NULL ||</span>
<span class="changed"> 330            current_chunk_too_small || commit_failure, "Sanity");</span>


 331 
<a name="68" id="anc68"></a><span class="changed"> 332     Metachunk* new_chunk = allocate_new_chunk(raw_word_size);</span>
<span class="changed"> 333 </span>
<span class="changed"> 334     if (new_chunk != NULL) {</span>
<span class="changed"> 335 </span>
<span class="changed"> 336       assert(new_chunk-&gt;free_below_committed_words() &gt;= raw_word_size, "Sanity");</span>
<span class="changed"> 337 </span>
<span class="changed"> 338       // We have a new chunk. Before making it the current chunk, retire the old one.</span>
<span class="changed"> 339       if (current_chunk() != NULL) {</span>
<span class="changed"> 340         salvage_chunk(current_chunk());</span>
<span class="changed"> 341         DEBUG_ONLY(InternalStats::inc_num_chunks_retired();)</span>
 342       }
<a name="69" id="anc69"></a><span class="new"> 343 </span>
<span class="new"> 344       _chunks.add(new_chunk);</span>
<span class="new"> 345 </span>
<span class="new"> 346       // Now, allocate from that chunk. That should work.</span>
<span class="new"> 347       p = current_chunk()-&gt;allocate(raw_word_size);</span>
<span class="new"> 348       assert(p != NULL, "Allocation from chunk failed.");</span>
<span class="new"> 349       log_trace(metaspace)(LOGFMT_SPCMGR ": .. allocated new chunk " CHKLVL_FORMAT " and taken from that.",</span>
<span class="new"> 350                            LOGFMT_SPCMGR_ARGS, current_chunk()-&gt;level());</span>
 351     }
<a name="70" id="anc70"></a><span class="changed"> 352 </span>

 353   }
 354 
 355 #ifdef ASSERT
<a name="71" id="anc71"></a><span class="changed"> 356   // When using allocation guards, establish a prefix.</span>
<span class="changed"> 357   if (p != NULL &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="changed"> 358     p = establish_prefix(p, raw_word_size);</span>
<span class="changed"> 359   }</span>
 360 #endif
 361 
<a name="72" id="anc72"></a><span class="new"> 362   if (p == NULL) {</span>
<span class="new"> 363     DEBUG_ONLY(InternalStats::inc_num_allocs_failed_limit();)</span>
<span class="new"> 364   } else {</span>
<span class="new"> 365     DEBUG_ONLY(InternalStats::inc_num_allocs();)</span>
<span class="new"> 366     _total_used_words_counter-&gt;increment_by(raw_word_size);</span>
<span class="new"> 367   }</span>
<span class="new"> 368 </span>
<span class="new"> 369   SOMETIMES(verify_locked(true);)</span>
<span class="new"> 370 </span>
<span class="new"> 371   log_trace(metaspace)(LOGFMT_SPCMGR ": returned " PTR_FORMAT ".",</span>
<span class="new"> 372                        LOGFMT_SPCMGR_ARGS, p2i(p));</span>
<span class="new"> 373 </span>
 374   return p;
<a name="73" id="anc73"></a><span class="new"> 375 </span>
 376 }
 377 
<a name="74" id="anc74"></a><span class="changed"> 378 // Prematurely returns a metaspace allocation to the _block_freelists</span>
<span class="changed"> 379 // because it is not needed anymore (requires CLD lock to be active).</span>
<span class="changed"> 380 void SpaceManager::deallocate_locked(MetaWord* p, size_t word_size) {</span>








 381 
<a name="75" id="anc75"></a><span class="changed"> 382   if (Settings::handle_deallocations() == false) {</span>
<span class="changed"> 383     return;</span>
 384   }
 385 
<a name="76" id="anc76"></a><span class="changed"> 386   assert_lock_strong(lock());</span>


 387 
<a name="77" id="anc77"></a><span class="changed"> 388   // At this point a current chunk must exist since we only deallocate if we did allocate before.</span>
<span class="changed"> 389   assert(current_chunk() != NULL, "stray deallocation?");</span>

 390 
<a name="78" id="anc78"></a><span class="changed"> 391   assert(is_valid_area(p, word_size),</span>
<span class="changed"> 392          "Pointer range not part of this SpaceManager and cannot be deallocated: (" PTR_FORMAT ".." PTR_FORMAT ").",</span>
<span class="changed"> 393          p2i(p), p2i(p + word_size));</span>
<span class="changed"> 394 </span>
<span class="changed"> 395   log_debug(metaspace)(LOGFMT_SPCMGR ": deallocating " PTR_FORMAT</span>
<span class="changed"> 396                        ", word size: " SIZE_FORMAT ".",</span>
<span class="changed"> 397                        LOGFMT_SPCMGR_ARGS, p2i(p), word_size);</span>
<span class="changed"> 398 </span>
<span class="changed"> 399   size_t raw_word_size = get_raw_allocation_word_size(word_size);</span>
<span class="changed"> 400   add_allocation_to_fbl(p, raw_word_size);</span>
<span class="changed"> 401 </span>
<span class="changed"> 402   DEBUG_ONLY(verify_locked(false);)</span>
 403 
<a name="79" id="anc79"></a>






 404 }
 405 
<a name="80" id="anc80"></a><span class="changed"> 406 // Prematurely returns a metaspace allocation to the _block_freelists because it is not</span>
<span class="changed"> 407 // needed anymore.</span>
<span class="changed"> 408 void SpaceManager::deallocate(MetaWord* p, size_t word_size) {</span>
<span class="changed"> 409   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 410   deallocate_locked(p, word_size);</span>


 411 }
 412 
<a name="81" id="anc81"></a><span class="changed"> 413 // Update statistics. This walks all in-use chunks.</span>
<span class="changed"> 414 void SpaceManager::add_to_statistics(sm_stats_t* out) const {</span>
<span class="changed"> 415 </span>
<span class="changed"> 416   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);</span>
<span class="changed"> 417 </span>
<span class="changed"> 418   for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 419     in_use_chunk_stats_t&amp; ucs = out-&gt;stats[c-&gt;level()];</span>
<span class="changed"> 420     ucs.num ++;</span>
<span class="changed"> 421     ucs.word_size += c-&gt;word_size();</span>
<span class="changed"> 422     ucs.committed_words += c-&gt;committed_words();</span>
<span class="changed"> 423     ucs.used_words += c-&gt;used_words();</span>
<span class="changed"> 424     // Note: for free and waste, we only count what's committed.</span>
<span class="changed"> 425     if (c == current_chunk()) {</span>
<span class="changed"> 426       ucs.free_words += c-&gt;free_below_committed_words();</span>
 427     } else {
<a name="82" id="anc82"></a><span class="changed"> 428       ucs.waste_words += c-&gt;free_below_committed_words();</span>
 429     }
<a name="83" id="anc83"></a>
 430   }
<a name="84" id="anc84"></a><span class="changed"> 431 </span>
<span class="changed"> 432   if (_fbl != NULL) {</span>
<span class="changed"> 433     out-&gt;free_blocks_num += _fbl-&gt;count();</span>
<span class="changed"> 434     out-&gt;free_blocks_word_size += _fbl-&gt;total_size();</span>
 435   }
<a name="85" id="anc85"></a>
 436 
<a name="86" id="anc86"></a><span class="changed"> 437   SOMETIMES(out-&gt;verify();)</span>
<span class="changed"> 438 </span>

 439 }
 440 
 441 #ifdef ASSERT
<a name="87" id="anc87"></a><span class="changed"> 442 </span>
<span class="changed"> 443 void SpaceManager::verify_locked(bool slow) const {</span>
<span class="changed"> 444 </span>
 445   assert_lock_strong(lock());
 446 
<a name="88" id="anc88"></a><span class="changed"> 447   assert(_growth_policy != NULL &amp;&amp; _chunk_manager != NULL, "Sanity");</span>

 448 
<a name="89" id="anc89"></a><span class="changed"> 449   _chunks.verify();</span>
<span class="changed"> 450 </span>
<span class="changed"> 451   if (_fbl != NULL) {</span>
<span class="changed"> 452     _fbl-&gt;verify();</span>
<span class="changed"> 453   }</span>
 454 
<a name="90" id="anc90"></a><span class="changed"> 455   // In slow mode, verify guard zones of all allocations</span>
<span class="changed"> 456   if (slow &amp;&amp; Settings::use_allocation_guard()) {</span>
<span class="changed"> 457     for (const Metachunk* c = _chunks.first(); c != NULL; c = c-&gt;next()) {</span>
<span class="changed"> 458       const MetaWord* p = c-&gt;base();</span>
<span class="changed"> 459       while (p &lt; c-&gt;top()) {</span>
<span class="changed"> 460         const prefix_t* pp = (const prefix_t*)p;</span>
<span class="changed"> 461         check_prefix(pp);</span>
<span class="changed"> 462         p += pp-&gt;word_size;</span>
<span class="changed"> 463       }</span>
<span class="changed"> 464     }</span>
<span class="changed"> 465   }</span>
 466 
<a name="91" id="anc91"></a>


 467 }
 468 
<a name="92" id="anc92"></a><span class="changed"> 469 void SpaceManager::verify(bool slow) const {</span>
<span class="changed"> 470 </span>
 471   MutexLocker cl(lock(), Mutex::_no_safepoint_check_flag);
<a name="93" id="anc93"></a><span class="changed"> 472   verify_locked(slow);</span>
<span class="changed"> 473 </span>
<span class="changed"> 474 }</span>
<span class="changed"> 475 </span>
<span class="changed"> 476 // Returns true if the area indicated by pointer and size have actually been allocated</span>
<span class="changed"> 477 // from this space manager.</span>
<span class="changed"> 478 bool SpaceManager::is_valid_area(MetaWord* p, size_t word_size) const {</span>
<span class="changed"> 479   assert(p != NULL &amp;&amp; word_size &gt; 0, "Sanity");</span>
<span class="changed"> 480   bool found = false;</span>
<span class="changed"> 481   if (!found) {</span>
<span class="changed"> 482     for (const Metachunk* c = _chunks.first(); c != NULL &amp;&amp; !found; c = c-&gt;next()) {</span>
<span class="changed"> 483       assert(c-&gt;is_valid_committed_pointer(p) ==</span>
<span class="changed"> 484              c-&gt;is_valid_committed_pointer(p + word_size - 1), "range intersects");</span>
<span class="changed"> 485       found = c-&gt;is_valid_committed_pointer(p);</span>
<span class="changed"> 486     }</span>
<span class="changed"> 487   }</span>
<span class="changed"> 488   return found;</span>
 489 }
<a name="94" id="anc94"></a><span class="new"> 490 </span>
 491 #endif // ASSERT
<a name="95" id="anc95"></a><span class="new"> 492 </span>
<span class="new"> 493 void SpaceManager::print_on(outputStream* st) const {</span>
<span class="new"> 494   MutexLocker fcl(_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="new"> 495   print_on_locked(st);</span>
<span class="new"> 496 }</span>
<span class="new"> 497 </span>
<span class="new"> 498 void SpaceManager::print_on_locked(outputStream* st) const {</span>
<span class="new"> 499   assert_lock_strong(_lock);</span>
<span class="new"> 500   st-&gt;print_cr("sm %s: %d chunks, total word size: " SIZE_FORMAT ", committed word size: " SIZE_FORMAT, _name,</span>
<span class="new"> 501                _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());</span>
<span class="new"> 502   _chunks.print_on(st);</span>
<span class="new"> 503   st-&gt;cr();</span>
<span class="new"> 504   st-&gt;print_cr("micro: %d, growth-policy " PTR_FORMAT ", lock " PTR_FORMAT ", cm " PTR_FORMAT ", fbl " PTR_FORMAT,</span>
<span class="new"> 505                 _is_micro_loader, p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));</span>
<span class="new"> 506 }</span>
<span class="new"> 507 </span>
 508 
 509 
 510 } // namespace metaspace
 511 
<a name="96" id="anc96"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="96" type="hidden" /></form></body></html>
